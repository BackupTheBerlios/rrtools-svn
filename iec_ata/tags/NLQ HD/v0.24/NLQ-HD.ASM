l10000: ;only for relabeling with QBasic program
;0       1         2         3         4         5         6         7         8         9     
;234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567
;Print the sourcecode:
;Relabel / Renumber the labels and change the tabs to spaces: rennlqhd.bas (QBasic-Prg)
;mark all the text in AVR Studio (shift&pagedown)
;Copy
;Paste into MS Word
;Pagelayout: 2cm left and right margin (not more than 2cm!!)
;mark all the text
;Font: Courier new  +8 cpi
;Print
;------------------------------------------------------------------------------------------------
;Find differences in two sourcecodes:
;start open office 2.4.0
;Extras -> options -> language -> linguistic -> check spelling while typing = off
;File -> open: load first file (NLQ-HD.ASM) to compare (Westeuopa (Windows-1251/WinLatin 1))
;Edit -> compare document: load second file
; -> cancel?
;the differences are red
;------------------------------------------------------------------------------------------------
;           NLQ-HD DOS   NLQ@GMX.DE   www.nlq.de
;------------------------------------------------------------------------------------------------
        #message define partname
        #define partname 1

; 1=mega162  IEC-ATA-V2   NLQ-HD/IEC-ATA          NLQHD-A  HD -- -- (no CHS)   (16384 Flashbytes)
;(2=mega32   MMC2IEC      NLQ-HD/MMC2IEC)  
; 3=mega644  SD2IEC       NLQ-HD/SD2IEC           NLQHD-I  -- -- SD
; 4=mega644  NLQ-HD       NLQ-HD/lite             NLQHD-L  HD CD --
;(5=mega644  NLQ-HD       NLQ-HD/HD-outputdriver           HD CD --)  
; 6=mega644  NLQ-HD       NLQ-HD/SD               NLQHD-S  -- -- SD
; 7=mega644  NLQ-HD       NLQ-HD/full             NLQHD-F  HD CD SD 

        #define iedbyn 0  ;IEC-debugbytes yes/no
                          ;!!! overwrites CBM-buffer 0d00-0dff !!!
                          ; bit0=CBM-IECIN
                          ; bit1=CBM-IECOUT

        .equ butrhi = 00  ;built track high   after 2009.11.14
        .equ buselo = 24  ;built sector low  range from $00-$63 (0-99)
                          ;!!!! decimal   not hexdec !!!! 
                           ;== is equal to 
                           ;!= is not equal to
                           ; | is bitwise or (  AltGr < (at German keyboard)  spoken: "pipe")
;  HD = hard disk
;  CD = CDROM
;  SD = SD- / MMC-card

;------------------------------------------------------------------------------------------------
;       bst r..,.      ;copies bit from register to T-flag
;       bld r..,.      ;copies T-flag to bit of register
/*       
        subi r12,$100-$20 ;               add $20 32  00  20  40  60  80  a0  c0  e0            
                          ;                           20s 40s 60s 80s a0s c0s e0s 00c
        sbci r13,$ff
        sbci r14,$ff
        sbci r15,$ff

 
                       ;                  add #$0020  00  20  40  60  80  a0  c0  e0
                       ;            =subtract #$ffe0
        subi r26,low($10000-$0020)  ;subtract #$e0
                                    ;add #$20         20s 40s 60s 80s a0s c0s e0s 00c
        
        sbci r27,high($10000-$0020) ;subtract #$ff    06  06  06  06  06  06  06  06
                                    ;add#$01          06  06  06  06  06  06  06  07  
*/
;------------------------------------------------------------------------------------------------
       #if partname == 1    
        #message 162-IEC-ATA-V2
        .device atmega162
        ;#pragma AVRPART ADMIN PART_NAME ATmega162 
       #endif

       #if partname == 7
        #message 644-NLQ-HD/full
        .device atmega644
        ;#pragma AVRPART ADMIN PART_NAME ATmega644
       #endif
;------------------------------------------------------------------------------------------------
       #if partname >= 2    
        #message 644-non-IEC-ATA

       #endif
;------------------------------------------------------------------------------------------------
       #if partname == 1    
        #message 162-IEC-ATA-V2

       #else
        #message 644-non-IEC-ATA

       #endif 
;------------------------------------------------------------------------------------------------        
       #if (partname == 1) | (partname == 4)    
        #message "partname:" partname
       
       #endif

       #if partname == 7
        #message 644-NLQ-HD/full
     
       #endif

;------------------------------------------------------------------------------------------------
 
       #if partname == 1    
        #message 162-IEC-ATA-V2
   
   
       #endif


       #if ((partname >= 4) & (partname <= 7))
         #message 644-NLQ-HD/all


       #endif
;------------------------------------------------------------------------------------------------
 
       #if partname == 1    
        #message 162-IEC-ATA-V2
   
       #endif
     
       #if partname == 3
        #message 644-NLQ-HD/SD2IEC
     
       #endif

       #if (partname == 4) | (partname == 5)
         #message 644-NLQ-HD/lite

       #endif
 
       #if partname == 6    
        #message 644-NLQ-HD/SD
   
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
   
       #endif
;------------------------------------------------------------------------------------------------
       #if partname == 3
        #message 644-NLQ-HD/SD2IEC
     
       #endif
;------------------------------------------------------------------------------------------------
       
       #if (partname == 3) | (partname == 7)    
        #message nlq-hd/SD-card
       
       #endif

;------------------------------------------------------------------------------------------------
                                                                                 ;rem HD-routines     
       #if (partname == 1) | (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/HD-routines
       
       #endif

;------------------------------------------------------------------------------------------------
                                                                                 ;rem CD-routines     
       #if (partname == 4) | (partname == 5) | (partname == 7)  
        #message nlq-hd/CD-routines
       
       #endif

;------------------------------------------------------------------------------------------------
                                                                                 ;rem SD-routines     
       #if (partname == 3) | (partname == 6) | (partname == 7)
        #message nlq-hd/SD-routines
       
       #endif

;------------------------------------------------------------------------------------------------
                                                                         ;rem multiple emulations
       #if (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/multiple emulations
       
       #endif
;------------------------------------------------------------------------------------------------
        .list
;------------------------------------------------------------------------------------------------
;
;                               IEC-ATA-V2 
;                          without any warranty
;                                              
;                   
;      6 IEC_reset-----------------------------.                 
;                              .----. .----.   |                                
;                              |1   | |  40|   o (JV)                               
;             ATA_diow --------|pb0 '-' vcc|---o--+5V  (pin7 of C64 joystickport or 
;                              |           |                       reset by C64USB)
;                              |2        39|                                   
;             ATA_dior --------|pb1     pa0|---------ad0
;                              |           |
;                              |3        38|
;      4 IEC_clk_out ----<I----|pb2  A  pa1|---------ad1
;                              |     T     |
;                              |4    M   37|
;      5 IEC_clk_in -----I>----|pb3  E  pa2|---------ad2
;                              |     L     |
;                              |5        36|
;      4 IEC_data_out ---<I----|pb4  A  pa3|---------ad3
;                              |     V     |
;                              |6    R   35|
;      5 IEC_data_in -----I>---|pb5     pa4|---------ad4 
;                              |     A     |
;                              |7    T   34|
;      1 IEC_srq_out -----<I---|pb6  M  pa5|---------ad5
;                              |     E     |
;      3 IEC_atn_out-<I-o#1    |8    G   33|
;                   (JC)o------|pb7  A  pa6|---------ad6
;      4 IEC_clk_in-----o#2    |     1     |
;                     #1       |9    6   32|
;      6 IEC_reset--I>-o o-----|rst  2  pa7|---------ad7
;                      #2o--gnd|           |
;                      (JR)    |10       31|
;             ATA_cs0 ---------|pd0     pe0|----<I-----IEC_srq_in 1 
;                              |           |
;                              |11       30|
;             ATA_cs1 ---------|pd1     ale|---------ale pin11 at 74573
;                              |           |
;                              |12   pe2-29|
;      3 IEC_atn_in -----I>----|pd2    oc1b|--------^^--[1kOhm]--+5V
;                              |INT0       |  '--[470Ohm]-o o- (+ debug-switch added by NLQ)
;                              |           |
;                              |13       28|
;             ATA_da0 ---------|pd3     pc7|---------a15                     
;                              |           |
;                              |14       27|
;             ATA_da1 ---------|pd4     pc6|---------a14                                
;                              |           |
;                              |15       26|
;             ATA_da2 ---------|pd5     pc5|---------a13                                
;                              |           |
;                              |16       25|
;                      wr------|pd6     pc4|---------a12                                
;                              |           |
;                              |17       24|
;                      rd------|pd7     pc3|---------a11        
;                              |           |
;                              |18       23|
;                              |xtal-2  pc2|---------a10 
;                              |           |
;                              |19       22|                
;                              |xtal-1  pc1|---------a09
;                              |           |
;                              |20       21|
;               2 GROUND ------|gnd     pc0|---------a08
;                              '-----------' 
;                                 IEC-ATA-V2
;(Circuit was probably wrong (Pin B2, B3 B4) -> changed 03.11.2007)
;------------------------------------------------------------------------------------------------
;                                                                    
;                              MMC2IEC 
;              !!! uses SMD => pin numbers are wrong !!!
;
;                                      .----. .----.                                  
;                                      |1   | |  40|                                 
;                                      |pb0 '-' pa0|---[470Ohm]---[LED1]--- +3.3V
;                                      |           |
;                                      |2        39|                                  
;                                      |pb1     pa1|---[470Ohm]---[LED2]--- +3.3V
;                                      |           |                                  
;                                      |3        38|                                   
;                                      |pb2  A  pa2|---[470Ohm]---[LED3]--- +3.3V
;                                      |     T     |                                  
;                                      |4    M   37|                                   
;                                      |pb3  E  pa3|
;                                      |     L     |                                  
;                                      |5        36|                                   
;           1 SPI-chip-select ---------|pb4  A  pa4|
;                                      |     V     |                                   
;                                      |6    R   35|                                  
;           2 SPI-data-in -------------|pb5     pa5|
;                                      |     A     |                                   
;                                      |7    T   34|                                  
;           7 SPI-data-out ------------|pb6  M  pa6|
;                                      |     E     |                                   
;                                      |8    G   33|                                  
;           5 SPI-clock ---------------|pb7  A  pa7|
;                                      |           |   
;                                      |9    3   32|   
;                                      |rst  2 aref| 
;                                      |           | 
;                                      |10       31|   
;                        +3.3V---------|vcc     gnd|- 0V
;                                      |           |   
;                                      |11       30|   
;           2 Gnd---------0V-----------|gnd    avcc|- +3.3V (don't forget)
;                                      |           |
;                                      |12       29|
;                                      |xtal-2  pc7|
;                                      |           |              
;                                      |13       28|              
;                                      |xtal-1  pc6|
;                                      |           |
;                                      |14       27|
;                                      |pd0     pc5|
;                                      |           |
;                                      |15       26|
;                                      |pd1     pc4|
;                                      |           |
;                                      |16       25|
;             SPI-carddetect ----------|pd2     pc3|
;                                      |           |
;                                      |17       24|              
;                                      |pd3     pc2|------IEC-clock (in and out)
;                                      |           |                (via transistor)
;                                      |18       23|
;                                      |pd4     pc1|------IEC-data  (in and out)
;                                      |           |                (via transistor)
;                                      |19       22|            
;                                      |pd5     pc0|------IEC-atn   (in and out)
;                                      |           |                (via transistor)                         
;                                      |20       21|    
;             SPI-writeprotect --------|pd6     pd7|
;                                      '-----------'                   
;                                              
;                                                                         
;bad:
; IEC-reset not conneted
; IEC-Atn cannot make an IRQ       
; IEC-pins can sink 20mA only
;------------------------------------------------------------------------------------------------
;                                                                    
;                              SD2IEC V1.2 
;              !!! uses SMD => pin numbers are wrong !!!
;
;                                      .----. .----.                                  
;                                      |1   | |  40|                                 
;                                      |pb0 '-' pa0|---------IecAtnIn (not-inverted) 
;                                      |           |
;                                      |2        39|                                  
;                                      |pb1     pa1|---------IecDtaIn (not-inverted)
;                                      |           |                                  
;                                      |3        38|                                   
;                                      |pb2  A  pa2|---------IecClkIn (not-inverted)        
;                                      |     T     |                                  
;                                      |4    M   37|                                   
;                                      |pb3  E  pa3|---------IecRsvIn (not-inverted)
;                                      |     L     |         so far not connected                         
;                                      |5        36|                                   
;           1 SPI-chip-select ---------|pb4  A  pa4|---------IecAtnOut (inverted)          
;                                      |     V     |                                   
;                                      |6    R   35|                                  
;                AVR-SPI-DtaOut -------|pb5     pa5|---------IecDtaOut (inverted) 
;           2 SPI-data-in              |MOSI       |         
;                                      |     A     |                                   
;                                      |7    T   34|                                  
;                AVR-SPI-DtaIn --------|pb6  M  pa6|---------IecClkOut (inverted)
;           7 SPI-data-out             |MISO E     |
;                                      |     G     |                                   
;                                      |8    A   33|                                  
;           5 SPI-clock ---------------|pb7     pa7|---------IecRsvOut (inverted)
;                                      |SCK  6     |         so far not connected
;                                      |     4     |   
;                                      |9    4   32|   
;                  switch&diode?-------|rst  P aref| 
;                                      |           | 
;                                      |10       31|   
;                        +3.3V---------|vcc     gnd|- 0V
;                                      |           |   
;                                      |11       30|   
;           2 Gnd---------0V-----------|gnd    avcc|- +3.3V (don't forget)
;                                      |           |
;                                      |12       29|          .-----.  
;             Gnd-[56pF]---------------|xtal-2  pc7|----------|1    |
;                        '-[8MHz]-.    |           |          |     |        
;                           crystal]-. |13       28|          |     |                 
;             Gnd-[56pF]---------------|xtal-1  pc6|----------|2    |   
;                                      |           |          |     |   
;                   .-----.            |14       27|          |     |   
;                   |    3|------------|pd0     pc5|----------|3 X6 |   
;                   |     |            |RXD        |          |     |       
;                   | X5 2|--Gnd       |           |          |     |   
;                   |     |            |15       26|          |     |
;                   |    1|------------|pd1     pc4|----------|4    |   
;                   '-----'            |TXD        |          |     | 
;                                      |           |   Gnd----|5    | 
;                                      |           |          '-----'
;                                      |           |
;                                      |16       25|          .-----.
;             SPI-carddetect ----------|pd2     pc3|----------|1    |diskchange    (value-switch)
;                                      |           |   Gnd----|2    |diskswitch 
;                   .----.             |17       24|          |     |            
; Gnd-oo--[10kOhm]--| X7 |-------------|pd3     pc2|----------|3    |reserve?   second diskchange
;    debug          '----'             |TXD        |          |     | s.diskchange? (mode-switch)
;    switch                            |           |          |     |
;                                      |18       23|          |     |
;  (at V1.1: X7 is here?)--------------|pd4     pc1|-[330Ohm]-|4    |LED1  (red)
;                                      |           |   Gnd----|5    |
;                                      |19       22|          |  X3 |  
;       .------------------------------|pd5     pc0|-[330Ohm9-|6    |LED2  (green)
;       |                              |           |   Gnd----|7    |                                   
;       |                              |20       21|          |     |    
;       |     SPI-writeprotect --------|pd6     pd7|----------|8    |IEC8/9
;       |                              '-----------'   Gnd----|9    |         
;       |                                                     |     |
;       '-----------------------------------------------------|10   |IEC10/11                                                                  
;                                                             '-----'
;there is a hardware-bug at my first hardware (V1.1) from shadowolf: 
;     - X7 isn't connected to PD3? (it's probably connected to PD4???)
;        (my V1.1 also debugs when PD3 is connected to ground??)
;     - it's not a 644P but a644: there is no second UART at PD2 and PD3                            
;bad:    
; IEC-reset not conneted
; IEC-Atn cannot make a lowlevel-IRQ (only toggle-IRQ)       
;------------------------------------------------------------------------------------------------
;
;                               NLQ-HD/lite (cheap version for PATA-IDE-HD
;                                                   4 =  without driver chips
;                                                        without I2C-real-time-clock)
;                                                   5 = with driver chips
;                          without any warranty
;                                                                       
;                                                                        
;                                                                            
;
;       IEC-BUS                                                ATA-BUS
;at    /       \ 
;flashing      normal                                          |||||||
;||||||||      ||||||                                          VVVVVVV
;VVVVVVVV      VVVVVV                                               
;                     
;   NLQ-HD/lite
;                                      .----. .----.                                  
;                                      |1   | |  40|                                 
;           3 Atn(Out) ----------------|pb0 '-' pa0|- a_dd0      17                        
;                                      |           |  
;                                      |2        39|                                  
;           1 Srq(In&Out)--------------|pb1     pa1|- a_dd1      15 
;                                      |           |                
;                                      |3        38|                                   
;           3 Atn(In&Out) -------------|pb2  A  pa2|- a_dd2      13                        
;                                      |     T     |                                  
;                                      |4    M   37|                                   
;           4 Clk(Out) ----------------|pb3  E  pa3|- a_dd3      11                          
;                                      |     L     |                                  
;                                      |5        36|                                   
;           5 Dta(Out) ----------------|pb4  A  pa4|- a_dd4       9
;                                      |     V     |                                   
;                                      |6    R   35|                                  
;DtaIn      5 Dta(In&Out) -------------|pb5     pa5|- a_dd5       7                        
;                                      |     A     |                                   
;                                      |7    T   34|                                  
;SrqOut     1 Srq(Out) ----------------|pb6  M  pa6|- a_dd6       5                     
;                                      |     E     |                                   
;                                      |8    G   33|                                  
;ClkIn      4 Clk(In&Out) -------------|pb7  A  pa7|- a_dd7       3                      
;                                      |           |   
;                    1N4148            |9    6   32|   
;Gnd        6 RstIn ---|<-----o--------|rst  4 aref| 
;                     Gnd-----o        |     4     | 
;                            JR-1      |           |
;                                      |10       31|   
;                        +5V-----------|vcc     gnd|- Gnd    
;                                      |           |   
;                                      |11       30|   
;           2 Gnd---------0V-----------|gnd    avcc|- +5V (don't forget)
;                                      |           |
;                                      |12       29|
;                                      |xtal-2  pc7|- a_dd15      18
;                                      |           |              
;                                      |13       28|              
;                [+5V]--[1kOhm]--.     |xtal-1  pc6|- a_dd14      16
;                                |     |           |
;                   1 a_reset-.  |     |14       27|
;                              --------|pd0     pc5|- a_dd13      14
;                  38 a_cs1---'   |    |           |
;                                 |    |           |
;                     Gnd--------oo    |           |                 
;                              JD-2    |           |
;                                      |15       26|
;                  25 a_dior ----------|pd1     pc4|- a_dd12      12
;                                      |           |
;                                      |16       25|              
;                  23 a_diow ----------|pd2     pc3|- a_dd11      10
;                                      |           |                
;                                      |17       24|              
;                  35 a_da0 -----------|pd3     pc2|- a_dd10       8
;                                      |           |           
;                                      |18       23|
;                  33 a_da1 -----------|pd4     pc1|- a_dd9        6
;                                      |           |            
;                                      |19       22|            
;                  36 a_da2 -----------|pd5     pc0|- a_dd8        4
;                                      |           | 
;             green-active             |           |            red-error 
;           .--[LED-green]--[+5V]      |           |     [+5V]--[LED-red]--.
;           |                          |20       21|                       |
;           '-[270Ohm]-----------------|pd6     pd7|--------------[270Ohm]-'
;               10mA            |      |           |     |          10mA 
;                    Gnd----o / o      |           |     o / o----Gnd  
;                        right-value   |           |   left-mode
;      perhaps debugswitch here?       '-----------'      
;                                              
;                                           0V ------ a_cs0       37
;                                                                         
;           2 Gnd---------------------------0V -------------------- a_gnd  2,19,22,24,26,30,40
;
;                                                      unconnected:  (20),21,27,28,29,31,32,34
;                                                      unconnected:   39 = HD-drive-active-LED
;
;bad, danger: debugjumper is connected to SrqOut (over SrqIn)
; when JD is closed and flashing: AVR pulls SrqOut-pin to +5V, but JD connects it to 0V
; shortcircuit!!!

;the internal pullup-resistors are 
; - 35kOhm at vcc=5V
; - 62kOhm at vcc=2.7V
; -100kOhm at vcc= 1.8V
;
; 644(V)  pulls at 5V 10mA to 0.7V
; 644P(V) pulls at 5V 10mA to 0.9V only!!!
; => use 644  (not644P)
; (1284P  pulls at 5V 10mA to 0.7V = good)

;                       0-4MHz    4-10MHz    10-20MHz
; 644 = normal         2.7-5.5V   2.7-5.5V   4.5-5.5V
; 644V = low voltage   1.8-5.5V   2.7-5.5V   --------
; 644P = pico power    2.7-5.5V   2.7-5.5V   4.5-5.5V
; 644PV = PP & lv      1.8-5-5V   2.7-5.5V   --------
;allow perhaps a diode from +5V to vcc to allow perhaps a real time clock with the internal 
; 128kHz oscylator?  !!still test whether pulldown voltage is at 4.3V as low as at 5V vcc
; (RTC isn't probably possible because it needs too much currency)

;test of pulldown-current (01.05.2009)
;amount of 1kOhm   current  74LS07  7407   2pins of 644
;pullup-resistors                          (not 1pin only)
;      0             0mA     0.08V  0.06V  0.00V
;      1             5mA     0.13V  0.12V  0.05V
;      2            10mA     0.16V  0.16V  0.10V
;      3            15mA     0.20V  0.19V  0.16V
;      4            20mA     0.22V  0.23V  0.21V
;      5            25mA     0.25V  0.26V  0.26V
;      6            30mA     0.28V  0.30V  0.30V
;      7            35mA     0.30V  0.33V  0.35V
;=> two 644-pins are as strong as a 74LS07
;   => additional outputdriverchip not necessary
;------------------------------------------------------------------------------------------------
l10010:
;doc2593.pdf p318 (M644 & M644V   (not M644P))
;Frequency   min powersupply voltage
;            M88     M88V
;           (M644P) (M644PV)
;            M644    M644V    M1284
; 4MHz       2.7V    1.8V     1.8V       
; 5MHz       2.7V    1.95V    1.95V      
; 6MHz       2.7V    2.1V     2.1V    
; 7MHz       2.7V    2.25V    2.25V      
; 8MHz       2.7V    2.4V     2.4V       <---------
; 9MHz       2.7V    2.55V    2.55V    
;10MHz       2.7V    2.7V     2.7V     
;11MHz       2.88V    -       2.88V 
;12MHz       3.06V    -       3.06V   
;13MHz       3.24V    -       3.24V   
;14MHz       3.42V    -       3.42V  
;15MHz       3.6V     -       3.6V   
;16MHz       3.78V    -       3.78V   
;17MHz       3.96V    -       3.96V 
;18MHz       4.14V    -       4.14V
;19MHz       4.32V    -       4.32V  
;20MHz       4.5V     -       4.5V     
;if a 644V (or 1284) is used:
; 3V-backup-battery and Shottky-diode would be enough
;
;                               NLQ-HD (cheap version for SD-/MMC-card
;                                                    without driver chips
;                                                    without I2C-real-time-clock)
;                                                        
;                          without any warranty
;                                                                       
;                                                                            
;                                                                        
;                                                                            
;
;       IEC-BUS                                               
;at    /       \ 
;flashing      normal                                         
;||||||||      ||||||                                         
;VVVVVVVV      VVVVVV                                               
;                                                                    
;NLQ-HD/SD
;                                      .----. .----.                                  
;                               1kOhm  |1   | |  40|                                 
;                            .-[1k2]---|pb0 '-' pa0|------Clk(Out) 4
;       SPI-Clk--------------+  1k8    |           |
;              Gnd-[3.3kOhm]-'         |           |
;                                      |2        39|                                  
;           1 Srq(In+Out) -------------|pb1     pa1|------Clk(Out) 4  
;                                      |           |                                  
;   (perhaps 1N4148+LED                |ain0     38|                                   
;                     (0-5V) VPS ------|pb2  A  pa2|------Clk(Out) 4
;    perhaps +1.5kOhm)                 |int2 T     |                                  
;                                      |     M   37|                                   
;           3 Atn(In)  ----------------|pb3  E  pa3|------Dta(Out) 5
;                                      |ain1 L     |                                  
;                                      |         36|                                   
;           1 Srq(Out) ----------------|pb4  A  pa4|------Dta(Out) 5
;                                      |     V     |                                   
;                                      |6    R   35|                                  
;DtaIn      5 Dta(In) -----------------|pb5     pa5|------Dta(Out) 5
;                                      |     A     |                                   
;                                      |7    T   34|       .-[2.7kOhm]-VPS (perhaps)                          
;SrqOut     1 Srq(Out) ----------------|pb6  M  pa6|-------
;                                      |     E     |       '-[1kOhm]--gnd  (perhaps)                           
;                                      |8    G   33|                                  
;ClkIn      4 Clk(In) -----------------|pb7  A  pa7|------VCC (2.6-4.6V)
;                                      |           |   
;                                      |9    6   32|   
;Gnd                Gnd-------o o------|rst  4 aref| 
;                             JR-1     |     4     | 
;                    BAT85             |     V     | 
;   VPS +5V------------>|--.     VCC   |10       31|             
;       .-[10µF]-'          -----------|VCC     gnd|-0V
;   gnd-'     VBB +3V-->|--'         | |           |
;                    BAT85           | |           | 
;                          .-[100nF]-' |11       30|
;           2 Gnd-0V-------------------|gnd    avcc|- vcc (don't forget)
;                                      |           |
;                                      |12       29|                     6/10/12.5pF-crystal
;                                      |xtal2   pc7|----32kHz-crystal--[10/18/22pF]--gnd                
;                                      |      TOSC2|              
;                                      |13       28|              
;                                      |xtal1   pc6|----32kHz-crystal--[10/18/22pF]--gnd                    
;                                      |      TOSC1|
;                              10kOhm  |14       27|
;                           .-[12kOhm]-|pd0     pc5|------sd-carddetect
;      AVR-SPI-DtaIn--------+  18kOhm  |MISO       |      =avr-input
;      (SD-card-DtaOut -> ) |          |           |      internal pullup to +5V 
;              Gnd-[33kOhm]-'   1kOhm  |15       26|              
;                            .-[1k2]---|pd1     pc4|------sd-writeprotect
;      AVR-SPI-DtaOu---------+  1k8    |MOSI       |      =avr-input 
;      (SD-card-DtaIn <- )   |         |           |      internal pullup to +5V 
;              Gnd-[3.3kOhm]-'         |           |
;                                      |16       25|         .---[10kOhm]--- +3.3V
;           6 RstIn---|<--------o------|pd2     pc3|---|<----+--SPI-(SD)-chip-select
;                   resetswitch-o      |int0       |  1N4148           (AVR-output)
;                                      |           |        
;                                      |17       24|
;           3 Atn(Out&IRQ) ------------|pd3     pc2|--free?
;                                      |int1       |
;                                      |           |
;                                      |           |     [+5V]--[LED-red]--. red-error
;                                      |18       23|                       |
;           3 Atn(Out) ----------------|pd4     pc1|--------------[270Ohm]-'
;                                      |        SDA|     |          10mA  
;                                      |           |     o / o----Gnd        left-mode
;                                      |           |   
;                                      |           |   [+5V]--[LED-green]--. green-active 
;                                      |19       22|                       |
;           3 Atn(Out) ----------------|pd5     pc0|--------------[270Ohm]-'
;                                      |        SCL|     |          10mA 
;                                      |           |     o / o----Gnd        right-value
;                                      |20       21|                       |
;           1 Srq(Pullup) -------------|pd6     pd7|-------o--(test-LED for RTC)
;                                      |           |  JD-2 o---gnd
;                                      '-----------'      
;                                                                         
;           2 Gnd---------------------------0V 

;voltage of divider:
;vcc=5V   (no RTC, no 1N4148 diode between VPS and VCC): use 1.8kOhm and 3.3kOhm resistors
;vcc=4.6V (RTC, BAT85 diode between VPS and VCC): use 1.2kOhm and 3.3kOhm resistors: 
;vcc=4.3V (RTC, 1N4148 diode between VPS and VCC): use 1.0kOhm and 3.3kOhm resistors: 

;if the leakgae-current of a BAT85 is low (much less than 2µA):
;Use perhaps BAT85 instead of 1N4148 => VCC increases from 4.3 to 4.6V
;
;The interrupts have priority in accordance with their Interrupt Vector position.
;The lower the Interrupt Vector address, the higher the priority.
; => connect sleep/awake to int0 (pd2) => highest priority?

;Peter Sieg uses 1.8 and 3.3kOhm resistors for divider
; http://www.forum64.de/wbb3/index.php?page=Thread&postID=293578#post293578
;bad, danger: debugjumper is connected to SrqOut (over SrqIn)
; when JD is closed and flashing: AVR pulls SrqOut-pin to +5V, but JD connects it to 0V
; shortcircuit!!!
;allow perhaps a diode from +5V to vcc to allow perhaps a real time clock with the internal 
; 128kHz oscylator?
;a0-a7 + c4-c7 max 100mA  
;c0-c3 + d0-d7 max 100mA
;b0-b7         max 100mA
;Atmel 
;-doc8002.pdf:
; In most AVR devices, external capacitors need to be connected to the TOSC1/2 pins,
; when connecting an external crystal. This applies to all parts with 1.8V capabilities. In
; other parts, the crystal can be connected directly between the TOSC1/2 pins. Refer
; do the device datasheet for details on crystal connections.
;-doc1259  AVR134: Real Time Clock (RTC) using the Asynchronous Timer
; As shown in Figure 2-1, the crystal should be connected directly between pins
; TOSC1 and TOSC2. Newer devices require external capacitors on these pins as they
; have a different internal oscillator, please refer to the device datasheet for details on
; crystal connections.
;or use low current 2mA LEDs????
;http://www.avrfreaks.net/index.php?name=PNphpBB2&file=viewtopic&t=65840&highlight=
;You can use the CLKPR to slow down the MCU so that your task is executed in a little bit more
; than 1 asynchronous clock cycle. This will reduce current consumption while the AVR is active.
; Note that the MCU clock must be more than 4 times faster than the asynchronous clock. Thus you
; can slow down the calibrated internal 8MHz oscillator to 250kHz when using a 32kHz crystal for
; TimerX

;make a 2mA-LED from +5V to PD2 and resistor to Gnd. => AVR goes earlier to sleep-mode
; so far it needs much current at switching from awake to sleep-mode.
; perhaps make a ?big? capacitor from vcc to gnd. => it has usually 4.3V => it powers the AVR at
; switching from awake -> slwep?
; the capacitor mustn't be too big, else the 1N4148 diode is destroyed at switching the power on 

;         Reverse current  Peak forward surge current
; -1N4148: 0.025µA          2A (1µs)
; -BAT85:  2    µA
; -1N4001  5    µA         50A (1/2/50 Hz)

;Problem when switching from awake to sleep:
;it takes time until the AVR sees that the voltage is so low that the AVR changes to sleep-mode.
;V-PS = votage power-supply   V-BB = voltage backup-battery

;when VPS is connected to pd2 (int0) and int0 generates the sleep-IRQ 
;VPS   VCC
;5.0V  4.3V  the current comes from VPS    AVR is awake
;3.3V  2.6V  the current comes from VPS    AVR is awake
;3.2V  2.6V  the current comes from VBB    AVR is awake but should sleep
;1.3V  2.6V  the current comes from VBB    int0 generates the sleep-IRQ    AVR: awake -> sleep
;0.0V  2.6V  the current comes from VBB    AVR sleeps
;at 3.2-1.3V the current comes from the backup-battery. This time must be short.
;I made this test:
;I connected a 1000µF-capacitor instead of a battery as VBB. I loaded the capacitor with 3V. 
;I connected a Digital-Multi-Meter (DMM) to the capacitor. I meassured the voltage and start a
;clock, when the voltage was 2.9V (the AVR was in power-save-mode (it needes 4.3µA):
; time  VBB
;  0s   2.90V
; 10s   2.85V
; 20s   2.80V
; 30s   2.75V
; 40s   2.70V
; 50s   2.65V
; 60s   2.60V
; => in power-down-mode a difference of 0.05V at the capacitor is a time of 10s.
;(1) VPS came from C64 (joystickport) and there was a 1000µF-capacitor at the NLQHD-SD-board
;then I switched VPS on => AVR is awake. I loaded the VBB-capacitor with 3V. I waited until the
;VBB was 2.9V. Then I switched off the VPS. I waited 10s. Then I measured the VBB at the
;capacitor: It was 2.65V. The difference is 0.25V. This is 50s. Because I measured the time
;10s after having switched off the VPS, I subtracted 10s. So switching off the VPS cost as 
;much current as 40s power-down. This would be good. The C64 pulls much current from the
;1000µF-VPS-capacitor (not the 1000µ-VBB-substitute-capacitor), so the time it need the voltage 
;falls from 3.2 to 1.3V is so short, that the sleep-IRQ is made very fast.
;(2) VPS came from a 5V 600mA power-supply (www.reichelt.de 'MW 3N06GS') (it has two
;330µF-capacitor built-in). I wanted to measure like at (1) how much the volatge decreases at
;switching off. But it took so much time from switching the VPS off until the AVR entered
;power-save-mode that the capacitor was empty before entering the sleep-mode. The time was so
;long that I could measure it with a DMM: 
;First there was no VBB-current: The voltage fell from 5 to 3.3V.  
;Then there was a VBB-current: The voltage fell from 3.2 to 1.3V. It took 10s until the VPS
;fell from 3.3V to 1.3V; the current was 5mA, 1000 times as much as in sleep-mode.
;=> switching the AVR off causes 5mA * 10s = 50mAs =  0.014mAh
;a CR2032 has 210mAh
;210mAh / 0.014mAh = 15000. => when you switch the AVR 15000 times off then the battery is empty
;Then I computed how long the AVR could run with 50mAs (0.014mAh) in power-save-
;mode (0.005mA = 5µA)
;50mAh / 0.005mA = 10000s = 166min = 3hours
;=> switching AVR off cost as much power as 3 hours power-save = bad.
;=> I searched a solution for switching the AVR faster off without needing additional hardware:
;use the analog-comparator (AC). Connect it to VCC and VPS. 
;when the power-supply is on: VPS is 0.7V higher than VCC (at a silicon-diode the volatge is
;0.7V)
;when the power-suuply is of: VCC is at least 2.6V (at a Shottky-diode the volatge is 0.4V) 
;=> when VPS falls below 2.6V then the analog-compartor generates the sleep-IRQ
;=> the voltage must fall below 2.6V only, not below 1.3V lika at pd2-int0-IRQ
;this should be much faster
;don't use pcint3 for waking up AVR, because this generates an IRQ even at a falling 
;(and rising) edge. Because the voltage and so the trigger-level of pd2 changes at switching off
;this could generate an awake-IRQ when the AVR is siwtched off. Use the pd2-int0-Irq for waiking
;up the AVR, because it can be configured that it generates an IRQ at a rising edge only.  
;the AC generates an IRQ one time only at the falling VPS-edge. When this edge-IRQ is lost, then
;there is no sleep-IRQ at all.
;=>read in the 100Hz-IRQ the AC and see when you have to jump to the sleep-mode
;bad: AIN0 is pb2. This is usually the AtnIn-pin, because this can generate an IRQ
;=> use pcint1 for AtnIn-IRQ 
; bad: pcint1-IRQ cannot be used for RTC-IEC-routines=> use pcint0 for RTC-IEC-routines 

;perhaps set bit7 in DIDR0 Digital Input Disable Register 0:
;Input Leakage Current I/O Pin: 1µA
;If this is disabled, then in the moment while switching from awake to sleep the backup-battery
;doesn't need 1µA?
;Analog Comparator Input Leakage Current: 50nA
;perhaps pa7 needs only 0.05µA instead of 1µA
;AC  needs 0.075mA
;ADC needs 0.315mA
;ComputerBild6/09,p18: mobile-phones must have a Micro-USB-plug
;CB12/09,p80: foto of USB-plugs
;perhaps: use such a plug for power supply 


;  (1)        (2)       (3)        (4)         (5)         (6)         (7)      (8)
;Versor-    Spannung  AVR-Trig-  Spannungs-  Spannungs-  Spannungs-  Diode +  1,8kOhm   
;gungs-     an VCC    ger        teiler      teiler      teiler      2mA-LED   +LED
;spannung   v. AVR    Level      330 u.      330 u.      330 u.       +
;                                330 Ohm     303 Ohm     250 Ohm     1,5kOhm
; 5,0V       4,6V      2,3V       2,5V +      2,4V +      2,2V -      2,6V +   1,8V - 
; 4,6V       4,2V      2,1V       2,3V +      2,2V +      2,0V -      2,2V +   1,8V - 
; 4,2V       3,8V      1,9V       2,1V +      2,0V +      1,8V -      1,8V -   1,8V - 
; 3,8V       3,4V      1,7V       1,9V +      1,8V +      1,6V -      1,6V -   1,8V + 
; 3,4V       3,0V      1,5V       1,7V +      1,6V +      1,4V -      1,2V -   1,8V + 
; 3,0V       2,6V      1,3V       1,5V +      1,4V +      1,2V -      0,8V -   1,8V + 
; 2,6V       2,6V      1,3V                                           0,4V -   1,8V +
; 2,2V       2,6V      1,3V                                           0,0V -   1,8V +
; 1,8V       2,6V      1,3V                                           0,0V -   1,8V +
; 1,4V       2,6V      1,3V                                           0,0V -   1,4V +
; 1,0V       2,6V      1,3V                                           0,0V -   1,0V -
; 0,6V       2,6V      1,3V                                           0,0V -   0,6V -
; 0,2V       2,6V      1,3V                                           0,0V -   0,2V -
;                                                                     good     bad

;(1) ist die Versorgungsspannung: Im Bereich 5-3,1V stammt sie von dem Netzteil oder C64.
;     Bei 3V stammt sie von der Backup-Batterie.
;(2) durch die Shottky-Diode, an der 0,4V abfaellt, ist VCC am AVR um eben diese 0,4V niedriger.
;(3) ist der Trigger-Level des AVRs in Abhaemgigkeit von der Versorgungsspannung und ist nicht
;     aenderbar.
;(4) - (7): 
;          + bedeutet, dass die erzeugte Spannung groesser ist als der AVR-Trigger-Level
;          - bedeutet, dass die erzeugte Spannung kleinerr ist als der AVR-Trigger-Level
;(4) ist die Spannung am Spannungsteiler bestehend aus zwei 330 Ohm-Widerstaenden.
;     Sie ist immer groesser, sodass der Pin nie umschaltet
;(5) ist die Spannung am Spannungsteiler bestehend aus 330 und 303 Ohm-Widerstaenden
;     Sie ist immer groesser, sodass der Pin nie umschaltet
;(6) ist die Spannung am Spannungsteiler bestehend aus 330 und 250 Ohm-Widerstaenden
;     Sie ist immer kleiner, sodass der Pin nie umschaltet
;(7) ist die Spannung am Spannungsteiler bestehend aus Si-Diode, LED u. 1,5kOhm Widerstand
;     An Diode und LED faellt (hoffentlich) halbwegs konstant 2,4V ab     
;     Bei ca 4,4V schaltet der AVR-Input um, sodass man hier in den Schlafmodus wechseln koennte
;(8) ist die Spannung am Spannungsteiler bestehend aus 1,5kOhm Widerstand und LED 
;     An der LED faellt (hoffentlich) halbwegs konstant 1,8V ab     
;     Bei ca 4,0V schaltet der AVR-Input um, sodass man hier in den Schlafmodus wechseln koennte

;gehause aus forum64: SD 10 GR 0.59 euro
;http://www.reichelt.de/?;ACTION=3;LA=444;GROUP=C714;GROUPID=3355;ARTICLE=16993;START=0;SORT=user;OFFSET=16;SID=29ITUHCKwQAR0AAFpAjsk90d7583f114f228b0340773da8b476d0

;------------------------------------------------------------------------------------------------
;http://www.forum64.de/wbb3/index.php?page=Thread&postID=342270#post342270
;Unseen: Cheap SD-cards don't support SPI

;http://www.forum64.de/wbb3/index.php?page=Thread&postID=343009#post343009
; Unseen: -standard-size-SD-cards MUST support SPI-interface
;         -Mini-SD: he doesn't know  
;         -Micro-SD; CAN or CANNOT support SPI-interface

;perhaps change the hardware???
;ProdManualMMCv5.2.pdf page24: see pullup resistors...
; page28: pullup-resistance:50-100kOhm
;Bus signal line capacitance: 250pF ( 5 MHz, 30 cards)
;                             100pF (20 MHz, 10 cards)
; 1N4148 has  4pF
; BAT85  has 10pF   

;     GND        AVR            SD         VDD       
;      0V        0-5V          0-3.3V      3.3V
;      |          |              |          | 
;      |          |              |          | 
;      |          |-->|-->|-->|--|          |  1N4148 when AVR pullsup                   1.33pF
;      |          |              |          |         changes AVR-5V -> SD-3.3V
;      |          |              |          | 
;      |          |------|<------|          |  1N4148 when AVR pulls down                4.00pF  
;      |          |              |          |         (changes AVR-0V -> SD-0.7V) 
;      |          |              |          |         (or BAT85 but higher capacitance)
;      |          |              |          | 
;      |          |---[50kOhm]---|          |  resistor when AVR is input and SD=output 
;      |          |              |          | 
;      |          |              |          | 
;      |          |              |          | 
;      |                         |          |
;      |---->|-------------------|          |  BAT85 as protection that V isn't         10.00pF 
;      |                         |---->|----|            > 3.3V+0.5V or < -0.5V         10.00pF
;                                                                                     ---------
;this is a change from 5V <-> 3.3V which is bidirectional                               25.00pF

; but the software would be very complicated: Every bit must be made manually!!!
;mmc2iec_petersieg.gif  no resistors at AVR-input from SD-card (=bad)
;                      (1.8kOhm and 3.3kOhm at AVR-outputs to SD-card)

;http://www.forum64.de/wbb3/index.php?page=Thread&postID=348026#post348026
;Ein Pullup-Widerstand am Ausgang der MMC/SD Karte (DO) ist für eine saubere Initialisierung
; per SPI notwendig



;------------------------------------------------------------------------------------------------
;Perhaps: PB2 can generate an IRQ (INT2)
; If the Flashram or EEPROM isn't corrupted when the IEC-Clock is always connected to PB7 (SCK)
;  then all IEC-Line could be connected to the same Port (PrtB) 
;  One would save a DIP-switch for connecting IEC-Clock to SCK (PB7) for flashing?????
;  
;  A switch could be connected to PD2 = Int0
;   => this could wake up the AVR from a sleep-mode
;      IRQ-Pin of real time clock could also be connected to PD2
;      => the RTC could also wake up the AVR    
;
;http://www.forum64.de/wbb3/index.php?page=Thread&postID=329726#post329726
; Unssen: Clock-line should be between 3.3V- and Dng-wire, far awy from datalines
;  else the clock-line could induct a voltage to the data-lines
          
;------------------------------------------------------------------------------------------------
;                               NLQ-HD/full
;
;                          without any warranty
;                                                                        
;       IEC-BUS                                                               ATA-BUS       
;at    /       \                                                        
;flashing      usually                                                         ||||||                         
;||||||||      ||||||                                                          VVVVVV                          
;VVVVVVVV      VVVVVV                                               
;                                                                    
;        
;          +3.3V-[1kOhm]-.                 
;                        |             .----. .----.                
;             SPI-Clk-----<07f<-----.  |    | |    |
;          (400kHz?) 0/3.3V     0/5V|  |1   '-'  26|
;                                   +--|pb0     pa0|------------------ a_dd0       17
;                  25 a_dior--------'  |XCK        |
;                                      |     A     |                                  
;                                      |2    T   39|
;           1 SrqIn------->244a>-------|pb1  M  pa1|------------------ a_dd1       15                          
;                                      |     E     |                                  
;                                      |3    L   38|                                   
;           3 AtnIn ------>244b>-------|pb2     pa2|------------------ a_dd2       13                        
;                                      |     A     |                                  
;                                      |4    V   37|                                   
;           4 ClkOut -----<07c<--------|pb3  R  pa3|------------------ a_dd3       11                          
;                                      |           |                                  
;                                      |5    A   36|                                   
;           5 DtaOut -----<07d<--------|pb4  T  pa4|------------------ a_dd4        9
;                                      |     M     |                                   
;                                      |6    E   35|                                  
;DtaIn      5 DtaIn  ----->244d>-------|pb5  G  pa5|------------------ a_dd5        7                        
;                                      |     A     |                                   
;                                      |7        34|                                  
;SrqOut     1 SrqOut -----<07a<--------|pb6  6  pa6|------------------ a_dd6        5                     
;                                      |     4     |                                   
;                                      |8    4   33|                                  
;ClkIn      4 ClkIn  ----->244c>-------|pb7     pa7|------------------ a_dd7        3                      
;                                      |           |
;                                      |9        32|                 |
;Gnd        6 RstIn----->244e>--|<--o--|reset  aref|---[47kOhm]-.  |/
;                           Gnd-----o  |           |            +--| BC547 (NPN)
;                                JG-1  |           | .-[47kOhm]-'  |\ 
;                                      |           | |               |
;                                      |           | '-Gnd           Gnd
;                                      |10       31|             
;                        +5V-----------|vcc     gnd|-0V
;                                      |           |
;                                      |11       30|   
;           2 Gnd---------0V-----------|gnd    avcc|- +5V (don't forget)
;                                      |           |
;                                      |12       29|
;             Gnd-[56pF]---------------|xtal-2  pc7|------------------ a_dd15      18
;                        '-[8MHz]-.    |           |              
;                           crystal]-. |13       28|              
;             Gnd-[56pF]---------------|xtal-1  pc6|------------------ a_dd14      16
;                                      |           |
;         +3.3V-[10kOhm]-.             |           |
;                        |             |14       27|
;         AVR-SPI-DtaIn--->244g>-------|pd0     pc5|------------------ a_dd13      14
;      (SD-card-DtaOut -> )            |MISO       |
;                                      |           |
;          +3.3V-[1kOhm]-.             |           |
;                        |             |15       26|
;         AVR-SPI-DtaOut--<07e<--------|pd1     pc4|------------------ a_dd12      13
;      (SD-card-DtaIn <- )             |MOSI       |
;                                      |           |
;                                      |16       25|
;                  23 a_diow ----------|pd2     pc3|------------------ a_dd11      12
;                                      |           |
;                                      |17       24|
;                  35 a_da0 -----------|pd3     pc2|------------------ a_dd10       8
;                                      |           |           
;                                      |18       23|
;                  33 a_da1 -----------|pd4     pc1|------------------ a_dd9        6
;                                      |           |            
;                                      |19       22|            
;                  36 a_da2 -----------|pd5     pc0|------------------ a_dd8        4
;                                      |           |
;                  +3.3V-[10kOhm]-.    |           | 
;                                 |    |20       21| 
;             I2C-Clk------------------|pd6     pd7|-----. 
;                                      '-----------'     | 
;                  +3.3V-[10kOhm]-.                      | 
;                                 |                      |
;             I2C-Dta------------------------------------'
;
;                                           0V ----------------------- a_cs0       37
;                                                                         
;           2 Gnd---------------------------0V -------------------- a_gnd  2,19,22,24,26,30,40
;
;                           unconnected:                             (20),21,27,28,29,31,32,34
;                           unconnected:                              39 = HD-drive-active-LED   
;
;Peter Sieg uses 33pF capacities at 8MHz-crystal
;check the voltage at AVR-SPI-DtaIn when no card is connected. Is it 3.9v or more???
; (if more then perhaps protection-diode to 3.3V???)
;make diode and 10kOhm-pullup-rsistor at reset line => one could save 1 dip-switch and use a
;resetswitch??????????????????????????
;one could perhaps make the HD-reset via an 56kOhm-resistor an an NPN-transistor an 'aref'
;one could make 4 switches at pcf8574 (but CMD-HD has also three switches only)?????
;or it could be connected to int of pcf8583 via 74LS244???
;probably no good idea, because it's not easy to make it CMD_HD compatikle
; because there must be also a possibility to change to the next NLQ-HD-emulation-device
;                 
;                                      .----. .----.                
;                                      |    | |    |
;                                      |1   '-'  16|
;                                  Gnd-|a0      Vdd|--- +3.3V  (!! not +5V !!)
;                                      |           |
;                                      |2        15|                                  
;                                  Gnd-|a1   P  sda|--- I2C-data                          
;                                      |     C     |                                  
;                                      |3    F   14|                                   
;                                  Gnd-|a2      scl|--- I2C-clock  (100kHz)                        
;                                      |     8     |                                  
;                                      |     5     |
;             green-active             |     7     |
;           .--[LED-green]--[+3.3V]    |     4     |
;           |                          |4        13|
;           '-[100Ohm]-----------------|p0     -int|
;               10mA            |      |           |
;                    Gnd----o / o      |           |
;                        right-value   |           |
;                                      |           |
;              red-error               |           |
;           .--[LED-red]--[+3.3V]      |           |
;           |                          |5        12|
;           '-[100Ohm]-----------------|p1       p7|------ sd-carddetect-in 
;               10mA            |      |           |    
;                    Gnd----o / o      |           |      
;                         left-mode    |           |   
;                                      |6        11|------ sd-writeprotect-in              
;                           Gnd---oo---|p2       p6|   
;                                JD-2  |           |          
;           1 a_reset-.                |7        10|
;                     +-X-<244f<-------|p3       p5|------ SPI-(SD)-chip-select-out 
;          38 a_cs1---'                |           |         
;                                      |8         9|
;                                  Gnd-|Vss      p4|----.
;                                      '-----------'    |
;                                                       |
;           3 AtnOut -----<07b<-------------------------'
;perhaps diode and pullup-resistor to a_reset and a_cs1 to allow TriState to allow 
; connection of aexternal USB-adapter
;                                                                    
;                                   .-----[12pF]------.
;                                   |                 |
;                                   |  .----. .----.  |                
;                                   |  |    | |    |  |
;                                   |  |1   '-'   8|  |  .---|<--- +3.3V  (!! not +5V !!)
;                    32kHz-crystal-----|osci    Vdd|----- 
;                                      |     P     |   | '---|<--- +3V-lithium-batteriy
;                                      |2    C    7|   |                       
;                    32kHz-crystal-----|osco F -int|   '-[100nF]-Gnd                            
;                                      |           |                                  
;                                      |3    8    6|                                   
;                                  Gnd-|a0   5  scl|----- I2C-clock  (100kHz)                                     
;                                      |     8     |                                  
;                                      |4    3    5|
;                                  Gnd-|Vss     sda|----- I2C-data          
;                                      '-----------'  
;
;                1N4148
;           1 Srq--|<-1kOhm-.   
;                           |
;           3 Atn--|<-1kOhm-|
;                           | 
;           4 Clk--|<-1kOhm-+-------DIP-switch3-- +5V   switches 25mA
;                           |  JP-3                    (unswitched: 100mA)
;           5 Dta--|<-1kOhm-|       
;                           |  
;           6 Rst--|<-1kOhm-'
;                  
; input connected to +5V:  LS244h

;             .------.
;             |      |
;  +5V--------|LM2937|-----------+3.3V
;       |     | -3.3 |        |
;       |     |      |        |                
;       |     '------'        |
;       |         |           |
;       '-[0.1µF]-|--[>=10µF]-'  => use 22µF
;                 0V 
;capacitor at input (0.1µF) only necessray if distance power supply filter capacitors to LM2937
; is more than 7.5cm
; LF33CV: always input-capacitor 0.1µF
;         output-capacitor 2.2µF
;make perhaps second IDE-plug for external USB-Adapter  ( = X at cuircuit-plan)
; !! then all lines (also a_reset and a_CS1) must be tristate

;http://www.forum64.de/wbb3/index.php?page=Thread&postID=258739#post258739
; Shadowolf explains why 56pF instead of 22pF capacities at 8MHz-crystal

;http://www.forum64.de/wbb3/index.php?page=Thread&postID=329726#post329726
;Unseen: Gnd or +3.3V-line must be between clock- and datalines!!!!!!!!!!!!!!!!
;------------------------------------------------------------------------------------------------
;        display

;                                          
;                                      .----. .----.                
;                                      |    | |    |
;                                 JR   |1   '-'  28|
;                                   o--|pc6     pc5|-switch escape (+ LED)
;                              gnd--o  |reset      |
;                                      |     A     |                                  
;                                      |2    T   27|
;             main-AVR-reset-----------|pd0  M  pc4|-switch ok     (+ LED (new track-step))
;                                      |     E     |                                  
;                                      |3    L   26|                                   
;                162-R/S---------------|pd1     pc3|-switch up    + LED (error)
;                                      |     A     |                                  
;                                      |4    V   25|                                   
;                162-E0 ---------------|pd2  R  pc2|-switch down  + LED (SD-LED)
;                                      |int0       |                                  
;                                      |5    A   24|                                   
;                162-E1 ---------------|pd3  T  pc1|-switch right + LED (CD-LED)
;                                      |int1 M     |                                   
;                                      |6    E   23|                                  
;                162-Dta4--------------|pd4  G  pc0|-switch left  + LED (HD-LED)
;                         1N4148       |     A     |                                   
;                 +5V-->|--.     vcc   |7        22|                                  
;                           -----------|vcc  8  gnd|----gnd
;                 +3V-->|--'         | |     8     |                                   
;                        bat85       | |     V     | 
;                          .-[100nF]-' |           |  '--------------.  
;                          |           |8        21|                 |
;                    gnd---------------|gnd    aref|---[47kOhm]-.  |/
;                                      |           |            +--| BC547 (NPN)
;                                      |           | .-[47kOhm]-'  |\ 
;                                      |           | |               |
;                                      |           | '-Gnd           Gnd
;                                      |9        20|                                 
;                        32kHz-crystal-|pb6    avcc|---vcc  
;                                      |tosc1      |
;                                      |           |
;                                      |10       19|
;                        32kHz-crystal-|pb7     pb5|---- I2C-Clk
;                                      |tosc2   sck|
;                                      |           |  
;                                      |11       18|   
;                162-Dta5--------------|pd5     pb4|----- loudness 2
;                                      |oc0b   miso|   
;                                      |12       17|
;                162-Dta6--------------|pd6     pb3|---- I2C-Dta
;                                      |oc0a   mosi|              
;                                      |           |  
;                                      |13       16|
;                                      |pd7     pb2|-----------------[2.2kOhm]----piezo-sound
;                162-Dta7--------------|       oc1b|     PWM-mode of timer1     | 
;                                      |           |                Gnd-[100nF]-'
;                                      |14       15|   
;                      loudness 0 -----|pb0     pb1|----- loudness 1
;                                      |       oc1a|                   
;                                      '-----------'      
;                       
;timer0 (8bit)
;timer1 is 16bit (for piezo-sound?)
;timer2 (8bit) is for RTC => cannot be used for PWM-output-pin

;perhaps better: pin16 as sound-output for floppy-sound (summer epm121)
; piezoschallwandler or elektromechanische schallwandler
;doc2542 Using the AVRs High-speed PWM.pdf
;r=10kOhm c=100nF => crossover-frequency=1024Hz???
;doc1456 Digital Sound Recorder.pdf
;r=12kOhm c=22nF => cut-off-frequency=4000Hz???
;=> use perhaps r=2.2 - 2.7kOhm c=100nF
;EPM121A1AWP-T has already 14nF capacitor

;perhaps it's possible to use a JFET instead of /four) reisitors for the sound level?
;http://www.mikrocontroller.net/topic/96548
;http://www.pci-card.com/versuch3.pdf
;http://www.mikrocontroller.net/articles/Standardbauelemente (BS170?)
;reichelt: perhaps BS170, BS108

;elector newsletter 12.07.2009: DPP = digital positionable potentiometer
; ON-Semiconductor  CAT5171 and CAT5172  =50kOhm / 100kOhm   I2C- / SPI-bus 

;http://www.ulrichradig.de/
; megalol =Sprachausgabe mit ATMEGA

; a display with 4 lines: does it consist of 2 controllers and you need a separte wire to E1-pin?

;Text-LCDs.pdf:there are 8 user defined chars. 
;charcode 0-7
;bitcode for char0 is at CG-RAM0-7, char1 at CG-RAM 8-$f...


;see l10010: if you use a 88V (not 88) then 3V-backup-battery (and Shottky-diode) could be enough. 

;it's not necessary to read the interface => 162-R/W could be always connected to gnd?

;http://sprut.de/electronic/lcd/index.htm
;   in the lower third of the article the 4-bit-acces is explained

;http://www.forum64.de/wbb3/index.php?page=Thread&postID=307134#post307134
;  here the 4-bit-interface is used????
;    http://home.iae.nl/users/pouweha/lcd/lcd0.shtml                                                     
; connection to main AVR
;- +5V
;  +3.3V/+5V for I2Cpullup
;  main-AVR-reset
;  I2C-Dta
;  I2C-Clk
;  Gnd   

;Elektor 3/09 p51: 162display-contrast pin is connected to +5V (without damage?)


; connected via I2C
; flashable via I2C
; 6 switches
; 4 LEDs
; Real Time Clock (for NLQ-HD/lite)
; if 4 of 6 switches are pressed then can make a hardware reset of main AVR
; perhaps reichelt        lcd 162c  or  lcd 162C led
;LCD 162:
; 5V => two wires to main-avr  1for 5V     1for 3.3Vpullup
; pins:
; - 8 datapins
; - 1 RS-pin: 0=instruction-code 1=databyte
; - 1 R/W-pin: 0=write 1=read
; - 1 E-pin: chip Enable = edge confirms byte

; - 2 I2C-pins
; - 6 switch-pins escape, ok, left, right, up, down
; - 4 LED-pins
; - 1 pin for hardwarereset of main-AVR
; - 2 RTC-pins

; type      PDIP    I/O  FLASH EEPROM RAM RTC


; mega48     28      23     4  0.25   0.5  +   34.6 * 10.1mm  (1.20 Euro) 1I/O-pin is reset *
; mega88     28      23     8  0.5    1    +   34.6 * 10.1mm  (1.89 Euro) 1I/O-pin is reset *
; mega168    28      23    16  0.5    1    +   34.6 * 10.1mm  (2.85 Euro) 1I/O-pin is reset
; mega328    28      23    32  1      2    +   34.6 * 10.1mm              1I/O-pin is reset

; mega8      28      23     8  0.5    1    +   34.6 * 10.1mm  (1.35 Euro) 1I/O-pin is reset

; tiny48     28      24     4  0.0625 0.25 -   34.6 * 10.1mm              no RTC
; tiny88     28      24     8  0.0625 0.5  -                              no RTC 

; mega48 has not bootloader area
; * Not recommended for new designs (MEGA44, MEGA88)
; * Not recommended for new designs (MEGA168 (17.06.2009))
; but 44PA, 88PA and 168PA are new chips (17.06.2009)

;http://www.maxim-ic.com/appnotes.cfm/an_pk/617
;http://www.maxim-ic.com/appnotes.cfm/an_pk/616/ln/en
; a 12.5pF 32kHz-crystal should have two RTC-chip-internal 25pF-capacities

;PCF8583: a 5-25pF-trimmer is made between +5V and OSCI (oscylator input)
;         (1 capacitor only, not 2)
; at M644: TOSC1 is input?

;C:\_downloads\View topic - rtc not being accurate  AVR Freaks.mht
; RTC is too slow -> increase capacitor
; RTC is too fast -> decrease capacitor

;doc1259.pdf (atmel): the crystal should be connected directly between pins
;TOSC1 and TOSC2. Newer devices require external capacitors on these pins as they
;have a different internal oscillator, please refer to the device datasheet for details on
;crystal connections.
;!!!capacitors (plural) not capacitor (singular) => two capacitors!!! 

;doc8002.pdf (atmel):
;In most AVR devices, external capacitors need to be connected to the TOSC1/2 pins,
;when connecting an external crystal. This applies to all parts with 1.8V capabilities. In
;other parts, the crystal can be connected directly between the TOSC1/2 pins. Refer
;do the device datasheet for details on crystal connections.
;------------------------------------------------------------------------------------------------
;Eagle Bibliotheken:
;http://www.forum64.de/wbb3/index.php?page=Thread&postID=238225&highlight=bibliothek#post238225
;http://www.forum64.de/wbb3/index.php?page=Thread&postID=169577&highlight=bibliothek#post169577
;http://www.forum64.de/wbb3/index.php?page=Thread&postID=166228&highlight=bibliothek#post166228

;SD-sockets:        Speicherkarten-Slots     MMC/SD Slots
;http://www.csd-electronics.de/de/index.htm bestellnummer  02012
;http://www.ulrichradig.de/home/index.php/menu_head/rhs_elektronik_onlineshop
;  ->Bauteile ->passiv ->MMC/SD-Slots (1.49Euro)
;https://www.it-wns.de/themes/kategorie/detail.php?artikelid=350&kategorieid=61&source=1


;Peter Sieg ordered prototype-board for 12 Euros
; http://www.forum64.de/wbb3/index.php?page=Thread&postID=295055#post295055
; www.platinenbelichter.de (Peter Sieg)
; www.platinenhersteller.de (Oliver Weißflach) http://www.anttronic.de/pcb/
; www.pcbcart.com (Peter Sieg) China
; www.futurlec.com (Nick Coplin) Thailand
; www.elektorpcbservice.de Elektor Newsletter 22.05.2009
; http://mme-pcb.de/kauf/kategorie13/index.html 25,90Euro + 5,00Euro (doublesided)


;Unseen: CIA and VIA: 
;http://www.forum64.de/wbb3/index.php?page=Thread&postID=230505#post230505

;protection against wrong power-connection: ???
;http://www.mikrocontroller.net/topic/42113

;Shodowolf says a DS1307 would be better 
;(http://www.forum64.de/wbb3/index.php?page=Thread&threadID=24676&pageNo=3)

;make a fifths jumper and connect via cable to AVR-chip which controls the LCD-display
; => one could flash the second AVR without openeing the housing
;
;make all 4 switch-/LED-pins to LEDs => there is 1 LED for every deviceemulation
;
;make the HD-LED-pin to an external LED
;
;at the reset-input: the 74LS244output is 0-15V. the anode of the 1N4148-diode is 0.75V.
; if it workst then it will be ok
; if 0.75V is not low enough to make areset then one will have to use a BAT85-diode???

;make a jumper on the circuitboard to allow changing of a_reset and a_cs1 from aref to pcf 8574
; if aref is too weak to power the transistor and is destroyed
;VREF can also be measured at the AREF pin with a high impedant voltmeter. Note that VREF is a
; high impedant source, and only a capacitive load should be connected in a system.

; level-changer: 74HC4050 ???  (http://www.mikrocontroller.net/topic/83405)

;don't forget 10µF (or more) capacitor at 3.3V. There were high currency-peaks (=low voltage-
; peaks) when I used a MMC-card which used 45mA => there were errors when reading the switches.

; 2.7V of overvoltage-protection is made with 2.7V 500mW zenerdiode

;
; SD-/MMC-card have usually 3.6V. Reichelt doesn't have a 3.6V voltage-regulator.
; There seems even to be no 3.5V-type
; => one must perhaps use a 3.3V-type and see whether the SD-card works with it?????
; If 3.3V instead of 3.5V: Use 100Ohm LED-resistors instead of 120Ohm ones
;
;                       -|<-  =1N4148
;
; perhaps use a BAT85 instead of a 1N4148. The foreward voltage at 30mA is 0.5 instead of 0.9V
; (allowed are 0.3V) but bat85 has greater capacity than 1N4148

;perhaps 1N4148-protection-diods to 2.7V-zener-diod (500mW)??? instead of 3.3V regulator???
;
;Electrical Life: 2000 operations min. - per switch - 24V DC,25mA.
;Non-Switching Rating: 100mA, 50V DC.
;Switching Rating : 25mA, 24V DC.
;Contact Resistance : (@ 100mA): 50 mOhm max. (initial). 100 mOhm max.after life test.
;
;also diods from 3.3V-pins to +3.3V-power to prevent that power goes to +5V if the
; AVR-pullup-resistor is activated or if the pin is switched to +5V output

;it's impossible to use the SPI-hardware of the AVR (e.g. pin pd0 and pd1 of UART) 
; because this would pull to +5V instead of +3.3V


;A proper, matched, switch on the socket side will indicate to the host that the card is
;write-protected or not. It is the responsibility of the host to protect the card. The position
;of the write protect switch is un-known to the internal circuitry of the card.
;sd works with 3.3V => avr cannot pull active to 5V. must use pullup-resistors to 3.3V
;use 10kOhm    page 3-8 of SanDisk Secure Digital (SD) Card Product Manual, Rev. 1.9

;the Action Replay cartridge floppy speeder synchronized perhaps every 4 bytes => the
; NLQ-HD-clock must probably be very exact => make a place on the circuit-board for a crystal and
; two capacities!!!!!
;------------------------------------------------------------------------------------------------
;           (1)         (2)     (3)       (4, 5)         (6)        (7)
;        IEC-ATA-V2  MMC2IEC  SD2IEC  NLQ-HD/lite     NLQ-HD/SD  NLQ-HD/full
;PB0         -                            AtnOut          -          -  
;PB1         -                            SrqIn         SrqIn      SrqIn
;PB2       ClkOut                         AtnIn         AtnIn      AtnIn
;PB3       ClkIn                          ClkOut        SrqOut     ClkOut
;PB4       DtaOut                         DtaOut        SrqOut     DtaOut
;PB5       DtaIn                          DtaIn         DtaIn      DtaIn
;PB6       SrqOut                         SrqOut        SrqOut     SrqOut
;PB7       AtnOut                         ClkIn         ClkIn      ClkIn
;         (ClkIn)

;PD2       AtnIn
;PE0       SrqIn
;                                                            PCF8574-Pin2
;                                                               AtnOut  
;           (1)         (2)     (3)       (4, 5)         (6)        (7)
;        IEC-ATA-V2  MMC2IEC  SD2IEC  NLQ-HD/liteonly  NLQ-HD/SD  NLQ-HD/full
;------------------------------------------------------------------------------------------------
;           (1)         (2)     (3)       (4, 5)         (6)        (7)
;        IEC-ATA-V2  MMC2IEC  SD2IEC  NLQ-HD/liteonly  NLQ-HD/SD  NLQ-HD/full
;SrqIn      e0          -        a3        b1            b1         b1 
;ClkIn      b3 (b7)     c2       a2        b7            b7         b7
;DtaIn      b5          c1       a1        b5            b5         b5
;AtnIn      d2          c0       a0        b2            b2         b2  
;SrqOut     b6          -        a7        b6         b6,b4,b3,b1   b6
;ClkOut     b2          c2       a6        b3           a0-a3       b3
;DtaOut     b4          c1       a5        b4           a4-a7       b4
;AtnOut     b7          c0       a4        b0           c0-c3    (I2C-bus)  
;
;         b0=diow             inverted               b0=SPI-Clk  b0=SPI-Clk 
;         b1=dior             outputs                               &dior
;           (1)         (2)     (3)       (4, 5)         (6)        (7)
;        IEC-ATA-V2  MMC2IEC  SD2IEC  NLQ-HD/liteonly  NLQ-HD/SD  NLQ-HD/full
;------------------------------------------------------------------------------------------------
;      IDE-plug  IECATA NLQ-HD  IDE  cable   
;
;       1 reset  IecRst pd2/aref 1
;       2 ground ground ground   2
;       3 a7     pa7    pa7      3
;       4 a8     pc0    pc0      4
;       5 a6     pa6    pa6      5
;       6 a9     pc1    pc1      6
;       7 a5     pa5    pa5      7
;       8 a10    pc2    pc2      8
;       9 a4     pa4    pa4      9 
;      10 a11    pc3    pc3     10
;      11 a3     pa3    pa3     11
;      12 a12    pc4    pc4     12
;      13 a2     pa2    pa2     13
;      14 a13    pc5    pc5     14
;      15 a1     pa1    pa1     15
;      16 a14    pc6    pc6     16    
;      17 a0     pa0    pa0     17
;      18 a15    pc7    pc7     18
;      19 ground ground ground  19 
;      20 key    nc     nc      20
;      21 DMARQ  nc     nc      21
;      22 ground ground ground  22  
;      23 DIOW   pb0    pd6/pd2 23
;      24 ground ground ground  24
;      25 DIOR   pb1    pd7/pb0 25
;      26 ground ground ground  26
;      27 IORDY  nc     nc      27
;      28 CSEL   ground nc      28
;      29 DMACK  nc     nc      29
;      30 ground ground ground  30    
;      31 INTRQ  nc     nc      31
;      32 IOCS16 nc     nc      32
;      33 DA1    pd4    pd4     33
;      34 PDIAG/CBLID nc nc     34
;      35 DA0    pd3    pd3     35
;      36 DA2    pd5    pd5     36
;      37 CS0    pd0    Gnd     37
;      38 CS1    pd1    +5V     38
;      39 DASP   LED    nc      39
;      40 ground ground ground  40
;------------------------------------------------------------------------------------------------
;
;
;                   .------------------------.
;                  /                         |
;                 /   1  2  3  4  5  6  7  8 | 
;                / 9                         |
;               |                            |            
;               |                            |  
;               |                            |  
;               |                            |  

;     1 Chip Select (Active low)                             PCF8574-Bit5   
;     2 DataIn      (from AVR to SD-card (=AVR-SPI-DtaOut))  PD1
;     3 VSS1        (Ground 0V)
;     4 VDD         (+3.3V should be 3.6V)
;     5 CLK                                                  PB0 
;     6 VSS2        (Ground 0V)
;     7 DataOut     (from SD-card to AVR (=AVR-SPI-DtaIn))   PD0
;     8 RSV         (Reserved  10kOhm to +3.3V)
;     9 RSV         (Reserved  10kOhm to +3.3V)
;       carddetect                                           PCF8574-Bit7
;       writeprotect                                         PCF8574-Bit6

;------------------------------------------------------------------------------------------------
;
;     5 pullup resistors from IEC-wires to +5V (1KOhm)
;       (perhaps not necessary if the AVR is in the middle of the device-chain
;          = the other devices pull the wires up)
;       (shouldn't be used if more than 3 different serial devices (plus AVR, plus C64) are
;         connected because else the currency which a device must make to pull a wire
;         to 0V could be too big)
;       connect 5 pullupresistors via 5 1n4148-diods via a DIP-switch/Jumper to +5V
;        => user can decide whether he wants pullup-resistors or not
;
;There are few pins. I2C-Clock must be a double-function of a different pin. I use dior, 
; the read pulse to the HD. da0-da2 are bad, because it could be delayed when a long I2C-cable
; is connected. diow is bad, because there is anything written into a HD status-register. 
; dior is perhaps delayed when a long I2C-cable is connected (=> add perhaps an additional
; NOP-command at reading HD-bytes). 
; I2C-Clock must be an open-collector at the documentinstruction. At NLQ-HD it isn't
; open-collector, but active pulled to +5V. I think that this doesn't cause problems as long
; as there is no second master connected to the I2C-bus. => It's forbitten to connect masters
; to the NLQ-HD-I2C-bus. Connect slaves only to the NLQ-HD-I2C-bus!!! 
; 
;Bad at I2C:
;-at flashing: I2C-Clock is high, I2C-Data is changed by the C64 (because connected to IEC-Clock) 
;   I2C-slave receives many Start- and Stop-conditions. I hope that this doesn't destroy 
;   (real-time-clock-) datas in the I2C-slave. I hope that the I2C-slave doesn't activate (=pull
;   to 0V) the I2C-data-line which is connected at flashing to IEC-Clock-line 
;   If this happened then JI would have to be disconnected while flashing
;-at HD-access: Every Dior-pulse to the HD is also a clock-pulse to the I2C-bus. 
;   => there must be always a Stop-condition to the I2C-bus sent => the I2C-slave doesn't
;   react on this I2C-clock-pulses
;-at I2C-access: Every I2C-Clock-pulse to the I2C-bus is also a read-pulse to the HD.
;   => the HD sends datas to the 16-bit-parralel-bus to the AVR.
;
;At Reset: Some HDs stop the motor and the heads touch the disk-surface = bad
;=> better if C64-reset isn't connected with HD-reset (but perhaps capacitor from HD-reset
;    to grond and diod from HD-reset to +5V (to empty capacitor when switched off)
;It's not possible to make a switch/jumper to an ATA-pin, because they aren't open collector.
;=> Switches/jumpers must be at IEC-pins (because they are open-collector)
;=> use SrqIn as switch (because C128-fast-serial-bus will probably never be implemented)
; The Debug-switch pulls the AVR-SrqIn-pin to 0V, but doesn't change the IEC-SrqIn-line at
;  the NLQ-HD-version with driver chips
; The Debug-switch pulls the AVR-SrqIn-pin and the IEC-SrqIn-line to 0V at the NLQ-HD-version
; without driver chips. When the Srq-line is pulled to 0V then a 1581 can't be accessed from the
; C64 ( a 1541 and a 1571 can be accessed)
;
;reset-resistor is probably not necessary; you can try without 
;
;there are very few pins (e.g. for a second switch for device-swap and disk-image-change and a 
;LED).
;
;perhaps aref pin32 could be used as an output pin (with amplifier-transistor). The reference
; voltage can be changed from 2.56 to 5V?????
;
;pin30 AVCC should be externally connected to VCC (+5V), even if the AnalogDigitalConverter is
; not used
;
;a-cs1 pin15 of AVR-MEGA644: The software never accesses the control block register of ATA-bus
; a_cs1 of ATA could be connected to +5V allways (or perhaps unconnected)
; => pin15 could perhaps be used for a switch???
;
;perhaps: 
;connect CS0 allways to ground    (possible because AVR never)
;connect CS1 via resistor to +5V  (accesses control block registers)
; =>pin15 can be use for HD-reset (saves two resistors and one transistor)
; =>pin14 can be used for real time clock via ??? 
; pin 17 could be used as clock for serial bus???


;------------------------------------------------------------------------------------------------
; +5V can be taken from pin 7 of C64 joystick-port
; Gnd can be taken from pin 8 of C64 joystick-port
;           
;
;
; ->244>- 74LS244 ( I->244>-O)  8 bus-driver            (244a - 244h)
;  (connect 2 unused driver-units with ?+5V? to avoid swinging???)
;  (use two of them for driving the 2 LEDs with 15-20mA???)
;
; -<07<- 7407    ( O-<07<-I)    6 driver  open collector  (07a - 07f)
;               7407 is probably not more produced => use 74LS07 instead
;               see LED-pins (l25500): An LS pulls with so few current to high, that it needs
;                  a long time untile in inactiev input is pulled by the LS to high
;                  => the AVR must perhaps pull active to high (pin=output and +5V)???
;                     (this would be dangerous at the cheap version to pull the IEC-line active
;                      to +5V)
;
; -<4148<-  diode 1N4148
;  C    A                   Cathode Anode
;
; The AVR has a built-in 30-60kOhm resistor at the reset-pin
;  => the 10kOhm pullup resistor is proably not necessary
;
; I = input    O = output
;
;user jumpers or dip-switches
;
;  #1
; -o                   usually PB1 is connected SrqIn  
;  o- = JD = Jumper Debug
; -o                   when connected to ground, then in debug mode 
;  #2                                            (debug-printing at reset
;                                                  or don't write into
;                                                  debug-buffer)
;a configbyte in the EEPROM must determine whether PB1 is for fast serial bus or debug-printing
;
; -o#1                 usually pb7 is connected to I2C-clock (to prevent accidential flashing)
;  o-   = JC = Jumper Clock                                                
; -o#2                 while flashing pb7 is connected to IEC-Clock-in
;
;  #1
; -o                   usually connected to IEC-Reset-in
;  o-   = JR = Jumper Reset
; -o                   while flashing connected to ground
;  #2
;
;
;                      usually connected to I2C-Data
;         JI = Jumper I2C  
;                      while flashing: perhaps necessary to open it
;
;  Jx-9  = number behind is number of DIP-switch
;        Make perhaps DIP-switch for pullup-resistors at IEC-lines
;         (and use 5 resistors and 5 diods)
;          => this DIP-switcj would be no1 and the numbers of the existing DIP-switches are
;               incremented
;
;
;
;  T = NPN-universal transistor (from AREF to a_reset = HD-Reset)
;
;               .-Collector
;             |/
;       Basis-|                     BC547   npn
;             |\
;               '-Emiter
;
; AREF isn't an output pin. It's the reverence voltage for the AnalogDigitalConverter.
; It is for capacities only. It is here used ilegally as an output.
; It must make 0.1mA to +5V. So I think that 0.1mA cannot destroy it?????? 
; Don't forget 47kOhm resistor 
;  !!! no warranty - own risk!!!
; (at a HD, I accidentially used, the current to pull a_reset to 0V was 0.06mA)
; but the transistor is nedded anyway to invert the level of AREF
; Don't forget to connect AVCC (pin30) additionally to +5V
;
;        IEC      
;      __   __  
;     /  | |  \ 
;    | 5  -  1 |
;    |    6    | view from the backside onto a C64/1541 (not onto a cable)
;    | 4     2 |  
;     \   3   /
;      '-----'
;
;   1 SRQ       
;   2 GND       
;   3 ATN       
;   4 CLK       
;   5 DTA       
;   6 RST       
;
;pb7 is SCK while flashing. PB7 mustn't be connected allways to IEC-Clock-in
;because: If C64 would make IEC-Clock accidential to 0V-active when the AVR
;makes a reset, then the AVR could go into flash-mode and it could be that
;the flashROM or EEPROM is overwritten.
;
;74LS244 =   8 Schmitt-trigger-input-driver  not-inverting
;only necessary if one want to switch the AVR off (with switch at +5V power
;supply).
;Reason: An AVR which isn't connected with +5V power supply pulls all pins to
;0V, so the IEC bus is locked. 
;isn't necessary if one never switches off the AVR
;
;7407 =   6 open-collector-busdriver-chip   not-inverting
;only necessary when more than three additional serial devices (additional to
;C64 and AVR) are connected to the IEC-bus.
;Reason: All serial devices have got a 1kOhm pullup-resistor, so it should be
;neccessary that it needs 5mA to pull a wire of the IEC-bus to 0V-active.
;The AVR-output can make 20mA. This should be enough for 1 C64 and 3 devices.
;isn't necessary if there are only  1 - 3 serial devices connected.
;also necessary if one wants to switch the AVR off
;Remark: The AVR-644 can sink 10mA only to 0V!!!
;NLQ-HD has here no 1kOhm pullup resitors => doesn't has additional 5mA to sink to 0V
;
;If you just want an interface of IEC- to ATA-HD-bus then it's possible to use
;an AVR and the cable with plugs only without any additionla chips.
;
;There is no crystal neccessary, the AVR uses the internal 8MHz oscylator.
;
;The jumper D is for debug-bytes of the debug-bytes. Close it; make a reset; 
;load and start 'debug-transfer' at the C64; the open JD; the AVR-RAM is transfered from AVR 
; to C64-RAM at $6000-$7100
;
;The 644 can sink 10mA only (It could source 20mA to +5V)
;The 8515, 162, 32 can sink 20mA
;The 644 should be supported to sink the LEDs with a 74LS244-driver
;At the cheap version the two pins for every IEC-line must sink together to 0V so this makes 20mA
; (10mA would be too few) 

;Commodore: Alles über den Commodore 64, Page 355: One can connect 5 devices to the IEC-bus 
; => 1 C64 and 5 device pull up with 5mA  => total 30mA 

;Although each I/O port can sink more than the test conditions 
; (20mA at VCC = 5V, 10mA at VCC = 3V) under steady state
;conditions (non-transient), the following must be observed:
;1.)The sum of all IOL, for ports A0-A7, C4-C7 should not exceed 100 mA.
;2.)The sum of all IOL, for ports C0-C3, D0-D7 should not exceed 100 mA.
;3.)The sum of all IOL, for ports B0-B7 should not exceed 100 mA.

; strange  is it now 10 or 20mA?????


;the original 1541/2-LEDs (red and green) have a voltage of 2.0V and 10.5mA with the 270mA
; resistors (when connected to ground directly (not an AVR- or an LS244-pin))
; 1541/2-resistors:    red: 330 Ohm      green: 150 Ohm
; => 270 Ohm is good compromise, especially if the LED-plug is connected wrongwise  

;Make a stable +5V power supply.
;
;The Reset pullup resitor isn't allways necessary; you can try without
;
;+----------------+---------------+-----+---+---+---+---+-----+-----+
;|                |               |     |   |   |   |Atn| Atn |E-LED|  
;|                |               |     |   |   |   | In| Out |swtch|
;+----------------+---------------+-----+---+---+---+   +     +     +
;|       (PB1)    |    (PB0)      |     |PD5|PD4|PD3|pd2| PD1 | PD0 | IEC-ATA-V2  pd7,6=external RAM
;+================+===============+=====+---+---+---+===+=====+=====+
;|       (PB0)    |     PD2       |     |PD5|PD4|PD3|PD2| +5V |  0V | NLQ-HD 
;|                |               |     |   |   |   |IOW|  1  |  0  |        
;+----------------+---------------+-----+---+---+---+---+-----+-----+                
;|  Read (-IOR)   |  Write (-IOW) | reg |A2 |A1 |A0 |   | CS1 | CS0 |
;+----------------+---------------+-----+---+---+---+---+-----+-----+----------+ vv/ww/xx/yy/zz
;| ILLEGAL        | ILLEGAL       |     | X | X | X |   |  0  |  0  | illegal  |   
;+----------------+---------------+-----+---+---+---+---+-----+-----+----------+ vv/ww/xx/yy/zz
;| High Impedance | Not Used      |  0  | 0 | 0 | 0 |   |  0  |  1  | <--+     | 01       -- --
;| High Impedance | Not Used      |  1  | 0 | 0 | 1 |   |  0  |  1  |    |     | 09       -- --
;| High Impedance | Not Used      |  2  | 0 | 1 | 0 |   |  0  |  1  | Control  | 11       -- --
;| High Impedance | Not Used      |  3  | 0 | 1 | 1 |   |  0  |  1  | Block    | 19       -- --
;| High Impedance | Not Used      |  4  | 1 | 0 | 0 |   |  0  |  1  | Registers| 21       -- --
;| High Impedance | Not Used      |  5  | 1 | 0 | 1 |   |  0  |  1  |    |     | 29       -- --
;| Altern Status  | Device Control|  6  | 1 | 1 | 0 |   |  0  |  1  |    |     | 31/f1/f5 -- --
;| Drive Address  | Not Used      |  7  | 1 | 1 | 1 |   |  0  |  1  | <--+     | 39/f9/fd -- --
;+----------------+---------------+-----+---+---+---+---+-----+-----+----------+ vv/ww/xx/yy/zz 
;| data Port      | data Port     |  0  | 0 | 0 | 0 |   |  1  |  0  | <--+     | 02/c2/c6 07 06
;| Error Register |Precompensation|  1  | 0 | 0 | 1 |   |  1  |  0  |    |     | 0a/ca/ce 0f 0e
;| Sector Count   | Sector Count  |  2  | 0 | 1 | 0 |   |  1  |  0  | Command  | 12/d2/d6 17 16
;| lba 0          | lba 0         |  3  | 0 | 1 | 1 |   |  1  |  0  | Block    | 1a/da/de 1f 1e
;| lba 1          | lba 1         |  4  | 1 | 0 | 0 |   |  1  |  0  | Registers| 22/e2/e6 27 26
;| lba 2          | lba 2         |  5  | 1 | 0 | 1 |   |  1  |  0  |    |     | 2a/ea/ee 2f 2e
;| lba 3          | lba 3         |  6  | 1 | 1 | 0 |   |  1  |  0  |    |     | 32/f2/f6 37 36
;| Status         | Command       |  7  | 1 | 1 | 1 |   |  1  |  0  | <--+     | 3a/fa/fe 3f 3e
;+----------------+---------------+-----+---+---+---+---+-----+-----+----------+ vv/ww/xx/yy/zz  
;| High Impedance | Not Used      |     | X | X | X |   |  1  |  1  |?inactive?| 3b/fb/ff -- --
;+----------------+---------------+-----+---+---+---+---+-----+-----+----------+ vv/ww/xx/yy/zz   
;These are the values for the PrtD (not DdrD)
;vv = without bits 7,6,2
;ww = with bits 7,6 =%11 same at IEC-ATA-V2 (external RAM)
;xx = with bit 2 = AtnIn must be input (Ddr=0) and PullUp=on (Port=1)
;=>
;-IEC-ATA-V2: use values xx for writing into PrtD 

;-at NLQ-HD/lite:
;    -don't change DdrD7 and DdrD6 (switch and LED)
;    -PrtD7 and PrtD6 are %00 (switch and LED)
;    - (DdrD5 - DdrD1 can be made to %1 high) 
;    - (DdrD0 must be %0)
;    - => DdrB=%uu111110 (u=unchanged)
;    -use value yy for PrtD
;    -(value for commnad/status is also value for inactive)

;-at NLQ-HD/full:
;    -DdrD7 - DdrD6 can be made to %0 low (open collector of I2C-bus)
;    -DdrD2 must be made to %1 high (ATA-DIOW=inactive (=push/pull-output)) 
;    -DdrD1 must be made to %1 high (AVR-DtaOut=inactive (=push/pull-output)) 
;    -DdrD0 cant be made to %0 low  (AVR-DtaIn=pullupsoff (=input) 
;    -use value zz for PrtD
;    -(value for command/status is also value for inactive)

; Error-LED and switch: PrtD always 0 because the LED is switched on/off with the DdrD

;Ddr of IDE-pins is 1 = output => pulls active (with 20mA) to +5V

;values of PD2 - PD0 while access to HD
; !!! important not to pull SD-card-pins active to +5V (because 3.3V only) 
;+-------------+-----------------+----------------------+----------------------+
;|             |PD2      Ddr Port|PD1          Ddr Port |PD1          Ddr Port |
;+-------------+-----------------+----------------------+----------------------+
;|1 IEC-ATA-V2 |AtnIn     0   1  |a_cs1         1  (0) 1|a_cs0         1  0 (1)|
;|           xx|                 |                      |                      | 
;+-------------+-----------------+----------------------+----------------------+
;|2 NLQ-HD/MMC |                 |                      |                      |
;+-------------+-----------------+----------------------+----------------------+
;|4 NLQ-HD/lite|a_reset   0   1  |left switch  0/1   0  |right switch 0/1   0  |
;|           yy|a_cs1            |and LED               |and LED               |
;+-------------+-----------------+----------------------+----------------------+
;|5 NLQ-HD/HD- |a_reset   0   1  |left switch  0/1   0  |right switch 0/1   0  |
;|   outputdrvr|a_cs1            |and LED               |and LED               |
;+-------------+-----------------+----------------------+----------------------+
;|6 NLQ-HD/SD  |   -      -   -  |                      |                      |
;+-------------+-----------------+----------------------+----------------------+
;|7 NLQ-HD/full|SPI-DtaIn 0   0  |I2C-data      0    0  |I2C-clock     0    0  |
;|           zz|                 |                      |                      | 
;+-------------+-----------------+----------------------+----------------------+


;+---+--------------------+--------------------+--------------------+
;|   |       1        d p |        4       d p |       7        d p | 
;|   |   IEC-ATA-V2   d r | NH-lite oupudr d r |    NH-full     d r | 
;|   |       xx       r t |        yy      r t |       zz       r t |
;+---+--------------------+--------------------+--------------------+
;|PD7| extrnlRAM-rd   1 1 |    LED&switch  ? 0 |     I2C-Dta    0 0 |
;+---+--------------------+--------------------+--------------------+
;|PD6| extrnlRAM-wr   1 1 |    LED&switch  ? 0 |     I2C-Clk    0 0 |
;+---+--------------------+--------------------+--------------------+
;|PD5|       da0      1 x |        da0     1 y |       da0      1 z |                
;+---+--------------------+--------------------+--------------------+
;|PD4|       da1      1 x |        da1     1 y |       da1      1 z |    
;+---+--------------------+--------------------+--------------------+
;|PD3|       da2      1 x |        da2     1 y |       da2      1 z |     
;+---+--------------------+--------------------+--------------------+
;|PD2|    IEC-AtnIn   0 1 |     ATA-diow   1 1 |    ATA-diow    1 1 |       
;+---+--------------------+--------------------+--------------------+
;|PD1|     ATA-CS1    1 1 |     ATA-dior   1 1 |    SPI-DtaOut  1 1 |                    
;+---+--------------------+--------------------+--------------------+
;|PD0|     ATA-CS0    1 1 |     ATA-reset  0 1 |    SPI-DtaIn   0 0 |
;+---+--------------------+--------------------+--------------------+




;=> 
;
;   Jochen Adler   Near Letter Quantity  
;   Haeldestr.9  D-74912 Kirchardt  Germany
;   NLQ@gmx.de  www.nlq.de
;
;
;
;                    without any warranty - own risk
;------------------------------------------------------------------------------------------------




;                   ATMEGA162 / ATMEGA644 runs at 8MHz 

; JD has two meanings: Jumper Debug      JiffyDos
; b.i. = branch if
; SA = secundary address
; DN = devicenumber
; DB = databyte
;------------------------------------------------------------------------------------------------
        ;0000-001f Registers r00-r31
.def r00 = r0     ;free for multiplication result or for temporary
.def r01 = r1     ;free for multiplication result or for temporary

.def r02 = r2     ;debug buffer mode  (read from EEPROM)
                  ;7 = save main-debug-bytes
                  ;6 = save not-main-debug-bytes (config-program must set also bit7 if
                  ;5 = save LBAs of sector                                bit6 is set) 
                  ;4 = save IEC-port
                  
                  ;0 = load only (config-program must clear all different bits if bit0 is set)
                  ;mustn't be #$ff (#$ff is illegal = empty EEPROM)

.def r03 = r3     ;old value debugbyte
.def r04 = r4     ;debug Y-vector low
.def r05 = r5     ;temporary memory (e.g. for bus declicking (port), compare at reading sector)

.def r06 = r6     ;#$00 (different values only at debug-printing) 
.def r07 = r7     ;#$ff (different values only at debug-printing) 

.def r08 = r8     ;
.def r09 = r9     ;
        ; r10     ;temporary memory for bus declicking (counter, flag for AtnMode, at printing)

        ; r11     ;sector in this cluster
        ; r12     ;cluster low            (LBA 0 (sector?))
        ; r13     ;cluster high           (LBA 1 (cylinder low?)) 
        ; r14     ;cluster higher         (LBA 2 (cylinder high?))
        ; r15     ;cluster highest        (LBA 3 (head))

        ; r16      Accu of 1541
        ; r17      Xreg of 1541
        ; r18      Yreg of 1541
        ; r19      direct memory access e.g. inc $0000, dec $e7,x..(command doesn't exist at AVR)

        ; r20      (filelength) 
        ; r21      (filelength)
        ; r22      (filelength) 
        ; r23      (filelength)
        
        ; r24      

        ; r25      don't use; for debug printing, debug-LED and counter delay*10µs
        ;          and for very short temporary values        

        ; r26      Xreglow  
        ; r27      Xreghigh for general-writing

        ; r28      Yreglow  
        ; r29      Yreghigh for general-reading  (for writing into debug buffer)

        ; r30      Zreglow  only register for lpm (icall ijmp)
        ; r31      Zreghigh  

;------------------------------------------------------------------------------------------------    
        ; 
        ;0020-00ff I/O
;------------------------------------------------------------------------------------------------
;        $0100-$017f values of NLQ-HD (not present at 1541 / CMD-HD)
;        $0180-$01ff stack (CMD-HD: $0100-=1ff)
;        $0200-$02ff inputbuffer (for all devices and SAs)
;        $0300-$03ff values existing at NLQ-HD, 1541 and CMD-HD
;        $0400-$05ff HD-buffer (necessary at M32 and M644)
;        $0600-$07ff values of actual drive (M644) (perhaps 0600-06ff only at M32???) 
;        $0800-$08ff CBM-buffer0 (M644)  (perhaps 0700-07ff at M32???) 
;        $0900-$09ff CBM-buffer1 (M644 only)
;        $0a00-$0aff CBM-buffer2 (M644 only)
;        $0b00-$0bff CBM-buffer3 (M644 only)
;        $0c00-$0cff CBM-buffer4 (M644 only)
;        $0d00-$0dff CBM-buffer5 (or for softwarspeeder?) (M644 only)
;                    (!!actually used for debugbytes!!)
;        $0e00-$0fff FAT (M644 only) (use one FAT-buffer only but compare
                            ;          FAT1 and and FAT2 entry)
;        $1000-$10af        ;debugbuffer
;        $10b0-$01ff        ;at reset not cleared RAM

                            ;04ff is still internal RAM at MEGA162

                            ;085f is last internal RAM at M32

;................................................................................................
        ;0100-04ff = internal RAM mega162
;................................................................................................
        .equ raepbe = $0100 ;ram for epromtest begin
                            ;EEPROM is copied to $0100-0114

                    ;  0100 ;flag for autorepair EEPROM-corruption ($55=no $aa=yes)
                    ;  0101 ;calibrationbyte for internal oscylator for 8MHz
                    ;  0102 :debug buffer mode -> r02
                    ;  0103 ;1/10s waiting loop after HD-reset    
                    ;  0104
                    ;  0105
                    ;  0106
        .equ fljdal = $0107 ;flag JiffyDOS allowed (read from EEPROM)
                             ;bit7 0=only CBM allowed  1=JiffyDOS alowed
                             ;bit0 at JD-LOAD: way to see that C64 is ready to receive next block
                             ;       0=waiting-loops (like 1541) 1=analyse C64-DataOut at fb06

        .equ tadenu = $0108 ;table device numbers
                    ;-$010a ;3 possible
                             ;7 = 0=present 1=not present (this device entry)
                             ;6 = 0=no Talker (e.g.printer) 1=Talker
                             ;5 = 0=no Listener 1=Listener
                             ;4-0 =devicenumber (4/8-30)
                             ;0108: HD
                             ;0109: CD
                             ;010a: SD
        .equ tadepa = $010b ;table device parameters
                    ;-$010d ;    in what to emulate (see devpar)   

        ;010e  eeprom->ram 
        ;010f  eeprom->ram 
        ;0110  eeprom->ram 
        ;0111  eeprom->ram 
        ;0112  eeprom->ram 
        ;0113  eeprom->ram
        ;0114  eeprom->ram 
        
        .equ raepen = $0115 ;ram for epromtest end +1

        .equ c6cor0 = $0100 ;C64-communication register 0 
        .equ c6cor1 = $0101 ;C64-communication register 1 
        .equ c6cor2 = $0102 ;C64-communication register 2
        .equ c6cor3 = $0103 ;C64-communication register 3
        .equ c6frre = $0104 ;C64-freeze-register 
                            ;C64 can determine which freeze-routine is activated
                            ;-01 = at create direntry 
                            ;-02 = at swapfile (l14190)
                                                       
                            ;$0100-0104 is free after reset routine 

        .equ cabyor = $0115 ;calibration byte original (after reset-routine of avr)
                            
        .equ ircoby = $0118 ;IRQ-counter-byte
         


        .equ seswfi = $011c ;sectors swapfile (in lba) !!swapfile must be unfragmented
                    ;-$011f ;64kB long   all 128 ($80) sectors must be in one row
                            ;reason: else every sector would have to be stored in AVR-memory
                            ;=>not enough memory   
                            ;if IEC-ATA-V2: there is no swapfile
                            ;!!! swapfile must be always at first FAT32 partition of master-HD!!!  
                            ;if NLQ-HD/full: swapfile must be on HD (not SD-card)
                            ;if NLQ-HD/lite&outputdriver:
                            ;                             swapfile on HD (or not necessary)
                            ;if NLQ-hd/SDonly and SD2IEC: swapfile on SDcard (or not necessary)
                            ;=> at every hardwaretype the swapfile is on a determined drive
                            ;   => a flag for on which emulationentry the swapfile is isn't
                            ;       necessary
                            ;seswfi+3 = #$ff: there is no swapfile

        .equ devpar = $012d ;device parameters  see tadepa!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                            ; not used
                            ;bit7&6: %00 = HD (IDE-master)
                            ;        %01 = CD (IDE-slave)
                            ;        %10 = SD ( / MMC card)



        .equ acsehb = $0130 ;actual sector in HD-buffer (in lba) sectoraddr. (not clusteraddr.)
                    ;-$0133 ;contains LBA-sector-address of sector which is really in HD-buffer
                            ;if a sector is requested from HD, but not written into HD-buffer,
                            ; .e.g.at load, where the HD-sector is directrly sent to the C64
                            ; then the HD-buffer and acsehb contain the old values 
                            ;only 28 of 32 bits are used (bit 0-27)
                            ;2^28*512bytes =  137438953472bytes =128GB
                            ; => only (FAT32) partitions up to 128GB supported 
                            ;if bit31 is set (=bit7 of acsehb+3) then there was an error      
                            ; and for security reasons the error bit in acsehd is set
                            ;  =the datas in the HD-buffer could be wrong=>read it from HD again 
                            ;flag for illegal sector must be at acsehb+3 (not at acenhb),
                            ; because acenhb isn't used at IEC-ATA-V2 (because of memory-reasons)
        .equ acenhb = $0134 ;actual emulation(entry)number (of sector) in HD buffer
                            ; 0,1,2  0=HD  1=CD  2=SD

        .equ idscre = $0135 ;IDE-sector count register usually 1 
        .equ idmasl = $0136 ;IDE-master/slave $00=master $10=slave  
                            ;!!!! change that emulation0=master
                            ;                 emulation1=slave!!!!!!!!!!!!!!!!  
     
        .equ idcore = $0137 ;IDE-command-register
                            ; $20: read sectors with retry
                            ; $30: write sectors with retry
                            ; $40: read verify sectors with retry
                            ;($ec: identify device)
                                 




        .equ ovhbtr = $013e ;overwrite HD-buffer-transfer read
        .equ ovhbtw = $013f ;overwrite HD-buffer-transfer write
                            ;it's impossible to make the override-byte in the swap area
                            ; because at swapfile it's overwritten with the original value
                            ; %000000000= no override funktion wanted (change perhaps to $ff??)
                            ;             at $00 bit 7&6 is %00: this would mean override
                            ;             function for IDE-HD, but $00 is an exeption for
                            ;             no override-function wanted
                            ;             The value $00 cannot exist
                            ;             $00 would mean: override-hardware: IDE-HD and 
                            ;                             no action to this hardware
                            ; %00.......= IDE-HD-override = master (bits 5-0 are not %..000000)
                            ; %01.......= IDE-CDROM-override = slave
                            ; %10.......= SD/MMC-card-override 
                            ; %11.......= use actual hardware (no override of hardware but
                            ;                                  override of action only)
                            ;perhaps: use $ff instaed of $00 for no override function wanted?????    

       #if (partname == 1) | (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/HD-routines
                            ;$0140-$014f = HD----------------------------------------------------

        .equ chscyl = $0142 ;CHS-mode cylinder low for HD
        .equ chscyh = $0143 ;CHS-mode cylinder high for HD   
        .equ chshea = $0144 ;CHS-mode heads for HD    
        .equ chsspt = $0145 ;CHS-mode sectors per track for HD 
        .equ chsphs = $0146 ;CHS-mode product heads*sectors-per-track for HD
                    ;-$0147 ;CHS-values must be in not-swap-area, because important at swapbuffer

     
       #endif

                          ;--------------------------------------------------------------------
        .equ acemen = $0170 ;actual emulated entry 0,1,2
                            ; 0=IDE-HD    master
                            ; 1=IDE-CDROM slave (not supported)
                            ; 2=SD/MMC-card
        .equ reemen = $0171 ;received emulation entry (received while listen/talk)

        .equ i2pova = $0172 ;I2C-port-value (of 8bit port expander chip)
        .equ debyhi = $0173 ;debug-byte-high               
                            ;there are so many debug bytes that it's difficult to find in the
                            ;debug buffer what is what. So this can be found easier by a highbyte
                            ;use perhaps values for the highbyte from $41-$5a (a-z) so that it's
                            ;easier to find

        .equ iedbvl = $017f ;IEC-debugvector low
;................................................................................................
          
                            ;0180-01ff Stack
        .equ stpobe = $01ff ;stackpointer at begin
                            ;at rcall/call: first the lowbyte is pushed to stack,
                            ; then the highbyte
                            ; e.g.  $1950 rcall l.....   1950 call l.....
                            ;stack:01ff: $51                  $52
                            ;      01fe: $19                  $19    (address in words)                        
                            ;pushes 2 bytes to stack (at devices with <=128kB-Flashram)
                   
                            ;for debug printing
                            ;$0180 i2pova I2C-port-value (of 8bit port expander chip)
                            ;$0181 eeprom test
                            ;$0182 eeprom test
                            ;$0183  
                            ;$1084 reset r20
                            ;$0185       r21
                            ;$0186       r22
                            ;$0187       r23 
                            ;$0188       r24 
                            ;$0189       r25
                            ;$018a       r26
                            ;$018b reset r27
                            ;$018c reset r06
                            ;$018d reset r07
                            ;$018e reset stackpointerlow
                            ;$018f freeze: r25     
                                                         
                            ;$0190-01af  temp for SPI-bus



;................................................................................................ 
        .equ inbube = $0200 ;inputbuffer begin
       ; .equ inbuen = $0229 ;inputbuffer end +1 at 1541    
       ; .equ inbuen = $0280 ;inputbuffer end +1 at CMD-FD (and CMD-HD?)  
        .equ inbuen = $02ff ;inputbuffer end +1 at and CMD-HD (or $02fe???)  
                            ;(0200-0229) / 0200-027f input buffer
                            ;at CMD-HD the inputbuffer is even $100 bytes from $0200-02ff!!!!!!!!  
                            ;CMD says: inputstring can be 254 bytes 
        .equ dasp00 = $02ff ;dataspace #$00  (important for IRQ routine)
;................................................................................................
             ;   : colon
             ;   , comma
             ;variables of the open filename command
             ;          size at
             ;         1541 AVR 
             ;007e                laprcb    last program track
             ;007f                acdrnu    actual drive number
             ;00a3                incove    inputbuffer low
             ;                              a3,a4 is the inputbufferwritevector when the 1541
             ;                              receives bytes from the C64 
             ;                              at the end of having received the bytes from the C64
             ;                              a3 shows to the end of the input-string
             ;                              at c2b3 there is a check whether the inputstring
             ;                              ends with Carriage-Return or
             ;                              Carriage-Return&Line-Feed and then the length-vector
             ;                              is copied from a3 to 0274 and a3 is reseted to 
             ;                              begin (#$00) 
             ;00d3
             ;               5+             direntry-length (of complete direntry)
             ;00d8-00dc  5  25+   cfdisc    direntry-sector (AVR:Cluster) o.file x in inputbuffer              
             ;                    cfdicl 
             ;00dd-00e1  5   5+   cfdive    direntry vector of file x in inputbuffer
             ;00e2-00e6  5   5+   cfdrno    drivenumber of file x in inputbuffer  
             ;00e7-00eb  5   5+   cffljo    joker-flag of file x in inputbuffer
             ;                               and filetype
             ; 
             ;024a                          actual filetype
             ;024b                          length of filename/command
             ;024c                temesa    temporary memory for backup of secundary address
             ;0253                opfifo    flag f.direntry found
             ;                               #$ff=not found
             ;                               #$00-#$04=number of filename in inputbuffer  
             ;0254                          flag for directory
             ;0258                          record length?? 
             ;026c               floker     errorflag
             ;026e               laprdr     last program drivenumber
             ;026f               laprcb     last program sector 
             ;0274               incoen     length of inputstring (filename/command)
             ;0275                          character to search  
             ;0276                          end+1 position of actual filename out of 5 of
             ;                               inputstring
             ;0277                cm0277    length of filename0????
             ;                              amount of filenames in front of '=' in inputbuffer???             
             ;                              memory for storing old amount of commas/filenames?
             ;0278                opamco    amount of commas = amount of filenames in inputbuffer
             ;0279                cm0279    1.) amount of commas before colon
             ;                              2.) number of filename of inputstring at c4d8 
             ;027a-027e 5/6   1+  cfpobc    begin of file x in inputbuffer    
             ;027b-027f 5/6   5+  cfpoco    end+1 of file x in inputbuffer
             ;                              these two tables share 5 of 6 memoryspaces together 
             ;0280-0284  5  16/0+           starttrack of file x in inputbuffer
             ;0285-0289  5  0/16+           startsector of file x in inputbuffer 
             ;028a                          joker flag
             ;028b                          flags for commands (bits) 
             ;028c                          counter for access to different drives           
             ;028e                opladr    drivenumber of last used drive
             ;028f                cm028f    flag f.inputfilenames still to search / all found
             ;0290       1    5   opudes    dirsector of found used direntry               ??                 
             ;                    opudec             
             ;0291       1    5   ofdesc    dirsector of first free direntry??  
             ;                    ofdecl
             ;0292                ofdeve    search free/used direntry and
             ;                              vector of first free direntry 
             ;0293                          flag for last block of directory
             ;                              0=last block 1-ff=there are follow-dir-blocks 
             ;                              c5be c5c4 c5d4                  
             ;                              routine c5ac-c63c 
             ;                              flag whether there is a follow dirblock
             ;                              -#$00 = there is no follow-dirblock
             ;                                      this is the last dirblock
             ;                              -#$01-ff = there is a follow-dirblock
             ;0294                opudep    direntryposition of found used dirfileentry
             ;0295                          counter f.direntries in one dirblock (0-7)  
             ;0296                opfity    filetype  
             ;0297                opfimo    filemode (read/write)

             ;               20             filelength of actual file in inputbuffer???


             ;                              space for tables: 62=$3e bytes
             ;                              + = table at 1541 x-dependant
             ;                                        at AVR load/store with displacement
              
             ;the AVR LDD- and STD-command (load/save with displacement) allows displacement-
             ;values from #$00-#$3f. => it's most logical that the counter for the number 
             ;of which file in inputbuffer is the actual one goes from 0-4. => the tables must
             ;begin from $0300-$033f, else the LDD/STD wouldn't work 

             ;at open usually:
             ;-X r26/27: vector to dirfilename $05e8   ($94),y at 1541    

             ;-Y r28/29: vector to inputbuffer $0200    0200,y (a3),y 0200,x at 1541
             ;           ldi r28,low(inbube)
             ;           ldi r29,high(inbube)                          

             ;-Z r30/31: input-parts-vector    $0300    027a,x e2,x 0280,x  at 1541
             ;           lds r30,opfifo ;flag for open filename found  = $0253 at 1541
             ;           ldi r30,$00   ;vector to filecounter in inputbuffer 
             ;           ldi r31,high(cfmebe) ;command/filename memory begin

        .equ cfmebe = $0300 ;command/filename memory begin---------------------------------------
                    ;-03xx  ; displacement of ldd std command must be $00-$3f 0-63     
                            ;there are 5 filename in one inputstring possible
                            ;=> most tables have 5 entries
                            ;   exception: cfpoco has 6 entries because
                            ;    5 filenames have 6 places in front and behind the names
                            ;cleared at l17460 (cfmebe - cfmeen) $0300-037f 

        .equ cfdrno = $0300 ;command/filename drive number                         = e2,x at 1541
                    ;-$0304
 
        .equ cfdile = $0305 ;cmd/flnm length of direntry of actual file inputbuffer (d8,x/dd,x)
                    ;-$0309 ;       0= length = 1 entry (1 shortentry)
                            ;       1= length = 2 entries (1 shortentry + 1 longentry)
                            ;       2= length = 3 entries (1 shortentry + 2 longentries)      
                            ;amount of dir-partentries
                            ;perhaps: bit 7-6 could be used for drive-number
                            ; if drive-number should be bigger than 255 (e.g. 0-999 like 64HDD)
                            ;it could be even possible to store cfdile (2bits), cfdive (3bits)
                            ; and 2 bits for increment drivenumber from 255 to 999 in one byte
                            ; this would save RAM but would increase Flashram
        .equ cfdive = $030a ;cmd/flnm vector of direntry of actual file inputbuffer   dd,x
                    ;-$030e ;$00, $20, $40, $60, $80, $a0, $c0, $e0
        .equ cfdisc = $030f ;command/filename sector in this cluster of direntry of   d8,x
                    ;-$0313 ;          actual file inputbuffer
        .equ cfdicl = $0314 ;cmd/flnm cluster of direntry of actual file inputbuffer  d8,x
                    ;-$0327 ; shows to first (of three) partentries
        .equ cffljo = $0328 ;command/filename flag for joker & filetype            = e7,x at 1541    
                    ;-$032c ; bit7: 0=no joker          1=joker
                            ;       bit 7 is taken from inputfilename
                            ;       bit6-0 is taken every time from dirfilename    
                            ; bit6: 0=can be scratched  1=scratch-protected
                            ; bit5: 0=not closed        1=closed
                            ; bit4: unused?
                            ;bit3-0: filetype  !!!!!change to bit4-0!!!!!!!!!!!!!!!!!!!!
        .equ cfpobc = $032d ;command/filename position of begin/commas            = 027a,x at1541  
                    ;-$0331 
        .equ cfpoco = $032e ;command/filename position of end/commas              = 027b,x at1541  
                    ;-$0332 
                            ;---------offset bigger than $3f---------
        .equ cfstcl = $0333 ;command/filename startcluster of file                = 0280,x/0285,x
                    ;-$0346 ;      5*4 entries  5 filenames
                            ;every entry: startcluster low, high, higher, highest
                            ;5 startcluster highest must be cleared with #$ff instead of #$00
        .equ cffile = $0347 ;command/filename filelength      
                    ;-$035a
                            ;----end of tables----
        .equ incove = $035b ;inputcommandvector  = $a3 at 1541 
                            ;highbyte is always #$01 (a4 at 1541 (=#$02))

        .equ cm0277 = $035c ;CBM-memory $0277 length of filename0???????????????????????????? 
                            ;           amount of filenames in front of '=' in inputbuffer???             
        .equ opamco = $035d ;open amount of commas  = $0278 at 1541
                            ;= amount of filenames in inputbuffer
        .equ cm0279 = $035e ;CBM-memory $0279 ???????????????????????? 
                            ;         1.) amount of commas before colon
                            ;         2.) number of filename of inputstring at c4d8 

        .equ opfity = $035f ;open-file-type  = $0296 at 1541
                            ;c2e7 (initialize/clear), c3b9, c4c9, c4d2, d81e
                            ;there is opfity and difity!!!!
                            ;  CMD-HD                         NLQ-HD
                            ;00 D del or search any filetype  D
                            ;01 S seq                         S   
                            ;02 P prg                         P  
                            ;03 U usr                         U 
                            ;04 L rel                         L 
                            ;05   cbm (1581-subdir)           
                            ;06 B dir directory (B=branch)    B  
                            ;07   sys (seen at CMD-HD) 
                            ;     or direct access?       
                            ;08   nat = native partition      N D16-image (16MB)
                            ;                                   1581copy uses .D1M for 1MB-images
                            ;                                                 .D2M for 2MB-images
                            ;                                   => .D16M would be 16MB-images    
                            ;                                  first three letters of D16M is D16
                            ;09 4 41  1541-partition          4 D64-image
                            ;0a 7 71  1571-partition            D71-image (not supported)             
                            ;0b 8 81  1581-partition          8 D81-image  
                            ;0c   c81 (don't know)
                            ;0d   prn                           dot or dotdot-entry??
                            ;0e   for foreign-partition       F foreign-file
                            ;0f   (?extended native?)           Volume-ID of root-dir?
                            ;10                               1 d1m (1m)
                            ;11                               2 d2m (2m)
                            ;12                               3 d4m (3m9)
                            ;13
                            ;14
                            ;15
                            ;16
                            ;17
                            ;18
                            ;19
                            ;1a
                            ;1b
                            ;1c   dot-entry
                            ;1d   dotdot-entry
                            ;1e   volume-ID
                            ;1f   (perhaps reserved for filetype-not-set?)
                            ;  R read
                            ;  W write
                            ;  A append
                            ;  M modify      
                            ;!!! see db13 at 1541 7=direct access????
       
        .equ opfifo = $0360 ;flag for open filename found  = $0253 at 1541        
                            ;0-5 = found and number of filename in inputbuffer
                            ;$ff = so far not found  
  
        .equ opudel = $0361 ;open used dir entry length 
                            ;complete direntry consists of:
                            ;0= only short direntry 
                            ;1= short direntry + 1 londdirentry
                            ;2= short direntry + 2 londdirentry
                            ;3= short direntry + 3 londdirentry
        .equ opudep = $0362 ;open used dir entry position=vector                 = $0294 at 1541
        .equ opudes = $0363 ;open used dir entry sector in this cluster          = $0290 at 1541
                            ;1541: c609,c639 (search in dir)
        .equ opudec = $0364 ; used dir entry cluster                             = $0290 at 1541
                    ;-$0367




        .equ cm028f = $036d ;CBM-memory $028f  flag f.inputfilenames still to search / all found
                            ;cm028f: 00 = at least one inputfilename still to search 
                            ;        ff = all inputfilenames found
     
        .equ cm028d = $036e ;CBM-memory $028d ???          
        .equ cm028c = $036f ;counter for access to different drives     
                            ; 0= search for filename on actual drive only: If filename at
                            ;     actual drive not found => don't continue search at
                            ;     different drive
                            ; 1= if file isn't found at actual drive => continue search
                            ;     at different drive
                            ;at AVR: never switch to differnt drive
                            ;        search always at actual drive only
                            ;        => this menory isn't necessary at AVR???
        .equ cm028a = $0370 ;CBM-memory $028a flag for joker  
                            ;bit7=flag for no joker/joker (to set a memory-variable)
                            ;bit6-0=counter for jokers (* ?) in actual inputname
                            ;       counter is 0-127 $00-7f
                            ;       inputbuffer at CMD-HD is 255 $ff bytes
                            ;       at CMD-HD there could be an overflow???? (if more than 
                            ;           127 jokers in a filename???)
                            ;       perhaps better at l16480  (instead of): 
                            ;              lds r18,cm028a          |
                            ;              ori r18,$01          (inc r18)
                            ;              sts cm028a,r18              
        .equ cm0276 = $0371 ;end+1 position of actual filename out of 5 of inputstring
        .equ cm024b = $0372 ;CBM-memory $024b = length of actual inputfilename/inputpart
                            ;c677, c6a8, c6b8, c6be
        .equ acdrnu = $0373 ;actual drive number  =$007f at 1541
        .equ cm0258 = $0374 ;CBM-memory $0258 record length ???     
        .equ opfimo = $0375 ;open filemode (read/write)   0297 at 1541
                            ;00=read 01=write?
        .equ cm024a = $0376 ;open actual filetype (bit7-4 is always %0000)
                            ;                     (change that bit7-5 is always %000)
        .equ floker = $0377 ;flag ok / error     errorflag  026c at 1541
                            ;00=no error=LED-on
                            ;01-ff=error=LED-blink
                            ;7f=100Hz-IRQ-routine has counted LEDerror-counter to end
                            ;80-ff=100Hz-IRQ-routine still has o count LEDerror-counter


        .equ difity = $0378 ;directory file type (=first byte of direntry at 1541)
                            ; is set at l15660 read next direntry of actual directory
                            ;there is opfity and difity!!!!
                            ;bit 7: closed-bit:  0=not closed 1=closed
                            ;       $00 = empty direntry
                            ;       $80 = DEL-file entry (not empty)
                            ;bit 6: write-protect-bit = scratch-protect-bit = read-only-bit
                            ;       0=can be deleted 1=cannot be deleted
                            ;bit 5: temporary while save-and-replace
                            ;bit 4: unused?
                            ;bit 3-0:  (at 1541 only bit2-0 is used) 
                            ; CMD-HD                         NLQ-HD
                            ;0 D del or search any filetype  D
                            ;1 S seq                         S   
                            ;2 P prg                         P  
                            ;3 U usr                         U 
                            ;4 L rel                         L 
                            ;5   cbm (1581-subdir)           
                            ;6 B dir directory (B=branch)    B  
                            ;7   sys (seen at CMD-HD)        
                            ;8   nat = native partition      N D16-image (16MB)
                            ;9 4 41  1541-partition          4 D64-image
                            ;a 7 71  1571-partition              
                            ;b 8 81  1581-partition          8 D81-image  
                            ;c   c81 (CPM-1581-pttn)
                            ;d   prn                           dot or dotdot-entry??
                            ;e F for foreign-partition       F foreign-file
                            ;f                                 Volume-ID of root-dir?
                            ;  R read                        R
                            ;  W write                       W 
                            ;  A append                      A
                            ;  M modify                      M
                            ;  1 1m                          1 D1M CMD-3.5"-DD-image
                            ;  2 2m                          2 D2M CMD-3.5"-HD-image
                            ;  3 3m9                         3 D4M CMD-3.5"-ED-image
 
        ;.equ temesa = $0379 ;temporary memory secundary address = 024c at 1541  necessary???
        .equ adspch = $037f ;additional special chars
                            ;00 = no additional special chars   (for WTE)
                            ;01 = '/' has same meaning as ':' (CD-command (for WTE)
                                               
        .equ cfmeen = $0380 ;command/filename memory end (+1) -----------------------------------
                            ;the merory is cleared from cfmebe to cfmeen
                            ;still see whether there is no memory within this area 
                            ;which mustn't be cleared
        .equ incoen = $0380 ;input command end (+1)  = $0274 at 1541
        .equ opladr = $0381 ;open last drive = 028e at 1541 

        .equ ornuld = $0390 ;ordernumber long directory entry lde (lde=long directory entry) 
                            ;#$ff = so far no lde found = search first lde
                            ;bit6 0=follow lde  1 = first lde
                            ;bit5-0 = counter for ldes (counts decrementing) 
      
                            ;ldst.. must be in front of sdst.. and close together l20460!!!!!!!!!
                            ;ldst.. contain values of first (not last) dir-partentry of one 
                            ;  complete entry
        .equ ldstle = $0391 ;long-directory-start-length of direntries for this complete direntry  
        .equ ldstve = $0392 ;longdirectory-start-vector of direntry in dir-sector
        .equ ldstsc = $0393 ;long-directory-start sector in this cluster of direntry in dir-sector              
        .equ ldstcl = $0394 ;long-directory-start-cluster  of direntry in dir-sector              
                    ;-$0397
        .equ ldchsu = $0398 ;lde checksum
    
        .equ sdstle = $0399 ;short-directory-start-length of direntries for this cmplete direntry  
        .equ sdstve = $039a ;short-directory-start-vector of direntry in dir-sector
        .equ sdstsc = $039b ;short-directory-start sector in this cluster of direntry in dir-sector              
        .equ sdstcl = $039c ;short-directory-start-cluster  of direntry in dir-sector              
                    ;-$039f ; if highestbyte = #$ff then shortentry not (yet) found
                            ;ldst.. must be in front of sdst.. and close together l20460!!!!!!!!!

        .equ cm0086 = $03a2 ;CBM-memory 0086 (temporary memory?)
                            ;at scratch: counter for deleted files
                            ;at reset: temp memory for actual device emulation
                            ; (mustn't be at DEB because of reset-routine)
     
        .equ cm0071 = $03a3 ;CBM-memory 0071
                            ;at test whether file is opened: counter for SA  
                            ;at create direntry part2: flag for save / rename               
       ;.equ cm028b =       ;at command-analysis: bitmask: c20c, c21d, c220, c24e, c251, c254 
                            ;at copy-analysis:    bitmask: c912, c928
                            ;at drivenumber: c36a, c383
                            ;     -#$00 = drivenumber found??
                            ;     -#$ff = drivenumber not found??  
    
    
    
                             
        .equ iccbjd = $03c0 ;IEC-routines
                             ;$00= CBM
                             ;$01= JiffyDOS-IECIN IECOUT
                             ;$60= JiffyDOS-LOAD
                             
        .equ iccode = $03c1 ;IECCommand&Devicenumber
                             ;$20-3e  Listen
                             ;$40-5e  Talk
                             ;$60-6f  SA
                             ;$a0-be  Unlisten + devicenumber
                             ;$c0-de  Untalk +devicenumber
                             ;$e0-ef  Close
                             ;$f0-ff  Open                            

                             
                                
        .equ flicbb = $03c2 ;flag IECbus bits
                             ;7 = IECAtnMode($7d) 0=dataMode 1=CommandMode
                             ;6 = IECTalk   ($7a)
                             ;5 = IECListen ($79)
                             ;4 = IECEoi at IECOUT 0=noEoi 1=Eoi (ldx$82 lda$f2,x and#$08 e92f)  
                             ;                    At Talk at IECOUT  from AVR to C64
                             ;                                       from AVR,IBM-PC to AVR
                             ;3 = IECEoi    ($f8) 0=noEoi 1=Eoi (at 1541 inverted!!!) received
                             ;                    at Listen at IECIN from C64 to AVR
                             ;                                       from AVR to IEEE,IBM-PC  
                             ;2 =           
    
        .equ icsawo = $03c3 ;IECSecundaryAddress without bits whether open,close,SA ($83)         
        .equ icsaco = $03c4 ;IECSecundaryaddressComplete (all 7 bits) ($84)

        .equ avinco = $03c5 ;AVR-internal command        
                             ;00=no command
                             ;ff=command
        
        .equ ermeve = $03c6 ;error message vector
        .equ ermeen = $03c7 ;error message end 
                             ; $00 = no byte in buffer                
                             ; $01-fe = end+1 and EOI at last byte (=end of file)
                             ; $ff = 254 databytes in buffer and noEOI (=there is a followblock)      
        .equ cocono = $03c8 ;command commandnumber  =022a at 1541
        .equ flated = $03c9 ;flag Atn-edge                                              ($7c)
                            ;bit7: 0=make DaOut active when receiving Atn-active-edge
                            ;      1=don't change DtaOut when receiving Atn-active-edge
                            ;bit0: 0=no Atn-edge received 1=Atn-edge received  ($7c)
            
;        .equ fli2ir = $03f1 ;flag i2c-bus IRQ
;        .equ i2irac = $03f2 ;I2C-IRQ-action
;------------------------------------------------------------------------------------------------
        .equ fabube = $0400 ;FAT-buffer-begin
        .equ fabuen = $0600 ;FAT-buffer-end (+1)
                            ; use 1 FAT-buffer only but compare FAT1 and FAT2 and use 
                            ;  identical FAT-sectors only
;------------------------------------------------------------------------------------------------
        .equ hdbube = $0600 ;hd-buffer begin
        .equ hdbuen = $0800 ;hd-buffer end (+1)
;------------------------------------------------------------------------------------------------
        .equ deembb = $0800 ;device-emulation-buffer-begin    
                            ;leave 0800-0820 free for later emulation of jobs?????

        .equ aterre = $0825 ;ATA error register  (can be read with m-r command) 
                            ; for every drive

        .equ acpanu = $0826 ;actual partition number (low) (0-255)
                    ;-$0827 ; (high when 0-999)

        .equ sepecl = $082f ;sectors per cluster for every device
                            ;e.g.first partition can have different clustersize as 
                            ; second partition on same HD  
                            ;microsoft allows max 32kB clusters
                            ;1 sector = 512 bytes
                            ;=> maximal value is 64 = $40 =%01000000
        .equ sbpabo = $0830 ;sectorbegin partition bootsector (in sectors in LBA (28bit))
                    ;-$0833
        .equ sbpaf1 = $0834 ;sectorbegin partition FAT1 (FAT32 supported only)
                    ;-$0837   
        .equ sbpaf2 = $0838 ;sectorbegin partition FAT2   (lowbyte first!!!!)
                    ;-$083b   
        .equ sbpada = $083c ;sectorbegin partition data
                    ;-$083f 
        .equ sbpaen = $0840 ;sectorbegin partition end of partition (+1) 
                    ;-$0843 
        .equ amfrcl = $0844 ;free clusters actual device 
                    ;-$0847 
                            ;amfrcl and fifrcl must be directly togther in RAM 
        .equ fifrcl = $0848 ;first free cluster actual drive
                    ;-$084b ;bits of highestbyte:
                            ; bit7: 0 = not yet set   1 = already set 
                            ;         (notread/read from one of the first sectors from HD)
                            ; bit6: 0 = search didn't start at cluster 00000000
                            ;       1 = search started at cluster 00000000
                            ; bit5  0 = not yet changed in RAM = still correct value in RAM
                            ;       1 = changed in RAM = must be rewritten to HD FSInfo-block
                            ;        (change of free clusters and of first free cluster)       

        .equ amtocl = $084c ;amount of total clusters
                    ;-$084f ;must this be stored in not-cleared RAM??? 
                            ; =amount of free clusters (not 1 more than amount of ftree clusters)   
                                                   
        .equ laprdr = $0852 ;last program drivenumber (for load"*") 
                            ;probably not necessary?????      
        .equ laprcb = $0854 ;last program clusterbegin (for load "*")
                    ;-$0857 ;if laprcb+3 >$0f then not set
                            ; 007e 026e 026f at 1541
        .equ laprfl = $0858 ;last program filelength (for load"*")
                    ;-$085b

;------------------------------------------------------------------------------------------------                           
        .equ erbube = $0900 ;error buffer begin
        .equ erbuen = $0a00 ;errorbuffer end +1 ;$0100 = 256bytes
                            ;0900-09ff          ;error-buffer                    
                            ;every device must have an individual errorbuffer
                            ;=> the errorbuffer must be at the device-swap-buffer
                            ;the errorbuffer must have a length of 256 bytes
                            ; because the m-r-command can read 256 bytes
                            ;256bytes (0900-09ff) is only needed at m-r, arr, aer, afr -commands
                            ;the SD-commands (aso) can also have a long errormessage
                            ;the maximal length of a normal errormesssage is $23 (35) bytes
                            ;usually only $0900-0922 is used
                            ; => 0923-09ff can be used for temporary things:
                            ;perhaps: innash, natac0, natac1, dibube
                            ;0123456789abc
                            ;00, ok,00,00
                            ;if it's shure that the ok-message is in the errorbuffer then 
                            ; one could use the area 090c-09ff

        .equ natac0 = $091e ;name-tail-counter1 
                            ;bit 7-6: bitwise flags which last number of shortnametail
                            ;          is found in dir numbers 8-9
                            ;           bit7 = '8'
                            ;           bit6 = '9'
                            ;bit 5  : flag for real-short-name / part of long-name
                            ;          0 = real short-name
                            ;          1 = part of a longname
                            ;bit 4
                            ;bit 3-0: position where last digit of tail is (2-7)
                       ;                        ($.f = no tail)
        .equ natac1 = $091f ;name-tail-counter0 bitwise flags which last number of shortnametail
                            ;  is found in dir numbers 0-7
                            ;   bit7 = '0'
                            ;   bit0 = '7'
        .equ innash = $0920 ;inputname short must start at $00,$20,$40..$e0 (e.g.$0120)
                    ;-$092a ;INS = input-name-short                     (not 0130, 0141, 014f)
                            ;INL = input-name-long
                            ;DNS = dir-name-short
                            ;DNL = dir-name-long
                            ;at load: compare long filenames only
                            ; if inputnamelong matches any dirnamelong then load the file
                            ; if inputnamelong doesn't match every dirnamelong then file not found
                            ;at save: generate first a short filename of the long filename
                            ;and then compare: 
                            ;condition   -> action
                            ;INL = DNL   -> file exists error (or save at save&replace)
                            ;                                 (or save if file isn't closed)
                            ;                (free the clusters in FAT later or before?)
                            ;INL <> DNL & INS matches no DNS -> save file, use generated INS
                            ;INL <> DNL & INS matches different DNS -> create/increment tail of
                            ;               INS and search in dir as long as the new INS doesn't
                            ;               match any DNS
                            ;INL <> DNL & (INS = ) INL = DNS of a different fileentry 
                            ;       this means: (INL=INS)
                            ;        the inputname is a shortname (8+3 characters, no illegal
                            ;                             shortname-character & length 1-8chars)
                            ;       the INL has accidentially the same ending as the DNS (a tail)  
                            ;             abcd-1 abcd~1
                            ;        the dirname is a longname (the longname (of the different
                            ;                              file) stays; only the (not-visible) 
                            ;                              shortname changes)
                            ;             ->create/increment tail of INS of different direntry
                            ;               and search in dir as long as the new INS doesn't
                            ;               match any DNS, then rename DNS of different file
                            ;               (checksum changes), then save actual file with 
                            ;               INL=INS  
        .equ tmvade = $092b ;temporary memory values of direntry
                    ;-$093f ;contains unchanged values of a direntry at rename
        .equ buwlfn = $0940 ;buffer Windows95 long filenames 
                    ;-$0967 ;UNICODE length: 2*(16+1+3)=40  

        .equ dibube = $0968 ;directory buffer begin 
                    ;-$097f ; perhaps similar to 1541-directorybuffer $02b1-02d4      
                            ;                      (if few RAM => this can perhaps made to 
                            ;                       0xe8-0xff of actual CBM-puffer 9.5.2008
                            ;                       or perhaps to 0x08-0x1f of actual direntry)                     
                            ;                       or perhaps to errorbuffer at the place
                            ;                        which is only neede for M-R-command
        .equ teflre = $0980 ;temporary filelength remaining   for append
                    ;-$0983



                    ; $09f0 ;pcf8583-RTC
                    ;-$09ff 








;------------------------------------------------------------------------------------------------
                            ;at 1541:
                            ;there are 19 addresses 0-18 $00-$12
                            ;every address has a channel (022b-023d)
                            ; (022b contains the channel of SA=0)
                            ; (023d contains the channel of SA=18)  
                            ;%oo..cccc
                            ; oo       bit7&6 = open-status
                            ; 00           00 = read
                            ; 01           01 = read&write
                            ; 10           10 = write
                            ; 11           11 = (not opened #$ff)
                            ;     cccc bit3-0 = channel
                            ;     0000   0000 = channel 0             
                            ;     0011   0011 = channel 3
                            ;     0101   0101 = channel 5
                            ;#$ff = there is no channel to this SA                          

                            ;there are 7 channels (0-6)
                            ; channel 0-3 = data-channels
                            ; channel 4   = command-channel (open,close,command)
                            ; channel 5   = error-channel  
                            ; channel 6   = BAM???
                            ;$0256 contains bitwise which channel is free/occupied
                            ; 0-bit = channnel ocupied
                            ; 1-bit = channel free
                            ; after reset: $0256 = #$0f = % 00001111 
                            ;               = channel 7-5 occupied     channel 3-0 free
                            ;allocating of channels starts with channel 0 
                            ;b5-ba       contains filelength low of channel (in blocks)
                            ;bb-c0       contains filelength high of channel (in blocks)
                            ;c1-c6       contains ??next record?? of channel???
                            ;c7-cc       contains recordlength of channel 
                            ;cd-d2       contains ??side-sector?? of channel
                            ;ec-f1       contain filetype and drivenumber of channel??
                            ;f2-f7       contain status of channel??? 
                            ;023e-0243   contains databyte of channel???
                            ;0244-0249   contains vector to last actual byte???
                            ;0260-0265   contains sector of direntry of channel
                            ;0266-026b   contains vector of direntry of channel

                            ;fa-ff  ????

                            ;there are 5 buffers (0-4)
                            ;every channel has two buffers, an active one and an inactive one
                            ;$a7-ad contains the first buffer of a channel
                            ;$ae-b4 contains the second buffer of a channel
                            ;$a7 first buffer of channel 0
                            ;$a8 first buffer of channel 1    
                            ;$a9 first buffer of channel 2
                            ;$aa first buffer of channel 3
                            ;$ab command-buffer of drive 1 ??
                            ;$ac error-buffer of drive 1 ??
                            ;$ad BAM-buffer drive 1 ??
                            ;$ae second buffer of channel 0
                            ;$af second buffer of channel 1
                            ;$b0 second buffer of channel 2
                            ;$b1 second buffer of channel 3
                            ;$b2 command-buffer of drive 0 ??
                            ;$b3 error-buffer of drive 0 ??
                            ;$b4 BAM-buffer drive 0 ??
                            ;%sd...bbb
                            ; s          bit7 = status 0=buffer=active  1=buffer=inactive
                            ;  d         bit6 : 0=buffer=not-dirty  1=buffer=dirty
                            ;      bbb   bit2-0 =buffernumber
                            ;#$ff = there is no buffer to this channel
                            ;allocating of buffers starts with buffer 4 
                            
                            ;00-04         contains job of buffer
                            ;06/07 - 04/0f contain track/sector of buffer
                            ;99/9a - a1/a2 contain vector of buffer
                            ;a3/a4         contain vector of command-buffer=input-buffer
                            ;a5/a6         contain vector of error-buffer
                            ;025b-025f     contains last job of buffer

                            ;problem: 
                            ;the 6502 can access the memory with lda 00,x
                            ;the AVR can access the memory only with X,Y or Z register
                            ;At the AVR the actual values and buffer must be copied to a defined
                            ; memory (swapped)

                            ;IEC-ATA: there is enough space for exactly 1 buffer to every SA
                            ;         there is enough flash for #-command
                            ;         it's not possible to make that the C64 wants that e.g.
                            ;         buffer 3 belongs to SA2 (open 2,x,2,"#3)
                            ;         => make the same buffer to a SA
                            ;            e.g.: buffer0 belongs to SA0
                            ;                  buffer18 belongs to address 18

                            ;else: there is enough flash for open2,x,2,"#3
                            ; => it's possible that buffer 3 belongs to SA2
                            ; one must use a table
                            ; there is RAM for 3 or 5 buffers (debending on whether
                            ;  =e00-0fff is used for sector-access-debugging-buffer)
                            ; => older buffers must be swaped to swapfile of HD
                            ; perhaps the table SA->channel isn't necessary
                            ; perhaps use at once a table SA->CBM-buffer

                            ;1541:        1SA (w) -> 1channel (x) -> 2buffers (y z) 
                            ;iec-ata:     1SA (w) -----------------> 1buffer (w) 
                            ;                                    (SA0  uses always CBM-buffer0)
                            ;                                    (SA18 uses always CBM-buffer18)
                            ;non-IEC-ATA: 1SA (w) -----------------> 1buffer (x)
                            ; if C64 makes 'open 1,dn,2,"#3"' then to SA2 belongs buffer3
                            ;there are no channels at NLQ-HD !!!!

        .equ tasach = $0a10 ;table secundaryaddress -> channel                  022b-023d at 1541
                    ;-$0a22 ;0a10:      SA0    = load-address                  022b
                            ;0a11:      SA1    = save-address                  022c
                            ;0a12-0a1e: SA2-14 = open-address                  022d-0239 
                            ;0a1f:      SA15   = command-channel-adrs (write)  023a
                            ;0a20:      SA15   = error-channel-adrs (read)     023b  
                            ;0a21:      (17 $11) internal-read-address         023c
                            ;0a22:      (18 $12) internal-write-address        023d
                            ;the 1541-listing  uses the expression 'channel' instead of 'address'
                            ;!!!! IEC-ATA- uses asfla1 (easier, shorter)     !!!!
                            ;!!!! not-IEC-ATA use bit 7&6 (more compatible?) !!!!

        .equ tachcb = $0a28 ;table channel -> CBM-buffer                  a7-ad (+ ae-b4) at 1541
                    ;-$0a2? ;the CMD-HD has 32 CBM-buffers??

        .equ taebcb = $0a30 ;table emulationbuffer <- CBM-buffer
                    ;-$0a34 ;there are 32 CBM-buffers
                            ;there are 5 emulationbuffers
                            ;better would be tacbeb, but then the table would be 32 bytes
                            ; so taebcb is a reverse table (is 5 bytes long only) 
     
        .equ vapb1b = $0a40 ;values physical buffer 1 begin
        .equ vapb1e = $0a60 ;values physical buffer 1 end (+1)
     
        .equ vapb2b = $0a60 ;values physical buffer 2 begin
        .equ vapb2e = $0a80 ;values physical buffer 2 end (+1)
     
        .equ vapb3b = $0a80 ;values physical buffer 3 begin
        .equ vapb3e = $0aa0 ;values physical buffer 3 end (+1)
     
        .equ vapb4b = $0aa0 ;values physical buffer 4 begin
        .equ vapb4e = $0ac0 ;values physical buffer 4 end (+1)
     




        .equ geactr = $0ac0 ;general actual track                                   = $80 at 1541
        .equ geacse = $0ac1 ;general actual sector                                  = $81 at 1541

        .equ geaccl = $0ac4 ;general actual cluster                              = $80/81 at 1541
                    ;-$0ac7


                    ; $0ac9 :perhaps length of direntry???  
        .equ ofdeve = $0aca ;open free dir entry vector                          = $0292 at 1541
                            ;1541: c454, c49f, c5f2, c5f5, d70b, d728, d73a, d73d, d7a2, ed94
                            ; before a free direntry is found: 0,2-ff=search used direntry
                            ;                                  1     =search free direntry
                            ; after a free direntry is found: position/vector of free direntry
                            ;         00,20,40,60,80,a0,c0,e0
                            ;         if 3 free direntries aren't found and
                            ;            no #$00-endflag-direntry => ofdeve = #$f0                           
                            ;probably important: #$01 or not#$01  cmp #$01
        .equ ofdesc = $0acb ;open free dir entry sector in this cluster           = $0291 at 1541
        .equ ofdecl = $0acc ;open free dir entry cluster                          = $0291 at 1541
                    ; -0acf ;1541: c5ae, c5e3, c5ee, (c948), d715, d735, d79a
                            ; searches 3 free (part-) direntries in a chain
                            ; if ofdecl+3 (=highest cluster) >$0f then no free direntry found
                            ;     before
                            ; if ofdecl+3 (=highest cluster) <=$0f then a free direntry was found
                            ; before
                            ;                              1541-$0291   NLQ-HD-ofdecl+3
                            ; 
                            ;make flag that free            lda #$00     (ldi r07,$ff)
                            ;direntry isn't found           sta $0291     sts ofdecl+3,r07   
                            ;
                            ;                               lda $0291     lds r16,ofdecl+3
                            ;                                             tst r16
                            ;b.i.free direntry found        bne ...       brpl ...
                            ;b.i.free direntry not found    beq ...       brmi ...                       
                            
                                             
                            ;at l20340 (search 3 free direntries in a chain):
                            ;ofdecl+3 while search of 3 free direntries:
                            ;bit7: 0=3 free direntries found   1=notyet found
                            ;bit6: 0=second or third possible free partdirentry
                            ;      1=first free partdirentry
                            ;bit5-4: counter for free partdirentries in a chain  
                            ;bit3-0: LBA-address of cluster 31-28
                        
                            ;ofdecl+3 after search of 3 free direntries:
                            ;bit7: 0=3 free direntries found
                            ;      1=3 free direntries in a chain not found at all
                            ;if bit7=1 then bit6 has this meaning:
                            ;  bit6: 0=flag that opfd..-values contain values of end of dir 
                            ;        1= should not be possible (would be error)  
                            
                            ;at find first free cluster :bit7-4 different meaning
                            
                            ;at l17020: the first ony-partdirentry is stored???
                            ;           this doesn't fit to the text above?

                            ;at l20330: three partdirentries are searched

                            ;ofdesc-ofdecl must be within $3f bytes in distance to ashbsc-ashbcl
                            ;opfdas - ofdecl must be always in this chain in memory
                            ;because copied from ashbsc (l20360)


                            ; affde is set to the last of several direntries at save
                            ;????????????????????????????????????????????????????????????????????
                            ; I don't know whereto acd.as shows -to first of several direntries 
                            ;                                   -to last of several direntries   
                            ;perhaps still store length of direntry???
                            ;this is important at test whether a file is opened at sratch 
                            ;  at l21940
                            ;or did I confound with acd.as?????????

        .equ acsacb = $0ad0 ;actual SA in CBM-buffer (00-$11 0-17)
                            ;  FF = nothing in CBM-buffer  
     
                            ;--------------------------------------------------------------------
                            ;delete this  
        .equ erbufl = $0ad8 ;errorbufferflags
                            ;bit7: 0=errorbuffer is at standard-location 
                            ;         (=no need to swap) 
                            ;      1=errorbuffer is at the CBM-buffer
                            ;         (must be swapped)
                            ;bit6: only important when bit7=1
                            ;      0=SA$0f-buffer is errorbuffer
                            ;      1=SA$0f-buffer is internal-read/write-buffer 
                            ;       (change this to SA$10/11??) 
                            ;=> bit7&6:
                            ; %00=SA$0f-buffer contains errorbuffer which is at standard-location
                            ; %01=illegal
                            ; %10=SA$0f-buffer contains errorbuffer which is at CBM-buffer
                            ; %11=SA$0f-buffer contains internal-read/write-buffer  at CBM-buffer
                            ;bit7 is imporatnt for swapping errorbuffer
                            ;delete thsi
                            ;--------------------------------------------------------------------
                            ;08d8-08df = variables of errorbuffer at pos 0a00-0aff
        .equ erbuve = $0adb ;error-buffer vector 
                            ;reads from error-buffer
        .equ erbufi = $0adc ;error-buffer filelength (remaining) (for EOI-calculating)
                    ;-$0add ;maximal length: $0100
                   ;(-$0adf)
;------------------------------------------------------------------------------------------------
                            ;0ae0-0aff = variables of actual buffer of actual SA
                            ;!!!!must be saved and restored to/from NLQ-SWAP.SYS

        .equ swbube = $0ae0 ;swap buffer begin
        .equ vapb0b = $0ae0 ;values physical buffer 0 begin

        .equ asfla0 = $0ae0 ;actual SA flags0 (0-17)
                       
                            ;bit5: 0=not save&replace 1=save&replace ($d91b)
                            ;bit2: 
                            
                            ;bit0&1:&00 = no dir                            =0254 at1541??
                            ;       &01 = short dir
                            ;       &10 = long dir without unused direntries
                            ;       &11 = long dir with unused direntries
                            ;used at d409, dacb, ed1a

        .equ asfla1 = $0ae1 ;actual SA flags1 (0-17) = 022b,x
                            ;bit 7: 0=not opened for write 1=opened for write
                            ;bit 6: 0=not opened for read  1=opened for read
                            ;  see 022b,x at 1541 but different bitmeaning here
                            ;  %00: not opened at all 
                            ;  %01: opened for read,  e.g.load, open2,x,2,"abc,y,r"
                            ;  %10: opened for write, e.g.save, open2,x,2,"abc,y,w" / "abc,y,a"
                            ;  %11: opened for read and write, e.g.rel-file (not supported)
                            ;!!!! IEC-ATA- uses bit 7&6 (easier, shorter)   !!!!
                            ;!!!! not-IEC-ATA use tasach (more compatible?) !!!!
                            ;bit 5: buffer-dirty-bit = bit6 of a7,x / ae,x at 1541 ?????????
                            ;  0: buffer not dirty
                            ;  1: buffer dirty
        .equ ashbve = $0ae2 ;actual SA HD-buffer vector  
                            ;reads from HD-buffer?????? 
        .equ ashbsc = $0ae3 ;actual SA HD-buffer sector in this cluster
                            ;!counts 256-bytes-cbm-sectors          =    $06/07 - $0e/0f at 1541
                            ; doesn't count 512-bytes-hd-sectors
                            ;bit7-1=512-bytes-hd-sectors
                            ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector
                            ;                               is actual cbm sector
                            ;=> lds r16,acsess
                            ;   lsr r16 
                            ;=> carry low: whether first or second half of hd-sector
                            ;   r16 can now be compaired with sepecl (sectors per cluster) 
        .equ ashbcl = $0ae4 ;actual SA HD-buffer cluster             =    $06/07 - $0e/0f at 1541
                    ;-$0ae7 ;ashbsc - ashbcl must be always in this chain in memory
                            ;because copied to ofdesc (l20360)
                            ;vector depends on buffernumber
                                      
        .equ asdeam = $0ae9 ;actual SA dir-entry amount of dirpartentries (0,1,2)               
        .equ asdeve = $0aea ;actual SA dir-entry vector    = 0266,y at1541 
                            ;1541: d7a7, d934, d9df, dbb2, dde8
                            ;                                     changed???????????????
        .equ asdesc = $0aeb ;actual SA dir-entry sector in this cluster   =0260,y
                            ;                                     changed?????
        .equ asdecl = $0aec ;actual SA dir-entry cluster                = 0260,y at 1541
                    ;-$0aef ;1541: d79f (save, open f.write?)
                            ;      d92f (save&replace)
                            ;      d9da (load, open f.read?)
                            ;      dbad (finish direntry at end of save/write)
                            ;      dde1 (test whether file is actually opened (e.g.at scratch))
                            ; 1541: y=channel-vector  
                            ;                                     changed>??????
                            ;acd.as must show to first of several direntries all the time,
                            ;because the test whether a file is actually opened is made with this
                            ;direntry-values              
                            ;(=> when the file is close => then the vector must be changed from
                            ; first to last direntry of several direntries        
        .equ asstcl = $0af0 ;actual SA startcluster
                    ;-$0af3

        .equ asfity = $0af5 ;actual SA file-type                       (= ec,x at 1541)
        .equ asdrnu = $0af6 ;actual SA drive-number                    (= ec,x at 1541)                                           
                    ; $0af7 ;perhaps highbyte of actual SA drive-number
                            ; if drivenumber is possible from 0-999 (like 64HDD)??????

        .equ ashbtr = $0af8 ;actual SA HD-buffer-transfer read (see ovhbtr)
        .equ ashbtw = $0af9 ;actual SA HD-buffer-transfer write (see ovhbtw) 
                            ;bit3-0 = standard-function 

                            ;this table is wrong !!!! values changed !!!
                            ;    0   %0000: no read-/write-function wanted
                            ;    1   %0001: just request sector but don't read/write
                            ;    2   %0010: read directly to FAT-buffer ($0e00-0fff)
                            ;               write directly from FAT-buffer ($0e00-0fff)
                            ;    3   %0011: comparedirectly to FAT-buffer ($0e00-0fff)
                            ;               write directly from FAT-buffer ($0a00-0bff) not used 
                            ;    4   %0100: read directly into swap-buffer0 ($04e0-05ff)
                            ;               write directly from swap-buffer0 ($04e0-05ff)
                            ;    5   %0101: read directly into swap-buffer1 ($04e0-05ff)
                            ;               write directly from swap-buffer1 ($04e0-05ff)
                            ;    6   %0110: read directly into swap-buffer2 ($04e0-05ff)
                            ;               write directly from swap-buffer2 ($04e0-05ff)
                            ;    7          not used
                            ;    8   %1000: read/write all values and buffers of one 
                            ;                 devicenumber (?first 512bytes-buffer?)
                            ;    9   %1001: read/write all values and buffers of one 
                            ;                 devicenumber (?first 512bytes-buffer?)
                            ;   a-b         unused    
                            ;    c   %1100: read from HD to HD-buffer at 0600-07ff    
                            ;               write from HD-buffer at 0600-07ff to HD
                            ;    d   %1101: read from HD to HD-buffer and from HD- to CBM-buffer
                            ;               at $0500-05ff 
                            ;               write from CBM- to HD-buffer and from HD-buffer to HD
                            ;               (bit 0 of ashbsc ($04eb) determines
                            ;               whether first or second half is copied)
                            ;   e-f         not used (c-f is value for copy into/over HD-buffer)
                            ;ashbtr/ashbtw always accesses the actual selected hardware (HD/
                            ;  CDROM/SD-card); they cannot access a different hardware
                            ;if the SD-card is selected and the software must access a different
                            ;  hardware (e.g. the HD to access the swapfile), then the
                            ;  override memories ovhbtr/ovhbtw must be used
                            ;....................................................................                      
                            ;$0800-$0fff contain values for actual device
                            ;if a different device (out of three possible ones) is accessed
                            ; then $0800-$0fff of the old device must be backuped to swapfile
                            ; and for new device must be loaded from swapfile
                            ;$07e0-$08ff contain values of actual SA secundary address of 
                            ; actual device
        .equ ascbve = $0afb ;actual SA CBM-buffer vector 
                            ;reads from CBM-buffer   writes to CBM-buffer
        .equ asflre = $0afc ;actual SA filelength (remaining) (for EOI-calculating)
                   ; -$0aff

        .equ vapb0e = $0aff ;values physical buffer 0 end (+1)
                            ;--------------------------------------------------------------------
        .equ cbbube = $0b00 ;CBM-buffer-begin   must be saved and restored to NLQ-SWAP.SYS
                            ;                           to ATA-HD at NLQ-HD only 
        .equ cbbuen = $0c00 ;CBM-buffer-end (+1)     change this to CBM-buffer0!!!!!
        .equ swbuen = $0c00 ;swap buffer end (+1)
;................................................................................................ 
        .equ cbb1be = $0c00 ;CBM-buffer1-begin
        .equ cbb1en = $0d00 ;CBM-buffer1-end (+1)
                            ;.................................................................... 
        .equ cbb2be = $0d00 ;CBM-buffer2-begin
        .equ cbb2en = $0e00 ;CBM-buffer2-end (+1)
                            ;.................................................................... 
        .equ cbb3be = $0e00 ;CBM-buffer3-begin            contains debugbytes of sectors
        .equ cbb3en = $0f00 ;CBM-buffer3-end (+1)
                            ;.................................................................... 
        .equ cbb4be = $0f00 ;CBM-buffer4-begin            contains debugbytes of sectors
        .equ cbb4en = $1000 ;CBM-buffer4-end (+1)

        .equ deembe = $1000 ;device-emulation-buffer-end (+1)
                            ;--------------------------------------------------------------------
;................................................................................................
        .equ debube = $1000 ;debugbufferbegin
        .equ debuen = $10b0 ;debugbufferend +1
;................................................................................................
;                           ;$10b0-$10ff  at reset unchanged memory------------------------------
        .equ dsdati = $10b0 ;dataspace date time        
                    ;-$10bf ;important for detection whether first/later reset         
                            ;....................................................................
                            ;now: free clusters   and the   first free cluster 
                            ;  is computed from the FS-Info-sector   
                            ;  this is fast and seems to work 
                            ;  (after Windows-Defrag / -Scandisk: the free clusters are correct
                            ;          the first free cluster is set to 00000002 
                            ;          => the first save takes a lonng time
                            ;              because the complete FAT must be searched for the 
                            ;              first free cluster)
                            ;   => this can be made at every reset
                            ;former: free clusters   and the   first free cluster 
                            ;  was computed by following the complete FAT (l25990 - l26200)
                            ; this is slow
                            ;   => this cannot be made at every reset
                            ;      it is made only at the first reset and the values are 
                            ;      stored at the at-reset-not-cleared-RAM
                            ; this routine isn't use at the moment and there is not enough
                            ; space in the not-cleared RAM
                            ; when this routine must be used again then frcld and fifrc must be 
                            ;  made again to the not-cleared-ram
                            ;....................................................................
        .equ hdcafl = $10c0 ;HD-capabilities flags 
                            ;bit7: 0=not accessable 1=accessable
                            ;bit1: LBA-mode 0=HD doesn't support (=CHS) 1=HD supports (=LBA)
                            ;make here more bits e.g. IDE-bus locked (HD no power supply)
                            ;                         FAT32 partition found/not found
                            ;                         NLQ-SWAP.SYS legalillegal
        .equ hdfldc = $10c1 ;HD flag disk change  (not used)                       (=$1c at 1541)                            

        .equ lefahd = $10c4 ;length FAT of HD 
                    ;-$10c7 ; important to store not in device emulation buffer because it's
                            ; possible that it must be rewritten when the active device is
                            ; changed 
        .equ cbadd0 = $10c8 ;clusterbegin actual directory drive0 
                    ;-$10cb  
                            ;....................................................................  
       #if (partname == 4) | (partname == 5) | (partname == 7)  
        #message nlq-hd/CD-routines
                            ;$0150-$015f = CD----------------------------------------------------
        .equ cdcafl = $10d0 ;CD-capabilities flags 
        .equ cdfldc = $10d1 ;CD flag disk change                             (bit0-3=$1c at 1541)
                            ;                                                (bit4-7=$1e at 1541)                             ;.................................................................... 
       #endif

       #if partname == 6
        #message nlq-hd/SD-only
        .equ airthu = $10d0 ;AVR-internal-RTC-hundredth
                            ; !!delete this    compute hundredth from
                            ;                   TCNT2  Timer/Counter Register
                            ;                   0-31 -> 3/100 - 96/100 in 3/100-steps   
        .equ airtse = $10d1 ;AVR-internal-RTC-second  
        .equ airtmi = $10d2 ;AVR-internal-RTC-minute  
        .equ airtho = $10d3 ;AVR-internal-RTC-hour  
        .equ airtda = $10d4 ;AVR-internal-RTC-day  
        .equ airtmo = $10d5 ;AVR-internal-RTC-month  
        .equ airtyl = $10d6 ;AVR-internal-RTC-year-low  
        .equ airtyh = $10d7 ;AVR-internal-RTC-year-high  
        .equ airtwd = $10d8 ;AVR-internal-RTC-weekday  
        .equ airtrs = $10d9 ;AVR-internal-RTS resetswitch swing counter        

        .equ airtmb = $10dd ;AVR-internal-RTC-mode-bits  10dc-10df=cleared at reset
        .equ airtmr = $10de ;AVR-internal-RTC-mainroutine
        .equ airtsl = $10df ;AVR-internal-RTC-stackpointer-low
        #endif
                            ;....................................................................
       #if (partname == 3) | (partname == 6) | (partname == 7)
        #message nlq-hd/SD-routines
                            ;$0160-$016f = SD----------------------------------------------------
        .equ sdcafl = $10e0 ;SD-capabilities flags 
                            ;bit7: 0=not accessable 1=accessable
                            ;bit1: LBA-mode 0=HD doesn't support (=CHS) 1=HD supports (=LBA)
                            ;make here more bits e.g. IDE-bus locked (HD no power supply)
                            ;                         FAT32 partition found/not found
                            ;                         NLQ-SWAP.SYS legalillegal
        .equ sdfldc = $10e1 ;SD flag disk change                             (bit0-3=$1c at 1541)
                            ;                                                (bit4-7=$1e at 1541)
                            ;bit4: pin of SS-card-detect
                            
                            ;bit1; 0=preserve actual dircluster 1=reset actual dircluster 
                            ;bit0: 0=SD-card not changed  1=SD-card changed
        .equ sddrac = $10e2 ;SD drive accessable                                    =$ff at 1541
        .equ smcaty = $10e3 ;SD/MMC card type
                            ;bit7-5: %000 = no card
                            ;        %001 = MMC
                            ;        %010 = thin SD (?standart capacity <=2GB?)  difference not
                            ;        %011 = thick SD (?standart capacity <=2GB?   supported
                            ;        %100 = high capacity SD (4GB - 16GB
                            ;        %101 = for future (e.g.32GB-SD) 
        .equ lefasd = $10e4 ;length FAT of SD 
                    ;-$10e7 ; important to store not in device emulation buffer because it's
                            ; possible that it must be rewritten when the active device is
                            ; changed 
                            ;when a SD-FAT-sector is rewritten to SD then lefasd is needed to
                            ; compute where the FAT2-sector must be written
        .equ cbadd2 = $10e8 ;clusterbegin actual directory drive2 SD 
                    ;-$10eb    
       #endif
                            ;....................................................................
                    ;$10f0-10ff  = values e.g.additional + additional -
                    ;                         off even at reset
                    ;       ;where store the devicenumbers at a device swap?? here (reset-proof)
                            ; or in memory which is resetted at reset??? 

        .equ acsefb = $10f0 ;actual sector in FAT-buffer (in lba)
                    ;-$10f3 ;contains LBA-sector-address of sector which is really in FAT-buffer
                            ;if bit31 is set (=bit7 of acsefb+3) then there was an error      
                           ; and for security reasons the error bit in acsehd is set
                            ;  =the datas in the FAT-buffer could be wrong=>read it from HD again 
                            ;flag for illegal sector must be at acsefb+3 (not at acenfb),
                            ; because acenfb isn't used at IEC-ATA-V2 (because of memory-reasons)
        .equ acenfb = $10f4 ;actual emulation(entry)number (of sector) in FAT buffer
                            ; 0,1,2  0=HD  1=CDROM  2=SD-card          
        .equ flfbch = $10f5 ;flags FAT-buffer changed
                            ; (if few RAM then perhaps together with acenfb??)      
                            ;bit7: FAT-buffer changed (doesn't matter whether allocate or free)
                            ;bit6: FAT-buffer changed by allocate cluster
                            ;bit5: FAT-buffer changed by free cluster
                            ;bit4: 0=use FAT1   1=use FAT2 (not used)
                            ;bit3: 0=don't compare FAT1 and FAT2   1=compare FAT1 and FAT2
                            ;bit2: 0=actual FAT isn't compared with FAT2 1=actual FAT is compared
                            ;bit1: 0=actual FATs are identical   
                            ;      1=difference of actual FAT1 and FAT2 
                            ;bit0:
                         
                            ;e.g.: when UI-/UJ-software-reset to HD:
                            ;in the FAT-buffer ther can be the FAT of the SD (not the HD)
                            ;this FAT can contain datas which must perhaps be rwritten to SD
                            ;=> FAT-buffer and values of FAT-buffer mustn't be cleared

                    ;$10fd ;l24670
                    ;$10fe ;l24670 
                    ;$10ff ;l25240


                            ;--------------------------------------------------------------------
                       
;     RAM-end:        $0500 ;RAM-end+1 internal 162-IEC-ATA-V2
;                     $8500 ;RAM-end+1 external 162-IEC-ATA-V2
;                     $1100 ;RAM-end+1 NLQ-HD 644
;------------------------------------------------------------------------------------------------
                      ;EEPROM

        ;0000                empty ($ff)
        ;0001-0015           table 0  $15 = 21 bytes
        ;0016-002a           table 1
        ;002b-003f           table 2
        ;                    there are three identical tables. So the AVR can compare them
        ;                    and find and repair an EEPROM-corruption
        ;0040-01ff           $01c0 = 446 bytes for erroressages??

             ;tables
        ;tab0 tab1 tab2                                                                          
        ;0001 0016 002b 0000 flag for autorepair EEPROM-corruption ($55=no $aa=yes)
        ;0002 0017 002c 0001 calibrationbyte for internal oscylator for 8MHz
        ;0003 0018 002d 0002 debug buffer mode -> r02
        ;0004 0019 002e 0003 1/10s waiting loop after HD-reset
        ;0005 001a 002f 0004 hardware-type in a format that can be read from C64-flasher
        ;0006 001b 0030 0005 hardware-type in a format that can be read from C64-flasher
        ;0007 001c 0031 0006      
        ;0008 001d 0032 0007 flag JiffyDOS allowed                -> $0107-RAM

        ;0009 001e 0033 0008 \                                    -> $0108
        ;000a 001f 0034 0009  tadenu = table device numbers       -> $0109-RAM
        ;000b 0020 0035 000a /                                    -> $010a

        ;000c 0021 0036 000b \                                    -> $010b
        ;000d 0022 0037 000c  tadepa = table device parameters    -> $010c-RAM
        ;000e 0023 0038 000d /                                    -> $010d

        ;000f 0024 0039 000e 
        ;0010 0025 003a 000f  
        ;0011 0026 003b 0010 
        ;0012 0027 003c 0011 
        ;0013 0028 003d 0012 ... 
        ;0014 0029 003e 0013                                                 -> $0113
        ;0015 002a 003f 0014  checksum                                       -> $0114
        .equ eeerbe = $0040   ;eeprom error begin
;------------------------------------------------------------------------------------------------
;        swapfile:
;                             there are 32 buffers for every device
;                             there are 3 device-emulations
;        0000-3fff            32 buffers (512bytes) for devicemulation0 (HD)
;        4000-7fff            32 buffers (512bytes) for devicemulation1 (CD)
;        8000-bfff            32 buffers (512bytes) for devicemulation0 (SD)
;        c000-cfff            device-buffer for emulation0 (HD)  (2kb of 4kb used) 
;        d000-dfff            device-buffer for emulation0 (CD)  (2kb of 4kb used) 
;        e000-efff            device-buffer for emulation0 (SD)  (2kb of 4kb used) 
;        f000-ffff            unused
;------------------------------------------------------------------------------------------------
        #if partname == 1    
         #message 162-IEC-ATA-V2
                              ;these labels must be accessed by lds/sts (not in/out) 
         .equ gicr   = $3b+$20 ;GicR at 162   general interrupt control register 
                               ;enables or disables IRQs e.g.at external pin
                               ;bit6 = AtnIn
                               ; = eimfr at 644          
  
        .equ iratin = gicr     ;IRQ-register AtnIn = IRQ0
        .equ ibatin = 6        ;IRQ-bit AtnIn 
    
        .equ tccr1a = $2f+$20 ;timer/counter control register 1a
                              ;7 com1a1
                              ;6 com1a0
                              ;5 com1b1
                              ;4 com1b0
                              ;3 foc1a
                              ;2 foc1b
                              ;1 wgm11
                              ;0 wgm10
        .equ tccr1b = $2e+$20 ;timer/counter control register 1b
                              ;address is different at 162 and 644
                              ;bits are same at 162 and 644
                              ;7 icnc1
                              ;6 ices1
                              ;5
                              ;4 wgm13
                              ;3 wgm12
                              ;2 cs12
                              ;1 cs11
                              ;0 cs10
        .equ tcnt1h = $2d+$20 ;timer/counter 1 counter register high
        .equ tcnt1l = $2c+$20 ;timer/counter 1 counter register low
        .equ ocr1ah = $2b+$20 ;timer/counter 1 output compare register a high
        .equ ocr1al = $2a+$20 ;timer/counter 1 output compare register a low
        ;.equ ocr1bh = $29+$20 ;timer/counter 1 output compare register b high
        ;.equ ocr1bl = $28+$20 ;timer/counter 1 output compare register b low

        .equ osccal = $04+$20 ;oscylator calibration byte
                              ;these labels must be accessed by lds/sts (not in/out) 
;................................................................................................
                            ;these labels must be accessed by in/out (not lds/sts) 
        .equ Sreg   = $3f   ;status register   (same at 162 and 644)
        .equ Sph    = $3e   ;stackpointer high (same at 162 and 644)
        .equ Spl    = $3d   ;stackpointer low  (same at 162 and 644)

        .equ met1oc = $38   ;memory timer1 output compare  ocf1a
                            ;different 162 and 644
        .equ bit1oc = 6     ;bit timer1 output compare
                            ;different 162 and 644
              
        .equ McucR  = $35   ;bit7 has different meaning from 162 to 644
                            ; not necessary at M644
                            ;7 sre
                            ;6 srw10
                            ;5 se
                            ;4 sm1
                            ;3 isc11
                            ;2 isc10
                            ;1 isc01
                            ;0 isc00
                            ; needed for switching external RAM off/on
                            ;needed for external IRQ0 level-sensitive (at M644: eicra)                           

        .equ tccr0_ = $33   ;Timer/Counter control0 = tccr0 (1 register   not 2)                                              
                            ;7 foc0
                            ;6 wgm00
                            ;5 com01
                            ;4 com00
                            ;3 wgm01
                            ;2 cs02
                            ;1 cs01
                            ;0 cs00
        .equ TcnT0  = $32   ;Timer/Counter0 (8Bits)

;        .equ SfioR  = $30   ;Special Function I/O Register  probably not necessary
                            ;different bits 
                            ;from 162 to 644
                            ;7 tsm  timer/counter (0)             
                            ;6 xmbk external RAM  (0)
                            ;5 xmm2 external RAM  (0)
                            ;4 xmm1 external RAM  (0)
                            ;3 xmm0 external RAM  (0)
                            ;2 pud  pullup ports  (0)
                            ;1 psr2 timer/counter (0)
                            ;0 psr310 timr/countr (0)        

        .equ eecr   = $1c   ;EEPROM control register
                            ; 7-4: unused
                            ; 3: eerie
                            ; 2: eemwe
                            ; 1: eewe
                            ; 0: eere 

        .equ EEdR   = $1d   ;EEPROM data Register
        .equ eearl  = $1e   ;EEPROM address register low
        .equ eearh  = $1f   ;EEPROM address register high

        .equ PrtA   = $1b
        .equ DdrA   = $1a
        .equ PinA   = $19

        .equ PrtB   = $18
        .equ DdrB   = $17
        .equ PinB   = $16

        .equ PrtC   = $15
        .equ DdrC   = $14
        .equ PinC   = $13

        .equ PrtD   = $12
        .equ DdrD   = $11
        .equ PinD   = $10
       
        .equ PrtE   = $07   
        .equ DdrE   = $06   
        .equ PinE   = $05   


        .equ pidesw = PinE  ;$05 pin debug-switch 
        .equ bidesw = 2     ;bit debug-switch (=error-LED)

        .equ poatdw = PrtB  ;port ATA diow
        .equ ddatdw = DdrB  ;Ddr ATA diow
        .equ piatdw = PinB  ;Pin ATA diow
        .equ biatdw = 0     ;bit ATA diow

        .equ poatdr = PrtB  ;port ATA dior
        .equ ddatdr = DdrB  ;Ddr ATA dior
        .equ piatdr = PinB  ;Pin ATA dior
        .equ biatdr = 1     ;bit ATA dior

        .equ poleer = PrtE  ;port LED error
        .equ ddleer = DdrE  ;ddr LED error
        .equ pileer = PinE  ;pin LED error
        .equ bileer = 2     ;bit LED error

        .equ piiema = PinB  ;pin IEC-main
        .equ ddiema = DdrB  ;ddr IEC-main
        .equ poiema = PrtB  ;port IEC-main 
     
                            ;(SrqIn not made because of too few memory) 
        .equ biclin = 3     ;bit ClkIn
        .equ bidain = 5     ;bit DtaIn
         
        .equ bisrou = 6     ;bit SrqOut
        .equ biclou = 2     ;bit ClkOut
        .equ bidaou = 4     ;bit DtaOut
        .equ biatou = 7     ;bit AtnOut

        .equ piatin = PinD  ;pin AtnIn
        .equ biatin = 2     ;bit AtnIn

        .equ idreda = $c6   ;IDE register data
        .equ idrepe = $ce   ;IDE register precompensation/error
        .equ idresc = $d6   ;IDE register sector count
        .equ idrel0 = $de   ;IDE register LBA0
        .equ idrel1 = $e6   ;IDE register LBA1
        .equ idrel2 = $ee   ;IDE register LBA2
        .equ idrel3 = $f6   ;IDE register LBA3
        .equ idrecs = $fe   ;IDE register command/status

        .equ obhasf = $00   ;%00...... override bits hardware of swapfile
                            ;%00 = use IDE-HD hardware  
                            ; (perhaps important in future when there will be a 
                            ;  M162-pincompatible chip with more than 16kB flash?)               

                            ;these labels must be accessed by in/out (not lds/sts) 
        #endif ; 162-IEC-ATA-V2
;------------------------------------------------------------------------------------------------
        #if ((partname >= 3) & (partname <= 7))
         #message 644-NLQ-HD/all with 644
                            ;these labels must be accessed by lds/sts (not in/out) 
        .equ eimsk  =$1d+$20;eimfr at 644   external interrupt mask register        AtnIn=PB2-IRQ         
                            ;enables or disables IRQs e.g.at external pin
                            ;bit2 = AtnIn
                            ; = GicR at 162          
        .equ pcicr  = $68   ;Pin Change Interrupt Control Register                  AtnIn=PA0-IRQ
        .equ pcifr  =$1b+$20;Pin Change Interrupt Flag Register
      
        .equ ocr2b  = $B4   ;OCR2A Timer/Counter2 Output Compare Register B     
        .equ ocr2a  = $B3   ;OCR2A Timer/Counter2 Output Compare Register A
        .equ tcnt2  = $B2   ;TCNT2 Timer/Counter2 (8 Bit)
        .equ tccr2b = $B1   ;Timer/Counter Control Register B
        .equ tccr2a = $B0   ;Timer/Counter Control Register A
        .equ timsk2 = $70   ;Timer/Counter2 Interrupt Mask Register
        .equ timsk1 = $6f   ;Timer/Counter1 Interrupt Mask Register
        .equ tifr2  =$17+$20 ;Timer/Counter2 Interrupt Flag Register

        .equ tccr1a = $80   ;timer/counter control register 1a
                            ;7 com1a1
                            ;6 com1a0
                            ;5 com1b1
                            ;4 com1b0
                            ;3 
                            ;2
                            ;1 wgm11
                            ;0 wgm10
        .equ tccr1b = $81   ;timer/counter control register 1b
                            ;address is different at 162 and 644
                            ;bits are same at 162 and 644
                            ;7 icnc1
                            ;6 ices1
                            ;5
                            ;4 wgm13
                            ;3 wgm12
                            ;2 cs12
                            ;1 cs11
                            ;0 cs10
        .equ tcnt1h = $85   ;timer/counter 1 counter register high
        .equ tcnt1l = $84   ;timer/counter 1 counter register low
        .equ ocr1ah = $89   ;timer/counter 1 output compare register a high
        .equ ocr1al = $88   ;timer/counter 1 output compare register a low
;        .equ ocr1bh = $8b   ;timer/counter 1 output compare register b high
;        .equ ocr1bl = $8a   ;timer/counter 1 output compare register b low
  
        .equ adcsra = $7a   ;ADC Control and Status Register A
        .equ admux  = $7c   ;AnalogDigitalConverter multiplexer selection

        .equ osccal = $66   ;oscylator calibration byte

        .equ eicra  = $69   ;external interrupt control register a         
                            ;in and out command doesn't work => must use sts lds
                            ;needed for external IRQ0 level-sensitivity      
;................................................................................................
                            ;these labels must be accessed by in/out (not lds/sts)   
        .equ Sreg   = $3f   ;status register   (same at 162 and 644)
        .equ Sph    = $3e   ;stackpointer high (same at 162 and 644)
        .equ Spl    = $3d   ;stackpointer low  (same at 162 and 644)


      
        .equ met1oc = $16   ;memory timer1 output compare    ocf1a
                            ;different 162 and 644
        .equ bit1oc = 1     ;bit timer1 output compare
                            ;different 162 and 644
          
        .equ TcnT0  = $26   ;Timer/Counter0 (8Bits)
        .equ tccr0_ = $25   ;Timer/Counter control0 B          = tccr0B  (!! 2 registers !!)
                            ;7 foc0a
                            ;6 foc0b
                            ;5 
                            ;4 
                            ;3 wgm02
                            ;2 cs02
                            ;1 cs01
                            ;0 cs00
        ;.equ tccr0a = $24   ;Timer/Counter control0 A
                            ;7 com0a1
                            ;6 com0a0
                            ;5 com0b1
                            ;4 com0b0
                            ;3
                            ;2
                            ;1 wgm01
                            ;0 wgm00 

        .equ eecr   = $1f   ;EEPROM control register
                            ; 7:6: unused
                            ; 5: eepm1
                            ; 4: eepm0
                            ; 3: eerie
                            ; 2: eempe
                            ; 1: eepe
                            ; 0: eere
        .equ EEdR   = $20   ;EEPROM data Register
        .equ eearl  = $21   ;EEPROM address register low
        .equ eearh  = $22   ;EEPROM address register high

        .equ PrtA   = $02
        .equ DdrA   = $01
        .equ PinA   = $00

        .equ PrtB   = $05
        .equ DdrB   = $04
        .equ PinB   = $03

        .equ PrtC   = $08
        .equ DdrC   = $07
        .equ PinC   = $06

        .equ PrtD   = $0b
        .equ DdrD   = $0a
        .equ PinD   = $09

                            ;these labels must be accessed by in/out (not lds/sts)        
        #endif ;644-NLQ-HD/all
;------------------------------------------------------------------------------------------------
        #if partname == 3
         #message 644-NLQ-HD/sd2iec
                            ;these labels must be accessed by lds/sts (not in/out) 
        .equ pcmsk0 = $6b   ;Pin Change Mask Register 0
        .equ iratin = pcicr ;IRQ-register AtnIn = PCIE0 (=Pin Change Interrupt Enable 0)
        .equ ibatin = 0     ;IRQ-bit AtnIn  (=PrtA makes IRQ  
                            ;                      whole PrtA,  not only AtnIn-pin)  
        .equ ibdain = 1     ;IRQ-bit DtaIn
/*
        .equ iratin = eimsk ;IRQ-register AtnIn = IRQ2    these would be the values
        .equ ibatin = 2     ;IRQ-bit AtnIn               for PB2-IRQ 
*/
        .equ spcr   =$2c+$20;SPI Control Register
        .equ spsr   =$2d+$20;SPI Status Register
        .equ spdr   =$2e+$20;SPI Data Register

        .equ spdaio = spdr  ;SPI-data-in/out
        .equ pisptc = spsr  ;pin SPI transmission complete
        .equ bisptc = 7     ;bit SPI transmission complete 
        .equ msspcs =PinB+$20 ;memoryspace SPI-CS  (bispcs is declared later)
                            ;!! this is only for checking whether SPI-CS is already active or not
                            ;these labels must be accessed by lds/sts (not in/out) 
;................................................................................................
                            ;these labels must be accessed by in/out (not lds/sts) 
        .equ bispcs = 4     ;bit SPI-CS  (=> make output and pull active to +3.3V) 
        .equ pospcs = PrtB  ;port SPI-ChipSelect 
        .equ ddspcs = DdrB  ;Ddr SPI-CS 
                            ;see also msspcs = memoryspace SPI-CS
             
        .equ pospcl = PrtB  ;port SPI-Clk 
        .equ ddspcl = DdrB  ;Ddr SPI-Clk 
        .equ bispcl = 7     ;bit SPI-Clk  (=> make output and pull active to +3.3V)

        .equ pospdi = PrtB  ;port AVR-SPI-DtaIn 
        .equ ddspdi = DdrB  ;Ddr AVR-SPI-DtaIn      
        .equ pispdi = PinB  ;AVR-pin SPI-DtaIn  
        .equ bispdi = 6     ;bit AVR-SPI-DtaIn   
     
        .equ pospdo = PrtB  ;port AVR-SPI-DtaOut
        .equ bispdo = 5     ;bit AVR-SPI-DtaOut  (=> make output and pull active to +3.3V)

        .equ posdcd = PrtD  ;port AVR-SD-CardDetect
        .equ ddsdcd = DdrD  ;Ddr AVR-SD-CardDetect
        .equ pisdcd = PinD  ;AVR-pin SD-CardDetect
        .equ bisdcd = 2     ;bit AVR-SD-CardDetect

        .equ posdwp = PrtD  ;port AVR-SD-WriteProtect 
        .equ ddsdwp = DdrD  ;Ddr AVR-SD-WriteProtect
        .equ pisdwp = PinD  ;AVR-pin SD-WriteProtect
        .equ bisdwp = 6     ;bit AVR-SD-WriteProtect

                            ;!!! IEC-outputs are inverted !!!
                            ; IEC-inputs are not inverted 
    
        .equ piiema = PinA  ;pin IEC-main
        .equ ddiema = DdrA  ;ddr IEC-main
        .equ poiema = PrtA  ;port IEC-main 
   
        .equ piatin = PinA  ;pin AtnIn

        .equ bisrin = 3     ;bit SrqIn 
        .equ biclin = 2     ;bit ClkIn
        .equ bidain = 1     ;bit DtaIn
        .equ biatin = 0     ;bit AtnIn
         
        .equ bisrou = 7     ;bit SrqOut (inverted)
        .equ biclou = 6     ;bit ClkOut (inverted)
        .equ bidaou = 5     ;bit DtaOut (inverted)
        .equ biatou = 4     ;bit AtnOut (inverted)

        .equ pidesw = PinD  ;pin debugswitch
        .equ bidesw = 3     ;bit debugswitch at V1.2 (PD4 at V1.1?)

        .equ poi2da = PrtD  ;port I2C-data
        .equ ddi2da = DdrD  ;ddr I2C-data
        .equ pii2da = PinD  ;pin I2C-data
        .equ bii2da = 7     ;bit I2C-data
    
        .equ poi2cl = PrtD  ;port I2C-clock
        .equ ddi2cl = DdrD  ;ddr I2C-clock
        .equ pii2cl = PinD  ;pin I2C-clock
        .equ bii2cl = 6     ;bit I2C-clock

        .equ poleer = PrtC  ;port LED error    must be made active to +3.3V
        .equ ddleer = DdrC  ;ddr LED error
        .equ pileer = PinC  ;pin LED error (red)
        .equ bileer = 1     ;bit LED error

        .equ poleac = PrtC  ;port LED active   must be made active to +3.3V
        .equ ddleac = DdrC  ;ddr LED active
        .equ pileac = PinC  ;pin LED active (green)
        .equ bileac = 0     ;bit LED active

        .equ poswva = PrtC  ;port switch value
        .equ ddswva = DdrC  ;ddr switch value
        .equ piswva = PinC  ;pin switch value
        .equ biswva = 2     ;bit switch value

        .equ poswmo = PrtC  ;port switch mode
        .equ ddswmo = DdrC  ;ddr switch mode
        .equ piswmo = PinC  ;pin switch mode
        .equ biswmo = 3     ;bit switch mode

        .equ obhasf = $80   ;%10...... override bits hardware of swapfile
                            ;%10 = use SD-card hardware                  
                            ; (there is no HD at SD2IEC)

                            ;these labels must be accessed by in/out (not lds/sts) 
        #endif ; 644-NLQ-HD/sd2iec
;------------------------------------------------------------------------------------------------
        #if partname == 4
         #message 644-NLQ-HD/lite
                              ;these labels must be accessed by lds/sts (not in/out) 
        .equ iratin = eimsk ;IRQ-register AtnIn = IRQ2
        .equ ibatin = 2     ;IRQ-bit AtnIn 
                            ;different at 162 and 644          
                              ;these labels must be accessed by lds/sts (not in/out) 
;................................................................................................
                            ;these labels must be accessed by in/out (not lds/sts)   
        .equ piiema = PinB  ;pin IEC-main
        .equ ddiema = DdrB  ;ddr IEC-main
        .equ poiema = PrtB  ;port IEC-main 
      
        .equ piatin = PinB  ;pin AtnIn

        .equ bisrin = 1     ;bit SrqIn 
        .equ biclin = 7     ;bit ClkIn
        .equ bidain = 5     ;bit DtaIn
        .equ biatin = 2     ;bit AtnIn
         
        .equ bisrou = 6     ;bit SrqOut
        .equ biclou = 3     ;bit ClkOut
        .equ bidaou = 4     ;bit DtaOut
        .equ biatou = 0     ;bit AtnOut

        .equ pidesw = PinD  ;pin debugswitch (ATA-reset&CS0)
        .equ bidesw = 0     ;bit debugswitch
        
        .equ poatdw = PrtD  ;port ATA diow
        .equ ddatdw = DdrD  ;Ddr ATA diow
        .equ piatdw = PinD  ;Pin ATA diow
        .equ biatdw = 2     ;bit ATA diow

        .equ poatdr = PrtD  ;port ATA dior
        .equ ddatdr = DdrD  ;Ddr ATA dior
        .equ piatdr = PinD  ;Pin ATA dior
        .equ biatdr = 1     ;bit ATA dior
 
        .equ poleac = PrtD  ;port LED active (green) = switch value
        .equ ddleac = DdrD  ;ddr LED active
        .equ pileac = PinD  ;pin LED active
        .equ bileac = 6     ;bit LED active
 
        .equ poleer = PrtD  ;port LED error (red) = switch mode
        .equ ddleer = DdrD  ;ddr LED error
        .equ pileer = PinD  ;pin LED error
        .equ bileer = 7     ;bit LED error

        .equ poswva = PrtD  ;port switch value = LED active (green)
        .equ ddswva = DdrD  ;ddr switch value
        .equ piswva = PinD  ;pin switch value
        .equ biswva = 6     ;bit switch value

        .equ poswmo = PrtD  ;port switch mode = LED error (red)
        .equ ddswmo = DdrD  ;ddr switch mode
        .equ piswmo = PinD  ;pin switch mode
        .equ biswmo = 7     ;bit switch mode
     
        .equ idreda = $07   ;IDE register data
        .equ idrepe = $0f   ;IDE register precompensation/error
        .equ idresc = $17   ;IDE register sector count
        .equ idrel0 = $1f   ;IDE register LBA0
        .equ idrel1 = $27   ;IDE register LBA1
        .equ idrel2 = $2f   ;IDE register LBA2
        .equ idrel3 = $37   ;IDE register LBA3
        .equ idrecs = $3f   ;IDE register command/status
                            ;these labels must be accessed by in/out (not lds/sts) 

        .equ obhasf = $00   ;%00...... override bits hardware of swapfile
                            ;%00 = use IDE-HD hardware                   

        #endif ; 644-NLQ-HD/lite
;------------------------------------------------------------------------------------------------
        #if partname == 6
         #message 644-NLQ-HD/SD
                              ;these labels must be accessed by lds/sts (not in/out) 
        .equ iratin = eimsk ;IRQ-register AtnIn = IRQ1
        .equ ibatin = 1     ;IRQ-bit AtnIn 
                            ;different at 162 and 644          
        .equ ibslaw = 2     ;IRQ-bit sleep/awake
        .equ ibrsin = 0     ;IRQ-bit RstIn
       
        .equ assr   = $b6   ;asynchronous status register 
        .equ ucsr0a = $c0   ;usart mspim control and status register 0 a (lds/sts-only
        .equ ucsr0b = $c1   ;usart mspim control and status register 0 b   not in/out)
        .equ ucsr0c = $c2   ;usart mspim control and status register 0 c
        .equ ubr0l  = $c4   ;usart mspim baud rate register 0 low
        .equ ubr0h  = $c5   ;usart mspim baud rate register 0 high
        .equ udr0   = $c6   ;usart I/O-data register

        .equ didr1  = $7f   ;Digital Input Disable Register 1 Analog Comparator (pb2 pb3)
        .equ didr0  = $7e   ;Digital Input Disable Register 0 Analg Digital Converter (pa0 - pa7)

        .equ pcmsk3 = $73   ;Pin Change Mask Register 3
        .equ pcmsk1 = $6c   ;Pin Change Mask Register 1
        
        .equ prr    = $64   ;Power Reduction Register

        .equ clkpr  = $61   ;Clock Prescale Register
        .equ wdtcsr = $60   ;Watchdog Timer Control Register


        .equ spdaio = udr0  ;SPI-data-in/out
        .equ pisptc = ucsr0a;pin SPI transmission complete
        .equ bisptc = 7     ;bit SPI transmission complete    
        .equ msspcs = PinC+$20 ;memoryspace SPI-CS
                            ;!! this is only for checking whether SPI-CS is already active or not
                            ;these labels must be accessed by lds/sts (not in/out)  
;................................................................................................
                            ;these labels must be accessed by in/out (not lds/sts)   
        .equ smcr   = $33   ;Sleep Mode Control Register 

        .equ acsr   = $30   ;Analog Comparator Control and Status Register  

        .equ bispcs = 3     ;bit SPI-CS  (=> make output and pull active to +3.3V)
        .equ pospcs = PrtC  ;port SPI-ChipSelect 
        .equ ddspcs = DdrC  ;Ddr SPI-CS 
                            ;see also msspcs = memoryspace SPI-CS

        .equ pospcl = PrtB  ;port SPI-Clk 
        .equ ddspcl = DdrB  ;Ddr SPI-Clk 
        .equ bispcl = 0     ;bit SPI-Clk  (=> make output and pull active to +3.3V)

        .equ pospdi = PrtD  ;port AVR-SPI-DtaIn 
        .equ ddspdi = DdrD  ;Ddr AVR-SPI-DtaIn      
        .equ pispdi = PinD  ;AVR-pin SPI-DtaIn  
        .equ bispdi = 0     ;bit AVR-SPI-DtaIn   
     
        .equ pospdo = PrtD  ;port AVR-SPI-DtaOut
        .equ ddspdo = DdrD  ;Ddr AVR-SPI-DtaOut
        .equ bispdo = 1     ;bit AVR-SPI-DtaOut  (=> make output and pull active to +3.3V)

        .equ posdcd = PrtC  ;port AVR-SD-CardDetect
        .equ ddsdcd = DdrC  ;Ddr AVR-SD-CardDetect
        .equ pisdcd = PinC  ;AVR-pin SD-CardDetect
        .equ bisdcd = 5     ;bit AVR-SD-CardDetect

        .equ posdwp = PrtC  ;port AVR-SD-WriteProtect 
        .equ ddsdwp = DdrC  ;Ddr AVR-SD-WriteProtect
        .equ pisdwp = PinC  ;AVR-pin SD-WriteProtect
        .equ bisdwp = 4     ;bit AVR-SD-WriteProtect
   
        .equ piiema = PinB  ;pin IEC-main
        .equ ddiema = DdrB  ;ddr IEC-main
        .equ poiema = PrtB  ;port IEC-main 
      
        .equ piatin = PinB  ;pin AtnIn

        .equ bisrin = 1     ;bit SrqIn 
        .equ biclin = 7     ;bit ClkIn
        .equ bidain = 5     ;bit DtaIn
        .equ biatin = 3     ;bit AtnIn
         
        .equ bisrou = 8     ;bit SrqOut
        .equ biclou = 8     ;bit ClkOut
        .equ bidaou = 8     ;bit DtaOut
        .equ biatou = 8     ;bit AtnOut

        .equ birsin = 2     ;bit RstIn !!! PortD !!!

        .equ polert = PrtD  ;port LED RTC = debug-switch
        .equ ddlert = DdrD  ;ddr LED RTC
        .equ pilert = PinD  ;pin LED RTC
        .equ bilert = 7     ;bit LED RTC

        .equ poleac = PrtC  ;port LED active (green) = switch value
        .equ ddleac = DdrC  ;ddr LED active
        .equ pileac = PinC  ;pin LED active
        .equ bileac = 0     ;bit LED active

        .equ poleer = PrtC  ;port LED error (red) = switch mode
        .equ ddleer = DdrC  ;ddr LED error
        .equ pileer = PinC  ;pin LED error
        .equ bileer = 1     ;bit LED error

       
        .equ pidesw = PinD  ;pin debugswitch (RTC-test-LED)
        .equ bidesw = 7     ;bit debugswitch

        .equ poswva = PrtC  ;port switch value = LED active (green)
        .equ ddswva = DdrC  ;ddr switch value
        .equ piswva = PinC  ;pin switch value
        .equ biswva = 0     ;bit switch value

        .equ poswmo = PrtC  ;port switch mode = LED error (red)
        .equ ddswmo = DdrC  ;ddr switch mode
        .equ piswmo = PinC  ;pin switch mode
        .equ biswmo = 1     ;bit switch mode
    
        .equ obhasf = $80   ;%10...... override bits hardware of swapfile
                            ;%10 = use SD-card hardware                  
                            ; (there is no HD at SD2IEC)

        #endif ; 644-NLQ-HD/SD
;------------------------------------------------------------------------------------------------
        #if partname == 7
         #message 644-NLQ-HD/full
                            ;these labels must be accessed by lds/sts (not in/out) 
        .equ iratin = eimsk ;IRQ-register AtnIn = IRQ2
        .equ ibatin = 2     ;IRQ-bit AtnIn 
                            ;different at 162 and 644          

        .equ ucsr0a = $c0   ;usart mspim control and status register 0 a (lds/sts-only
        .equ ucsr0b = $c1   ;usart mspim control and status register 0 b   not in/out)
        .equ ucsr0c = $c2   ;usart mspim control and status register 0 c
        .equ ubr0l  = $c4   ;usart mspim baud rate register 0 low
        .equ ubr0h  = $c5   ;usart mspim baud rate register 0 high
        .equ udr0   = $c6   ;usart I/O-data register

        .equ spdaio = udr0  ;SPI-data-in/out
        .equ pisptc = ucsr0a;pin SPI transmission complete
        .equ bisptc = 7     ;bit SPI transmission complete    
        .equ msspcs = i2pova;memoryspace SPI-CS
                            ;!! this is only for checking whether SPI-CS is already active or not
                            ;these labels must be accessed by lds/sts (not in/out)  
;................................................................................................
                            ;these labels must be accessed by in/out (not lds/sts)                                   
        .equ bispcs = 5     ;bit SPI-CS = bit 5 of pcf8574               !!pcf8574!!
                            ;see also msspcs = memoryspace SPI-CS

        .equ pospcl = PrtB  ;port SPI-Clk (via 74LS07 (open-collector -> 3.3V))
        .equ ddspcl = DdrB  ;Ddr SPI-Clk (via 74LS07 (open-collector -> 3.3V))
        .equ bispcl = 0     ;bit SPI-Clk  (=> make output and pull active to +5V)

        .equ pospdo = PrtD  ;port AVR-SPI-DtaOut (via 74LS07 (open-collector -> 3.3V))
        .equ bispdo = 1     ;bit AVR-SPI-DtaOut  (=> make output and pull active to +5V)

        .equ pospdi = PrtD  ;port AVR-SPI-DtaIn 
        .equ ddspdi = DdrD  ;Ddr AVR-SPI-DtaIn      
        .equ pispdi = PinD  ;AVR-pin SPI-DtaIn (connected via 74LS244) 
        .equ bispdi = 0     ;bit AVR-SPI-DtaIn   

        .equ bisdcd = 7     ;bit AVR-SD-CardDetect                       !!pcf8574!!
        .equ bisdwp = 6     ;bit AVR-SD-WriteProtect                     !!pcf8574!!

        .equ bileer = 1     ;bit-error-LED-pin (red)    =switch mode     !!pcf8574!!
        .equ bileac = 0     ;bit-active-LED-pin (green) = switch value   !!pcf8574!!

        .equ biswmo = 1     ;port switch mode = LED error (red)          !!pcf8574!!
        .equ biswva = 0     ;port switch value = LED active (green)      !!pcf8574!!

        .equ piiema = PinB  ;pin IEC-main
        .equ ddiema = DdrB  ;ddr IEC-main
        .equ poiema = PrtB  ;port IEC-main 
      
        .equ piatin = PinB  ;pin AtnIn

        .equ bisrin = 1     ;bit SrqIn 
        .equ biclin = 7     ;bit ClkIn
        .equ bidain = 5     ;bit DtaIn
        .equ biatin = 2     ;bit AtnIn
         
        .equ bisrou = 6     ;bit SrqOut
        .equ biclou = 3     ;bit ClkOut
        .equ bidaou = 4     ;bit DtaOut
        .equ biatou = 0     ;bit AtnOut

        ;.equ pidesw = PinB  ;pin debugswitch  (=at I2C-PCF85..)
        ;.equ bidesw = 1     ;bit debugswitch 

        .equ poatdw = PrtD  ;port ATA diow
        .equ ddatdw = DdrD  ;Ddr ATA diow
        .equ piatdw = PinD  ;Pin ATA diow
        .equ biatdw = 2     ;bit ATA diow

        .equ poatdr = PrtB  ;port ATA dior
        .equ ddatdr = DdrB  ;Ddr ATA dior
        .equ piatdr = PinB  ;Pin ATA dior
        .equ biatdr = 0     ;bit ATA dior
 
        .equ poi2da = PrtD  ;port I2C-data
        .equ ddi2da = DdrD  ;ddr I2C-data
        .equ pii2da = PinD  ;pin I2C-data
        .equ bii2da = 7     ;bit I2C-data
    
        .equ poi2cl = PrtD  ;port I2C-clock
        .equ ddi2cl = DdrD  ;ddr I2C-clock
        .equ pii2cl = PinD  ;pin I2C-clock
        .equ bii2cl = 6     ;bit I2C-clock

        .equ idreda = $06   ;IDE register data
        .equ idrepe = $0e   ;IDE register precompensation/error
        .equ idresc = $16   ;IDE register sector count
        .equ idrel0 = $1e   ;IDE register LBA0
        .equ idrel1 = $26   ;IDE register LBA1
        .equ idrel2 = $2e   ;IDE register LBA2
        .equ idrel3 = $36   ;IDE register LBA3
        .equ idrecs = $3e   ;IDE register command/status (and inacticve)

        .equ obhasf = $00   ;%00...... override bits hardware of swapfile
                            ;%00 = use IDE-HD hardware                   
                            ;the swapfile must be at the IDE-HD. It cannot be at the SD-card.
                            ;when the content of the HD is backuped to the swapfile on the
                            ; SD-card and the SD.card is removed then the IDE contents cannot
                            ; be restored
                                   
                            ;these labels must be accessed by in/out (not lds/sts) 
        #endif ; 644-NLQ-HD/full
;------------------------------------------------------------------------------------------------
        .org $0000
;------------------------------------------------------------------------------------------------
l10020: jmp l23920     ;external reset   the commands in this table must be 
                       ; two-words-commands  (never one-word-commands) 
       #if partname == 1    
        #message 162-IEC-ATA-V2

       .org $0002
        rjmp l10400     ;external IRQ 0   Port D2 used at IEC-ATA-V2  IEC-AtnIn

       .org $0003       ;wordaddress0003 = byteaddress0006-0007
       .db $20,$02      ;$20 = %00100000
                        ;At flashing the C64 cannot read a byte with the read-eprom-command
                        ; completely, because at flashing the SPI-dataline is connected to IecSrq
                        ; IECSrq cannot be read by the C64 directly; IecSrq acn only make 
                        ; an C64-IRQ when there is a edge from high (5V) to low (0V).
                        ; => All even bits (6,4,2,0) must be 0, all odd bits contain the
                        ; information. 
                        ; %0010t0t0
                        ;  0 1       bit 7 and 5 contain softwaretype
                        ;              0=IEC2IEEE
                        ;              1=NLQ-HD
                        ;              2=NLQ-FD
                        ;              3=illegal value   
                        ;      t t   bit 3 and 1 contain the timing
                        ;              0=universal
                        ;              1=NTSC
                        ;              2=PAL
                        ;              3=illegal value 
                        ;$02 = %00000010
                        ;       h0h0h0h0
                        ;       h h h h  =Hardwaretype
                        ;       0 0 0 1  = $01 
                        ;to enshure that correct software runs on correct hardware
                        ; (else a 3.3V-SD-card-pin could be pulled active to +5V
                        ;   => SD-card could perhaps be destroyed???) 
                        ;don't change this position, important for QBasic-PRG to see which 
                        ; hardwareversion
                        ;these 2 bytes have at all hardware-boards the same memoryposition  
                        ;$20 = bytes 39 and 40 of nlq-hd.hex-file  
                        ;$02 = bytes 41 and 42 of nlq-hd.hex-file  
        .org $0004

;/*                      ;these IRQ are needed only for testing whether an illegal IRQ is made
                        ;delete these vetors later 
        ldi r25,$02     ;external IRQ 1   Port D3 
        rjmp freeze

        .org $0006
        ldi r25,$03     ;external IRQ 2   Port E0 
        rjmp freeze

        .org $0008
        ldi r25,$04     ;PCINT0 Pin Change Interrupt Request 0
        rjmp freeze

        .org $000a
        ldi r25,$05     ;PCINT1 Pin Change Interrupt Request 1
        rjmp freeze

        .org $000c
        ldi r25,$06     ;TIMER3 CAPT Timer/Counter3 Capture Event
        rjmp freeze

        .org $000e
        ldi r25,$07     ;TIMER3 COMPA Timer/Counter3 Compare Match A
        rjmp freeze

        .org $0010
        ldi r25,$08     ;TIMER3 COMPB Timer/Counter3 Compare Match B
        rjmp freeze

        .org $0012
        ldi r25,$09     ;TIMER3 OVF Timer/Counter3 Overflow
        rjmp freeze

        .org $0014
        ldi r25,$0a     ;TIMER2 COMP Timer/Counter2 Compare Match
        rjmp freeze

        .org $0016
        ldi r25,$0b     ;TIMER2 OVF Timer/Counter2 Overflow
        rjmp freeze

        .org $0018
        ldi r25,$0c     ;TIMER1 CAPT Timer/Counter1 Capture Event
        rjmp freeze

        .org $001a
        ldi r25,$0d     ;TIMER1 COMPA Timer/Counter1 Compare Match A
        rjmp freeze

        .org $001c
        ldi r25,$0e     ;TIMER1 COMPB Timer/Counter1 Compare Match B
        rjmp freeze

        .org $001e
        ldi r25,$0f     ;TIMER1 OVF Timer/Counter1 Overflow
        rjmp freeze

        .org $0020
        ldi r25,$10     ;TIMER0 COMP Timer/Counter0 Compare Match
        rjmp freeze

        .org $0022
        ldi r25,$11     ;TIMER0 OVF Timer/Counter0 Overflow
        rjmp freeze

        .org $0024
        ldi r25,$12     ;SPI, STC Serial Transfer Complete
        rjmp freeze

        .org $0026
        ldi r25,$13     ;USART0, RXC USART0, Rx Complete
        rjmp freeze

        .org $0028
        ldi r25,$14     ;USART1, RXC USART1, Rx Complete
        rjmp freeze

        .org $002a
        ldi r25,$15     ;USART0, UDRE USART0 Data Register Empty
        rjmp freeze

        .org $002c
        ldi r25,$16     ;USART1, UDRE USART1 Data Register Empty
        rjmp freeze

        .org $002e
        ldi r25,$17     ;USART0, TXC USART0, Tx Complete
        rjmp freeze

        .org $0030
        ldi r25,$18     ;USART1, TXC USART1, Tx Complete
        rjmp freeze

        .org $0032
        ldi r25,$19     ;EE_RDY EEPROM Ready
        rjmp freeze

        .org $0034
        ldi r25,$1a     ;ANA_COMP Analog Comparator
        rjmp freeze

        .org $0036
        ldi r25,$1b     ;SPM_RDY Store Program Memory Ready
        rjmp freeze

        .org $0038
;*/                     ;these IRQ are needed only for testing whether an illegal IRQ is made
                        ;delete these vetors later
       #endif           ;IEC-ATA-V2 
      
       #if partname == 3 ;-----------------------------------------------------------------------
        #message 644-NLQ-HD/sd2iec

       .org $0002
        rjmp l10700     ;external IRQ 0   Port D2
                        ;ldi r25,$01 is made at l10700

       .db $20,$0a      ;partname to compare with value from eeprom
                        ;$20 -> timing0 = universal
                        ;$0a = %00001010
                        ;       0 0 1 1 =3 =
                        
                        ;to enshure that correct software runs on correct hardware
                        ; (else a 3.3V-SD-card-pin could be pulled active to +5V
                        ;   => SD-card could perhaps be destroyed???) 
                        ;don't change this position, important for QBasic-PRG to see which 
                        ; hardwareversion
                        ;these 2 bytes have at all hardware-boards the same memoryposition       
        .org $0004
        ldi r25,$02    ;external IRQ 1   Port D3 
        rjmp freeze

        .org $0006
        ldi r25,$03    ;external IRQ 2   Port B2
        rjmp freeze
  
        .org $0008   
        rjmp l10400    ;Pin Change Interrupt Request 0 probably PrtA 
        .db $ff,$ff    ;                 bit0 of PrtA = IEC-AtnIn
                       ;                          used at SD2IEC-hardware
                       ;                 bit1 of PrtA = IEC-DtaIn
                       ;                          used at 1541U-debug 
        .org $000a
        ldi r25,$05    ;Pin Change Interrupt Request 1
        rjmp freeze

        .org $000c
        ldi r25,$06    ;Pin Change Interrupt Request 2
        rjmp freeze

        .org $000e
        ldi r25,$07    ;Pin Change Interrupt Request 3
        rjmp freeze

        .org $0010
        ldi r25,$08    ;Watchdog Time-out Interrupt
        rjmp freeze

        .org $0012
        ldi r25,$09    ;Timer/Counter2 Compare Match A  
        rjmp freeze    ;            
             
        .org $0014
        ldi r25,$0a    ;Timer/Counter2 Compare Match B
        rjmp freeze    ;            

        .org $0016  
        ldi r25,$0b    ;Timer/Counter2 Overflow
        rjmp freeze    ;            

        .org $0018  
        ldi r25,$0c    ;Timer/Counter1 Capture Event
        rjmp freeze    ;            

        .org $001a     ;Timer/Counter1 Compare Match A   used for 100 timer-IRQs per second
        rjmp l10450    ;                                 (for i2c-SD/MMC-carddetect-polling)
        .db $ff,$ff     

        .org $001c
        ldi r25,$0e    ;TIMER1_COMPB Timer/Counter1 Compare Match B
        rjmp freeze    ;            

        .org $001e  
        ldi r25,$0f    ;TIMER1_OVF Timer/Counter1 Overflow
        rjmp freeze    ;            

        .org $0020  
        ldi r25,$10    ;TIMER0_COMPA Timer/Counter0 Compare Match A
        rjmp freeze    ;            

        .org $0022  
        ldi r25,$11    ;TIMER0_COMPB Timer/Counter0 Compare match B
        rjmp freeze    ;            

        .org $0024  
        ldi r25,$12    ;TIMER0_OVF Timer/Counter0 Overflow
        rjmp freeze    ;            

        .org $0026  
        ldi r25,$13    ;SPI_STC SPI Serial Transfer Complete
        rjmp freeze    ;            

        .org $0028  
        ldi r25,$14    ;USART0_RX USART0 Rx Complete
        rjmp freeze    ;            

        .org $002a  
        ldi r25,$15    ;USART0_UDRE USART0 Data Register Empty
        rjmp freeze    ;            

        .org $002c  
        ldi r25,$16    ;USART0_TX USART0 Tx Complete
        rjmp freeze    ;            

        .org $002e  
        ldi r25,$17    ;ANALOG_COMP Analog Comparator
        rjmp freeze    ;            

        .org $0030  
        ldi r25,$18    ;ADC ADC Conversion Complete
        rjmp freeze    ;            

        .org $0032  
        ldi r25,$19    ;EE_READY EEPROM Ready
        rjmp freeze    ;            

        .org $0034  
        ldi r25,$1a    ;TWI 2-wire Serial Interface
        rjmp freeze    ;            

        .org $0036  
        ldi r25,$1b    ;SPM_READY Store Program Memory Ready    
        rjmp freeze
     
        .org $0038
       #endif


       #if ((partname >= 4) & (partname <= 7))
        #message 644-NLQ-HD/all

       .org $0002
       #if partname == 6
        #message 644-NLQ-HD/SDonly
        rjmp l10080    ;external IRQ 0   Port D2                            NH-SDonly: IEC-RstIn
     
       #else           
        reti           ;external IRQ 0   Port D2
       #endif     
 
       .org $0003   
       #if partname == 4
        #message 644-NLQ-HD/lite
        .db $20,$20    ;%00100000 
                       ; 0 1 0 0 
        #endif
       
       #if partname == 5
        #message 644-NLQ-HD/HD-outputdriver
        .db $20,$22    ;%00100010 
                       ; 0 1 0 1 
        #endif
       
       #if partname == 6
        #message 644-NLQ-HD/SDonly
        .db $20,$28    ;%00100000 
                       ; 0 1 1 0 
        #endif
       
       #if partname == 7
        #message 644-NLQ-HD/full
        .db $20,$2a    ;%00101010 
                       ; 0 1 1 1 
        #endif
         
                       ;partname to compare with value from eeprom
                       ;to enshure that correct software runs on correct hardware
                       ; (else a 3.3V-SD-card-pin could be pulled active to +5V
                       ;   => SD-card could perhaps be destroyed???) 
                       ;don't change this position, important for QBasic-PRG to see which 
                       ; hardwareversion
                       ;these 2 bytes have at all hardware-boards the same memoryposition       
        .org $0004
       #if partname == 6
        #message 644-NLQ-HD/SDonly
        rjmp l10400    ;external IRQ 1   Port D3                  NH-SDonly: IEC-AtnIn
        .db $ff,$ff    
      
       #else           
        ldi r25,$02    ;external IRQ 1   Port D3                 
        rjmp freeze
       #endif

        .org $0006
       #if partname == 6
        #message 644-NLQ-HD/SDonly
        rjmp l10110    ;external IRQ 2   Port B2                  NH-SDonly: VCC = sleep
        .db $ff,$ff 
             
       #else           
        rjmp l10400    ;external IRQ 2   Port B2                  non-SDonly: IEC-AtnIn
        .db $ff,$ff    
       #endif
  
        .org $0008   
        ldi r25,$04    ;Pin Change Interrupt Request 0  
        rjmp freeze   
                      
        .org $000a
       #if partname == 6
        #message 644-NLQ-HD/SDonly
        rjmp l10060    ;Pin Change Interrupt Request 1             NH-SDonly: start IEC-transfer
        .db $ff,$ff    
      
       #else           
        ldi r25,$05    ;Pin Change Interrupt Request 1
        rjmp freeze
       #endif     
         
        .org $000c
        ldi r25,$06    ;Pin Change Interrupt Request 2
        rjmp freeze

        .org $000e
       #if partname == 6
        #message 644-NLQ-HD/SDonly
        rjmp l10150    ;Pin Change Interrupt Request 3             NH-SDonly: VCC = awake
        .db $ff,$ff    
      
       #else   
        ldi r25,$07    ;Pin Change Interrupt Request 3       
        rjmp freeze
       #endif

        .org $0010
        #if partname == 6
        #message 644-NLQ-HD/SDonly
        rjmp l10160    ;Watchdog Time-out Interrupt NH-SDonly: used for RTC when time-out
        .db $ff,$ff
      
       #else           
        ldi r25,$08    ;Watchdog Time-out Interrupt
        rjmp freeze
       #endif     
    
        .org $0012
       #if partname == 6
        #message 644-NLQ-HD/SDonly
        rjmp l10300    ;Timer/Counter2 Compare Match A    NH-SDonly: used for RTC when AVR sleeps
        .db $ff,$ff

       #else           
        ldi r25,$09    ;Timer/Counter2 Compare Match A
        rjmp freeze
       #endif      
       
        .org $0014
       #if partname == 6
        #message 644-NLQ-HD/SDonly
        rjmp l10200    ;Timer/Counter2 Compare Match B NH-SDonly: used for RTC when AVR is awake
        .db $ff,$ff
             
       #else           
        ldi r25,$0a    ;Timer/Counter2 Compare Match B 
        rjmp freeze
       #endif     

        .org $0016   
        ldi r25,$0b    ;Timer/Counter2 overflow
        rjmp freeze
 
        .org $0018  
        ldi r25,$0c    ;Timer/Counter1 Capture Event
        rjmp freeze    ;            

        .org $001a    
        rjmp l10450    ;Timer/Counter1 Compare Match A   used for 100 timer-IRQs per second
        .db $ff,$ff    ;                                 (for i2c-SD/MMC-carddetect-polling)

        .org $001c
        ldi r25,$0e    ;TIMER1_COMPB Timer/Counter1 Compare Match B
        rjmp freeze    ;            

        .org $001e  
        ldi r25,$0f    ;TIMER1_OVF Timer/Counter1 Overflow
        rjmp freeze    ;            

        .org $0020  
        ldi r25,$10    ;TIMER0_COMPA Timer/Counter0 Compare Match A
        rjmp freeze    ;            

        .org $0022  
        ldi r25,$11    ;TIMER0_COMPB Timer/Counter0 Compare match B
        rjmp freeze    ;            

        .org $0024  
        ldi r25,$12    ;TIMER0_OVF Timer/Counter0 Overflow
        rjmp freeze    ;            

        .org $0026  
        ldi r25,$13    ;SPI_STC SPI Serial Transfer Complete
        rjmp freeze    ;            

        .org $0028  
        ldi r25,$14    ;USART0_RX USART0 Rx Complete
        rjmp freeze    ;            

        .org $002a  
        ldi r25,$15    ;USART0_UDRE USART0 Data Register Empty
        rjmp freeze    ;            

        .org $002c  
        ldi r25,$16    ;USART0_TX USART0 Tx Complete
        rjmp freeze    ;            

        .org $002e  
        ldi r25,$17    ;ANALOG_COMP Analog Comparator
        rjmp freeze    ;            

        .org $0030  
        ldi r25,$18    ;ADC ADC Conversion Complete
        rjmp freeze    ;            

        .org $0032  
        ldi r25,$19    ;EE_READY EEPROM Ready
        rjmp freeze    ;            

        .org $0034  
        ldi r25,$1a    ;TWI 2-wire Serial Interface
        rjmp freeze    ;            

        .org $0036  
        ldi r25,$1b    ;SPM_READY Store Program Memory Ready    
        rjmp freeze
     
        .org $0038
       #endif
;------------------------------------------------------------------------------------------------
txdati: .db __DATE__   ;AVR-Studio 4.12 -> Project -> Assembler Options ->
        #message __DATE__ ;                    Additional Parameters:  -FD"%%Y-%%m-%%d %%H.%%M"
                       ;don't change this position, important for QBasic-PRG to see which 
                       ; hardwareversion
                      
                       ;different memorypositions at different hardware-boards
                       ;2008-12-31 23.59       
                       ;    a  b  c  d    <- flags for Qbasic-program to test whether correct
                       ;    |  |  |  |         nlq-hd.hex-file
                       ;    51 57 76 82   <- memoryposition in nlq-hd.hex-file at IEC-ATA-V2
                       ;   182 | 207 |    <- memoryposition innlq-hd.hex-file at 644-boards
                       ;      188   213   <-´
       .db "NLQ-HD"
;------------------------------------------------------------------------------------------------
       #if partname == 6
        #message 644-NLQ-HD/SDonly
l10030:                ;every rjmp of this table must have 2bytes (1word)
        rjmp l11470    ;2 2=CBM-IECIN-routine    l10030 = wordaddres $0026 ($0043 when all
                       ;                                  IRQ-vectors are set for debuging)
        rjmp l11740    ;2 3=CBM-IECOUT-routine          = wordaddres $0027 ($0044)
        rjmp l11650    ;2 4=JD-IECIN                    = wordaddres $0028 ($0045)
        rjmp l11890    ;2 5=RTC-JD-IECOUT               = wordaddres $0029 ($0046)
        rjmp l12170    ;2 6=RTC-JD-LOAD from AVR-RAM    = wordaddres $002a ($0047)
        rjmp l10050    ;2 7=RTC-JD-LOAD from SD-card    = wordaddres $002b ($0048)
l10040: .db $0         ;only rjmp (relative jump) allowed no jmp (no absolute jump)
;------------------------------------------------------------------------------------------------
l10050: jmp l27230
;------------------------------------------------------------------------------------------------
                       ;from IRQ-vector
                       ;1 command of mainprogram (1 or 2 cycles)
                       ;2 push program counter onto the stack
                       ;2 rjmp l10060 (IRQ-vector) (not 3cycles for jmp as on p17 of doc2593)
l10060:                ;                                           Pin Change Interrupt Request 1
                       ;                                       NH-SDonly: start IEC-transfer?
                       ;  !!!! mustn't change r08 (=Sreg) and r24 !!!!
                       ;  mustn't change r16 at CBM-IECOUT
        in r08,Sreg    ;1 backups statusregister
        
        sts pcicr,r06  ;2 #$00 Pin Change Interrupt Control Register  
                       ;                                         disable further pinchange-IRQs 
                       ;also flag that RTC-IEC-subroutines (not -mainroutine) is executed

        sei            ;1 enable IRQs (sleep-IRQ, RstIn-IRQ)
        lds r25,airtmb ;2 AVR-internal-RTC-mode-bits
                       ;  7=sleep-IRQ finished routine
                       ;  6=reset-IRQ finished routine
                       ;  5=watchdog time-out finished routine
                       ;  4=IEC-error finished routine 
                       ;  3=IEC-Atn-change finished routine (in databyte-mode but AtnIn=active)
                       ;  2=IEC-Atn-change finished routn (in commandbyte-mode but AtnIn=inactive)
                       ;  1=normal end of routine
                       ;  0= 0=RTC-values changed by timer2-IRQ   (direct-IEC- & IRQ-RTC-mode)
                       ;     1=RTC-values changed by mainprogram  IRQ-IEC- & direct-RTC-mode
        tst r25        ;1
        breq l10070    ;1 b.i.not in correct routine             
        
        lds r25,airtmr ;2 AVR-internal-RTC-mainroutine               
                       ;     0=illegal
                       ;     1=illegal
                       ;     2=CBM-IECIN
                       ;     3=CBM-IECOUT
                       ;     4=JD-IECIN
                       ;     5=JD-IECOUT
                       ;     6=JD-LOAD
                       ;     7-ff=illegal
        cpi r25,$02    ;1
        brcs l10070    ;1 b.i.0-1

        cpi r25,$08    ;1
        brcc l10070    ;1 b.i.8-ff

        lds r25,airtsl ;2 AVR-internal-RTC-Stackpointer low  
        tst r25        ;1
        brpl l10070    ;1
    
        cpi r31,$01    ;1
        brcc l10070    ;1 b.i.ijump-vector illegal


;ldi r25,$a1    ;a1----
;rcall l13090


        ijmp           ;2 indirect jump to IEC-routine ----- (l10030)
                       ;=29cycles

l10070: ldi r25,$a2    ;a2----  =illegal value
        rjmp l10180
;------------------------------------------------------------------------------------------------
l10080:                ;                                       PD2 INT0 reset-pin  hardware reset
                       ;                                   falling edge IRQ
                       ;problem at special RTC-IEC-routines: difference when
                       ; -reset-switch is pressed while mainroutine of special RTC-IEC-routines
                       ;   => this routine must backup SReg of special RTC-IEC-routines to r08
                       ; -reset-switch is pressed while IEC-subroutine of special RTC-IECroutines
                       ;   => Sreg of special RTC-IEC-mainroutine is stored to r08 at l10060
                       ;    => Sreg mustn't be stored again to r08
                       ;        (because then the Sreg of the IEC-subroutine would be backuped
                       ;     => SReg would be wrong at end (wouldn't contain value of 
                       ;         RTC-IEC-mainroutine)
 
        ldi r25,$f9    ;f9----
        rcall l13090

        in r00,Sreg    ;backups statusregister   !!r00  not r08!!
                       ; but not yet clear whether Sreg of RTC-IEC-main or -subroutine  

        lds r25,pcicr  ;Pin Change Interrupt Control Register  
                       ;also flag for RTC-IEC-main / -subroutines is executed
                       ;#$00=RTC-IEC-subroutine
                       ;01-ff =RTC-IEC-mainroutine
        tst r25
        breq l10090    ;b.i.RTC-IEC-subroutine (SReg of RTC-IECmainroutine is backuped at l10060)

                       ;=RTC-IEC-mainroutine 
        mov r08,r00    ;r08=Sreg of RTC-IEC-mainroutine 

l10090: lds r25,airtmb ;AVR-internal-RTC-mode-bits
                       ;7=sleep-IRQ finished routine
                       ;6=reset-IRQ finished routine
                       ;5=watchdog time-out finished routine
                       ;4=IEC-error finished routine 
                       ;3=IEC-Atn-change finished routine (in databyte-mode but AtnIn=active)
                       ;2=IEC-Atn-change finished routn (in commandbyte-mode but AtnIn=inactive)
                       ;1=normal end of routine
                       ;0= 0=RTC-values changed by timer2-IRQ   (direct-IEC- & IRQ-RTC-mode)
                       ;   1=RTC-values changed by mainprogram  IRQ-IEC- & direct-RTC-mode
        bst r25,0      ;
        brtc l10100    ;b.i.mainprogram is not in correct routine

        lds r00,airtmr ;AVR-internal-RTC-mainroutine               
        tst r00
        breq l10100             

        lds r00,airtsl ;AVR-internal-RTC-stackpointer-low
                       ;make stackpointer that this IRQ returns to the mainprogram
                       ; and not to the IEC-routines below
        tst r00
        brpl l10100    ;b.i.illegal value
      
        ori r25,$40    ;set bit that reset-switch finished routine
        sts airtmb,r25 ;AVR-internal-RTC-mode-bits
      
        out Spl,r00    ;stackpointer low    
        out Sreg,r08   ;restores status register 
        reti           ;r25=airtmb  return to RTC-mainprogram (not IEC-routines)

l10100: jmp l23930     ;PD3 INT0 reset-pin  hardware reset
;------------------------------------------------------------------------------------------------
l10110:                ;                         external int2-IRQ PB2=0V = AVR: awake->sleep-IRQ
        ldi r25,$f8    ;f8----
        rcall l13090
     
        in r00,Sreg    ;backups statusregister   !!r00  not r08!!
                       ; but not yet clear whether Sreg of RTC-IEC-main or -subroutine  

        lds r25,pcicr  ;Pin Change Interrupt Control Register  
                       ;also flag for RTC-IEC-main / -subroutines is executed
                       ;#$00=RTC-IEC-subroutine
                       ;01-ff =RTC-IEC-mainroutine
        tst r25
        breq l10120    ;b.i.RTC-IEC-subroutine (SReg of RTC-IECmainroutine is backuped at l10060)

                       ;=RTC-IEC-mainroutine 
        mov r08,r00    ;r08=Sreg of RTC-IEC-mainroutine 

l10120: lds r25,airtmb ;AVR-internal-RTC-mode-bits
                       ;7=sleep-IRQ finished routine
                       ;6=reset-IRQ finished routine
                       ;5=watchdog time-out finished routine
                       ;4=IEC-error finished routine 
                       ;3=IEC-Atn-change finished routine (in databyte-mode but AtnIn=active)
                       ;2=IEC-Atn-change finished routn (in commandbyte-mode but AtnIn=inactive)
                       ;1=normal end of routine
                       ;0= 0=RTC-values changed by timer2-IRQ   (direct-IEC- & IRQ-RTC-mode)
                       ;   1=RTC-values changed by mainprogram  IRQ-IEC- & direct-RTC-mode
        bst r25,0      ;
        brtc l10130    ;b.i.mainprogram is not in RTC-IEC-routine

        lds r00,airtmr ;AVR-internal-RTC-mainroutine               
        tst r00
        breq l10130             

        lds r00,airtsl ;AVR-internal-RTC-stackpointer-low
                       ;make stackpointer that this IRQ returns to the mainprogram
                       ; and not to the IEC-routines below
        tst r00
        brpl l10130    ;b.i.illegal value
      
        ori r25,$80    ;set bit that sleep-IRQ-switch finished routine
        sts airtmb,r25 ;AVR-internal-RTC-mode-bits
      
        out Spl,r00    ;stackpointer low    
        out Sreg,r08   ;restores status register 
        reti           ;r25=airtmb  return to RTC-mainprogram (not IEC-routines)

l10130: cli            ;disable IRQ  (perhaps important at end of RTC-IEC-routines?)

        ldi r16,$80
        ldi r17,$05    ;%00000101 = 8MHz / 32 = 256kHz 
        sts clkpr,r16  ;Clock Prescale Register
        sts clkpr,r17  ;Clock Prescale Register

        ldi r25,$04    ;enables bit2 of portB as IRQ-trigger = sleep/awake 
        sts pcmsk1,r25 ;Pin Change Mask Register 3
           
        ldi r25,$02
        sts pcicr,r25  ;Pin Change Interrupt Control Register    enable PortB-IRQ
        sts pcifr,r25  ;Pin Change Interrupt Flag Register   clears old IRQ-flag
                       ;sleep/awake-pin should have 0V 
                
        ldi r25,$02
        sts timsk2,r25 ;Timer/Counter2 Interrupt Mask Register
                       ;bit0 = Timer/Counter2 Overflow Interrupt Enable
                       ;bit1 = Timer/Counter2 Output Compare Match A Interrupt Enable (sleep)
                       ;bit2 = Timer/Counter2 Output Compare Match B Interrupt Enable (awake)
                       ;=RTC-IRQ        
                
        sts iratin,r06 ;disable AtnIn-IRQs (int2), sleep-IRQ and reset-switch-IRQ  

        sts timsk1,r06 ;Timer/Counter1 Interrupt Mask Register
                       ;disable 100Hz-timer1-IRQs                      
       
        ldi r25,0b00111000
        sts wdtcsr,r25 ;Watchdog Timer Control Register
                       ;7:   wdif Watchdog Interrupt Flag
                       ;6:   WDIE Watchdog Interrupt Enable
                       ;5:   wdp3 Watchdog Timer Prescaler 3
                       ;4    WDCE Watchdog Change Enable
                       ;3:   WDE  Watchdog System Reset Enable
                       ;2-0: WDP2-0: Watchdog Timer Prescaler 2, 1 and 0
                       ;             pdp3-0=%0101 = 0.5s 
                       ;wdce=1 and wde=1 => allows changig of the watchdog
        
        ldi r25,0b00100000
        sts wdtcsr,r25 ;disables watchdog-IRQs (this sts must be within 4cycles)

        ldi r25,0b10101111; save power
        sts prr,r25    ;Power Reduction Register
                       ;Bit 7 - PRTWI: Power Reduction TWI
                       ;Bit 6 - PRTIM2: Power Reduction Timer/Counter2
                       ;Bit 5 - PRTIM0: Power Reduction Timer/Counter0
                       ;Bit 4 - Res: Reserved bit
                       ;Bit 3 - PRTIM1: Power Reduction Timer/Counter1
                       ;Bit 2 - PRSPI: Power Reduction Serial Peripheral Interface
                       ;Bit 1 - PRUSART0: Power Reduction USART0
                       ;Bit 0 - PRADC: Power Reduction ADC


        out DdrA,r06   ;the pins are clamped to ground while sleep
        out PrtA,r06   ; => a internal pullup-resistor would cost power?
        out DdrB,r06   
        out PrtB,r06   
        out DdrC,r06   
        out PrtC,r06   
        out DdrD,r06   
        out PrtD,r06   
      
        sts adcsra,r06 ;#$00 switch off ADC 
       
        ;ldi r25,$80
        ;sts acsr,r25   ;switch off Analog Comparator  
                       ;Analog Comparator is already disabled at prr???  

                       ;brown out dectector

                       ;Internal Voltage Reference is disabled when:
                       ;& Brown-out Detection is disabled 
                       ;& Analog Comparator is disabled
                       ;& ADC is disabled

                       ;watchdog-timer

                       ;On-chip Debug System

        ldi r25,$0f
        sts didr1,r25  ;Digital Input Disable Register 1 Analog Comparator (pb2 pb3)

        sts didr0,r07  ;#$ff Digital Input Disable Register 0 Analg Digital Converter (pa0 - pa7)

        sts sdfldc,r07 ;SD flag disk change                             (bit0-3=$1c at 1541)
                       ;                                                (bit4-7=$1e at 1541)
                       ;bit4: pin of SS-card-detect
                       ;bit1; 0=preserve actual dircluster 1=reset actual dircluster 
                       ;bit0: 0=not changed  1=changed

        lds r16,airtse 
        lds r17,airtmi         
        lds r18,airtho      
        lds r19,airtda      
        lds r20,airtmo      
        lds r21,airtyl
        lds r22,airtyh      
        lds r23,airtwd      
    
        ldi r25,$f7   ;f7----
        mov r26,r04   ;debugvector low
        ldi r27,high(debube)
        bst r26,0     ;copies even/odd-bit from debugvector low to T-flag
        brtc l10140   ;b.i.even

        st x+,r07     ;#$ff   make debugvector even

l10140: ldi r28,$07

        sbic PinD,2    ;b.i.sleep/awake-pin = 0V  

        rjmp l10150    ;= sleep/awake-pin = +5V  

        ldi r29,$07    ;power-save-mode  and  sleep-enable-bit set
        sei            ;enable IRQs
        out smcr,r29   ;Sleep Mode Control Register 
        sleep            
        ldi r25,$f5    ;f5--
        rjmp freeze         
                                    
                       ;what happens when the RTC-timer makes exactly an IRQ between CLI
                       ; and before SLEEP-command? 
                       ; Does the before-the-Sleep-command-received-IRQ-bit also awakes the AVR? 
                       ;what happens when the IRQ is disabled? (CLI)
                       ; is the IRQ-routine executed?? 
                       ;doc2593 p41: 
                       ;If Timer/Counter2 is enabled, it will keep running during sleep. The
                       ; device can wake up from either Timer Overflow or Output Compare event
                       ; from Timer/Counter2 if the corresponding Timer/Counter2 interrupt
                       ; enable bits are set in TIMSK2, and the Global Interrupt Enable bit in
                       ; SREG is set.
                       ;=> IRQ must be enabled = SEI
;------------------------------------------------------------------------------------------------
l10150:                ;                               pin change IRQ PB2 = AVR: sleep->awake-IRQ              
        cli            ;disable IRQs (necessary??)   
      
        mov r04,r26    ;debugvector low
        
        ldi r25,$f6    ;f6----
        rcall l13090
        
        out smcr,r06   ;#$00 clear Sleep Mode Control Register      

        sts pcicr,r06  ; clear Pin Change Interrupt Control Register 

        ldi r25,$04
        sts timsk2,r25 ;Timer/Counter2 Interrupt Mask Register
                       ;bit0 = Timer/Counter2 Overflow Interrupt Enable
                       ;bit1 = Timer/Counter2 Output Compare Match A Interrupt Enable (sleep)
                       ;bit2 = Timer/Counter2 Output Compare Match B Interrupt Enable (awake)
                       ;=RTC-IRQ        


        
        sts airtse,r16 
        sts airtmi,r17     
        sts airtho,r18      
        sts airtda,r19      
        sts airtmo,r20      
        sts airtyl,r21
        sts airtyh,r22      
        sts airtwd,r23      

        ldi r16,$80
        sts clkpr,r16  ;Clock Prescale Register
        sts clkpr,r06  ;#$00 Clock Prescale Register  %00000000 = 8MHz / 1 = 8MHz 



        sts prr,r06    ;#$00 Power Reduction Register  enable hardware
        sts didr1,r06  ;#$00 Digital Input Disable Register 1
        sts didr0,r06  ;#$00 Digital Input Disable Register 0
        
        rjmp l10100    ;-> jmp l23930 PD3 INT1 reset-pin  hardware reset
;------------------------------------------------------------------------------------------------
l10160:                ;                                              Watchdog Time-out Interrupt
                       ;                                 used for RTC when time-out                                                             
                       ;                                 mustn't change r24
                       ;while mainroutine of special RTC-IEC-routines:
                       ; WDR-command => this routine is never made
                       ;=> this routine can only be made when the RTC-IEC-subroutines hang
                       ; => Sreg of special RTC-IEC-mainroutine is stored to r08 at l10060
                       ;  => Sreg can be restored at end always from r08
  
        ldi r25,$fa    ;fa----
        rcall l13090
                          
        lds r25,airtmb ;AVR-internal-RTC-mode-bits
                       ;7=sleep-IRQ finished routine
                       ;6=reset-IRQ finished routine
                       ;5=watchdog time-out finished routine
                       ;4=IEC-error finished routine 
                       ;3=IEC-Atn-change finished routine (in databyte-mode but AtnIn=active)
                       ;2=IEC-Atn-change finished routn (in commandbyte-mode but AtnIn=inactive)
                       ;1=normal end of routine
                       ;0= 0=RTC-values changed by timer2-IRQ   (direct-IEC- & IRQ-RTC-mode)
                       ;   1=RTC-values changed by mainprogram  IRQ-IEC- & direct-RTC-mode
        bst r25,0      ;
        brts l10190    ;b.i.mainprogram is in correct routine

                       ;=error: watchdog-time-out when not activated by mainprogram
l10170: ldi r25,$a3    ;a3----

l10180: rjmp freeze

l10190: lds r00,airtmr ;AVR-internal-RTC-mainroutine               
        tst r00
        breq l10170             

        lds r00,airtsl ;AVR-internal-RTC-stackpointer-low
                       ;make stackpointer that this IRQ returns to the mainprogram
                       ; and not to the IEC-routines below
        tst r00
        brpl l10170    ;b.i.illegal value

        ori r25,$20    ;set bit that watchdog time-out finished routine
        sts airtmb,r25 ;AVR-internal-RTC-mode-bits
        
        out Spl,r00    ;stackpointer low    
        out Sreg,r08   ;restores status register 
        reti           ;r25=airtmb  return to RTC-mainprogram (not IEC-routines)
;------------------------------------------------------------------------------------------------
                       ;from IRQ-vector  
l10200: in r06,Sreg    ;backups status register               Timer/Counter2 Compare Match B IRQ     
        mov r07,r16    ;backups r16                               when 644 is awake

;/*      
        push r25
        mov r25,r03    ;=last written debugbyte
        cpi r25,$fb
        breq l10210
        
        cpi r25,$fc
        breq l10210    ;b.i.this IRQ-routine wrote last byte into debugbuffer
                       ;  = to prevent that debugbuffer is overwritten with
                       ;    many #$ff when in main waitingloop

        ldi r25,$fb
        mov r03,r25
        rcall l13090   ;fb-- 1Hz-RTC-timer2-IRQ-routine

l10210: pop r25
;*/

        ldi r16,$07     ;clear all IRQ-bits of timer2 
        sts tifr2,r16   ;important because RTC-timer2 sleep-routine uses output compare A-IRQ 
                             
        lds r16,airtse ;seconds-------- (00,06,12...54)
                       ;......................................................   
        cbi ddlert,bilert ;=LED-RTC-off  = default
        sbi polert,bilert ;prt LED-RTC pulupon      usually there is no LED at the debug-pin
                       ; => the pullup-resistor must be activated to prevent swinging 
;/*     
                       ;add this command (/*) when it's important to measure the currency
                       ; of the circuit to see how long the backup-battery works

        bst r16,1      ;copies bit of seconds that changes every time to T-flag
        brtc l10220    ;b.i.00,12,24,36,48

        cbi polert,bilert ;prt LED-RTC   =06,18,30,42,54  
        sbi ddlert,bilert ;= makes LED-RTC=on=output         LED-RTC-on
;*/                     ;NLQHD-SD: RTC-LED is changed in IRQ:
                       ; mainprogram: (1) in r16,DdrD
                       ;                  andi r17,..  
                       ;              (2) out DdrD,r16
                       ;              (3) in r17,PrtD
                       ;                  ori r17,..  
                       ;              (4) out PrtD,r17
                       ; when ther is an RTC-IRQ exactly beetween (1) and (2) or (3) and (4)
                       ; then the RTC-LED is wrong. It's even possible that the RTC-LED is
                       ; pulled active to +5V
                       ;  = dangerous, because debugswitch is there 
                       ; DdrD is also: 
                       ;  ddspcs, ddspdi, ddspdo, ddlert, ddleac, ddleer, ddswva, ddswma
                       ; PrtD is also: 
                       ;  pospcs, pospdi, pospdo, polert, poleac, poleer, poswva, poswma
                       ; one must make a CLI before and a SEI after 
l10220:                ;......................................................   
        subi r16,$100-06 ;1 add #$06 seconds--------- 
        sts airtse,r16
        cpi r16,$3c    ;60
        ldi r16,$00
        sts airthu,r16 ;clears AVRinternal hundredth
        brcc l10240    ;b.i.60

l10230: rjmp l10290    ;=0-59

l10240: sts airtse,r16
     
        lds r16,airtmi ;minutes--------
        inc r16
        sts airtmi,r16
        cpi r16,$3c    ;60
        brcs l10230    ;b.i.0-59

        ldi r16,$00 
        sts airtmi,r16
     
        lds r16,airtho ;hours---------
        inc r16
        sts airtho,r16
        cpi r16,$18    ;24
        brcs l10230    ;b.i.0-23

        ldi r16,$00 
        sts airtho,r16
     
        lds r16,airtda ;days--------
        inc r16
        sts airtda,r16
        cpi r16,$1d    ;29
        brcs l10280    ;b.i.1-28

                       ;=day=29-32
        bst r16,0      ;copies bit0 to T-flag 30,32->T=low  29,31->T=high
        cpi r16,$1f    ;31
        lds r16,airtmo
        brcc l10250    ;b.i.31, 32
                       
                       ;=day=29-30
        cpi r16,$02
        brne l10280    ;b.i.not february

                       ;=february
        brtc l10270    ;b.i.30.02

        lds r16,airtyl ;year-low 0-255
        andi r16,$03
        breq l10270    ;b.i.29.02.2000,2004,2008,2012,2016...2100

        rjmp l10280

l10250:                ;=day=31,32
        brtc l10270    ;b.i.32.xx.20yy
                       ;                            1 2 3   5   7 8   10    12
                       ;=day=31  month with 30days:       4   6     9    11
        cpi r16,$08
        brcs l10260
                 
        dec r16        ;                                          7    9    11                                      
                       ;                                            8    10
l10260: andi r16,$01   ;masks even/odd-bit
        brne l10280    ;b.i.odd month (february branched before)
 
l10270: ldi r16,$01
        sts airtda,r16 ;day=1 
     
        lds r16,airtmo ;months--------
        inc r16
        sts airtmo,r16
        cpi r16,$0d    ;13
        brcs l10280    ;b.i.1-12

        ldi r16,$01
        sts airtmo,r16
     
        lds r16,airtyl ;year-low 0-255 (hexdec)  year:0-65535--------
        inc r16
        sts airtyl,r16        
        brne l10280

        lds r16,airtyh ;year-low 0-255 (hexdec)  year:0-65535
        inc r16
        sts airtyh,r16        

l10280: lds r16,airtwd ;weekdays (0-6)--------
        inc r16
        sts airtwd,r16
        cpi r16,$07    ;7
        brcs l10290    ;b.i.0-6

        ldi r16,$00
        sts airtwd,r16

l10290: mov r16,r07    ;restores r16
        clr r07        ;
        sts dasp00,r07 ;important that memory isn't overwritten by mainprogram
        dec r07        ;#$ff
        
        out Sreg,r06   ;restores status register 
        lds r06,dasp00 ;#$00 dataspace #$00      (ldi r06,$00-command doesn't exist)   
                       ;                            (clr r06 would change flags)
        reti
;-----------------------------------------------------------------------------------------------      
l10300:                ;                                       Timer/Counter2 Compare Match A IRQ     
                       ;                                                 when AVR sleeps

        st x+,r25      ;f7----
        st x+,r16      ;seconds 00,06..
        cpi r26,low(debuen)
        brcs l10310

        ldi r26,low(debube)

l10310: out spl,r07    ;1 #$ff reset stackpointer 

        sts tifr2,r28  ;2 #$07 important because RTC-timer2 awake-routine uses compare match B-IRQ 

        ;cbi polert,bilert ;  prt LED-RTC
        ;sbi ddlert,bilert ;  = malkes LED-RTC=off=input                    
        ;bst r16,1      ;  copies bit of seconds that changed every time to T-flag
        ;brts l10320    ;  b.i.06,18...  
    
        ;cbi ddlert,bilert ;  =00,12...             
        ;sbi polert,bilert ;  prt LED-RTC pulupon      usually there is no LED at the debug-pin
         
                       ;it's impossible to switch on and off the RTC-LED, because the
                       ;ports are clamped to 0V while sleeping       
               
l10320: subi r16,$100-06 ;1 add #$06 seconds--------- 
        cpi r16,$3c    ;1 60
        brcs l10380    ;2 b.i.0-59

l10330: ldi r16,$00
     
        inc r17        ;  minutes--------  
        cpi r17,$3c    ;  60
        brcs l10380    ;  b.i.0-59

        ldi r17,$00 
       
        inc r18        ;  hours---------
        cpi r18,$18    ;  24
        brcs l10380    ;  b.i.0-23

        ldi r18,$00 
      
        inc r19        ;  days--------
        cpi r19,$1d    ;  29
        brcs l10370    ;  b.i.1-28

                       ;  =day=29-32
        bst r19,0      ;  copies bit0 to T-flag 30,32->T=low  29,31->T=high
        cpi r19,$1f    ;  31
        brcc l10340    ;  b.i.31, 32
                       
                       ;  =day=29-30
        cpi r20,$02
        brne l10370    ;  b.i.not february

                       ;  =february
        brtc l10360    ;  b.i.30.02

        andi r21,$03   ;  year-low 0-255
        breq l10360    ;  b.i.29.02.2000,2004,2008,2012,2016...2100

        rjmp l10370

l10340:                ;  =day=31,32
        brtc l10360    ;  b.i.32.xx.20yy
                       ;                              1 2 3   5   7 8   10    12
                       ;  =day=31  month with 30days:       4   6     9    11
        mov r24,r20
        cpi r24,$08
        brcs l10350
                 
        dec r24        ;                                            7    9    11                                      
                       ;                                              8    10
l10350: andi r24,$01   ;  masks even/odd-bit
        brne l10370    ;  b.i.odd month (february branched before)
 
l10360: ldi r19,$01    ;  day=1 
     
        inc r20        ;  months--------
        cpi r20,$0d    ;  13
        brcs l10370    ;  b.i.1-12

        ldi r20,$01
      
        inc r21        ;  year-low 0-255 (hexdec)  year:0-65535--------
        brne l10370

        inc r22        ;  year-high 0-255 (hexdec)  year:0-65535
      
l10370: inc r23        ;  weekdays (0-6)--------
        cpi r23,$07    ;  7
        brcs l10380    ;  b.i.0-6

        ldi r23,$00
        
l10380: sei            ;1 enable IRQ
        out smcr,r29   ;1 #$07 Sleep Mode Control Register 
        sleep          ;  power-save-mode  and  sleep-enable-bit set   
        ldi r25,$f4    ;  f4--
        rjmp freeze         

                       ;If Timer/Counter2 is used to wake the device up from Power-save or
                       ;ADC Noise Reduction mode, precautions must be taken if the user wants to
                       ;re-enter one of these modes: The interrupt logic needs one TOSC1 cycle 
                       ;to be reset. If the time between wake-up and reentering sleep mode is 
                       ;less than one TOSC1 cycle, the interrupt will not occur, and the device
                       ;will fail to wake up. If the user is in doubt whether the time before 
                       ;re-entering Power-save or ADC Noise Reduction mode is sufficient, the 
                       ;following algorithm can be used to ensure that one TOSC1 cycle has 
                       ;elapsed:
                       ;a. Write a value to TCCR2x, TCNT2, or OCR2x.
                       ;b. Wait until the corresponding Update Busy Flag in ASSR returns to zero.
                       ;c. Enter Power-save or ADC Noise Reduction mode.
                       ; tosc1 = pin C6 = input-pin of 32kHz crystal
 
                       ;startup-time from power-save: 16 (8MHz-)clockcycles (8MHz-crystal)
                       ;                               6 (8MHz-)clockcycles (internal oscylator)
                       ; until IRQ is executed:        ? (256kHz-)clockcycles
                       ; this routine                  9 (256kHz-)clockcycles
                       ; time must be more than 1 32kHz-cycle
                       ; 9 (256kHz-)clockcycles is more than 1 32kHz-cycle
                       ; = ok (=> AVR nust run at 256kHz, not at 8MHz)
                       ;Power-consumption: 2.5V    5.0V  (doc2593 p325)
                       ;active-mode
                       ; 8MHz crystal      3.5mA   7.5mA
                       ; 8MHz internal     3.5mA   7.5mA
                       ; 1MHz internal     0.6mA   1.4mA
                       ; 128kHz internal   0.1mA   0.2mA
                       ;power-save-mode    0.005mA 0.008mA (watchdog = off)

                       ;a CR2032 has 210mAh
                       ;power-consumption is 0.01mA (4.3µA = 5µA = 0.005mA)
                       ; 210mAh/0.01mA=21000h = 875d = 2.4y
                       
       #endif         
;------------------------------------------------------------------------------------------------
l10390:cli             ;important to disable IRQ when directly jumped from program
                       ;.........................................................
l10400:                ;                                          external IRQ 0/2 pin-toggle-IRQ
                       ;Global Interrupt Enable Bit is cleared                     Atn-active-IRQ
                       ;=>impossible that second IRQ is executed while first one is executed
                       ;=>r06 r07 are always #$00/#$ff
                       ;=C64 makes ATN = active
                       ;=Atn-line edge from inactive to active                     

                       ;IRQ-Atn-Ack is made by:
                       ;IEC-ATA-V2:   pd2 falling edge  int0
                       ;SD2IEC:       pa0 toggle        pcint0
                       ;NLQ-HD:       pb2 falling edge  int2   


        in r06,Sreg    ;backups status register   IRQ is diabled                        fe67/e853
                       ;r06=#$00 r07=#$ff (always)

                       ;IRQ-bit is cleared automatically when this routine is executed       e853 
       #if partname == 3
        #message 644-NLQ-HD/SD2IEC
        tst r07        ;usually r07=#$ff
                       ;if r07=#$00 then this is the flag for 1541U-debug 
        brne l10410    ;b.i.usual AtnIn-IRQ
        
        jmp l23370     ;=1541U = DtaIn-IRQ
l10410:     
       #endif

l10420: sbic piatin,biatin ;2 skips if IECAtn=active
        rjmp l10440    ;  =IECAtn=inactive (too short IEC-Atn-peek => no reaction)
        lsr r07        ;1
        brne l10420    ;2   5*8=40 = 5µs at 8MHz    
                       ;testing the Atn-line is optional at IEC-ATA-V2 and NLQ-HD-hardware
                       ; because here an IRQ is generated only at a falling edge
                       ;testing the Atn-line must be at SD2IEC 
                       ; because here an IRQ is generated at a falling and rising edge 

        lds r07,flated ;flag Atn-edge 
                       ;bit7: 0=make DaOut active when receiving Atn-active-edge
                       ;      1=don't change DtaOut when receiving Atn-active-edge
                       ;bit0: 0=no Atn-edge received 1=Atn-edge received  ($7c)
        set
        bld r07,0      ;sets bit0 as flag that Atn-edge received
        sts flated,r07 ;                                                                     e858
        tst r07
        brmi l10430    ;b.i.don't change DtaOut when receiving Atn-active-edge
 
       #if partname == 1    
        #message 162-IEC-ATA-V2
        cbi poiema,bidaou ;PrtB4 = push to 0V
        sbi ddiema,bidaou ;DdrB4 sets data to active as answer to C64-ATN=active 
                       ;    by making DDRB to output  
       #endif

       #if partname == 3    
        #message 644-NLQ-HD/sd2iec
        sbi ddiema,bidaou ;DdrA = output  
        sbi poiema,bidaou ;PrtA = +5V (outputs are inverted)
                       ;sets data to active as answer to C64-ATN=active
       #endif

       #if partname == 4
         #message 644-NLQ-HD/lite
        in r07,poiema   ;don't use rcall l12870 because this would change r25
        clt
        bld r07,bidaou ;copies t-flag -> bit4 of r07 DtaOut
        bld r07,bidain ;                    5        DtaIn (and Out)
        out poiema,r07 ;
                       ;it's important to use 2 output-pins at the cheap version
                       ; because every pin can sink 10mA only to 0V
        in r07,ddiema
        set
        bld r07,bidaou ;copies t-flag -> bit4 of r07 DtaOut
        bld r07,bidain ;                    5        DtaIn (and Out)
        out ddiema,r07 ;
       #endif

       #if partname == 6
         #message 644-NLQ-HD/SD
        in r07,PrtA    ;don't use rcall l12870 because this would change r25
        clt
        bld r07,3      ;copies t-flag -> bit3 of r07 DtaOut
        bld r07,4      ;                    4        
        bld r07,5      ;                    5                     
        out PrtA,r07  ;
                       ;uses 4 output-pins at SD because the pulldown force is 
                       ; weaker at 4.3V as it is at 5V
        in r07,DdrA
        set
        bld r07,3      ;copies t-flag -> bit3 of r07 DtaOut
        bld r07,4      ;                    4
        bld r07,5      ;                    5
        out DdrA,r07   ;
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
        cbi poiema,bidaou ;PrtB = push to 0V
        sbi ddiema,bidaou ;DdrB = output sets data to active as answer to C64-ATN=active 
                       ;    by making DDRB to output  
       #endif

l10430: push r25
        ldi r25,$fd
        rcall l13090   ;fd-- (AtnIn=active-edge)
        pop r25

l10440: push r25
        ldi r25,$fe
        rcall l13090   ;fe-- AtnIn-pin-change-IRQ-routine
        pop r25

        clr r07        ;(a)
                       ;problem: when there is a second IRQ within the first IRQ exactly between
                       ; (a) and (b) then:
                       ;r07 is at the end of the second IRQ #$ff (while the first IRQ still
                       ; thinks that r07=#$ff, the first IRQ stores '$ff to dasp00, then 
                       ; decrements r07 in the first IRQ to #$fe
                       ; and loads r06 with #$ff instead of #$00
                       ;14.06.2009 copy 205 files from SD2IEC to IEC-ATA-V2 with FCOPY
                       ; this happened accidentially about every 600th file
        sts dasp00,r07 ;(b) important for l10440 (c) that memory isn't overwritten by mainprogram
        dec r07        ;#$ff
        out Sreg,r06   ;restores status register 
        lds r06,dasp00 ;(c) #$00 dataspace #$00      (ldi r06,$00-command doesn't exist)   
                       ;                             (clr r06 would change flags)
        reti           ;                                                                     e85a
;================================================================================================
                       ;the 100Hz-IRQ mustn't be disabled a long time
                       ;=> disable AtnIn-IRQ by writing #$00 into iratin (don't use cli)
                       ; use cli (and sei at end) only at IecIn and IecOut
;================================================================================================
                       ;                                       Timer/Counter1 Compare Match A-IRQ
                       ;                                100 IRQs per second             fe67/f2b0
                       ;The Output Compare Flag is automatically cleared when the
                       ; interrupt is executed
                       ;Alternatively, the flag can be cleared by software by writing a
                       ; logical one to its I/O bit location.
        #if ((partname >= 3) & (partname <= 7))
         #message 644-NLQ-HD/644all
l10450:                ; 5  cycles for IRQ-vector  (page 17 644-doc)
                       ; 2  rjmp
        ;sts tcnt1h,r06 ; 2 #$00 Timer/Counter1 to prevent that timer counts to              f99f
                       ; end a second time while this routine is executed
        in r06,Sreg    ; 1 backups status register
        mov r07,r16    ; 1 backups r16 

;/*      
        push r25
    
       #if partname == 6    
        #message 644-NLQ-HD/SD
        mov r25,r03  ;=last written debugbyte
        cpi r25,$fb
        breq l10460
        
        cpi r25,$fc
        breq l10460 

        ldi r25,$fc
    
       #else
        ldi r25,$fc
        cp r25,r03     ;=last written debugbyte
        breq l10460    ;b.i.this IRQ-routine wrote last byte into debugbuffer
                       ;  = to prevent that debugbuffer is overwritten with
                       ;    many #$ff when in main waitingloop
       #endif

        mov r03,r25

        rcall l13090   ;fc-- 100Hz-timer1-IRQ-routine

l10460: pop r25
;*/

        lds r16,floker ;flag ok / error     errorflag  026c at 1541
        tst r16
        brpl l10470    ;b.i.0-7f (0=no blinking 
                       ;         7f=LEDerror-blinking and 100Hz-IRQ-counter counted to end                  
                       ;         80-ff=LEDerror-blinking and 100Hz-IRQ-counter still must count                   
 
        dec r16        ;decrements counter
        sts floker,r16
 
l10470:                ;                         --------disk-change-test in IRQ--------f9a2-f9b0
/*
       #if partname == 3
        #message 644-NLQ-HD/SD2IEC
        cbi ddspcd,bispcd ;SPI-CardDetect = input
        sbi pospcd,bispcd ;SPI-CardDetect = pullupon
        ldi r16,$03
        sbic pispcd,bispcd ;s.i.SPI-CardDetect=closed = s.i.SMC is inserted

        sts sdfldc,r16 ;SD flag disk change  
                       ;    sets flag that disk is changed   (=$1c at 1541)                  f9af
       #endif
*/

/*      
       #if partname == 7
        #message 644-NLQ-HD/full
        lds r16,fli2ir ;flag i2c-bus IRQ    
        tst r16
        brpl l10480    ;b.i.mainprogram doesn't use I2C-routines

        rjmp l10690    ;=mainprogram uses I2C-routines

l10480: brne l10490    ;b.i.$01-$2c

                       ;=#$00 =I2C must be initialized for IRQ-access
                       ;the I2C-IRQ relies on that at the end of the I2C-mainroutines
                       ; I2C-Clk and I2C-Dta are high 
        ldi r16,$2c 
        sts fli2ir,r16
        
        ldi r16,0b10111001 ; sends bit7 first     bit0 last
        sts i2irac,r16 ;               Dta Clk
                       ;after this:    low high  = middle of start
                       ;2c->2b  %10    low low   = end of start
                       ;2b->2a  %11    low high  = bit7 of $41= slaveaddress of pcf8574 for read
                       ;2a->29  %10    low low   = bit7 of $41 = 0-bit
                       ;29->28  %01   high low   = bit6 of $41 = 1-bit
                       ;..............................................
                       ;28->27  %11   high high  = bit6 of $41 = 1-bit
                       ;27->26  %10   high low   = bit6 of $41 = 1-bit
                       ;26->25  %00    low low   = bit5 of $41 = 0-bit
                       ;25->24  %11    low high  = bit5 of $41 = 0-bit
                       ;.............................................. 
                       ;24->23  %10    low low   = bit5 of $41 = 0-bit
                       ;23->22  %11    low high  = bit4 of $41 = 0-bit
                       ;22->21  %10    low low   = bit4 of $41 = 0-bit
                       ;21->20  %11    low high  = bit3 of $41 = 0-bit
                       ;..............................................
                       ;20->1f  %10    low low   = bit3 of $41 = 0-bit
                       ;1f->1e  %11    low high  = bit2 of $41 = 0-bit
                       ;1e->1d  %10    low low   = bit2 of $41 = 0-bit
                       ;1d->1c  %11    low high  = bit1 of $41 = 0-bit
                       ;..............................................
                       ;1c->1b  %10    low low   = bit1 of $41 = 0-bit
                       ;1b->1a  %01   high low   = bit0 of $41 = 1-bit
                       ;1a->19  %11   high high  = bit0 of $41 = 1-bit
                       ;19->18  %10   high low   = bit0 of $41 = 1-bit
                       ;..............................................
                       ;18->17  %11   high high  = ack: 3µs later the slave must make Dta-low   
                       ;17->16  %10   high low   = ack
                       ;16->15  %11   high high  = bit7 of port = SPI-CardDetect
                       ;15->14  %10   high low   = bit7 of port
                       ;............................................... 
                       ;14->13  %11   high high  = bit6 of port
                       ;13->12  %10   high low   = bit6 of port
                       ;12->11  %11   high high  = bit5 of port
                       ;11->10  %10   high low   = bit5 of port
                       ;...............................................
                       ;10->1f  %11   high high  = bit4 of port
                       ;0f->0e  %10   high low   = bit4 of port
                       ;0e->0d  %11   high high  = bit3 of port
                       ;0d->0c  %10   high low   = bit3 of port
                       ;...............................................
                       ;0c->0b  %11   high high  = bit2 of port
                       ;0b->0a  %10   high low   = bit2 of port
                       ;0a->09  %11   high high  = bit1 of port
                       ;09->08  %10   high low   = bit1 of port
                       ;...............................................     
                       ;08->07  %11   high high  = bit0 of port
                       ;07->06  %10   high low   = bit0 of port
                       ;06->05  %11   high high  = ack of master to slave
                       ;05->04  %10   high low   = ack   high=doesn't request more bytes
                       ;...............................................
                       ;04->03  %00    low low   = stop
                       ;03->02  %11    low high  = stop 
                       ;02->01  %01   high high  = stop
                       ;01->00  %01   high high  = nothing
                       ;               Dta Clk
        rjmp l10540    ;Dta high->low while clock=high  = start condition 

l10490: cpi r16,$17
        brne l10500    ;b.i.not at pos of ack from slave

        in r16,pii2da
        andi r16,bii2da
        breq l10510    ;b.i.slave makes Dta low = slave present

                       ;=slave doesn't make Dta low = slave not present
                       ;               Dta Clk
                       ;18->17        high high  = ack: 3µs later the slave must make Dta-low 
                       ;................................................................
                       ;05->04  %10   high low   = ack   high=doesn't request more bytes
                       ;04->03  %00    low low   = stop
                       ;03->02  %11    low high  = stop 
                       ;02->01  %01   high high  = stop

        ldi r16,$05
        sts fli2ir,r16 ;sets value for stop-condition
        
        ldi r16,0b10001101
        rjmp l10520 

l10500: cpi r16,$15
        brne l10510    ;b.i.not at pos of CardDetect-pin

        in r16,pii2da
        andi r16,bii2da
        breq l10510    ;b.i.slave makes Dta low = SMC is inserted

                       ;=slave doesn't make Dta low = SMC isn't inserted
        ldi r16,$01
        sts fldcsm,r16 ;flag disk change SD-/MMC-Card
                       ;    sets flag that disk is changed   (=$1c at 1541)                  f9af

l10510: lds r16,i2irac ;I2C-IRQ-action    bit7->carry   bit6->plus/minus
l10520: lsl r16        ;%00=Dta low
        lsl r16        ;%01=Dta high
        sts i2irac,r16 ;%10=Clk low
                       ;%11=Clk high
        brcc l10530    ;b.i.%0x = b.i.Dta-change wanted

        brpl l10560    ;b.i.%10 =Clk low 

        rjmp l10570    ;=$11    =Clk high

l10530: brmi l10550    ;b.i.%01 =Dta high

                       ;=%00    =Dta low
l10540: sbi ddi2da,bii2da ;I2C-data = output-0V   I2C-data->low
        rjmp l10580    ; (I2C-data = open-collector)------------

l10550: cbi ddi2da,bii2da ;I2C-data = input       I2C-data->high
        rjmp l10580    ; (I2C-data = open-collector)------------

l10560: sbi ddi2cl,bii2cl ;I2C-clock = output-0V  I2C-clock->low
        rjmp l10580    ; (I2C-clock = open-collector)-----------

l10570: cbi ddi2cl,bii2cl ;I2C-clock = input      I2C-clock->high
                        ; (I2C-clock = open-collector)

l10580: lds r16,fli2ir
        dec r16         ;decrement fli2ir
        sts fli2ir,r16 
        andi r16,$03
        brne l10690     ;b.i.not at end of one action-byte

        lds r16,fli2ir      
        andi r16,$fc   ;masks off bit1&0
        cpi r16,$08
        brcs l10590   

        ldi r16,0b00110101 ;=$00 or $04
        rjmp l10680 

l10590: brne l10600   

        ldi r16,0b11101110 ;=$08
        rjmp l10680 

l10600: cpi r16,$10
        brcs l10610   

        ldi r16,0b11101110 ;=$0c
        rjmp l10680 

l10610: brne l10620   

        ldi r16,0b11101110 ;=$10
        rjmp l10680 

l10620: cpi r16,$18
        brcs l10630   

        ldi r16,0b11101110 ;=$14
        rjmp l10680 

l10630: brne l10640   

        ldi r16,0b11101110 ;=$18
        rjmp l10680 

l10640: cpi r16,$20
        brcs l10650   

        ldi r16,0b10011110 ;=$1c
        rjmp l10680 

l10650: brne l10660   

        ldi r16,0b10111011 ;=$20
        rjmp l10680 

l10660: cpi r16,$28
        brcs l10670   

        ldi r16,0b10111011 ;=$24
        rjmp l10680 

l10670: ldi r16,0b11100011 ;=$28
     
l10680: sts i2irac,r16 

l10690:      
       #endif
*/
        ;ldi r16,$02    ; 1
        ;sts tifr1,r16  ; 2 Timer/Counter1 Interrupt Flag Register   clears IRQ-flag (if timer 
                       ;   reaches end a second time before executing this routine)
        mov r16,r07    ; 1 restores r16
        clr r07        ; 1
        sts dasp00,r07 ; 2 important that memory isn't overwritten by mainprogram
        dec r07        ; 1 #$ff
        
        out Sreg,r06   ; 1 restores status register 
        lds r06,dasp00 ; 2 #$00 dataspace #$00      (ldi r06,$00-command doesn't exist)   
                       ;                            (clr r06 would change flags)
        reti           ; 4
       #endif
;================================================================================================
       #if partname >= 2    
        #message 644-non-IEC-ATA
l10700: ldi r25,$01    ;freeze of IRQ-vector 1
       #endif

freeze:                ;                                                                   freeze
        sts $018f,r25  ;backups debug-byte
                       ;02-34 = IRQ
                       ;f0 = AVR pulls IEC-line active to +5V (NLQHD-lite, NLQHD-SD)
        ldi r25,$bf    ;stackpointerlow = bf  important that freeze-subroutines 
        out Spl,r25    ;doesn't overwrite stack
 
       #if partname != 6    
        #message 644-NLQ-HD/not-SD
        cli            ;disable IRQs to prevent that IRQ changes r06,r07   
                       ;this isn't possible at NLQHD-SD because of RTC
                       ;at NLQHD-SD: The IRQ must be enabled
       #endif
     
       #if partname == 6    
        #message 644-NLQ-HD/SD
        ldi r25,0b00111000
        sts wdtcsr,r25 ;Watchdog Timer Control Register
                       ;7:   wdif Watchdog Interrupt Flag
                       ;6:   WDIE Watchdog Interrupt Enable
                       ;5:   wdp3 Watchdog Timer Prescaler 3
                       ;4    WDCE Watchdog Change Enable
                       ;3:   WDE  Watchdog System Reset Enable
                       ;2-0: WDP2-0: Watchdog Timer Prescaler 2, 1 and 0
                       ;             pdp3-0=%0101 = 0.5s 
                       ;wdce=1 and wdw=1 => allows changig of the watchdog
        
        ldi r25,0b00100000
        sts wdtcsr,r25 ;disables watchdog-IRQs (this sts must be within 4cycles)
       #endif

l10710:                ;                                            -------- LED on --------
       #if partname == 7
        #message 644-NLQ-HD/full
        ldi r20,$fd    ;error-LED on    
        call l23790    ;write r20 to I2C-parallel-port (changes r25)
                       ;don't use rcall l10750 because this writes two bytes into debugbuffer
       #else
        rcall l10750   ;error-LED on
       #endif
                        ;                                            -------- LED on --------
        rcall l10720   ;delay
                       ;                                             -------- LED off ---------   
       #if partname == 7
        #message 644-NLQ-HD/full
        ldi r20,$ff    ;error-LED off    
        call l23790    ;write r20 to I2C-parallel-port
                       ;don't use rcall l10770 because this writes two bytes into debugbuffer
      #else
        #message "partname:" partname
        rcall l10770   ;error-LED off
       #endif
                       ;                                             -------- LED off ---------   
        rcall l10720   ;delay  
        rcall l10720   ;delay  

        rjmp l10710    ;endlessloop
;------------------------------------------------------------------------------------------------
l10720: clr r00        ;                                        0.65s delayloop for errorblinking
l10730: ldi r25,$ff
        rcall l10840   ;255 * 10µs = 2550µs = 2.5ms
        dec r00
        brne l10730    ;256 * 2.5ms = 652ms = 0.65s
        ret
;================================================================================================
                       ;Timer (all three timers):
                       ;1. the clocksource must be selected at flashing
                       ;   cksel 3-0 bit3-0 of fuse low byte
                       ;   %0010 = internal oscylator
                       ;   internal oscylator runs always with 8MHz
                       ;2. the (initial) prescaler must be selected at flashing
                       ;   ckdiv8 = bit of fuse low byte
                       ;   %1 = unprogrammed = no prescaler = runs with 8MHz
                       ;   the prescaler divides the clock for all things by 1 to 256
                       ;   system-clock-frequency: 8MHz - 32kHz
                       ;   the prescaler can be changed with the clock prescale register
                       ;     (not used)
                       ;=> the system-clock (after the prescaler) is always 8MHz
                       ;3. the initial calibrationbyte is loaded automatically from the AVR
                       ;   at the AVR reset
                       ;   NLQ-HD-software loads at reset-routine a value from the EEPROM
                       ;   and stores it to the calibrationbyte (162: $04+$20  644: $66+$20)
                       ;   M162: there is 1 range only from $00-$7f
                       ;   M644: there are 2 ranges (which overlap each other):
                       ;          from $00-$7f (low range)
                       ;          from $80-$ff (high range)
                       ;          => try both ranges at calibration and use the closer value
                       ;
                       ;every timer has its own prescaler:
                       ;timer0: cs00, cs01, cs02: divider: 1, 8,     64,      256, 1024
                       ;timer1: cs10, cs11, cs12: divider: 1, 8,     64,      256, 1024
                       ;timer2: cs20, cs21, cs22: divider: 1, 8, 32, 64, 128, 256, 1024

;------------------------------------------------------------------------------------------------
; timer0 =  8bit for timing 
; timer1 = 16bit for error-LED and at 644 for 100Hz-IRQ cannot be used for timing
; timer2 =  8bit for RTC

;wgm93-90     wgm02-00   wgm13-10   wgm22-20


;Mode     Timer/Counter Mode of Operation   TOP   Update of OCRnx at TOVn Flag Set on
;T0 T1 T2
; 0  0  0   Normal                           0xFFFF Immediate          MAX
; 1  1  1   PWM, Phase Correct, 8-bit        0x00FF TOP                BOTTOM
;    2      PWM, Phase Correct, 9-bit        0x01FF TOP                BOTTOM
;    3      PWM, Phase Correct, 10-bit       0x03FF TOP                BOTTOM
; 2  4  2   CTC                              OCRnA  Immediate          MAX
; 3         Fast PWM                         0xFF   TOP                MAX
;       3   Fast PWM                         0xFF   BOTTOM             MAX
; 4         (Reserved)
;    5      Fast PWM, 8-bit                  0x00FF BOTTOM             TOP
;    6      Fast PWM, 9-bit                  0x01FF BOTTOM             TOP
;    7      Fast PWM, 10-bit                 0x03FF BOTTOM             TOP
;    8      PWM, Phase and Frequency Correct ICRn   BOTTOM             BOTTOM
;    9      PWM, Phase and Frequency Correct OCRnA  BOTTOM             BOTTOM
;   10      PWM, Phase Correct               ICRn   TOP                BOTTOM
; 5 11  5   PWM, Phase Correct               OCRnA  TOP                BOTTOM
;   12      CTC                              ICRn   Immediate          MAX
; 6 13  6   (Reserved) 
; 7     7   Fast PWM                         OCRA   TOP                TOP
;   14      Fast PWM                         ICRn   BOTTOM             TOP
;   15      Fast PWM                         OCRnA  BOTTOM             TOP

                       ;timer/counter0  8bit  for timing
                       ;timer/counter1 16bit  for error-LED                   
                       ;timer/counter2  8bit  for 100 Timer-IRQs per second  (RTC 32kHz-crystal?)
                       ;only at M162: timer/counter3 16bit
    
                       ;so far: for timing a 8bit-timer (timer0) is used
                       ;if for timing a 16bit-timer would be necessary, then perhaps:
                       ; M162: use 16bit-timer3 for LED              use 16-bit-timer1 for timing 
                       ; M644: use 8bit-timer0 f.100Hz-IRQ and LED   use 16-bit-timer1 for timing
                       ; (timer2 must be free for RTC)
                       
                       ;general registers of timers 0-2 
                       ;a '9' is a replacement for 0-2 (use 0 instead of 9 for timer 0...)

                       ;foc9 force output compare
                       ;     foc0, foc1a,foc1b, foc2

                       ;wgm93-wgm90: waveform genaration mode
                       ;      determines 

                       ;com91-90: compare match output mode
                       ;      com1a1-com1a0, com1b1-com1b0 
                       ;      determines what happens with the portpins when the timer
                       ;       has the same value as the programmed value

                       ;csel92-csel90: clock select
                       ;      determines timer-prescaler (not system-clock-prescaler)   
                       ;      %000 = no timer-prescaler
                       ;      %101 = 1/1024 timer-prescaler

                       ;tcnt9 timer counter register tcnt0 
                       ;      actual value of timer/counter  

                       ; from l13990, l25500
l10740:                ;                                                     Error-LED-blink c12c
       #if partname == 1    
        #message 162-IEC-ATA-V2
                       ;wanted timer functions:
                       ;CTC clear timer on compare match
                       ;   when the counter is equal to a programmed value then the counter is 
                       ;    reset to 0000  
                       ;   counter counts up (not down)
                       ;   => wgm13-wgm10 must be %0100 = compares with output compare register A
                       ;           (not input compare register   never output compare register B)

        ldi r25,$0c    ;%000 01 100 Clear Timer1 on Compare match 256/8MHz=32us   Error-LED blink
        sts tccr1b,r25 ;Timer/Counter1ControlRegisterB          32us*$0f0f=123ms             c12c
                       ;sts instead of out                     123*2=246ms=0.25s
                       ;                                                  = 4Hz
                       ;M162&M644
                       ;7 icnc1
                       ;6 ices1
                       ;5
                       ;4 wgm13
                       ;3 wgm12
                       ;2 cs12
                       ;1 cs11
                       ;0 cs10
                       ;Bit4-3=WGM13-WGM12=%01 (=part of wgm13-10)
                       
                       ;bit2-0 = %100 = CS12-CS10 = timer-prescaler clock/256
      
        sts tccr1a,r06 ;#$00 Timer/Counter1ControlRegisterA     necessary????                                 
                       ;  M162    M644     
                       ;7 com1a1  com1a1
                       ;6 com1a0  com1a0
                       ;5 com1b1  com1b1
                       ;4 com1b0  com1b0
                       ;3 foc1a
                       ;2 foc1b
                       ;1 wgm11   wgm11
                       ;0 wgm10   wgm10

                       ;Bit5,4= com1b1-com1b0 =function of oc1b-pin = pin29 = PrtE2-pin at M162
                       ;                                            = pin18 = PrtD4-pin at M644
                       ;        %00         = no action at oc1b-pin on compare match        
                       ;Bit1-0=WGM11-WGM10=%00
                       ; =>WGM13-WGM10=%0100=4=Clear Timer on Compare Mode and use output compare
                       ;                         registers
                       ;   =clears timer to $0000 when it reaches value ocr1a ($0f0f)         
 
        ;sts tcnt1h,r06 ;Timer/Counter1 high
        ;sts tcnt1l,r06 ;Timer/Counter1 low    make Timer1 = $0000
                       ;at write: The highbyte must be written before the lowbyte
                       ;at read: The lowbyte must be read before the highbyte 

                       ;ocr1a determines the TOP-value of the counter 
        ldi r25,$0f    ;about 4Hz  
        sts ocr1ah,r25 ;T/C1 Output Compare Register A high
        sts ocr1al,r25 ;T/C1 Output Compare Register A low
                       ;at write: The highbyte must be written before the lowbyte
                       ;at read: OCR1a has no special 'Accessing 16-bit Registers'

                       ;IEC-ATA: timer1 (16bit) counts single/error-LED only
                       ;         timer1 counts 0.25s
                       ;         timer1 influences single/error-LED directly
                       ;M644:    timer1 (16bit) countse 100Hz-IRQ              ->l23850
                       ;         100Hz-IRQ influences single/error-LED 
       #else
        #message 644-non-IEC-ATA
                       ;non-IEC-ATA: timer1 makes 100Hz-IRQ
                       ;         100Hz-IRQ decrements counter (floker)
                       ;         floker influences single/error-LED 
        ldi r25,$7f    ;flag that single/error-LED goes on at once 
        sei            ;enable IRQs??????????????
       #endif      
        sts floker,r25 ;sets flag ok / error to error-blink     errorflag  026c at 1541 
;................................................................................................
                       ; from l10710, l16670, l19560, l24090, l25310, l25820
l10750:                ;                                                      Single/Error-LED on
                       ;                                                                c100/c118
       #if (partname == 1) | (partname == 4) | (partname == 5) | (partname == 6)   
        #message "partname:" partname
        cbi poleer,bileer ;clears bit LED error in Port LED error = 0V 
        sbi ddleer,bileer ;sets bit errorLED in datadirectionregister errorLED = output 
        ret
       #endif

       #if partname == 3    
        #message "partname:" partname
        sbi poleer,bileer ;sets bit LED error in Port LED error = 3.3V 
        sbi ddleer,bileer ;sets bit errorLED in datadirectionregister errorLED = output 
        ret
       #endif

       #if partname == 7
        #message 644-NLQ-HD/full
                           ;Error-LED on                                         changes r20, r25
         ldi r25,$fd     ;bitmask for clear bit 1 = error-LED-bit
         rjmp l10790
       #endif
;------------------------------------------------------------------------------------------------
                       ; from l13880, l17290 
l10760: sts floker,r06 ;#$00 clears flag ok / error to error-blink 026c at 1541     Error-LED off
        ret            ;                                                                     c123
                       ;IEC-ATA-V2: Single-LED is switched off in main-waiting-loop
                       ;NLQ-HD: Error-LED is switched on in main-waiting-loop(really on?)or off?)
;------------------------------------------------------------------------------------------------
l10770:                ;                                                     single/error-LED off
       #if partname == 1    
        #message "partname:" partname
        cbi ddleer,bileer ;clears bit error-LED in datadirectionregister activeLED=input
        ret
       #endif
      
       #if partname == 3    
        #message "partname:" partname
        cbi poleer,bileer ;clears bit error-LED in Port LED active = 0V
        sbi ddleer,bileer ;sets bit error-LED in datadirectionregister activeLED=output
        ret
       #endif
    
       #if (partname == 4) | (partname == 6)   
        #message "partname:" partname
        cbi poleer,bileer ;clears bit error-LED in Port LED active = 0V
        cbi ddleer,bileer ;clears bit error-LED in datadirectionregister activeLED=input
        ret
       #endif

       #if partname == 7
        #message 644-NLQ-HD/full
        ldi r25,$02   ;mask for set bit 1 = error-LED-bit
        rjmp l10810   ;write r21 to pcf8574  
       #endif
;------------------------------------------------------------------------------------------------
       #if partname >= 2
        #message non-IEC-ATA
                       ; from l16690, l19560
l10780:                ; !!!doesn't exist for IEC-ATA-V2                            active-LED on
       #endif
     
       #if partname == 3    
        #message "partname:" partname
        sbi poleac,bileac ;sets bit active-LED in Port LED active = 3.3V  
        sbi ddleac,bileac ;sets bit activeLED in datadirectionregister activeLED=output
        ret
       #endif

       #if (partname == 4) | (partname == 6)       
        #message "partname:" partname
        cbi poleac,bileac ;clears bit active-LED in Port LED active = 0V  
        sbi ddleac,bileac ;sets bit activeLED in datadirectionregister activeLED=output
        ret
       #endif

       #if partname == 7
        #message 644-NLQ-HD/full
        ldi r25,$fe   ;mask for clear bit 0 = active-LED-bit
l10790: jmp l23760    ;write r21 to pcf8574  
       #endif
;------------------------------------------------------------------------------------------------
       #if partname >= 2
        #message non-IEC-ATA
l10800:                ; !!!doesn't exist for IEC-ATA-V2                           active-LED off
       #endif
    
       #if partname == 3    
        #message "partname:" partname
        cbi poleac,bileac ;clears bit active-LED in Port LED active = 0V
        sbi ddleac,bileac ;sets bit activeLED in datadirectionregister activeLED=output
        ret
       #endif

       #if (partname == 4) | (partname == 6)       
        #message "partname:" partname
        cbi poleac,bileac ;clears bit active-LED in Port LED active = 0V
        cbi ddleac,bileac ;clears bit activeLED in datadirectionregister activeLED=input
        ret
       #endif

       #if partname == 7
        #message 644-NLQ-HD/full
        ldi r25,$01   ;mask for set bit 0 = active-LED-bit
l10810: jmp l23770    ;write r21 to pcf8574  
       #endif
                       ;Every LED has two posibilities:
                       ;-Error-LED: normal: On
                       ;            error: Blink
                       ;-Active-LED: normal:Off
                       ;             active: On
                       
                       ;             IEC-ATA-V2    non-IEC-ATA-V2-hardware
                       ;             single LED      errorLED activeLED
                       ;normal          off            on       off
                       ;file is open    on             on       on  
                       ;error          blink          blink      ? 
;================================================================================================
l10820: push r16       ;2 (+3 for rcall  /   +4 for call)                       10µs waiting loop
        ldi r16,$17    ;1 
l10830: dec r16        ;1  
        brne l10830    ;2/1
        pop r16        ;2
        ret            ;4 3+2+1+23*(1+2)-1+2+4=80cycles=10µs at 8MHz    
;------------------------------------------------------------------------------------------------
l10840: push r25       ;2 (+3 for rcall  /   +4 for call)                   r25*10µs waiting loop
        ldi r25,$18    ;1 
l10850: dec r25        ;1  3*24-1=71
        brne l10850    ;2 in loop    1 not in loop
        nop            ;1
        pop r25        ;2
        dec r25        ;1  2+1+71+1+2+1+2=80
        brne l10840    ;2 in loop    1 not in loop
        ret            ;4
;================================================================================================
l10860:                ;                                   read byte after ATN-edge          e85b

                       ;action at end of
                       ;-listen: e8d2 l11100 test what C64 makes with Atn-line
                       ;   open4,4 (without SA): C64 makes Atn=inactive => e8d7 l11130
                       ;                             analyse command
                       ;                              -listen => $ea2e  l13510
                       ;                              -talk   => DtaOut=I ClkOut=A $e909 l13360
                       ;                              -else   => $ea4e  l25290 mainwaitingloop
                       ;   open2,8,0 (with SA); C64 makes Atn=active => e884 l10880
                       ;                       ***  receive next commandbyte from C64 
                       ;-SA after listen: e902 l11220 wait until C64 makes Atn=inactive
                       ;                     when C64 makes Atn=inactive: analyse command
                       ;                       ***    -listen => $ea2e  l13510
                       ;                              -talk   => DtaOut=I ClkOut=A $e909 l13360
                       ;                              -else   => $ea4e  l25290 mainwaitingloop
                       ;-open: e902 l11220 wait until C64 makes Atn=inactive
                       ;                     when C64 makes Atn=inactive: analyse command
                       ;                       ***    -listen => $ea2e  l13510
                       ;                              -talk   => DtaOut=I ClkOut=A $e909 l13360
                       ;                              -else   => $ea4e  l25290 mainwaitingloop
                       ;-close: close SA -> e8d2 l11100 test what C64 makes with Atn-line
                       ;                          C64 send usually unlisten at once
                       ;                          C64 makes Atn=inactiev => e8d7 l11130
                       ;                             analyse command
                       ;                              -listen => $ea2e  l13510
                       ;                              -talk   => DtaOut=I ClkOut=A $e909 l13360
                       ;                              -else   => $ea4e  l25290 mainwaitingloop
                       ;                           C64 makes Atn=active => e884 l10880
                       ;                       ***   receive next commandbyte from C64 
                       ;-unlisten: e902 l11220 wait until C64 makes Atn=inactive
                       ;                     when C64 makes Atn=inactive: analyse command
                       ;                              -listen => $ea2e  l13510
                       ;                              -talk   => DtaOut=I ClkOut=A $e909 l13360
                       ;                       ***    -else   => $ea4e  l25290 mainwaitingloop

                       ;-talk: e8d2 l11100 test what C64 makes with Atn-line
                       ;   open4,4 (without SA): C64 makes Atn=inactiev => e8d7 l11130
                       ;                             analyse command
                       ;                              -listen => $ea2e  l13510
                       ;                              -talk   => DtaOut=I ClkOut=A $e909 l13360
                       ;                              -else   => $ea4e  l25290 mainwaitingloop
                       ;   open2,8,0 (with SA); C64 makes Atn=active => e884 l10880
                       ;                       ***  receive next commandbyte from C64 
                       ;-SA after talk: e902 l11220 wait until C64 makes Atn=inactive
                       ;                     when C64 makes Atn=inactive: analyse command
                       ;                              -listen => $ea2e  l13510
                       ;                       ***    -talk   => DtaOut=I ClkOut=A $e909 l13360
                       ;                              -else   => $ea4e  l25290 mainwaitingloop
                       ;-untalk: e902 l11220 wait until C64 makes Atn=inactive
                       ;                     when C64 makes Atn=inactive: analyse command
                       ;                              -listen => $ea2e  l13510
                       ;                              -talk   => DtaOut=I ClkOut=A $e909 l13360
                       ;                       ***    -else   => $ea4e  l25290 mainwaitingloop

                       ;*** = normal action

        sei            ;enable IRQ (important when routine at l11240 is left)  
                       ;must be enabled because of RTC-IRQ
                       ;(1541 disables IRQ)
        rcall l12870   ;= DtaOut = Active
                       ; (should be so from IRQ-routine)
                       ; (important when IECAtnIn changes from inactive to active while 
                       ;    IECOUT or IECIN (when IRQs inhibited)) 
                       ;AtnAck-hardware isn't present
                       ;Pullup-resistors aren't necessary because
                       ;-there are resistors at the inputs-pins of the AVR (if no driver chips)
                       ;-the 7407-inputs pullup strongly enough (if driver chips)

        ldi r25,$02    ;02----
        rcall l13090
        
        ldi r16,$80
        sts flated,r16 ;clears flag Atn-edge    $7c at 1541                                  e85e
                       ;makes that DtaOut isn't changed at next Atn-active-edge
        ldi r16,$80
        sts flicbb,r16 ;sets flag for IEC-Atn clears flag for IEC-Listen,-Talk,-Eoi     e85e-e862
    
       #if partname >= 2    
        #message 644-all
        sts reemen,r07 ;#$ff clears received emulation entry
       #endif

        ldi r16,low(stpobe) ;$ff                                                             e864
        out Spl,r16    ;stackpointerlow = ff                                                 e866
        ldi r16,high(stpobe)
        out Sph,r16    ;stackpointer high to 01 => stackpointer to 01ff  
        
        rcall l12910   ;ClkOut = Inactive                                                    e86d
      
       #if ((partname >= 3) & (partname <= 7))
        #message 644-NLQ-HD/all
        rcall l12970   ;SrqOut = Inactive
        rcall l13020   ;xx-- at NH-full (I2C-port) AtnOut = Inactive
       #endif
        
        ldi r25,$03    ;03-- 
        rcall l13130

                       ;icsaco,icsawo,iccode mustn't be cleared here because they are still
                       ;needed after an Unlisten at AVR-internal to see whether command / Open
                       ;
                        
                       ;emumod & devpar mustn't be cleared because at unlisten/untalk it is
                       ;important to which emulated device the command goes
                        
        sts iccbjd,r06 ;#$00 clears flag f. JiffyDos IEC routines

                       ;DtaOut is made active at l10860                                      e870                

l10870: rcall l11260   ;reads IEC-bus (Atn & Clock&data&Srq) (If IECAtn=inactive -> l11130)
        brpl l10870    ;b.i.IECClock=active      waits until C64 makes Clock=inactive (c41:e87b)
                       ;                                                   
        ldi r25,$04    ;04--
        rcall l13130
       
                       ;JiffyDOS waits here 350µs (but JD doesn't wait              (j41:e879)                 
                       ;until C64 makes Clock=active (l10870)
                         
l10880: rcall l11440   ;----reads one byte from C64 (r16) DataOut=active  ClockOut=inactive  e884
                       ; (allways CBM-routines)
                       ;changes perhaps r28/r29 Y-reg (when JiffyDOS-C64 and commandbyte)
                         
        ldi r25,$05    ;05--
        rcall l13130
        
        mov r25,r16    ;xx--     received IEC-byte
        rcall l13130

        lds r25,iccbjd ;flag f.JiffyDos       
        rcall l13130

/*                      ;------------------------------------------------------------------------
                        ;for redirecting printer-listing of SMON to a file on dn=25 
                        ;switch printer off
                        ;open 2,25,2,"<filename>,s,w
                        ;reset of c64 (but not of NLQ-HD)
                        ;SMON laden (from a different device)
                        ;shift-D -> sends listing to printer-address-04 -> NLQ-HD-dn25
                        ;reset C64
                        ;open 15,25,15
                        ;close15 (file is closed)
        cpi r16,$24         
        brne l10890 
     
        ldi r16,$39    ;25

l10890: cpi r16,$60
        brne l10900

        ldi r16,$62

l10900:
*/                     ;-------------------------------------------------------------------------  

        cpi r16,$3f    ;                                                                     e887
        brne l10920    ;b.i.not unlisten 
                       ;=UNLISTEN----------                                 
       
        ldi r25,$3f    ;3f--
        rcall l13130
        
l10910: lds r16,flicbb ;flag IECBusBits
        andi r16,$df   ;clears bit 5  clears flag f.listen                                   e88b
        
        rjmp l10940    ;to end of Untalk (same jobs)---------------------------------------------

l10920: cpi r16,$5f
        brne l10950    ;b.i.not untalk
        
        ldi r25,$5f    ;5f--
        rcall l13130

l10930: lds r16,flicbb ;flag IECBusBits
        andi r16,$bf   ;clears bit6  clears flag f.Talk                                      e889

l10940: sts flicbb,r16 ;clears flag f. listen/talk                                      e88d/e897

        lds r16,iccode ;should be Listen ($20-3e)   Talk ($40-5e)
                       ;      when an Unlisten    when an Untalk comes      
        ori r16,$80    ;      $20-3e -> $a0-be    $40-5e -> $c0-de
        sts iccode,r16 ;stores to IECCommand&Devicenumber 
                       ;important to store old command for AVR-internal  
        rjmp l11210    ;wait until C64 makes Atn=inactive                               e88f/e899 
                       ;-------------------------------------------------------------------------
          
l10950:                ;                         Listen      Talk        SecAd Open  Close  
        mov r17,r16    ;received IEC-commandbyte 20 2f 30 3e 40 4f 50 5e 60 6f e0 ef f0 ff (e8b7)
        andi r17,$60   ;01100000                 20 20 20 20 40 40 40 40 60 60 60 60 60 60 (e8b8)
        
        mov r25,r17    ;displays Listen-/Talk-/SA-bits          00 10 70 80 90 a0 b0 c0 d0
        rcall l13130   ;xx--                                    00 00 60 00 00 20 20 40 40

       #if partname >= 2    
        #message 644-all
        ldi r28,low(tadenu+$03) ;$0b ylow   y=010b Vector to 010b (0108-010a = table)
        ldi r29,high(tadenu+$03) ;$01 yhigh   table device number
       #endif 

        cpi r17,$40    ;                                                                     e89b
        brne l10980    ;b.i.not Talk                                                         e89d

        ldi r25,$a0    ;(a0--)
        ldi r20,$c0    ;11000000 sets flag f.Talk clears flag f.Listen  (Atn-flag stays active)

       #if partname == 1    
        #message 162
        lds r17,tadenu ;iec-ata has HD only       
        andi r17,$df   ;%11011111 masks Listen-bit off
        cp r16,r17
        breq l11020    ;b.i.Talk to this device in table device numbers

l10960: rjmp l11200    ;Talk but not to AVR = all inactive&wait until C64 makes Atn=inactive

       #else
        #message 644-all
l10970: ld r17,-y      ;010a-0108 predecremented
        andi r17,$df   ;%11011111 masks Listen-bit off
        cp r16,r17
        breq l11000    ;b.i.Talk to this device in table device numbers
        cpi r28,low(tadenu) ;$08
        brne l10970

        rjmp l11200    ;Talk but not to AVR = all inactive&wait until C64 makes Atn=inactive
       #endif 

l10980: cpi r17,$20    ;                                                                     e8a9
        brne l11050    ;b.i.not Listen 20-3e %001.....                                       e8ab

        ldi r25,$a1    ;(a1--)
        ldi r20,$a0    ;10100000 sets flag f.listen clears flag f.talk  (Atn-flag stays active)

       #if partname == 1    
        #message 162
        lds r17,tadenu ;iec-ata has HD only       
        andi r17,$bf   ;masks Talk-bit off
        cp r16,r17
        brne l10960    ;b.i.Listen but not to AVR=all inactive&wait until C64 makes Atn=inactive
        
                       ;=Listen to this device in table device numbers

       #else
        #message 644-all
l10990: ld r17,-y      ;010a-0108 predecremented
        andi r17,$bf   ;masks Talk-bit off
        cp r16,r17
        breq l11000    ;b.i.Listen to this device in table device numbers
        cpi r28,low(tadenu) ;$08
        brne l10990
        
        rjmp l11200    ;Listen but not to AVR = all inactive&wait until C64 makes Atn=inactive

                       ;Listen to AVR r28,r29=pointer in tadenu
                       ;.........................................................................
l11000: ldd r17,y+$03  ;device-posibilities
        sts devpar,r17
        subi r28,low(tadenu); result = deviceemulationnumber 0-3
        sts reemen,r28 ;received emulation entry
       #endif 

l11010:                ;l11010 is from IEC2IEEE  probably not more neccesary?????????????  
                       ;......................................................................... 
l11020: rcall l13130   ;a0-- (at talk)  a1-- (at listen)
        sts iccode,r16 ;stores read IEC-command byte to IECCommand&Devicenumber
        sts flicbb,r20 ;set flag f.listen/talk  clear flag f.talk/listen (Atn-flag stays active)
       
       #if (partname == 3) | (partname == 6)   
        #message 644-NLQ-HD/SD2IEC
        lds r16,sdfldc ;SD flag disk change       =SD                        (bit0-3=$1c at 1541)
        andi r16,$01   ;                                                     (bit4-7=$1e at 1541)
        breq l11030    ;b.i.media not changed
 
        call l18950    ;free all buffers (without closing them)
                       ;perhaps important for close??
l11030:
       #endif

       #if partname == 7    
        #message 644-all
        ldi r25,$a2    ;a2--      
        rcall l13130

        lds r16,reemen ;received emulation entry
        rcall l14330   ;(87-- xx-- xx-- ... kk--) 
                       ;swap device-emulation-buffer r16=wanted new device-emulation-entry
                       ;r16=reemen -> acemen 
                       ;important for close  that correct DEB is in AVR-RAM
            
        ldi r25,$a3    ;a3--      
        rcall l13130

        lds r16,acemen ;actual emulation entry
        cpi r16,$02    
        brne l11040    ;b.i.not SD

        lds r16,sdfldc ;SD flag disk change       =SD                        (bit0-3=$1c at 1541)
        andi r16,$01   ;                                                     (bit4-7=$1e at 1541)
        breq l11040    ;b.i.media not changed
     
        ldi r25,$a4    ;a4--      
        rcall l13130
 
        call l18950    ;free all buffers (without closing them) 
                       ;changes r26,r27 X
                       ;perhaps important for close??
l11040:          
       #endif 

        ldi r16,$60    ;sets default for SA (not open, not close) and for SA=0 
        sts icsaco,r16 ;important if there is no SA sent 
        sts icsawo,r06 ;#$00 e.g. open4,4 instead of open4,4,0  
        rjmp l11100    ;--------

l11050: cpi r16,$61    ;compares received commandbyte with SA=$61 = SA for SAVE  (Je89f)
        brne l11060
       
        lds r18,flicbb ;flag IEC Bus B
        cpi r18,$c0    ;compares with flag f.Talk flag f.not-Listen
        brne l11060    ;b.i.not TALK

        ldi r16,$60    ;loads SA for LOAD    =TALK+SAforSAVE=illegal=flag for JiffyDOS-LOAD
        sts iccbjd,r16 ;IEC CBM/JD  = JD-LOAD
                       ;AVR received TALK + SAforSAVE from C64
                       ;AVR sends TALK + SAforLOAD to IEEE-floppy => IEEE-floppy sends bytes 

l11060: cpi  r17,$60   ;                                                                     e8ba           
        breq l11070    ;b.i.open,close,secundary-address (or $70-7f = not defined)           e8bc

        rjmp l11200    ;not open,close,secundary-address   (= command isn't to AVR)          e8bc
        
                       ;                                          = open,close,secundary-address

                       ;listen+open: talk-error-buffer is already closed when listen received
                       ;               at l11010
                       ;             unknown whether the here-opened-file is later for writing
                       ;               into file (listen) or for reading from file (talk)
                       ;               => don't open a new talk buffer after liste+open
                       ;                  open a new talk-buffer when 
                       ;                  (after listen+open+filename+unlisten) talk+SA is
                       ;                  received (then you know that it's talk)
                       ;                  (if it would be listen then it would be:
                       ;                    listen+open+filename+unlisten+listen+SA)
                       ;listen+close: talk-error-buffer is already closed when listen received
                       ;               at l11010 
                       ;listen+SA:  talk-error-buffer is already closed when listen received
                       ;               at l11010 
                       ;talk+SA:
                       ; -if no floppy => nothing (look if talk-buffer already exists
                       ;                           else open it) 
                       ; -if floppy => (look if talk-buffer already exists, else open it)
                       ;    -if data-channel (0-14) => close error-talk-buffer         
                       ;    -if error-chanel (15) => nothing additional 

                       ;there are two kinds of talk-buffers: - a talk-data-buffer (=talk-buffer)
                       ;                                     - a talk-error-buffer 
                         

l11070: sts icsaco,r16 ;IEC-secundary-address-complete                                       e8bf

        ldi r25,$06    ;06--    
        rcall l13130
  
        mov r17,r16    ;
        andi r16,$0f   ;                                                                     e8c1                                                                     e8c1
        sts icsawo,r16 ;SA-only without bits whether open/close/SA = $83 at 1541             e8c3

        mov r16,r17    ;SA (complete)                                                        e8c5
        andi r16,$f0   ;                                                                     e8c7
        cpi  r16,$e0   ;                                                                     e8c9
        breq l11080    ;b.i.close                                                            e8cb     
        
        rjmp l11210    ;=not close                                                           e8cb

l11080: ldi r25,$08    ;08--
        rcall l13130

        lds r16,icsawo ;wanted new CBM-buffer ($00-$0f 0-15)
        cpi r16,$0f    ;make this compare perhaps at the first command of l14190 ???
        breq l11090    ;b.i.command-/errorchannel
                       ;the command-buffer is never written to HD
                       ; =>not necessary to read it
                     
        rcall l14190   ;save old-actual cbm-buffer to swapfile and 
                       ;load new-actual CBM-buffer from swapfile 

l11090: call l21580    ;close                                                                e8ce
                       ;it's important that the correct DEB device-emulation-entry is
                       ;already loaded
 
                       ;at close in 1541 continues here
                       ;after close there should be sent an Unlisten  (Listen, Close, Unlisten)
                       ;(after Open and SecAddr a.ListenTalk there are databytes sent)
                       ;between close and unlisten C64 makes Atn=inactive for short period of
                       ;  time                        
                       ;=>when 1541/AVR has closed then it's perhaps faster to receive the 
                       ;Unlisten here at once without waiting for C64 makes IECAtn=inactive
                       ;At 1541: There should be a hardwareIRQ and the flag for a
                       ;         Atn-active-change should be set
                       ;At AVR: AVR forgets to see that C64 had made IECAtn=inactive for a 
                       ;         short time-period
                       ;If there should be a problem here perhaps a rjmp l11130 could help???   
         rjmp l11110   ;at close: directly after the clsoe ($e0-ef) the unlisten ($3f) is sent
                       ;there are no databytes sent from C64 to the floppy
                       ;routine goes to receive unlisten even when C64 made Atn=inactive bewteen
                       ; close and unlisten                      
                       
                       ;from l11040 (talk, listen)
l11100: lds r18,flated ;flag Atn-edge                                                        e8d2
        andi r18,$01   ;mask bit Atn-edge received
        brne l11120    ;b.i.between l10860 and here (l11100) the C64 made Atn=inactive and
                       ; then Atn=active again
                       ;NLQ-HD is slower than a 1541
                       ; -because it loads the device emulation buffer (DEB)
                       ; -because it loads the actual SA-buffer
                       ;=> it's possible that the C64 makes Atn=inactive for such a short time
                       ;    that the AVR cannot read it. Then the C64 makes it active again
                       ;this command prevents that the AVR hangs in an endlessloop
                       ;example:
                       ;C64 sends listen then at once unlisten:
                       ; AVR loads DEB from HD while C64 makes Atn=inactive at end of listen
                       ;  and C64 makes then at once Atn=active when it sends unlisten
                       ;C64 sends listen, then SA, then at once unlisten
                       ; AVR loads SA-buffer from HD while C64 makes Atn=inactive at end of
                       ;  listen and C64 makes then at once Atn=active when it sends unlisten

l11110: sbis piatin,biatin ;skips if AtnIn=inactive                                          e8d2

l11120: rjmp l10880    ;=Atn=active  -> read next command byte                               e8d5
                       ;.........................................................................
                       ;from l10940, l11210, l11280
l11130:                ;                        AtnIn=inactive ----------------------------- e8d7
                       ;there is no AtnAck-Hardware
                       ;                                                    AVR-DataOut is active
                       
        ldi r25,$09    ;09----
        rcall l13090
   
        sei            ;enables IRQ (important when routine at l11240 is left)  
                       ;=> AVR-AtnAck-emulation on
                       ;if C64 makes C64-Atn=active then the AVR makes an IRQ and sets 
                       ;AVR-DataOut=active (but AVR-DataOut is already active)
                       ;=> C64 waits 
       
        lds r16,flated ;flag Atn-edge
        andi r16,$7f   ;makes flag that make DtaOut=actiev when receiving Atn-active-edge
        sts flated,r16

        lds r16,flicbb ;=Atn-mode is finished 
        andi r16,$7f
        sts flicbb,r16 ;clears flag f.Atn-mode
        
        andi r16,$60   ;masks Talk & Listen bit
        breq l11140    ;b.i. Talk- and Listen-bit both not set
                       ;     =command wasn't to this devIEC / to NLQ-HD        
                       ;important not swap buffer if command not to this device
                       ;because icsawo contains senseless value of former acces to NLQ-HD
     
                       ;what happens with icsawo when receiving an Unlisten/Untalk???????????????          
        lds r16,icsawo ;wanted new SA (=CBM-buffer) ($00-$0f 0-15)
        cpi r16,$0f
        breq l11140    ;b.i.command-/errorchannel
                       ;command- and error-buffer are always in RAM, never in swapfile

        rcall l14190   ;save old-actual cbm-buffer to swapfile and 
                       ;load new-actual CBM-buffer from swapfile 
      
l11140: ldi r25,$01

l11150: sbic piatin,biatin ;s.i.C64 maks Atn=active

        rjmp l11160    ;C64 makes Atn=inactive   

        rcall l10820   ;10µs waiting loop
        
        inc r25
        brne l11150    ;waits until C64 makes Atn=inactive
                       ;is this necessary or is this made at l11220-l11230
                       ;At listen:
                       ;waits until C64 makes Atn=inactive
                       ;else the AVR is too fast -> receives 1IECIN-byte -> 
                       ; sees at l11450 / l11640 that Atn = active and leaves routine
                
                       ;At talk:
                       ;waits until C64 makes Atn=inactive   
                       ;else the AVR is too fast -> it makes DtaOut = inactive before
                       ; the C64 sees that AVR makes Dta=active at end of having sent
                       ; secundary-address ($eda9) => C64-time-out-errer ST=3  
              
l11160: rcall l13130   ;xx-- delay-counter (in 10µs steps)
                       ;   about 30µs (when debugbytes are on)
        
        lds r16,flicbb ;flag f.listen e8e3
        andi r16,$20
        breq l11170    ;b.i.not listen
        
        ldi r25,$0a    ;0a--                                                              =Listen
        rcall l13130

        rcall l13510   ;(a8--) jsr $ea2e reads bytes from C64 and sends to ???
                       ;IECIN disables IRQ= switches AtnAck-emulation off 
                       ;at end (e.g.after receiving of command): DtaOut = Active???????
        rjmp l11190    ;to main-waiting-loop -----------------------------------------------

l11170: lds r16,flicbb
        andi r16,$40
        breq l11180    ;b.i.not talk
                       ;                                            DtaOut=active ClkOut=inactive    
        ldi r25,$a8    ;a8--
        rcall l13130
     

        sbic piatin,biatin ; skips if AtnIn=active
            
                       ;problem: 1541 has an AtnAck-hardware
                       ; when C64 makes Atn=active then the 1541-AtnAck-hardware makes 
                       ; 1541-DtaOut=active even when the software makes DtaOut=inactive here
                       ;AVR has no AtnAck-hardware: 
                       ;example: C64 sends talk, SA, untalk (without any databyte between)
                       ;the AVR must make DtaOut=active as reaction to C64-Atn=active at unlisten
                       ; this must be made in software (Atn.edge-IRQ and no Dta=inactive here)
                       ; AVR wands to send databyte from AVR to C64 (l11700) and sees at once
                       ; that C64 makes Atn=active and jumps to l10860

        rcall l12840   ;DataOut = Inactive   perhaps waitingloop here???                     e8f1
                       ;only when C64 makes Atn=inactive

        rcall l12880   ;ClockOut = Active                                                    e8f4
                       ;                                            DtaOut=inactive ClkOut=active

                       ;AVR-DataOut is now inactive!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                       ;=>if C64 makes now ATN=active then the AVR-IRQ-routine (l10400) must
                       ;make AVR-DataOut fast enough to active to show to the C64 that the AVR
                       ;isn't ready
                       ;if there will be a routine where the IRQ cannot be disabled 
                       ;(e.g. later secundary IEC-bus-routines with any fastloader)
                       ;then the AVR must perhaps make AVR-DataOut to active while the IRQ is
                       ;disabled and make it to inactive when the IRQ can be enabled ??
                                
                       ;perhaps waiting here at least 40µs because 1541 is so slow    
                       ; (only if 360µs JD loop would be deleted)  

                       ;AVR makes here DtaOut=I and ClkOut=A
                       ;the C64 waits at edd6 until the AVR makes Clk=A
                       ;here must be a very long delayloop to allow that the C64 has enought
                       ; time to read the Clk=A 
                       ; (before the AVR makes it inactive at sending IECOUT)
                       ;when the delayloop is too short then the C64 doesn't make Atn=I ($edd0)
                       ; fast enough -> the AVR wants to send IECOUT but sees that Atn is active 
                       ; -> leaves the IECOUT-routine -> wants to receive byte after atn-edge
                       ; -> makse her Clk=inactiev => the C64 waits in an endlessloop at $edd6
                       ; until June2009: AVR waits after having received SA until C64 makes 
                       ;  Atn=inactive => used $28=40 for delayloop
                       ;  (AtnIn was deteted by low-level-IRQ)
                       ; since June2009: AtnIn is detected by edge-IRQ => no waiting-loop
                       ; value for delayloop increased to
                       ;this is wrong

                       ;waits 
                       ;else the AVR is too fast -> send 1IECOut-byte -> 
                       ; sees at l11700 that Atn = active and leaves routine
                       ;is this still necessary????
                       ; or is this already made at l11150???
        ldi r25,$28    ;=40
        rcall l10840   ;400µs waiting loop ;perhaps 360µs delay at first byte? (fb0f)  
                       ;JiffyDos makes 360µs delay-loop at fb0f if JD-DataOut or JD-Load
                       ; (not at CBM-DataOut)  (don't know why)
                       ;AVR makes 400µs delay loop allways (at JD-DataOut, JD-Load, CBM-DataOut)
                       ;if the delaylopp would be deleted at CBM-DataOut then there should be
                       ; at least a 50µs delayloop that allows the C64 to read the lines even if
                       ; there should be a C64-badline)
                          
        rcall l13360   ;(ad--) e8f7 job when Talk received       jsr e909  IRQ is enabled

l11180:                ;rcall l12910 ClkOut = Inactive       ;e8fa ea4e      
                       ;rcall l12840 DtaOut = Inactive
                       ;C64 can send e.g. a new Talk-command while AVR has send old Untalk to 
                       ;Ieee. AVR must let IECDataOut to active to prevent that C64 thinks that
                       ;AVR would be in receive-routine and C64 would begin to send the Talk
                       ; while AVR isn't yet in receive-routine but in main-waiting-loop
l11190: jmp l25290     ;to main-waiting-loop -----------------------------------------------
        
                       ;from l10970 (talk to different device), l10990 (listen to different
                       ;      device), l11060 (command to different device)
l11200: rcall l12910   ;ClockOut = Inactive                   drive isn't listened/talked to e8fd
        rcall l12840   ;DataOut=inactive
                       ;AtnAck needn't be activated because ther is no AtnAck-hardware
                        
                       ;from l10940 (unlisten/untalk), l11070 (SA, open)
l11210: ldi r25,$10    ;$10----                                   wait until IECAtn=inactive e902 
        rcall l13090

        lds r18,flated ;flag Atn-edge
        andi r18,$01   ;mask bit Atn-edge received
        brne l11230    ;b.i.between l10860 and here (l11210) the C64 made Atn=inactive and
                       ; then Atn=active again
                       ;NLQ-HD is slower than a 1541
                       ; -because it loads the device emulation buffer (DEB)
                       ; -because it loads the actual SA-buffer
                       ;=> it's possible that the C64 makes Atn=inactive for such a short time
                       ;    that the AVR cannot read it. Then the C64 makes it active again
                       ;this command prevents that the AVR hangs in an endlessloop
                       ;example:
                       ;C64 sends listen then at once unlisten:
                       ; AVR loads DEB from HD while C64 makes Atn=inactive at end of listen
                       ;  and C64 makes then at once Atn=active when it sends unlisten
                       ;C64 sends listen, then SA, then at once unlisten
                       ; AVR loads SA-buffer from HD while C64 makes Atn=inactive at end of
                       ;  listen and C64 makes then at once Atn=active when it sends unlisten
                       
l11220: sbis piatin,biatin ;2 skips if AtnIn=inactive                                        e902
        
        rjmp l11220    ;  =Atn=active                                                        e907
        
l11230: ldi r25,$11    ;$11--
        rcall l13130

        rjmp l11130    ;=Atn is inactive (or was inactive and is now active again            e905  
                       ;                  because NLQ-HD was too slow)            
;------------------------------------------------------------------------------------------------
l11240:  ;mov r05,r16  ;copies actual value -> old value       test whether Atn-mode-change  ea59
                       ;    (error at first time)
;        ldi r16,$05
;        mov r10,r16   ;  counter register
;        
l11250:  ;in r16,piatin ;1 pin AtnIn PinD/PinB = IECAtnIn
;        andi r16,1<<biatin ;1 #$04 masks Bit2 = IECAtnIn
;        cpse r05,r16  ;2 compares old and actual value of IECAtnIn
;        rjmp l11240  ;  b.i.IECAtnIn is not constant
;        ;----------
;        dec r10       ;1  7*5=35  =  4µs at 8Mhz 
;        brne l11250  ;2  (1541 makes 1541:lda$1800 cmp$1800 = 4µs bus constant)

                       ;=IECAtn-line is constant for 4µs   <-------mode1------------------------

l11260: clr r05        ;clears r05                             test whether Atn-mode-change  ea59

        ldi r16,$03    ;                 routine changed => perhaps check timing???????????????? 
        mov r10,r16    ;counter for 3 times 
           
                       ;      iav2 sdie nlhd
l11270: in r16,piatin  ;1     PinD/PinA/PinB = IECAtnIn 
 
        andi r16,1<<biatin ;1 #$04           = IECAtnIn  masks IecAtn-pin
                       ;      bit2 
        add r05,r16    ;1
      
        ldi r16,$03    ;1
l11280: dec r16        ;1      3*3-1 +1 = 9 +1+1+1 + 1 + 1+2 = 16 = 2µs
        brne l11280    ;2/1   

        mov r16,r05    ;1

        dec r10        ;1     reads IECBus 3 times  4µs and takes average <----mode2-----------
        brne l11270    ;2                       3210=bits of PrtD 
                       ;      0000  0000  0000  0100
                       ;      0000  0000  0100  0100
                       ;      0000  0100  0100  0100
                       ;      ----  ----  ----  ----
                       ;      0000  0100  1000  1100

/*
ldi r25,$3e    ;3e----
rcall l13090

lds r25,flicbb
rcall l13090

mov r25,r16
rcall l13090

lds r25,airtmb ;----
rcall l13130
    
lds r25,airtmr ;----
rcall l13130

lds r25,airtsl ;----
rcall l13130

        in r25,DdrA    ;xx-- DdrA
        call l13090 
        in r25,PrtA    ;xx-- PrtA 
        call l13090 
        in r25,PinA    ;xx-- PinA
        call l13090 
       
        in r25,DdrB    ;xx-- DdrB
        call l13090 
        in r25,PrtB    ;xx-- PrtB 
        call l13090 
        in r25,PinB    ;xx-- PinB
        call l13090 



*/        
        lds r10,flicbb ;flag f. Atn-mode                           
        rol r10        ; AtnMode bit -> carry
        
        andi r16,1<<(biatin+1) ;#$08   masks IECAtnIn
       
        brcc l11330    ;b.i.not in Atn-mode
                       ;               =Atn-mode
   
       #if partname == 6    
        #message 644-NLQ-HD/SD
        brne l11290    ;b.i.in Atn-mode but AtnIn=inactive  = mode changes
               
        rjmp l11370    ;=in Atn-mode and AtnIn=active  = mode stays Atn-mode

       #else
        breq l11370    ;b.i.in Atn-mode and AtnIn=active  = mode stays Atn-mode
       #endif
        
l11290: push r25       ;=Atn-Mode but AtnIn=inactive
        
        ldi r25,$40    ;40----
        rcall l13090

        pop r25
        rcall l13130   ;xx--  (debugbyte from routine above to debugbuffer)

        mov r25,r20    ;------   counter for IECIN bits perbyte
        rcall l13090

        mov r25,r17    ;xx-- so far read IECIN byte
        rcall l13130

       #if partname == 6    
        #message 644-NLQ-HD/SD
        lds r25,airtmb ;AVR-internal-RTC-mode-bits
                       ;7=sleep-IRQ finished routine
                       ;6=reset-IRQ finished routine
                       ;5=watchdog time-out finished routine
                       ;4=IEC-error finished routine 
                       ;3=IEC-Atn-change finished routine (in databyte-mode but AtnIn=active)
                       ;2=IEC-Atn-change finished routn (in commandbyte-mode but AtnIn=inactive)
                       ;1=normal end of routine
                       ;0= 0=RTC-values changed by timer2-IRQ   (direct-IEC- & IRQ-RTC-mode)
                       ;   1=RTC-values changed by mainprogram  IRQ-IEC- & direct-RTC-mode
        bst r25,0      ;
        brtc l11310    ;b.i.mainprogram is direct-IEC- & IRQ-RTC-mode

                       ;=IRQ-IEC- & direct-RTC-mode
        lds r00,airtmr ;AVR-internal-RTC-mainroutine               
        tst r00
        breq l11300    ;b.i.mainprogram is not in same mode

        lds r00,airtsl ;AVR-internal-RTC-stackpointer-low
                       ;make stackpointer that this IRQ returns to the mainprogram
                       ; and not to the IEC-routines below
        tst r00
        brpl l11300    ;b.i.mainprogram is not in same mode
        
        ori r25,$04    ;sets bit that Atn-change finished routine  (Atn=active->inactive)
        sts airtmb,r25 ;AVR-internal-RTC-mode-bits

        out Spl,r00    ;stackpointer low    
        out Sreg,r08   ;restores status register 
        reti           ;r25=airtmb  return to RTC-mainprogram (not IEC-routines)

l11300: ldi r25,$a8    ;a8----
        jmp freeze

l11310:                ;=direct-IEC- & IRQ-RTC-mode
        lds r00,airtmr ;AVR-internal-RTC-mainroutine               
        tst r00
        brne l11300    ;b.i.mainprogram is not in same mode         

        lds r00,airtsl ;AVR-internal-RTC-stackpointer-low
        tst r00
        brne l11300    ;b.i.mainprogram is not in same mode
       #endif

l11320: ldi r16,low(stpobe) ;mode changes from Atn- to data-mode
        out Spl,r16    ;stackpointerlow = 7f
        rjmp l11130    ;to routine at end of Atn !!stack is at C64 wrong!!


        ;---
l11330:                ;               =not in Atn-mode=in data-mode

        brne l11370    ;b.i.in data-mode and AtnIn=inactive  = mode stays in data-mode

                       ;=Databyte-Mode but AtnIn=active <----    
                       ; (DataOut=active is important but made at follow routine)

        ;ldi r25,$41   ;41---- 
        ;rcall l13090  ;temporary !!!must be fast enough to make data fast enough to active

       #if partname == 6    
        #message 644-NLQ-HD/SD
l11340: push r25       ;=Databyte-Mode but AtnIn=active
        rcall l12870   ;DtaOut = active   emulation of AtnAck-hardware
        
        ldi r25,$41    ;41----
        rcall l13090

        pop r25
        rcall l13130   ;xx--  (debugbyte from routine above to debugbuffer)

        mov r25,r17    ;------   counter for IECOUT bits perbyte
        rcall l13090

        mov r25,r18    ;xx-- so far sent IECOUT byte
        rcall l13130

        lds r25,airtmb ;AVR-internal-RTC-mode-bits
                       ;7=sleep-IRQ finished routine
                       ;6=reset-IRQ finished routine
                       ;5=watchdog time-out finished routine
                       ;4=IEC-error finished routine 
                       ;3=IEC-Atn-change finished routine (in databyte-mode but AtnIn=active)
                       ;2=IEC-Atn-change finished routn (in commandbyte-mode but AtnIn=inactive)
                       ;1=normal end of routine
                       ;0= 0=RTC-values changed by timer2-IRQ   (direct-IEC- & IRQ-RTC-mode)
                       ;   1=RTC-values changed by mainprogram  IRQ-IEC- & direct-RTC-mode
        bst r25,0      ;
        brtc l11360   ;b.i.mainprogram is direct-IEC- & IRQ-RTC-mode

                       ;=IRQ-IEC- & direct-RTC-mode
        lds r00,airtmr ;AVR-internal-RTC-mainroutine               
        tst r00
        breq l11350    ;b.i.mainprogram is not in same mode

        lds r00,airtsl ;AVR-internal-RTC-stackpointer-low
                       ;make stackpointer that this IRQ returns to the mainprogram
                       ; and not to the IEC-routines below
        tst r00
        brpl l11350    ;b.i.mainprogram is not in same mode
        
        ori r25,$08    ;sets bit that Atn-change finished routine  (Atn=inactive->active)
        sts airtmb,r25 ;AVR-internal-RTC-mode-bits

        out Spl,r00    ;stackpointer low    
        out Sreg,r08   ;restores status register 
        reti           ;r25=airtmb  return to RTC-mainprogram (not IEC-routines)

l11350: ldi r25,$a9    ;a9----
        jmp freeze

l11360:                ;=direct-IEC- & IRQ-RTC-mode
        lds r00,airtmr ;AVR-internal-RTC-mainroutine               
        tst r00
        brne l11350    ;b.i.mainprogram is not in same mode         

        lds r00,airtsl ;AVR-internal-RTC-stackpointer-low
        tst r00
        brne l11350    ;b.i.mainprogram is not in same mode
       #endif

        rjmp l10860    ;reads byte after Atn-edge  = change from data- to Atn-mode 
;------------------------------------------------------------------------------------------------
                       ;from l11280, l11330, l11460, l11530, l11830
l11370:                ;                                                 reads IEC-bus-port  e9c0
       #if partname == 1    
        #message 162-IEC-ATA-V2



        ;mov r05,r16   ;copies actual value -> old value 
                       ;    (error at first time)
        ;ldi r16,$05   ;                                                 
        ;mov r10,r16   ;counter 
        
l11380: ;in r16,piiema ;1 PrtB = IECPort
        
        ;andi r16,0b00101000 ;1 masks Bit 5,3 = DataIn ClockIn ( AtnIn & SrqIn not possible) 

        ;cpse r05,r16  ;2 compares old and actual value
        ;rjmp l11370   ;  b.i.value is not constant
        ;----------
        ;dec r10       ;1  7*5=35  =  4µs at 8Mhz 
        ;brne l11380   ;2  (1541 makes 1541:lda$1800 cmp$1800 = 4µs bus constant)



        clr r05        ;clears r05 

        ldi r16,$03    ;                 routine changed => perhaps check timing????????????????
        mov r10,r16    ;counter for 3 times 

l11390: in r16,piiema  ;1 PrtB = IECPort 
        andi r16,$28   ;1 %00101000 masks Bit 5,3 = DataIn ClockIn
        add r05,r16    ;1
        
        ldi r16,$03    ;1
l11400: dec r16        ;1      3*3-1 +1 = 9 
        brne l11400    ;2/1        1+1+1 + 9+ 1 + 1+2 = 16 = 2µs
      
        mov r16,r05    ;1     (command is at this place because of timing)
      
        dec r10        ;1     reads IECBus 3 times  4µs and takes average
        brne l11390    ;2                    210=bits of PrtB (=example for SrqIn)
                       ;      000  000  000  010
                       ;      000  000  010  010
                       ;      000  010  010  010
                       ;      ---  ---  ---  ---
                       ;      000  010  100  110



                       ;=IECPortIn read 3 times in 4µs
                       ;DataIn ClockIn
                       ;  6      4    
        rol r16        ;  7      5    
        rol r16        ;  c      6    
        rol r10
        rol r16        ;         7    
        ror r10        ;  c      7    
        andi r16,$80   ;%10100000 masks bit 7  (carry stays)
                   
                       ;CarryLow = DataInActive  CarryHigh = DataInInactive
                       ;Plus = ClockInActive     Minus =ClockInInactive
                       ; (SrqIn= not possible)
        ret           
   
       #endif

       #if partname == 3
         #message 644-NLQ-HD/sd2iec

                       ;   PA0:  AtnIn
                       ;   PA1:  DtaIn
                       ;   PA2:  ClkIn
                       ;   PA3:  SrqIn
                       ;   PA4:  AtnOut
                       ;   PA5:  DtaOut
                       ;   PA6:  ClkOut
                       ;   PA7:  SrqOut
        clr r05        ;clears r05 

        ldi r16,$03    ;                 routine changed => perhaps check timing????????????????
        mov r10,r16    ;counter for 3 times 
                       ;                                      DtaIn ClkIn AtnIn SrqIn
l11410: in r16,piiema  ;1 PrtA = IECPort                       1     2     0     3
        bst r16,2      ;1 copies ClkIn-bit to T-flag
        bld r16,4      ;1 copies T-flag (ClkIn-bit) to bit4     1     4     0     3 
        bst r16,1      ;1 copies DtaIn-bit to T-flag
        bld r16,6      ;1 copies T-flag (Dta-bit) to bit6       6     4     0     3
        bst r16,0      ;1 copies AtnIn-bit to T-flag
        bld r16,2      ;1 copies T-flag (Atn-bit) to bit2       6     4     2     3
        bst r16,3      ;1 copies SrqIn-bit to T-flag
        bld r16,0      ;1 copies T-flag (Srq-bit) to bit0       6     4     2     0
        andi r16,0b01010101 ;1 masks Bit 6,4,2,0 = DtakIn ClkIn AtnIn SrqIn
        add r05,r16    ;1
        nop            ;1        
        nop            ;1         1+1+1+1+1+1+1 + 1+1+1+1 + 1+2 = 16 = 2µs

        dec r10        ;1     reads IECBus 3 times  4µs and takes average
        brne l11410    ;2      10=bits of PrtB (=example for SrqIn) 
                       ;       00  00  00  01
                       ;       00  00  01  01
                       ;       00  01  01  01
                       ;       --  --  --  --
                       ;       00  01  10  11
        mov r16,r05    ;                                        7     5     3     1     
                       ;=IECPortIn read 3 times in 4µs
        bst r16,5      ;1 copies ClkIn-bit to T-flag
        bld r16,6      ;1 copies T-flag (ClkIn-bit) to bit6     7     6     3     1 
        lsl r16        ;                                        c     7     4     2
                       ;CarryLow = DataInActive  CarryHigh = DataInInactive
                       ;Plus = ClockActive     Minus =ClockInInactive  (=bit7)
                       ; (AtnIn=bit 4 of r16, SrqIn=bit 2 of r16)
        ret           

       #endif ;644-NLQ-HD/sd2iec

       #if ((partname >= 4) & (partname <= 7))
         #message 644-NLQ-HD/all

                       ;if PB0: (AtnOut) (or SPI-Clk&dior) (or SrqOut)
                       ;   PB1:  SrqIn
                       ;   PB2:  AtnIn                                 (Int2-IRQ)
                       ;   PB3: (ClkOut)                   (or SrqOut) 
                       ;   PB4: (DtaOut)                   (or SrqOut)
                       ;   PB5:  DtaIn                                 (MOSI)
                       ;   PB6: (SrqOut)                               (MISO)
                       ;   PB7:  ClkIn                                 (SCK)
                       ;then:
        clr r05        ;clears r05 

        ldi r16,$03    ;                 routine changed => perhaps check timing????????????????
        mov r10,r16    ;counter for 3 times 
                       ;NLQHD-SD: AtnIn = bit3   NLQ-HD-else: AtnIn = bit2
                       ;                                      DtaIn ClkIn AtnIn SrqIn
l11410: in r16,piiema  ;1 PrtB = IECPort                        5     7    2/3    1
        bst r16,biatin ;1 copies AtnIn-bit to T-flag
        bld r16,2      ;1 copies T-flag (AtnIn-bit) to bit2     5     4     2     1 
        bst r16,7      ;1 copies ClkIn-bit to T-flag
        bld r16,4      ;1 copies T-flag (ClkIn-bit) to bit4     5     4     2     1 
        bst r16,5      ;1 copies DtaIn-bit to T-flag
        bld r16,6      ;1 copies T-flag (Dta-bit) to bit6       6     4     2     1
        bst r16,1      ;1 copies SrqIn-bit to T-flag
        bld r16,0      ;1 copies T-flag (Srq-bit) to bit0       6     4     2     0
        andi r16,0b01010101 ;1 masks Bit 6,4,2,0 = DtakIn ClkIn AtnIn SrqIn
        add r05,r16    ;1
        nop            ;1        
        nop            ;1         1+1+1+1+1+1+1 + 1+1+1+1 + 1+2 = 16 = 2µs

        dec r10        ;1     reads IECBus 3 times  4µs and takes average
        brne l11410    ;2      10=bits of PrtB (=example for SrqIn) 
                       ;       00  00  00  01
                       ;       00  00  01  01
                       ;       00  01  01  01
                       ;       --  --  --  --
                       ;       00  01  10  11
        mov r16,r05    ;                                        7     5     3     1     
                       ;=IECPortIn read 3 times in 4µs
        bst r16,5      ;1 copies ClkIn-bit to T-flag
        bld r16,6      ;1 copies T-flag (ClkIn-bit) to bit6     7     6     3     1 
        lsl r16        ;                                        c     7     4     2
                       ;CarryLow = DataInActive  CarryHigh = DataInInactive
                       ;Plus = ClockInActive     Minus =ClockInInactive  (=bit7)
                       ; (AtnIn=bit 4 of r16, SrqIn=bit 2 of r16)
        ret           

       #endif ;644-NLQ-HD/all
;------------------------------------------------------------------------------------------------
                       ;timer0:
                       ;for EOI-detecting
                       ;for JD-IEC-routines recognition
                       ;for JD-timing 
                       
                       ;timer0 is (so far) always used in normal mode
                       ;mode is made by:
                       ; -M162: wgm01-wgm00  all bits are in tccr0
                       ; -M644: wgm02-wgm00  bits are in tccr0a and tccr0b
                       ;timer-prescaler is cs02-cs00 
                       ;   -M162: bit 2-0 of tccr0
                       ;   -M644: bit 2-0 of tccr0b
                       ;M644: at normal mode: tccr0a = #$00 (always)
                       ; if only normal mode is wanted then tccr0a must never be accessed
                       ;timer0-prescaler can be made with-M162: tccr0
                       ;                                 -M644: tccr0b

                       ;from l13570, l13710
l11430:                ;                                     reads one byte from C64  IECIN  e9c9
                       ;disadvantage: AVR-AtnAck-emulation is switched off
                       ;          ( !!!changes Z-vector!!!  if differnt timing for uni NTSC PAL)
                       ; (so far different timing isn't implemented)  
                       ;  (JD-1541 also hasn't differnt timing)
                       ;this diables also 100Hz-IRQ => at sd2iec the debugswitch doesn't work
    
                       ;if JiffyDos-C64 and commandbyte: changes r28,r29 Y-reg
    
        lds r16,iccbjd ;IEC CBM / JiffyDos                      DataOut=active ClockOut=inactive
        cpi r16,$00
        breq l11440    ;=CBM-serial bus routines   (00)
        
        rjmp l11630    ;b.i.JD-serial bus routines (01-ff 1-255)--------------------

                       ;from l10880  receive command-byte
l11440:                ;                   uses:                                        CBM-IECIN
                       ;                   r03=at debugbyte
                       ;                   r05=bus-declicking
                       ;                   r10=counter for bus-declicking
                       ;                   r16=temporary register and received IECIN-byte
                       ;                   r17=received IECIN-byte (and SD-only: special IEC-rout
                       ;                   r19=temporary register
                       ;                   r20=counter for bits per byte
                       ;                   r25=debugbyte 
                       ;                   r28=Yl=vector to devicenumber
                       ;                   r29=Yh=vector to devicenumber
                 
                       ;!!!! pay attention that r24 is unused at this subroutine !!!!
                       ;!!!! it's needed for SDonly RTC IRQ !!!!


        
        ldi r25,$20    ;20---- 
        rcall l13090

       #if (iedbyn  & $01) == 1  ;IEC-debugbytes yes/no
                                 ; & = bitwise and
                                 ;!!! overwrites CBM-buffer 0d00-0dff !!!
                                 ; bit0=CBM-IECIN
                                 ; bit1=CBM-IECOUT      l
        in r19,piiema
       #endif   

l11450: rcall l11260   ;tests for AtnMode change & reads bus                                 e9cd
                       ;subroutine doesn't return when C64 changes Atn
        brpl l11450    ;b.i.C64 makes Clock=active / waits until C64 makes Clock=inactive    e9d5
       
        ldi r25,$21    ;21---
        rcall l13130   ;at SDonly and IEC-routines: this routine must return always
                       ;    must never make a freeze  

       #if partname == 6    
        #message 644-NLQ-HD/SD
        ldi r17,$02    ;flag for CBM-IECIN 
        rjmp l12370    ;make DtaOut=inactive and
                       ;when Dta-line goes inactive -> IRQ jumps to l11470
       .db $0          ;r17 is used by all 5 IECroutines and isn't set at begin of all 5 routines  
       
       #else 
        cli            ;disables IRQs    from l10880 => CLI=important
        rcall l12840   ;DataOut=inactive                                                     e9d7
                       ;=flag to C64 that C64 can start
                       ;flag that C64 can start transmission is when all serial
                       ; devices make DtaOut=inaczive

       #if (iedbyn  & $01) == 1  ;IEC-debugbytes yes/no
                                 ; & = bitwise and
                                 ;!!! overwrites CBM-buffer 0d00-0dff !!!
                                 ; bit0=CBM-IECIN
                                 ; bit1=CBM-IECOUT      l
        in r20,piiema
       #endif   

l11460: rcall l11370   ;reads bus (returns always)                                      e9dc/ff20     
        brcc l11460    ;b.i.any other serial device makes DataIn=active                      ff25
                       ;waits until all other serial devices make DataIn=inactive 
                       ;IRQ is disabled  (CLI)
                       ;=> AtnAck-emulation is switched off
                       ;=> even if C64 makes Atn=active then the AVR shouldn't make
                       ; AVR-DataOut=active 
                       ;=>the data-line couldn't be made to active by the AVR
                       ;=> the AVR cannot lock itself  => not dangerous?
       #endif
                              
                       ;from l10060 (pinchange-IRQ (NH-SD))                 
l11470: ldi r25,$22    ;22--- 
        rcall l13130 
      
       #if (iedbyn  & $01) == 1  ;IEC-debugbytes yes/no
                                 ; & = bitwise and
                                 ;!!! overwrites CBM-buffer 0d00-0dff !!!
                                 ; bit0=CBM-IECIN
                                 ; bit1=CBM-IECOUT      l
        lds r28,iedbvl ;IEC-debugvector low
        ldi r29,$0d
      
        ldi r25,$20
        st y,r25
        inc r28 
        st y,r19       ;from l11440
        inc r28

        ldi r25,$21
        st y,r25
        inc r28 
        st y,r20       ;from l11450
        inc r28

        ldi r25,$22
        st y,r25
        inc r28        ;don't use st y+ (don't increment highbyte)
        in r25,piiema
        st y,r25
        inc r28
        sts iedbvl,r28
       #endif   

        ldi r20,$08    ;counter f. 8 bits per byte                                           e9c9
        
        ldi r19,$03    ;%.....011  (wgm make normal mode)
        out tccr0_,r19 ;starts timer0 (8bit) with 8MHz/64 = 1count per 8µs for EOI-recognition
        out Tcnt0,r06  ;#$00 to timer0 counts up 32*8µs=256µs

l11480: rcall l11260   ; (no return if wrong Atn-mode)
        brpl l11520    ;b.i.C64 makes Clock=active within 256µs = no EOI
       
        in r19,Tcnt0   ;reads timer
        cpi r19,$20
        brcs l11480    ;b.i.counter<$20 = if not yet 256µs without C64 makes Clock=active
 
                       ;= 256µs without C64 makes Clock=active
l11490: rcall l12870   ;DataOut=active    =EOI received                                 EOI-begin
        
        ldi r25,$23    ;(23--- eoi) 
        rcall l13130

       #if (iedbyn  & $01) == 1  
        st y,r25
        inc r28        
        in r25,piiema
        st y,r25
        inc r28
       #endif   

l11500: in r19,Tcnt0
        cpi r19,$30
        brcs l11500    ;waits 128µs (1541 waits 50µs)
                        
        ldi r25,$24    ;(24--- eoi)
        rcall l13130
                
       #if (iedbyn  & $01) == 1  
        st y,r25
        inc r28        
        in r25,piiema
        st y,r25
        inc r28
        sts iedbvl,r28
       #endif   

        rcall l12840   ;DataOut=inactive

l11510: rcall l11260   ;tests for Atn-mode-change & reads IEC-port  (no return if wrong Atn-mode)
        brmi l11510    ;b.i.C64 makes Clock=inactive / waits until C64 makes Clock=active

        lds r19,flicbb
        ori r19,$08
        sts flicbb,r19 ;sets flag for EOI                                                 EOI-end
        
l11520: ldi r19,$a0    ;160                                            =for CBM/JD-recognition   
        out Tcnt0,r19  ;from $a0 to $bb timer0 counts up $1b=27*8µs=216µs
      
        ldi r25,$25    ;(25---)
        mov r03,r25

       #if (iedbyn  & $01) == 1  
        st y,r25
        inc r28        
        in r25,piiema
        st y,r25
        inc r28
       #endif

l11530: rcall l11370   ;reads bus   (carry=DataIn)     (returns always)        

       #if (iedbyn  & $01) == 1  
        brpl l11540    ;b.i.C64 makes Clock=active                          (jd:e9f5)           

        rjmp l11600    ;=C64 makes Clock=inactive / waits until C64 makes Clock=inactive
   
       #else    
        brmi l11600    ;b.i.C64 makes Clock=inactive / waits until C64 makes Clock=inactive
       #endif          ;                (jd:e9f5)      
        
l11540: lds r19,fljdal ;flag JiffyDos allowed   CBM- (00) / JiffyDos- (80) IECBusRoutines
        andi r19,$80
        breq l11530    ;b.i.only CBM allowed  / JD-serial routines not alowed 
        
        in r19,Tcnt0   ;=JD-IECBusRoutines allowed
        cpi r19,$bb
        brcs l11530    ;b.i.timer0 not counted 216µs (later 1500µs)
        
                       ;r17=so far read IECINByte      =C64 doesn't make Clock=inactive
                       ;           (f674)                 within 216µs = JiffyDos-C64
                       ;                                  after transmission of bit 6
                       ;                                  before transmission of bit 7
        lsr r17        ;shifts so far read IECINByte into correct possition (bit7=low)
 
       #if (iedbyn  & $01) == 1  
        ldi r25,$26    ;[26--]
        st y,r25
        inc r28        
        in r25,piiema
        st y,r25
        inc r28

        st y,r17       ;[so far read byte, but lsr]
        inc r28        
        in r25,piiema
        st y,r25
        inc r28
        push r28
        
        ldi r25,$27    ;[27--]
       #endif   
                           
        ldi r28,low(tadenu+$03) ;$0b ylow   y=010a Vector to 010a (0108-010a = table)
        ldi r29,high(tadenu+$03) ;$00 yhigh table device numbers
        
l11550: ld r19,-y      ;010a-0108 predecremented
        cpi r28,low(tadenu-1) ;$8f Ylow
        breq l11580    ;b.i.end of table reached    =not Listen or Talk to this AVR

        andi r19,$df   ;%11011111 masks Listen-bit off
        cp r17,r19
        breq l11560    ;b.i.Talk to this device in table device numbers
        
        ld r19,y       ;010a-0108 (y stays unchanged)
        andi r19,$bf   ;%10111111 masks Talk-bit off
        cp r17,r19
        brne l11550    ;b.i.not Listen to this device
        
                       ;devicenumber #$01 (=AVR itself) isn't checked => speed from C64 to
                       ;AVR-itself is allways CBM, never JD. Important for calibration byte
                       ;when AVR isn't exactly running with 8MHz
         
l11560: 
       #if (iedbyn  & $01) == 1  
        pop r28
        ldi r29,$0d
        ldi r25,$28
        st y,r25       ;[28--]
        inc r28        
        in r25,piiema
        st y,r25
        inc r28
       #endif   
 
        ldi r19,$01    ;=Listen or Talk to AVR  
        sts iccbjd,r19 ;sets flag f.JiffyDos            
        
        rcall l12870   ;DataOut=active
        
       #if (iedbyn  & $01) == 1  
        ldi r25,$29
        st y,r25       ;[29--]
        inc r28        
        in r25,piiema
        st y,r25
        inc r28
       #endif   

l11570: ldi r25,$29    ;41
        rcall l10840   ;waits 410µs
         
        rcall l12840   ;DataOut=inactive
    
       #if (iedbyn  & $01) == 1  
        ldi r25,$2a
        st y,r25       ;[2a--]
        inc r28        
        in r25,piiema
        st y,r25
        inc r28

        ldi r25,$2b    ;[2b--]
        rjmp l11590
       #endif   
        
l11580: 
       #if (iedbyn  & $01) == 1  
        pop r28
        ldi r29,$0d
l11590: st y,r25       ;[27-- 2b--]
        inc r28        
        in r25,piiema
        st y,r25
        inc r28
       #endif   
 
        lsl r17        ;shifts so far read IECINByte into old correct value
        out Tcnt0,r06  ;#$00 starts timer0 so that it counts 160*8=1400µs
        rjmp l11530
        ;-----------
                
l11600: ldi r25,$2c    ;(2c---)
        mov r03,r25
 
       #if (iedbyn  & $01) == 1  
        st y,r25       
        inc r28        
        in r25,piiema
        st y,r25
        inc r28
        sts iedbvl,r28
       #endif   
                       ;carry mustn't change from l11530 to here     
        ror  r17       ;shifts data-bit into r17 (not inverted at AVR)

l11610: rcall l11260   ;tests for Atn-mode-change & reads IEC-bus
        brmi l11610    ;b.i.C64 makes Clock=inactive / waits until C64 makes Clock=active                
                
        ldi r25,$2d    ;(2d---)
        mov r03,r25

       #if (iedbyn  & $01) == 1  
        st y,r25       
        inc r28        
        in r25,piiema
        st y,r25
        inc r28
       #endif   
        
        dec r20        ;decrement counter for 8 bits per byte
    
       #if (iedbyn  & $01) == 1  
        breq l11620

        rjmp l11520    ;----loop----
               
       #else
        brne l11520    ;----loop----
       #endif
        
l11620: rcall l12870   ;DataOut=active
        mov r16,r17
                
        ldi r25,$2e    ;2e---
        rcall l13130

       #if (iedbyn  & $01) == 1  
        st y,r25       
        inc r28        
        in r25,piiema
        st y,r25
        inc r28
       #endif   

        mov r25,r16    ;xx----   AVR-IECIN-byte
        rcall l13090

       #if (iedbyn  & $01) == 1  
        st y,r25       
        inc r28        
        in r25,piiema
        st y,r25
        inc r28
        sts iedbvl,r28
       #endif   

       #if partname == 6    
        #message 644-NLQ-HD/SD
        lds r25,airtmb ;AVR-internal-RTC-mode-bits
                       ;7=sleep-IRQ finished routine
                       ;6=reset-IRQ finished routine
                       ;5=watchdog time-out finished routine
                       ;4=IEC-error finished routine 
                       ;3=IEC-Atn-change finished routine (in databyte-mode but AtnIn=active)
                       ;2=IEC-Atn-change finished routn (in commandbyte-mode but AtnIn=inactive)
                       ;1=normal end of routine

                       ;0= 0=RTC-values changed by timer2-IRQ   (direct-IEC- & IRQ-RTC-mode)
                       ;   1=RTC-values changed by mainprogram  IRQ-IEC- & direct-RTC-mode
        ori r25,$02    ;sets bit that normal end of routine finished routine
        sts airtmb,r25 ;AVR-internal-RTC-mode-bits      
        out Sreg,r08   ;restores status register 
       #endif

        reti           ; = ret + sei   enables 100Hz-IRQ-----------------------------------------
                       ;r16=r17=read byte            DataOut=active  ClockOut=inactive
                       ;                             =>flag for C64 to wait
                       ;                             => unimportant that AtnAck-emulation
                       ;                                  is switched off           end CBM-IECIN

                       ;. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    

l11630:                ;                   uses                                          JD-IECIN
                       ;                   r25=debugbyte 
                       ;                   r16=temporary register and received IECIN-byte
                       ;                   r17=received IECIN-byte
                       ;                   r19=temporary register
               
                       ;!!!! pay attention that r24 is unused at this subroutine !!!!
                       ;!!!! it's needed for SDonly RTC IRQ !!!!

        ;andi r30,$18  ;masks bits for table for timing values
        ;ldi r31,$ff   ;sets Z-vector  (iccbjd would contain vector to
                       ; correct timing-table in flashRom => read it with LPM-command
                       ; (so far not implemented)  

                       ;input lines aren't declicked
                       ;JD-1541 aren't declicked, too
                       ;if there should be errors then perhaps declick like at CBM-IECIN   

        cli            ;disable IRQs 

        ldi r25,$2f    ;2f----
        rcall l13090

        sbis piatin,biatin ;s.i.IECAtn=inactive
l11640: rjmp l10860    ;reads byte after Atn-edge  = change from data- to Atn-mode 
            
        in r16,piiema  ;reads IEC-bus                              (fbd3)

       #if partname == 6    
        #message 644-NLQ-HD/SD
        ldi r17,$04    ;flag for JD-IECOUT 
        rjmp l12370    ;make DtaOut=inactive and
                       ;when Clk-line goes inactive -> IRQ jumps to l11650
       .db $0          ;r17 is used by all 5 IECroutines and isn't set at begin of all 5 routines  
                
                       ;from l10030 (RTC-JD-IECIN)
                       ;=C64 makes Clk=inactive or C64 makes Atn=active
                       ;   29cycles from mainprogram when C64 makes C64-Clk=inactive to here
l11650: andi r16,1<<biclin ;1 masks IECClockIn (before)
        brne l11670    ;    1 b.i.C64 makes Clock=inactive(=C64error)(!AVR made AVR-DataOut=inactive
                       ;     => if C64 wants to send the next command-byte then C64 could think
                       ;         that AVR-DataOut=inactive is flag that AVR is ready 
                       ;         => C64 could begin to send next byte  = bad           
        sbis piatin,biatin ;2 s.i.C64-Atn=inactive
        rjmp l11340    ;      indirectly to read byte after Atn-edge  
                       ;      = change from data- to Atn-mode                        
        ldi r17,$02    ;    1 %.....010
        ldi r19,$14    ;    1
        nop            ;    1

       #else 
        rcall l12840   ;DataOut=inactive                           (fbd8)

        ldi r17,$02    ;%.....010
        ldi r19,$10     

        andi r16,1<<biclin ;masks IECClockIn (before)
        brne l11670    ;b.i.C64 makes Clock=inactive (=C64error) (!AVR made AVR-DataOut=inactive
                       ;     => if C64 wants to send the next command-byte then C64 could think
                       ;         that AVR-DataOut=inactive is flag that AVR is ready 
                       ;         => C64 could begin to send next byte  = bad           

l11660: sbis piatin,biatin ;s.i.C64-Atn=inactive
        rjmp l10860    ;reads byte after Atn-edge  
                       ;= change from data- to Atn-mode                           uni-   
        sbis piiema,biclin ;s.i.C64 makes Clock=inactive                       1541 versal NTSC PAL
        rjmp l11660    ;waits until C64 makes Clock=inactive       (fdbe)
                       ;when EOI: C64 sends last byte with EOI (ed19)        0µs    0µs
                       ;C64-ClockOut stays active
                       ;=>1541 even after having read last EOI-byte,
                       ;it reads the next one
                       ;=>it waits at l11660
                       ;C64 makes Atn=active (when sending unlisten (after EOI))
                       ;but at 1541 the AtnAck-hardware makes
                       ;41-DataOut=active 
                       ;so 41-DataOut=active even if the direct 
                       ;DataOut-register is made
                       ;         inactive (fbd8) => 41-DataOut=active = flag for C64 to wait
                       ;the AVR hasn't got an AtnAck-hardware = problem 
                       ;JD-C64 makes 64Clock=inactive (ed49)
                       ;=>JD-1541 ends waiting-loop at l11660, but doesn't make 
                       ; AVR-DataOut=active, because there is no AtnAck-hardware and because
                       ; AtnAck-emulation is switched off and 
                       ;    if there would be no Atn-test four times while receiving one byte:                     
                       ;    AVRreads one not-existing byte from C64
                       ;    and sees at the end of this that
                       ;          C64 makes Atn=active
                       ;    and jump to the CBM routine
                       ;          (where routine after ATN-edge is made)
                       ;    Here AvrDataOut is made active (very late)
                       ;    could be perhaps too late to show C64 that AVR isn't ready
                       ;     (and C64 could perhaps begin to send command byte)
                       ;=> make test for C64-Atn=active four times
       #endif 

l11670: out tccr0_,r17 ;#$02 %.....010 starts timer0 (8bit) with 8MHz/8 = 1count per 1µs
                       ;   (wgm make normal mode)             
        out Tcnt0,r19  ;$10 to timer0 counts up from $10                          (0.41-1.1µs)       
        
        ldi r25,$20
        rcall l11690   ;waits until correct time and reads PinB             0d-14 $10µs
        bld r16,4      ;ClkIn-bit -> bit4 of IECIN-byte
        bst r17,bidain ;DtaIn-bit
        bld r16,5      ;DtaIn-bit -> bit5

        ldi r25,$2d
        rcall l11690   ;waits until correct time and reads PinB             1a-21 $1dµs 
        bld r16,6      ;ClkIn-bit -> bit6 of IECIN-byte
        bst r17,bidain ;DtaIn-bit
        bld r16,7      ;DtaIn-bit -> bit7

        ldi r25,$38
        rcall l11690   ;waits until correct time and reads PinB             25-2c $28µs 
        bld r16,3      ;ClkIn-bit -> bit3 of IECIN-byte
        bst r17,bidain ;DtaIn-bit
        bld r16,1      ;DtaIn-bit -> bit1

        ldi r25,$45
        rcall l11690   ;waits until correct time and reads PinB             32-39 $35µs      
        bld r16,2      ;ClkIn-bit -> bit2 of IECIN-byte
        bst r17,bidain ;DtaIn-bit
        bld r16,0      ;DtaIn-bit -> bit0

        com r16        ;inverts all bits because byte is sent inverted from C64

        ldi r25,$52
        rcall l11690   ;waits until correct time and reads PinB             3f-46 $42µs       
                       ;checks whether AtnIn is active
                       ; ClkIn -> T-flag

        rcall l12870   ;DataOut=active                                                       fc05
                       ;is the rcall fast enough????
                       ;NLQ-HD: first checks whether AtnIn is active (fc08)
                       ;          then makes DtaOut = Active
                       ;1541: first makes DtaOut = Active
                       ;          then checks whether AtnIn is active

        brtc l11680    ;b.i.ClkIn was active = b.i.noEOI    

        lds r19,flicbb ;=EOI received (ClkIn was inactive)
        ori r19,$08
        sts flicbb,r19 ;sets flag for EOI
        
l11680: mov r17,r16    ;=received data-byte  (never command-byte) 
        
        mov r25,r16    ;xx----   AVR-IECIN-byte
        rcall l13090

        lds r25,flicbb
        rcall l13090   ;---- (flicbb)   
                       ;C64: at end of C64-JD-IECOUT it looks whether AVR makes Dta=active
                       ; (fc82)
                       ; if not then time out error (st=3)
                       ;the AVR is very fast: when it wants to receive the next byte (l11640)
                       ; then it makes DtaOut=inactive. 
                       ;if this happens faster than the C64 can read the Dta-line then the
                       ; C64 thinks that there is a time-out-error
                       ;perhaps: ther could be perhaps even a C64-badline between $fc76-$fc82
                       ; this are 43 additional C64-cycles)
                       ; => the AVR must hold DtaOut=active long enough 
                       ; (even when debugbytes are deactivated)

        ldi r25,$05
        rcall l10840   ;50µs waiting loop             
   
       #if partname == 6    
        #message 644-NLQ-HD/SD
        lds r25,airtmb ;AVR-internal-RTC-mode-bits
                       ;7=sleep-IRQ finished routine
                       ;6=reset-IRQ finished routine
                       ;5=watchdog time-out finished routine
                       ;4=IEC-error finished routine 
                       ;3=IEC-Atn-change finished routine (in databyte-mode but AtnIn=active)
                       ;2=IEC-Atn-change finished routn (in commandbyte-mode but AtnIn=inactive)
                       ;1=normal end of routine

                       ;0= 0=RTC-values changed by timer2-IRQ   (direct-IEC- & IRQ-RTC-mode)
                       ;   1=RTC-values changed by mainprogram  IRQ-IEC- & direct-RTC-mode
        ori r25,$02    ;sets bit that normal end of routine finished routine
        sts airtmb,r25 ;AVR-internal-RTC-mode-bits      
        out Sreg,r08   ;restores status register 
       #endif

        reti           ;= ret + sei  enables 100Hz-timer IRQ
                       ;AVR-DataOut=active        (AVR-ClockOut=inactive)
                       ;=> =flag for C64 to wait                                     end JD-IECIN
                       ;=>unimportant that AVR-AtnAck-emulation is switched off  
;------------------------------------------------------------------------------------------------
                       ;from l11670, l11670, l11670, l11670
l11690: in r17,Tcnt0   ;1 reads timer
        cp r17,r25     ;1
        brne l11690    ;2 waits until 

                       ;fortunately only DtaIn and ClkIn is needed (not AtnIn and not SrqIn) 
        in r17,piiema  ;reads IECPort DtaIn  ClkIn
                       ;IEC-ATA-ClkIn   5      3
                       ;SD2IEC          1      2
                       ;NLQ-HD-ClkIn    5      7
       
        bst r17,biclin ;copies ClkIn-bit -> T-flag
        
        sbis piatin,biatin    ;s.i.C64-AtnIn=inactive
        rjmp l10860    ; (resets stackpointer)     
        
        ret            ;T=low = ClkIn=Active  T=high   = ClkIn=Inactive
;================================================================================================
                       ;from l13420, l13480
l11700:                ;IECOUT IEC from AVR to C64  DataOut=inactive ClockOut=active  IECOUT e916

        ldi r25,$50    ;50----
        rcall l13090

        mov r25,r16    ;xx----     AVR-IECOUT-byte (isn't sent if C64 makes Atn=active)
        rcall l13090
        
        lds r25,flicbb ;xx--     IECBusBits
        rcall l13130
        
        sbis piatin,biatin ;s.i.C64-Atn=inactive                                             e916
        rjmp l10860    ;read byte after Atn=active-edge  !doesn't close Talk-buffer!
                       ;never sends command-bytes => Atn is allways inactive
                       ;this is bad at device-swap command,
                       ;because here NLQ-HD sends command-bytes

        rcall l12840   ;DataOut=inactive (should be so even before)                          

        lds r17,iccbjd ;IEC CBM JiffyDos
        cpi r17,$00
     
       #if partname == 1    
        #message 162-IEC-ATA-V2
        brne l11880    ;b.i.JD 
 
       #else
        breq l11720    ;b.i.CBM

        rjmp l11880    ;=JD
       #endif
        ;------------                                                             
    
       #if partname >= 2    
        #message 644-non-IEC-ATA
                       ;from l12820 - l12830 (device-swap)
l11710: ldi r25,$50    ;50----                                                         CBM-IECOUT
        rcall l13090   ;                                                           at device swap

        mov r25,r16    ;xx----     AVR-IECOUT-byte 
        rcall l13090
        
        lds r25,flicbb ;xx--     IECBusBits
        rcall l13130
        
        ;rcall l12840   ;DataOut=inactive (should be so even before)                          
       #endif

l11720:                ;                   uses                                        CBM-IECOUT
                       ;                   r03=at debugbyte
                       ;                   r05=bus-declicking
                       ;                   r10=counter for bus-declicking
                       ;                   r16=to sent IECOUT-byte
                       ;                   r17=counter for bits per byte
                       ;                   r18=temporary register for to sent IECOUT-byte
                       ;                   r25
                       ;
                       ;!!!! pay attention that r24 is unused at this subroutine !!!!
                       ;!!!! it's needed for SDonly RTC IRQ !!!!

                       ;ClockOut=active  DataOut=inactive  

        ldi r25,$51    ;51--
        rcall l13130

        mov r18,r16    ;r18=r16=to sent IECOUTByte  

l11730: rcall l11260   ;test for AtnMode Change & reads IECBus (DtaIn-> carry)               e919
                       ;no return if Atn=active
        ror r16        ;DtaIn: c->b7   ClkIn: b7->b6        

       #if partname == 6    
        #message 644-NLQ-HD/SD
        ldi r17,$03    ;flag for CBM-IECOUT 
        rjmp l12370    ;make DtaOut=inactive and
                       ;when Dta-line goes inactive -> IRQ jumps to l11470
       .db $0          ;r17 is used by all 5 IECroutines and isn't set at begin of all 5 routines  
      
                       ;from l10030 (RTC-CBM-IECOUT)
                       ;=C64 makes Dta=inactive  or C64 makes Atn=active
l11740: lsl r16
        brcs l11770    ;b.i.C64 made data=inactive (=C64 not present?)  =error               e923
   
        rcall l11260   ;read bus (no return if different Atn-mode)
                       ;important when C64 makes Atn=active?
                       ; is this command fast enough?????????

                       ; flag for not yet ready at IEC from floppy to C64:
                       ;  -C64:    Dta=active (Clk=inactive)
                       ;  -floppy: Clk=active (Dta=inactive)
                       ;usually (C64 reads next databyte)
                       ; C64 is ready before floppy is ready:
                       ;  C64 waits untile floppy makes Clk=inactive (ee1b-ee1e)
                       ; floppy is ready before C64 is ready
                       ;  floppy makes Clk=inactive (e91f), 
                       ;  floppy waits until C64 makes Dta=inactive (e925-e92d (EOI) /
                       ;                                             e937-e93f (noEOI)
                       ;special (C64 aborts databytetransfer by sending untalk)
                       ; 1. C64 (edef) makes Clk=active (edf0)
                       ; 2. C64 makes Atn=active (edf3-edf8) 
                       ; 3. C64 makes Dta=inactive (ed24)
                       ; 6. waits 1000µs (ed3d)
                       ; -C64 sends untalk before floppy is ready:
                       ;   floppy sees at e916 that C64 makes Atn=active ->ea63 -> ea68 -> e85b
                       ; -floppy is ready before C64 sends untalk
                       ;   floppy sees at e925 (EOI) / e937 (noEOI) that C64 makes Atn=active

                       ;illegal-special (C64 aborts databytetransf.b.sndg listen, talk, unlisten)
                       ; 3. C64 makes Dta=inactive (ed24)
                       ; 4. C64 makes Atn=active (ed2e-ed33)       
                       ; 5. C64 makes Clk=active (ed37) 
                       ; 6. waits 1000µs (ed3d)
                       ; -C64 sends listen, talk, unlisten before floppy is ready:
                       ;   floppy sees at e916 that C64 makes Atn=active ->ea63 -> ea68 -> e85b
                       ; -floppy is ready before C64 sends listen, talk, unlisten
                       ;   floppy sees at e925 (EOI) / e937 (noEOI) that C64 makes Atn=active
                       
                       ;!!!! still test the RTC-IECOUT-routine when it is aborted by not-untalk)

       #else 
        cli            ;disable IRQs
                       ; => AtnAck-emulation is switched off (and AVR-DataOut=inactive)
                       ;   => dangerous if C64 makes C64-Atn=active

        rcall l12910   ;ClkOut = inactive (mustn't change r16)                (C64:ee1e)     e91f
        lsl r16
l11750: brcs l11770    ;b.i.C64 made data=inactive too early (=C64 not present?)  =error     e923
 
                       ;=C64 makes Atn=active  = ok
l11760: rcall l11260   ;read bus (no return if different Atn-mode)                      e925/e928
        brcc l11760    ;waits until C64 makes data=inactive   (C64:ee2a)                     e92d
       #endif 

        lds r16,flicbb ;IECBusBits                                                      e92f-e933
        andi r16,$10   ;masks bit 4                                                     e92f-e933
        breq l11810    ;b.i.noEoi                                                            e935
   
                       ;                                               --------------begin of EOI 
l11770:                ;=Eoi    
        ldi r25,$53    ;53--  
        rcall l13130

l11780: ;rcall l11260                                                             e937
        ;brcc l11780   ;wait until C64 makes data=inactive                   (C64:ee2a)      e93f

l11790: ldi r25,$54    ;(54--)   C64 makes from ee47 to ee2a C64-DataOut to active for 84 cycles
                       ;rcall l13130 would be too long 
        mov r03,r25    ;if it hangs here then you can debug it by r03=#$25 

                       ;before line: handshake; no waiting-loop necessary
                       ;------------------------------------------------------------------------ 
                       ;after line: timing important => waiting-loops 
       #if partname >= 2    
        #message 644-non-IEC-ATA
        ldi r17,$00
       #endif

l11800: rcall l11260   ;10µs read bus (no return if different Atn-mode)                 e941/e944
                       ; changes r05, r16, r10, (r00), (r25)
       #if partname >= 2    
        #message 644-non-IEC-ATA
        dec r17
        breq l11860
       #endif

        brcs l11800    ;waits until C64 makes data=active   (C64:ee47)                       e949

        ldi r25,$55    ;55--
        rcall l13130
                       ;                                               ----------------end of EOI
        
l11810: rcall l12880   ;e94b ClockOut=active  sign to C64 that transmission starts  (ee37)   e94b
l11820: rcall l11260   ;10µs  read bus (no return if different Atn-mode)                e94e/e951
        brcc l11820    ;waits until C64 makes data=inactive  (C64:ee2a  -first time if noEOI e956 
                       ;                                                -second time if EOI)                                         
        ldi r25,$56    ;    56--
        rcall l13130   ;5µs at NH-full   other are even longer

        ldi r17,$08    ;counter f.8 bits per byte                                       e958/e95a
        ldi r25,$0a    ;=0a = 100µs waiting-loop
                       ;AVR-CBM-IECOUT:
                       ;usually this routine is used for sending bytes to a C64 only        
                       ;exeption: at device-swap it is used for sending bytes to a floppy
                       ;at this floppy there is a detection whether there is a CBM-C64
                       ; or a JD-C64.   
                       ;the time-period      CBM-C64 JD-C64   CBM-1541  JD-1541   NLQ-HD
                       ; from (Clk=active)            ed5f      e94b      e934    l11810
                       ; to (Clk=inactive)            ed7c      e976      e955    l11840
                       ; mustn't be too big          73-137c  136-138µ  123-125µ   ~130µ
                       ; at the first databit         cycles     µs        µs        µs
                       ; else the external floppy thinks that there is a JD-C64
                       ;  NLQ-HD: 10 + 5+ 100 + 10 + 10 + x = 140µs 

l11830: rcall l10840   ;110/100µs waiting-loop 
        rcall l11370   ;10µs reads IEC-port                                                   e95c
        brcc l11860    ;b.i.C64 makes data=active (=error)                                   e961
                                    
        lsr r18        ;to sent IECOUTByte  DataOut = allways inactive here                  e968
        brcs l11840    ;b.i.1-bit  (DataOut stays inactive)                                  e96c

        rcall l12870   ;DataOut=active =0-bit                                                e96e

l11840: rcall l10820   ;10µs waiting-loop
        rcall l12910   ;ClockOut=inactive                                                   D  CI
        ldi r25,$07
        rcall l10840   ;wait 10µs*7 70µs
                       ;1541 makes ClockOut=inactive for ?70?µs
                       ;C64  makes ClockOut=inactive for 26 (- 69) cycles
                       ;         26cycles+43cycles for badline =69cycles
                       ;this mustn't be too long at device-swap, when NLQ-HD sends commands
                       ;   not to the C64 but to a CBM-floppy
                       ; this must be <216µs because else the CBM-floppy would recognize this as
                       ; flag for jiffydos-serial-bus-routines   
        rcall l12880   ;ClockOut=active                                                     D  CA
        rcall l10820   ;wait 10µs
        rcall l12840   ;DataOut=inactive                                                    DI CA
        rcall l10820   ;waits 10µs
        ldi r25,$0a    ;value for 100µs waiting-loop
        dec r17        ;counter bits per byte    
        brne l11830

        ldi r25,$57    ;57--
        rcall l13130

       #if partname >= 2    
        #message 644-non-IEC-ATA
        ldi r17,$00
       #endif

l11850: rcall l11260   ;test if AtnModeChange & reads bus                                   DI CA

       #if partname >= 2    
        #message 644-non-IEC-ATA
        dec r17
        breq l11860
       #endif
    
        brcs l11850    ;b.i.DataIn=inactive   waits until C64 makes data=active
        
        ldi r25,$58    ;58--
        rcall l13130
    
       #if partname == 6    
        #message 644-NLQ-HD/SD
        lds r25,airtmb ;AVR-internal-RTC-mode-bits
                       ;7=sleep-IRQ finished routine
                       ;6=reset-IRQ finished routine
                       ;5=watchdog time-out finished routine
                       ;4=IEC-error finished routine 
                       ;3=IEC-Atn-change finished routine (in databyte-mode but AtnIn=active)
                       ;2=IEC-Atn-change finished routn (in commandbyte-mode but AtnIn=inactive)
                       ;1=normal end of routine

                       ;0= 0=RTC-values changed by timer2-IRQ   (direct-IEC- & IRQ-RTC-mode)
                       ;   1=RTC-values changed by mainprogram  IRQ-IEC- & direct-RTC-mode
        ori r25,$02    ;sets bit that normal end of routine finished routine
        sts airtmb,r25 ;AVR-internal-RTC-mode-bits      
        out Sreg,r08   ;restores status register 
       #endif
        
        ldi r25,$10    ;=16 = 160µs waiting-loop
        rcall l10840   ;160µs waiting-loop see text below (problem / bug)   
       
        reti           ; = ret + sei                                                        DI CA
                       ;allow IRQs important because DataOut=inactive 
                       ;if C64 sends command-byte then the serial drive must make DataOut=active
                       ;=> AtnAck-substitute-IRQ must be allowed
                       ; AtnAck-emulation is switched on                        
                       ; is this correct?????  
                       ;or is AtnIn-IRQ disbaled because iratin is #$00???????????????? 

                       ;  ClockOut=active  DataOut=inactive (always  EOI & noEOI)
       ;-----------------  
                       ;from l11830
l11860:                ;=IECOUT-error
        ldi r25,$59    ;59--
        rcall l13130
        
       #if partname == 6    
        #message 644-NLQ-HD/SD
        lds r25,airtmb ;AVR-internal-RTC-mode-bits
                       ;7=sleep-IRQ finished routine
                       ;6=reset-IRQ finished routine
                       ;5=watchdog time-out finished routine
                       ;4=IEC-error finished routine 
                       ;3=IEC-Atn-change finished routine (in databyte-mode but AtnIn=active)
                       ;2=IEC-Atn-change finished routn (in commandbyte-mode but AtnIn=inactive)
                       ;1=normal end of routine

                       ;0= 0=RTC-values changed by timer2-IRQ   (direct-IEC- & IRQ-RTC-mode)
                       ;   1=RTC-values changed by mainprogram  IRQ-IEC- & direct-RTC-mode
        ori r25,$10    ;sets bit that IEC-error finished routine
        sts airtmb,r25 ;AVR-internal-RTC-mode-bits      
        out Sreg,r08   ;restores status register 
                       ;!! carry doesn't contain flag for ok/error)
        reti           ;!! the stack isn't restored from airtsl
                       ;this reti only works when then IECOUT-toutine makes an error
                       ; it cannot be jumped from any subroutine
       #endif
  

l11870: jmp l25290     ;(C64 makes data=active) to main waiting loop          end CBM-IECOUT e999             
                       ;problem   bug at C64-kernal:
                       ;usually ST = $90 is #$00 it is cleared at begin of IEC from floppy to C64
                       ; at end of C64-CBM-IECIN: C64 must make C64-Dta=active
                       ;  = flag for floppy that C64 isn't ready
                       ;when C64 $90 = #$40 e.g. when the status isn't cleared after the last 
                       ; disk access (e.g. last load)
                       ;C64 makes:
                       ;- Talk
                       ;- SA after Talk => C64-Dta=active (C64-Clk=inactive)
                       ;- C64 reads 1. byte from floppy
                       ;   reads firts byte correctly until $ee79
                       ;   ee79: bit 6 of $90 is wrongly high
                       ;         => C64 makes jsr ee06  c64 makes C64-DtaOut=inactive
                       ;             at end of C64-CBM-IecIn = bug = error
                       ;          (C64 must make C64-DtaOut=active at end of C64-CBM-IecIn)
                       ;-C64 reads 2. byte from floppy
                       ;   1541 sees at $e919-e923 = l11730-l11750 that C64 made 
                       ;   C64-DtaOut=inactive too early
                       ;   1541 jumps to routine where a byte is sent to C64 with EOI
                       ;   (it doesn't jump to any error-routine)
                       ;   => even when the C64 makes C64-DaOut=inactive too early
                       ;       the byte is correctly sent fom 1541 to C64
                       ;   C64 recognizes EOI from 1541 and sets bit 6 of $90
                       ;   (this bit is set already before (this is the reason for th bug)
                       ;    but C64 sets it nevertheless (evidenced by a test)) 
                       
                       ;problem at NLQHD:
                       ;(1) C64 makes Dta=active at ee76 (correct)
                       ;(2) C64 makes Dta=inactive at $ee7d (bug)
                       ;the time between (1) and (2) is 107cycles = 109µs at PAL
                       ; when a badline: 107+43=150cycles = 153µs at PAL
                       ; a real 1541 is so slow that it needs these 153µs for taking the
                       ;  next byte from the buffer
                       ; the AVR is so fast that it wants to send the next databyte while
                       ; the time between (1) and (2)
                       ; AVR doesn't see that C64 makes C64-DtaOut=inactive at $ee7d wrongly
                       ; AVR is so fast that it is already at begin of send next databyte
                       ;  to C64
                       ; AVR thinks that C64-DtaOut=inactive is made from C64 at $ee2a
                       ; AVR is so fast that it thinks that C64-DtaOut=inactive is 
                       ;  begin of next byte / doesn't see that this is buggy end of actual byte
                       ;=> one must make a 160µs delay-loop at l11850
                       ;program with this bug: DOS-WEDGE V5.1 of CBM-demo-disks


                       ;. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    

l11880:                ;                   uses                                        =JD-IECOUT
                       ;                   r16=to sent IECOUT-byte
                       ;                   r17=temp
                       ;                   r18=at counter
                       ;                   r19=temp
                  
                       ;!!!! pay attention that r24 is unused at this subroutine !!!!
                       ;!!!! it's needed for SDonly RTC IRQ !!!!
                                 
                       ;400µs delay loop is made at l11170 - l11180
                        
                       ;input-lines aren't declicked
                       ;JD-1541 input-lines aren't declicked, too
                       ;perhaps declick as at CBM-IECOUT if there should be errors

       #if partname == 6    
        #message 644-NLQ-HD/SD
        ldi r17,$05    ;flag for JD-IECIN 
        rjmp l12370    ;make ClkOut=inactive and
                       ;when Dta-line goes inactive -> IRQ jumps to l11890
       .db $0          ;r17 is used by all 5 IECroutines and isn't set at begin of all 5 routines  
                
                       ;from l10030 (RTC-JD-IECIN)
                       ;=C64 makes Dta=inactive or C64 makes Atn=active
                       ;   29cycles from mainprogram when C64 makes C64-Clk=inactive to here
l11890: sbis piatin,biatin ;2 s.i.C64-Atn=inactive
        rjmp l11340    ;      indirectly to read byte after Atn-edge  
                       ;      = change from data- to Atn-mode                        
        ldi r17,$02    ;    1 %.....010
        ldi r19,$14    ;    1
        nop            ;    1
        nop            ;    1
        nop            ;    1

       #else 
        cli            ;disable IRQs
                       ; => AtnAck-emulation is switched off (and AVR-DataOut=inactive)
                       ;   => dangerous if C64 makes C64-Atn=active
                            
        rcall l12910   ;ClockOut=inactive                  (ff88)
      
        ldi r17,$02    ;%.....010
        ldi r19,$10    ;startvalue counter

        ldi r25,$5c

l11900: sbis piatin,biatin ;2 s.i.C64-Atn=inactive
        rjmp l11970    ;(5c--)  reads byte after Atn-edge                         uni-
                       ;    = change from data- to Atn-mode                 1541 versal NTSC PAL
l11910: sbis piiema,bidain ;1/2  s.i.C64 makes data=inactive
        rjmp l11900    ;2 waits until C64 makes data=inactive     (ffbb)     0µs    0µs
                       ;    1 loop = 5cycles =0.63µs at 7.37MHz  
       #endif
         
        out tccr0_,r17 ;1 #$02 %.....010 starts timer0 (8bit) with 8MHz/8 = 1count per 1µs
                       ;  (wgm make normal mode)
l11920: out Tcnt0,r19  ;1 $10 to timer0 counts up from $10                  (0µs) 0.41-1.1µs 
         
                       ;when C64 makes data=inactive then the AVR needs
                       ;from l11910 to l11920 3cycles =0.41µs

                       ;when the C64 makes data=inactive 0.001µs after
                       ;the AVR has read the line at l11910 then the AVR
                       ;must wait one complete loop l11900 - l11910 
                       ;=>delay is 0.41+0.68µs=1.1µs

               
                       ;1541 sends to sent byte inverted 

        ldi r19,$19
        rcall l11980   ;sends bit 0&1                                       06-0d $09µs
        
        ldi r19,$23    
        rcall l11980   ;sends bit 2&3                                       10-17 $13µs 
        
        ldi r19,$2d    
        rcall l11980   ;sends bit 4&5                                       1b-22 $1eµs 

        ldi r19,$38    
        rcall l11980   ;sends bit 6&7                                       25-2c $28µs     D7 C6

        ldi r19,$43
        lds r16,flicbb ;IECBusBits
        andi r16,$10   ;masks bit 4
        breq l11930    ;b.i.noEoi     DataOut=inactive    ClockOut=active

        ldi r16,$01    ;$01=Eoi       DataOut=active  ClockOut=inactive 
                       ;                  EOI

        rcall l11980   ;sends                                          EOI: 30-37 $33µs   (DA CI)     
        ldi r19,$64     
                       ;hold this for about 21=33µs
                       ;jd41 at EOI: sets data=active Clock=inactive
                       ;doesn't wait at ffde-ffe3
                       ;rts to fb70
                       ;doesn't branch at fb72
                       ;makes data=inactive clock=active at fb74-fb78
                       ;=>holds EOI-flag for 33µs to bus
                       ;if bus isn't constant within 4µs then the
                       ;cmp-loop is perhaps made and it's
                       ;42µs instaed of 33µs
                       ;waits at ffde-ffe3 until C64 makes data=active
                       ;(C64 at receiving IECIN-byte with EOI and Untalk:
                       ;  makes data=active for 109µs
                       ;  => enough time for 41 to read it)

l11930: ldi r16,$02    ;$02=noEoi                                     (EOI: 51-58 $54µs)                             
                       ;                                             noEOI: 30-37 $33µs 
                       ;      noEOI:  DataOut=inactive    ClockOut=active 
        rcall l11980   ;sends noEOI (or end after EOI):                                     DI CA

        rcall l10820   ;waits 10µs  (jd41 reads bus 4µs after having made DataOut=inactive)
        
        ldi r25,$5e    
l11940: sbis piatin,biatin ;s.i.C64-Atn=inactive
        rjmp l11970    ;(5e--)  =C64 makes Atn=active
        sbic piiema,bidain ;s.i.C64 makes data=active
        rjmp l11940    ;waits until C64 makes data=active       (ffbb)

l11950: ldi r25,$5f    ;5f--
        rcall l13130
      
       #if partname == 6    
        #message 644-NLQ-HD/SD
        lds r25,airtmb ;AVR-internal-RTC-mode-bits
                       ;7=sleep-IRQ finished routine
                       ;6=reset-IRQ finished routine
                       ;5=watchdog time-out finished routine
                       ;4=IEC-error finished routine 
                       ;3=IEC-Atn-change finished routine (in databyte-mode but AtnIn=active)
                       ;2=IEC-Atn-change finished routn (in commandbyte-mode but AtnIn=inactive)
                       ;1=normal end of routine

                       ;0= 0=RTC-values changed by timer2-IRQ   (direct-IEC- & IRQ-RTC-mode)
                       ;   1=RTC-values changed by mainprogram  IRQ-IEC- & direct-RTC-mode
        ori r25,$02    ;sets bit that normal end of routine finished routine
        sts airtmb,r25 ;AVR-internal-RTC-mode-bits      
        out Sreg,r08   ;restores status register 
       #endif        
      
        reti           ; = ret +SEI   enables 100Hz-timer-IRQ                               DI CA
                       ;DataOut=inactive  ClockOut=active                           end JD-IECOUT

l11960: ldi r25,$5d    ;5d--

l11970: rcall l13130

       #if partname == 6    
        #message 644-NLQ-HD/SD
        rjmp l11340    ;indirectly to read byte after Atn-edge  

       #else 
        rjmp l10860    ;reads byte after Atn-edge  = change from data- to Atn-mode
       #endif
;------------------------------------------------------------------------------------------------
l11980:                ;                                      subroutine of JD-IecOut and JD-Load
        #if partname == 1    
        #message 162-IEC-ATA-V2
        in r17,poiema  ;reads PrtB
        ori r17,$14    ;%00010100 sets bit4&2  DataOut&ClockOut  default: inactive
        lsr r16        ;to send IECOUT-byte  bit0,2,4,6->carry
        brcs l11990    ;b.i.1-bit to send = inverted 0-bit

        andi r17,$fb   ;clears clockOut bit of port  (->active)

l11990: sbis piatin,biatin ;s.i.C64-Atn=inactive
        rjmp l11960    ;5d--  read byte after Atn=active-edge  !doesn't close Talk-buffer!
                       ;never sends command-bytes => Atn is allways inactive
        lsr r16        ;bit1,3,5,7->carry
        brcs l12000     

        andi r17,$ef   ;clears DataOut bit of port  (->active)

l12000: in r18,Tcnt0   ;reads timer0
        cp r18,r19
        brcs l12000    ;waits
         
        out poiema,r17 ;makes bit0,2,4,6->ClockOut  bit1,3,5,7->DataOut

        ret
       #endif
    
        #if partname == 3    
        #message 644/SD2IEC
        in r17,poiema  ; scdascda   reads PrtA
        andi r17,$9f   ;%10011111  masks off bit5&6  DataOut&ClockOut  default: inactive
        lsr r16        ;to send IECOUT-byte  bit0,2,4,6->carry
        brcs l12010    ;b.i.1-bit to send = inverted 0-bit

        ori r17,$40    ;sets clockOut bit of port as active

l12010: sbis piatin,biatin ;s.i.C64-Atn=inactive
        rjmp l11960    ;5d--  read byte after Atn=active-edge  !doesn't close Talk-buffer!
                       ;never sends command-bytes => Atn is allways inactive
        lsr r16        ;bit1,3,5,7->carry
        brcs l12020     

        ori r17,$20    ;sets DataOut bit of port as active

l12020: in r18,Tcnt0   ;reads timer0
        cp r18,r19
        brcs l12020    ;waits
         
        out poiema,r17 ;makes bit0,2,4,6->ClockOut  bit1,3,5,7->DataOut
                       ;SD2IEC-outputs are inverted
        ret
       #endif

       #if partname == 4
         #message 644-NLQ-HD/lite
       
        in r17,ddiema  ;reads ddrB
        andi r17,0b11100111 ;masks off bit4&3  DtaOut & ClkOut
        in r25,poiema
        ori r25,0b00011000 ;

        lsr r16        ;to send IECOUT-byte  bit0,2,4,6->carry
        brcs l11990    ;b.i.1-bit to send = inverted 0-bit

        ori r17,$08    ;sets clkOut bit of port
        andi r25,$f7   ;clears ClkOut-bit of PrtB

l11990: sbis piatin,biatin ;s.i.C64-Atn=inactive
        rjmp l11960    ;5d--  read byte after Atn=active-edge  !doesn't close Talk-buffer!
                       ;never sends command-bytes => Atn is allways inactive
        lsr r16        ;bit1,3,5,7->carry
        brcs l12000     

        ori r17,$10    ;sets DataOut bit of port
        andi r25,$ef   ;clears DtaOut-bit of PrtB

l12000: in r18,Tcnt0   ;reads timer0
        cp r18,r19
        brcs l12000    ;waits
         
        out ddiema,r06   ;#$00 to prevent that AVR pulls active to +5V
                       ;low-bit         high-bit
        out poiema,r25 ;pullups-on (1)  (nothing (0))
        out ddiema,r17 ;(nothing (0))   output loq 0V (1)
                       ;makes bit0,2,4,6->ClockOut  bit1,3,5,7->DataOut
        ret
       #endif
 
       #if partname == 6
         #message 644-NLQ-HD/SD

                       ;the AtnIn-IRQ is disabled => DtaOut cannot be changed by AtnIn-IRQ       
        ldi r17,$00    ;DdrA default: DtaOut & ClkOut inactive
        ldi r25,$7f    ;PrtA default: DtaOut & ClkOut inactive
                       ;bit7= input & pullup=off (VCC)
                       ;bit6= input & pullup=on (voltage divider  so far not connected)

        lsr r16        ;to send IECOUT-byte  bit0,2,4,6->carry
        brcs l12050    ;b.i.1-bit to send = inverted 0-bit

        ori r17,$07    ;sets clkOut bit of DdrA
        andi r25,$f8   ;clears ClkOut-bit of PrtA

l12050: sbis piatin,biatin ;s.i.C64-Atn=inactive
        rjmp l11960    ;5d--  read byte after Atn=active-edge  !doesn't close Talk-buffer!
                       ;never sends command-bytes => Atn is allways inactive
        lsr r16        ;bit1,3,5,7->carry
        brcs l12060     

        ori r17,$38    ;sets DataOut bit of DdrA
        andi r25,$c7   ;clears DtaOut-bit of Prta

l12060: in r18,Tcnt0   ;reads timer0
        cp r18,r19
        brcs l12060    ;waits
         
        out DdrA,r06   ;#$00 to prevent that AVR pulls active to +5V
                       ;low-bit         high-bit
        out PrtA,r25   ;pullups-on (1)  (nothing (0))
        out DdrA,r17   ;(nothing (0))   output loq 0V (1)
                       ;makes bit0,2,4,6->ClockOut  bit1,3,5,7->DataOut
        ret
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
        in r17,poiema  ;reads PrtB
        ori r17,0b00011000 ;sets bit4&3  DatOut & ClkOut =default:inactive
        lsr r16        ;to send IECOUT-byte  bit0,2,4,6->carry
        brcs l12070    ;b.i.1-bit to send = inverted 0-bit

        andi r17,$f7    ;sets clkOut bit of port as active

l12070: sbis piatin,biatin ;s.i.C64-Atn=inactive
        rjmp l11960    ;5d--  read byte after Atn=active-edge  !doesn't close Talk-buffer!
                       ;never sends command-bytes => Atn is allways inactive
        lsr r16        ;bit1,3,5,7->carry
        brcs l12080     

        andi r17,$ef    ;sets DtaOut bit of port as active

l12080: in r18,Tcnt0   ;reads timer0
        cp r18,r19
        brcs l12080    ;waits
         
        out poiema,r17 ;makes bit0,2,4,6->ClockOut  bit1,3,5,7->DataOut

        ret
       #endif
;------------------------------------------------------------------------------------------------
l12090:                ;make shure that in HD-buffer there is already the first HD-sector
                       ;of the PRG
                       ;HD-buffer mustn't be changed by swapping the CBM-buffer!!!!!!!!!!!!!!
                         
                       ;r10 = second byte of word which is to sent
                       ;r11 = sector in this cluster
                       ;r12-r15=actual cluster
                       ;r16 = actual byte                                          =JiffyDOS-LOAD
                       ;r17 = DdrB  
                       ;r18 = timer0                       AVR-DataOut=Inactive
                       ;r19 = timevalues                   AVR-ClockOut=Active              DI CA
                       ;r20 = filelength                   IRQ is enabled   
                       ;r21 = filelength                   AtnAck-emulation is switched on = good
                       ;r22 = filelength
                       ;r23 = filelength
                       ;r25 = PrtB
                       ;
                       ;r28 = Y-vector low
                       ;r29 = Y-vector high
                         
                       ;400µs delay-loop is made at l11170 - l11180

                       ;C64 had read loadaddress (2 bytes), then Untalk, Talk, SA$61 
                       ;  = JD-LOAD
        
        ldi r16,$01    ;%....0001
        sts ashbtr,r16 ;actual SA HD-buffer-transfer read (0-17) 
                       ;   flags for don't read from HD into HD-buffer = request sector only
                       ;advantage of reading directly:
                       ;- faster because first storing to HD-buffer and then reading from
                       ;   HD-buffer isn't necessary
                       ;- faster because HD-buffer contains FAT => needn't be read from HD again
        sts ashbtw,r06 ;#$00 clears actual SA HD-buffer-transfer write (?necessayr?)
                        
        lds r16,fljdal ;flag JiffyDOS allowed (and flag of method how C64 reads stop-key)
        andi r16,$01   ;masks bit for way to see when C64 is ready for next block
        brne l12110    ;b.i.C64-DataOut=inactive at fb06-way 

l12100: sbis piatin,biatin ;s.i.C64-Atn=inactive    = waiting-loop-way
        rjmp l12360    ; main waiting loop  (!talk buffer isn't closed)       

        sbis piiema,bidain ;s.i.C64 makes data=Inactive (ff30)
        rjmp l12100    ;waits until C64 makes data=Inactive (fb06)  
        
l12110: ldi r25,$c0    ;c0----
        rcall l13090

        
        ;ldi r30,$00    ;$80 debugbufferbegin at LOAD (0000-007f)
        ;ldi r31,$c0    ;Z-vector =$c000 (=write load-debug-bytes into not-existing RAM)
                        ;even at 32kB external RAM there is no RAM at c000) 

        ;bst r02,0      ;debug buffer mode
        ;brtc l12120    ;b.i.not save load debug bytes
        
        ;ldi r31,high(debube) ;$10 Z-vector=$1000=vector for load-debug-bytes

l12120: ;in r16,piiema   ;IEC-bus
        ;st z+,r16       
        ;andi r30,$7f    

l12130: ldi r28,$02    ;readvector to third byte of HD buffer because staraddress is already sent
        ldi r29,high(hdbube) ;reads from 512bytes HD-buffer (not CBM-buffer)
        
        lds r20,asflre ;actual SA filelength (remaining) (for EOI-calculating)
        lds r21,asflre+1
        lds r22,asflre+2
        lds r23,asflre+3

        rjmp l12160    ;(external RAM must be on)--------
 
       #if (partname == 1) | (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/HD-routines
                       ;...............................................................sectorloop
                       ;                                                    begin read loadbuffer
l12140:                ;perhaps: start timer to compute time which C64 needs for stop-key

        rcall l14760   ;read follow-512-HD-sector of actual cluster             
                       ;but don't write into HD-buffer
   
                       ;status register                                        r16=address 
        rcall l14070   ;read status register (set correct values for 3 ports)  changes: r17
        andi r18,$08   ;masks data Request bit                                 r18=DataInLow    
        brne l12150    ;b.i.data is present                                    r19=DataInHigh

        ldi r17,$40    ;(40-- 64--)   
        rjmp syserr    ;system error 

l12150: ldi r16,idreda ;IDE register data
        out PrtD,r16   ;addresses register
                       ;                                   begin send 1 sector (512 bytes) to C64

                       ;r12-r15=actual cluster?????

                       ;r20-r23=remainig filelength
                       
                       
                       ;if first HD-buffer (at HD-buffer 0a00-0bff)
                       ; r28=vector low
                       ; r29=vector high (#$04/05)
                       ;if second, third... sector
                       ; r28=counter words (not bytes) for to read words from HD
                       ; r29=0=read first byte of word 1=read second byte of word (#$00/01)
      
      
        ldi r28,$00    ;counter 256 words in one sector
        ldi r29,$00    ;flag for first byte of this word to sent
      
        lds r20,asflre ;actual SA filelength (remaining) (for EOI-calculating)
        lds r21,asflre+1
        lds r22,asflre+2
        lds r23,asflre+3

       #if partname == 1       
        #message 162-IEC-ATA-V2
        ldi r25,$02
        out Mcucr,r25   ;exmem off ($02) = ATA-parallelports on
       #endif ;162-IEC-ATA-V2

       #endif          ;of l12140

l12160: ldi r25,$c5    ;c5--
        rcall l13130

        ;st z+,r25
        ;andi r30,$7f    
 
        ;st z+,r20
        ;andi r30,$7f    

        ;in r16,PinB
        ;st z+,r16
        ;andi r30,$7f  
        
       #if partname == 6    
        #message 644-NLQ-HD/SD
        ldi r17,$06    ;flag for JD-LOAD from AVR-RAM 
        rjmp l12370    
       .db $0          ;r17 is used by all 5 IECroutines and isn't set at begin of all 5 routines  
                
                       ;from l10030 (RTC-JD-LOAD from AVR-RAM)
                       ;=C64 makes Dta=inactive or C64 makes Atn=active
                       ;   29cycles from mainprogram when C64 makes C64-Clk=inactive to here
l12170: 

       #else 
        cli            ;disables 100Hz-IRQ  => at sd2iec the debug switch isn't polled
       #endif 
             
                       ;r10 = ATA-byte-high
                       ;r16
                       ;r17
                       ;r19
                       ;r20 = filelength   
                       ;r21 = filelength
                       ;r22 = filelength
                       ;r23 = filelength
                       ;r25 = 
                       ;
                       ;r28 = Y-vector low
                       ;r29 = Y-vector high
                       ;r30 = Zl perhaps at load-debug 
                       ;r31 = Zh perhaps at load-debug 

                       ;!!!! pay attention that r24 is unused at this subroutine !!!!
                       ;!!!! it's needed for SDonly RTC IRQ !!!!


l12180: ldi r25,$14    ;=20  =200µs                                                         DI CA
        lds r16,fljdal ;flag JiffyDOS allowed
        andi r16,$01
        breq l12200    ;b.i.waiting-loop-way    

l12190: sbis piatin,biatin ;s.i.C64-Atn=inactive    = waiting-loop-way
       #if partname == 6    
        #message 644-NLQ-HD/SD
        rjmp l11960    ;5d--  read byte after Atn=active-edge
                       ;!!!! difference !!!!
       #else  
        rjmp l12360    ;  main waiting looop       
       #endif

        sbis piiema,bidain ;s.i.C64 makes data=Inactive
        rjmp l12190    ;waits until C64 makes data=Inactive (fb06)  
        ldi r25,$06    ;60µs waitingloop because C64 needs
                       ;from making C64-DataOut=inactive (fb06)
                       ;to reading bus (fb0c)
                       ;8 + 43 (badline) = 51µs   

                       ;waits until C64 has finished stop-key-routine
                       ;and C64 is ready to receive next block
                       ; 60µs  

l12200: rcall l10840   ;200µs waiting loop because C64 must have enought time for STOP-key
                       ;routine (important if HD would read requested sector very fast 
                       ;(perhaps from cache?) and this would be shorter than 200µs)

                       ;D=I C=A => C64 is in loop at fb0c?

        ;in r16,piiema
        ;st z+,r16
        ;andi r30,$7f    

        rcall l12870   ;DataOut=Active                     (ff98)                          DA CA
        rcall l10820   ;waits 10µs
        rcall l12910   ;ClockOut=inactive                  (ff9d)                          DA CI
                       ;=> C64 leaves loop at fb0e and
                       ;branches to fb3e

        ldi r25,$08
        rcall l10840   ;80µs waiting loop             (ffa0-ffb5)

        ;in r16,PinB
        ;st z+,r16
        ;andi r30,$7f    
     
       #if (partname == 1) | (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/HD-routines
        cpi r29,$04    
        brcs l12220    ;b.i.direct-read from HD (#$00/01)
       #endif                
                       ;.................................................................byteloop

l12210: ld r16,y+      ;reads from HD-buffer $0402-05ff (=first HD-sector of LOAD)
  
       #if (partname == 1) | (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/HD-routines
          rjmp l12230    ;changes r28,r29

l12220:                ;=reads directly from IDE-HD or SD/MMC-card
                       ;read directly from HD without buffering

                       ;125ns delay  (should be >=70ns) 
    
        ;in r25,PinB
        ;st z+,r25
        ;andi r30,$7f    
 
        ;in r25,PinA
        ;st z+,r25
        ;andi r30,$7f    


        ;in r25,PinC
        ;st z+,r25
        ;andi r30,$7f    


        ;in r25,PinD
        ;st z+,r25
        ;andi r30,$7f    


        cbi poatdr,biatdr ;dioR = active (=low)

        nop
        nop
        nop            ;5*125ns=625ns delay (should be >=600ns)
        nop
        nop    
        
        ;in r25,piatdr
        ;st z+,r25
        ;andi r30,$7f    


        in r16,PinA    ;reads data0-7     = lowbyte first
        in r10,PinC    ;reads data8-15

        ;mov r25,r18
        ;st z+,r25
        ;andi r30,$7f    


        ;mov r25,r19
        ;st z+,r25
        ;andi r30,$7f    


        sbi poatdr,biatdr ;dioR =inactive (=high)
        
        ;in r25,piatdr
        ;st z+,r25
        ;andi r30,$7f    


        ;st z+,r28
        ;andi r30,$7f    

        ;st z+,r16
        ;andi r30,$7f    
       #endif

l12230: rcall l12840   ;  DataOut=inactive  r16=to sent byte                        
        rcall l12910   ;1 ClockOut=inactive  (important at first byte in loop)   (ffb5)    DI CI

        ldi r17,$08    ;1
l12240: dec r17        ;1
        brne l12240    ;3/2  
                       ;30cycles=4µs at 8MHz = enought time that data-line goes inactive 
                         


        ldi r17,$02    ;1 %.....010
        ldi r19,$10    ;1 startvalue counter

        ;in r25,PinB
        ;st z+,r25
        ;andi r30,$7f    

l12250: sbis piatin,biatin ;2 s.i.C64-Atn=inactive
       #if partname == 6    
        #message 644-NLQ-HD/SD
        rjmp l11960    ;5d--  read byte after Atn=active-edge
                       ;!!!! difference !!!!
       #else  
        rjmp l12360    ;  main waiting looop       
       #endif
                       ;                                                          uni-
                       ;                                                    1541 versal NTSC PAL
l12260: sbic piiema,bidain ;1/2  s.i.C64 makes data=active
        rjmp l12250    ;2 waits until C64 makes data=active       (ffbb)     0µs    0µs
                       ;    1 loop = 5cycles =0.63µs at 8MHz  
  
        out tccr0_,r17 ;1 #$02 %.....010 starts timer0 (8bit) with 8MHz/8 = 1count per 1µs
                       ;    (wgm make normal mode)
l12270: out Tcnt0,r19  ;1 $10 to timer0 counts up from $10                  (0µs) 0.38-1µs 
         
                       ;when C64 makes data=inactive then the AVR needs
                       ;from l12260 to l12270 3cycles =0.38µs

                       ;when the C64 makes data=inactive 0.001µs after
                       ;the AVR has read the line at l12260 then the AVR
                       ;must wait one complete loop l12250 - l12260 
                       ;=>delay is 0.38+0.63µs=1µs


        ;ldi r25,$c6   ;(c6--)
        ;st z+,r25
        ;andi r30,$7f     

        ;in r25,PinB
        ;st z+,r25
        ;andi r30,$7f       


                       ;1541 sends inverted to sent byte

        ldi r19,$19
        rcall l11980   ;sends bit 0&1                             (ffbd)    06-0d $09µs    D1 C0
        
        ldi r19,$23    
        rcall l11980   ;sends bit 2&3                             (ffc4)    10-17 $13µs    D3 C2
        
        ldi r19,$2e    
        rcall l11980   ;sends bit 4&5                             (ffcc)    1b-22 $1eµs    D5 C4

        ldi r19,$38    
        rcall l11980   ;sends bit 6&7                             (ffd3)    25-2c $28µs    D7 C6

        rcall l10820   ;waits 10µs (1541 holds bit 7&6 at IECOUT 10µs long
                       ;=> this must be enough also at JD-LOAD) 
          
        subi r20,$01   ;decrements remaing filelength by 1
        sbci r21,$00
        sbci r22,$00
        sbci r23,$00

        mov r19,r20
        or r19,r21
        or r19,r22
        or r19,r22
        breq l12300    ;b.i.last byte =EOI (r19=#$00 = flag that EOI finished loop)
   
       #if (partname == 1) | (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/HD-routines
        cpi r29,$04
        brcs l12280    ;b.i.#$00/01 = directly read from HD
       #endif
          
                       ;=#$04/05 = b.i.first load-sector=load from HD-buffer (AVR-RAM)
        cpi r29,high(hdbuen) ;#$04/05  = copy from HD-buffer (not CBM-buffer)
        brne l12210    ;.........byteloop (external RAM off)
    
                       ;=end of first sector (in AVR-RAM)
        rjmp l12290    ;end of first sector

        #if (partname == 1) | (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/HD-routines
l12280:                ;=copy directly from HD (without buffering)
        mov r16,r10    ;copies highbyte to lowbyte of from HD read word
        inc r29        ;increments flag for first/second byte of received word  
        andi r29,$01
        brne l12230    ;send second byte of received word
        
        dec r28        ; (external RAM on)  
        brne l12220    ;next word in this HD-sector......................................byteloop
       #endif 

l12290:                ;=end of 1 sector
        ldi r19,$01    ;flag that end of 1 sector finished loop  
                   
l12300:                ;                                         = end of load or end of 1 sector
                       ;                                             |  |   |       |  | | |
                       ;                                             r19=#$00       r19=#$01
       #if partname == 1     
        #message 162-IEC-ATA-V2
        out PrtD,r07  ;addressregister to high (saves energy?)
       #endif ;162-IEC-ATA-V2

       #if (partname == 4) | (partname == 7)    
        #message 644-NLQ-HD/lite-lite & full
        ldi r25,idrecs ;IDE register command/status  %..111111  = also value for inactive
        out PrtD,r25
       #endif ;644-NLQ-HD/lite-lite & full

       #if partname == 1       
        #message 162-IEC-ATA-V2 
        ldi r25,$82
        out Mcucr,r25  ;exmem on
       #endif ;162-IEC-ATA-V2

        sts asflre,r20 ;actual SA filelength (remaining) (for EOI-calculating)
        sts asflre+1,r21
        sts asflre+2,r22
        sts asflre+3,r23
                       ;read next HD-block from HD = end of 512 bytes HD-sector
                       ;loop must be finished if:
                       ; - 512 bytes sector is transmitted
                       ; - last byte was sent (Then EOI must still be made) 
                      
        ;ldi r25,$c8    ;(c8--)               
        ;mov r03,r25
        ;st z+,r25
        ;andi r30,$7f  
        
        rcall l12880   ;ClockOut=Active       (about 11µs later than bit    30-37 $33µs 
        rcall l12840   ;DataOut=Inactive   (ffdb)    7&6 set to bus)                    
        rcall l10820   ;waits 10µs                                                         DI CA
         
        ;ldi r25,$c9    ;(c9--)
        ;mov r03,r25        
        ;st z+,r25
        ;andi r30,$7f    

        ;in r25,PinB
        ;st z+,r25 
        ;andi r30,$7f    

l12310: sbis piatin,biatin ;s.i.C64-Atn=inactive (=l27350)
       #if partname == 6    
        #message 644-NLQ-HD/SD
        rjmp l11960    ;5d--  read byte after Atn=active-edge
                       ;!!!! difference !!!!
       #else  
        rjmp l12350    ; close talkbuffer -> main waiting looop       
       #endif

        sbic piiema,bidain ;s.i.C64 makes data=active
        rjmp l12310    ;waits until C64 makes data=active (fb51)  

        sei            ;enable 100Hz-IRQ----------------------------------------

        ;ldi r25,$ca    ;(ca--)
        ;mov r03,r25        
        ;st z+,r25 
        ;andi r30,$7f    
        
        ;in r25,PinB
        ;st z+,r25
        ;andi r30,$7f    

       #if partname == 6    
        #message 644-NLQ-HD/SD
        lds r25,airtmb ;AVR-internal-RTC-mode-bits
                       ;7=sleep-IRQ finished routine
                       ;6=reset-IRQ finished routine
                       ;5=watchdog time-out finished routine
                       ;4=IEC-error finished routine 
                       ;3=IEC-Atn-change finished routine (in databyte-mode but AtnIn=active)
                       ;2=IEC-Atn-change finished routn (in commandbyte-mode but AtnIn=inactive)
                       ;1=normal end of routine

                       ;0= 0=RTC-values changed by timer2-IRQ   (direct-IEC- & IRQ-RTC-mode)
                       ;   1=RTC-values changed by mainprogram  IRQ-IEC- & direct-RTC-mode
        ori r25,$02    ;sets bit that normal end of routine finished routine
        sts airtmb,r25 ;AVR-internal-RTC-mode-bits      
        out Sreg,r08   ;restores status register 
        ret            ;r16=#$01 =end of 1 sector finished loop 

l12320:
       #endif        

        cpi r19,$00    ;flag whether EOI or end of 1 sector finished loop
        breq l12340    ;b.i.EOI finished loop

                       ;=end of 1 sector finished loop
        ldi r25,$cb    ;cb--                                                               DI CA
        rcall l13130
       
        ;st z+,r25
        ;andi r30,$7f    
      
        ;in r25,PinB
        ;st z+,r25
        ;andi r30,$7f    

       #if partname == 1    
        #message nlq-hd/IEC-ATA
        rjmp l12140    ;noEOI = load next sector from HD
       #endif
 
       #if partname == 3
        #message 644-NLQ-HD/sd2iec
        jmp l27210     ;to SMC-routine  
       #endif 
     
       #if partname == 4    
        #message nlq-hd/lite
        rjmp l12140    ;noEOI = load next sector from HD
       #endif

       #if partname == 6
        #message 644-NLQ-HD/sdhw
        jmp l27210     ;to SMC-routine  
       #endif 

       #if partname == 7
        #message 644-NLQ-HD/full
        lds r16,acemen ;actual emulated entry 0,1,2
                       ; 0=IDE-HD    master
                       ; 1=IDE-CDROM slave (not supported)
                       ; 2=SD/MMC-card
        cpi r16,$02
        brne l12330    ;b.i.not SD/MMC-card

        jmp l27210     ;to SMC-routine 

l12330: rjmp l12140    ;noEOI = load next sector from HD
       #endif 

                       ;noEOI = load next sector from HD/SD............................sectorloop
                       ;from l27390
l12340:                ;=EOI
        ldi r25,$0a    ;=10                  AVR-DataOut=Inactive  AVR-ClockOut=Active
        rcall l10840   ;100µs waiting loop                            (ff65)

        rcall l12910   ;ClockOut=inactive                             (ff65)               DI CI

        ldi r25,$0a    ;=10
        rcall l10840   ;100µs waiting loop                            (ff68)

        rcall l12880   ;ClockOut=Active                               (ff6b)               DI CA

        ldi r25,$0a    ;=10
        rcall l10840   ;100µs waiting loop                       (ff6e-ff71)

        rcall l12910   ;ClockOut=inactive                             (ff73)               DI CI

        ldi r25,$cc    ;cc-- 
        rcall l13130
        ;st z+,r25
        ;andi r30,$7f    

        ;in r16,PinB
        ;st z+,r16
        ;andi r30,$7f    


        ;in r16,PinB
        ;st z+,r16
        ;andi r30,$7f    

        ;ldi r25,$cd
        ;st z+,r25
        ;andi r30,$7f    

l12350: rcall l13880   ;ok-message into errorbuffer  (probably not neccessary????)
     
        ;lds r16,c6cor0
        ;cpi r16,$01
        ;brne l12360
       
        ;ldi r25,$10   ;10--
        ;jmp freeze

l12360: jmp l25290     ;to main-waiting-loop                                          end JD-LOAD
;------------------------------------------------------------------------------------------------
       #if partname == 6    
        #message 644-NLQ-HD/SD
                       ;                                              IRQ-routines for SDonly RTC
                       ;
.db $0


                       ;from l11450 (CBM-IECIN), l11720 (CBM-IECOUT)
                       ;     l
l12370:                ;                                     SDonly RTC-IRQ-routine for CBM-IECIN
                       ;                                     mustn't change r16
        push r24       ;backup r24 to stack
                       ;r24 is the only register with immediate-access which isn't used at
                       ; CBM-IECIN, JD-IECIN, CBM-IECOUT, JD-IECOUT and JD-LOAD
                       ;=> r24 must be used here
                       ;it's possible that r24 is used by the mainprogram above
       ;push r08       ;r08 is used at the IRQ-routine to backup the status-register
                       ; because r08 isn't used (so far) by a mainprogram 
                       ;  it needn't be backuped here
                       ; if r08 would be used => would be have to backuped here

        push r30       ;backup Z
        push r31

        ldi r25,$01
        sts airtmb,r25 ;AVR-internal-RTC-mode-bits
                       ;7=sleep-IRQ finished routine
                       ;6=reset-IRQ finished routine
                       ;5=watchdog time-out finished routine
                       ;4=IEC-error finished routine 
                       ;3=IEC-Atn-change finished routine (in databyte-mode but AtnIn=active)
                       ;2=IEC-Atn-change finished routn (in commandbyte-mode but AtnIn=inactive)
                       ;1=normal end of routine
                       ;0= 0=RTC-values changed by timer2-IRQ   (direct-IEC- & IRQ-RTC-mode)
                       ;   1=RTC-values changed by mainprogram  IRQ-IEC- & direct-RTC-mode
       
        sts airtmr,r17 ;AVR-internal-RTC-mainroutine               
                       ;     0=illegal
                       ;     1=illegal
                       ;     2=CBM-IECIN
                       ;     3=CBM-IECOUT
                       ;     4=JD-IECIN
                       ;     5=JD-IECOUT
                       ;     6=JD-LOAD
                       ;     7-ff=illegal
      
        ldi r25,$e8    ;e8--
        rcall l13130

        mov r25,r17    ;-- airtmr
        rcall l13130
 
        in r25,Spl     ;stackpointer low                       
        dec r25        ;stackpointer shows to this routine level
        dec r25     
        sts airtsl,r25 ;AVR-internal-RTC-stackpointer-low
                       ;all following commands must be made without any soubroutine
                       ; because else the stored stackpointer would be wrong
                       ;the IRQ pushes two bytes to the stack = this is the return-address
                       ; to this main-program above
    
        rcall l13130   ;-- airtsl

        in r30,Spl     
        ldi r31,$01
        subi r30,$100-$04 ;adds #$04
                       ;remove pos of free stackposition and remove push r24, push r30, push r31
                       ;Z shows now to returnaddress of routine which made call IEC...
        ld r25,z+
        rcall l13130   ;-- returnaddress high of routine which made call IEC...

        ld r25,z+
        rcall l13130   ;-- returnaddress low of routine which made call IEC...

        ldi r30,low(l10030-2) ; begin of ijmp-table of IEC-routines
        ldi r31,high(l10030-2)
        add r30,r17    ;adds offset to correct routine
        adc r31,r06    ;#$00 adds carry

        mov r25,r30    ;-- ijmp-vector 02 $26 $43 RTC-CBM-IECIN 
        rcall l13130   ;               03 $27 $44 RTC-CBM-IECOUT
                       ;               04 $28 $45 RTC-JD-IECIN 
        mov r25,r31    ;--
        rcall l13130

        cli            ;disable IRQs
        wdr            ;reset watchdog  
        ldi r25,0b00111000
        sts wdtcsr,r25 ;Watchdog Timer Control Register
                       ;7:   wdif Watchdog Interrupt Flag
                       ;6:   WDIE Watchdog Interrupt Enable
                       ;5:   wdp3 Watchdog Timer Prescaler 3
                       ;4    WDCE Watchdog Change Enable
                       ;3:   WDE  Watchdog System Reset Enable
                       ;2-0: WDP2-0: Watchdog Timer Prescaler 2, 1 and 0
                       ;             pdp3-0=%0101 = 0.5s  (%1000 would be 4s!!!!!!!)
                       ;wdce=1 and wdw=1 => allows changig of the watchdog
        
        ldi r25,0b11100000
        sts wdtcsr,r25 ;allows watchdog-IRQs 0.5s (this sts must be within 4cycles)
                       ;this clears perhaps also the watchdog-IRQ-bit wdif (writing a 1 to it)? 

        ldi r25,$05
        sts iratin,r25 ;disable AtnIn-IRQs (int1) 
                       ;sleep-IRQ and reset-switch-IRQ stay enabled  

        sts timsk2,r06 ;#$00 Timer/Counter2 Interrupt Mask Register
                       ;disable RTC-timer2-IRQs                      

        sts timsk1,r06 ;Timer/Counter1 Interrupt Mask Register
                       ;disable 100Hz-timer1-IRQs                      
        cpi r17,$02
        brne l12380

                       ;=CBM-IECIN
        ldi r25,$20    ;enables bit5 of portB as IRQ-trigger = DtaIn 
        sts pcmsk1,r25 ;Pin Change Mask Register 1
       
        ldi r25,$02
        sts pcicr,r25  ;Pin Change Interrupt Control Register    enable PortB-IRQ
                       ;also flag that RTC-IEC-mainroutines (not -subroutine) is executed
       
        sts pcifr,r25  ;Pin Change Interrupt Flag Register   clears old IRQ-flag
        out DdrA,r06   ;#$00  DtaOut:a->i   (ClkOut stays i)
        out PrtA,r07   ;#$ff
        sei            ;enables IRQs...................................IRQ-enabled..............
                       ;             => all registers (exept r24) can be changed
        rjmp l12520

l12380: cpi r17,$03
        brne l12420
                       ;=CBM-IECOUT
                       ;problem: could happen that C64 makes C64-DtaOut from active to inactive
                       ; between l11720 and l12380 => the Dta-edge-IRQ could be lost
                       ; (C64 makes C64-DtaOut=inactive only if there is an error) 
 
        ldi r25,$28    ;enables bit5 of portB as IRQ-trigger = DtaIn 
                       ;        bit3 of PortB as IRQ-trigger = AtnIn
        sts pcmsk1,r25 ;Pin Change Mask Register 1
       
        ldi r25,$02
        sts pcifr,r25  ;Pin Change Interrupt Flag Register   clear old IRQ-flag
                       ;when C64 makes C64-DtaOut from active to inactive after this command
                       ; then the Dta-edge-IRQ isn't lost = good
        in r25,piiema 
        andi r25,1<<biatin
        breq l12400    ;b.i.C64 makes C64-AtnOut=active = e.g.at untalk
                   
        tst r16
        brmi l12390    ;b.i.C64 made C64-DtaOut=inactive even before l10660

        in r25,piiema 
        andi r25,1<<bidain
        breq l12410    ;b.i.C64 makes C64-DtaOut=active = ok

l12390:                ;=C64 made or makes C64-DtaOut=inactive too early
                       ;  or C64 makes Atn=active    
  
        ori r16,$80    ;sets bit that C64 made C64-DtaOut=inactive too early
                       ;reset-switch-IRQ and time-out-IRQ is enabled at l10060
      
l12400: ldi r25,$e9    ;e9--
        rcall l13130

        mov r25,r16    ;--
        rcall l13130

        out DdrA,r06   ;#$00  ClkOut:a->i   (DtaOut stays i)
        out PrtA,r07   ;#$ff
        call l10060    ;C64 made C64-DtaOut=inactive too early (=error?)
                       ;=> there will be no Dta-edge-IRQ
                       ;jump directly to pin-change-IRQ
                       ;-> l11740
        rjmp l12520

l12410: ldi r25,$02
        sts pcicr,r25  ;Pin Change Interrupt Control Register    enable PortB-IRQ
                       ;also flag that RTC-IEC-mainroutines (not -subroutine) is executed
       
        out DdrA,r06   ;#$00  ClkOut:a->i   (DtaOut stays i)
        out PrtA,r07   ;#$ff
        sei            ;enables IRQs...................................IRQ-enabled..............
                       ;             => all registers (exept r24) can be changed
                       ;-> l11740
        rjmp l12520    ;2

l12420: cpi r17,$04
        brne l12460 
 
                       ;=RTC-JD-IECIN
        ldi r25,$88    ;enables bit7 of portB as IRQ-trigger = ClkIn 
                       ;        bit3 of PortB as IRQ-trigger = AtnIn
        sts pcmsk1,r25 ;Pin Change Mask Register 1
       
        ldi r25,$02
        sts pcifr,r25  ;Pin Change Interrupt Flag Register   clear old IRQ-flag
                       ;when C64 makes C64-DtaOut from active to inactive after this command
                       ; then the Dta-edge-IRQ isn't lost = good
        in r25,piiema 
        andi r25,1<<biatin
        breq l12440    ;b.i.C64 makes C64-AtnOut=active 
    
        andi r16,1<<biclin ;masks IECClockIn (before)
        brne l12440    ;b.i.C64 makes Clock=inactive (=C64error) (!AVR made AVR-DataOut=inactive
                       ;b.i.C64 made C64-ClkOut=inactive even before l11640
                       ;     => if C64 wants to send the next command-byte then C64 could think
                       ;         that AVR-DataOut=inactive is flag that AVR is ready 
                       ;         => C64 could begin to send next byte  = bad           

        in r25,piiema 
        andi r25,1<<biclin
        breq l12450    ;b.i.C64 makes C64-ClkOut=active = ok

l12430:                ;=C64 made or makes C64-ClkOut=inactive too early
                       ;  or C64 makes Atn=active    
  
        ori r16,1<<biclin ;sets bit that C64 made C64-ClkOut=inactive too early
                       ;reset-switch-IRQ and time-out-IRQ is enabled at l10060
      
l12440: ldi r25,$ea    ;ea--
        rcall l13130

        mov r25,r16    ;--
        rcall l13130

        out DdrA,r06   ;#$00  DtaOut:a->i   (ClkOut stays i)
        out PrtA,r07   ;#$ff
        call l10060    ;C64 made C64-ClkaOut=inactive too early (=error?)
                       ;=> there will be no Clk-edge-IRQ
                       ;jump directly to pin-change-IRQ
                       ;-> l11650
        rjmp l12520

l12450: ldi r25,$02
        sts pcicr,r25  ;Pin Change Interrupt Control Register    enable PortB-IRQ
                       ;also flag that RTC-IEC-mainroutines (not -subroutine) is executed
       
        out DdrA,r06   ;#$00  DtaOut:a->i   (ClkOut stays i)
        out PrtA,r07   ;#$ff
        sei            ;enables IRQs...................................IRQ-enabled..............
                       ;             => all registers (exept r24) can be changed
                       ;-> l11650
        rjmp l12520    ;2

l12460: cpi r17,$05
        brne l12490 
 
                       ;=RTC-JD-IECOUT
        ldi r25,$28    ;enables bit5 of portB as IRQ-trigger = DtakIn 
                       ;        bit3 of PortB as IRQ-trigger = AtnIn
        sts pcmsk1,r25 ;Pin Change Mask Register 1
       
        ldi r25,$02
        sts pcifr,r25  ;Pin Change Interrupt Flag Register   clear old IRQ-flag
                       ;when C64 makes C64-DtaOut from active to inactive after this command
                       ; then the Dta-edge-IRQ isn't lost = good
        in r25,piiema 
        andi r25,1<<biatin
        breq l12470    ;b.i.C64 makes C64-AtnOut=active 
    
        in r25,piiema 
        andi r25,1<<bidain
        breq l12480    ;b.i.C64 makes C64-DtaOut=active = ok

l12470:                ;=C64 made or makes C64-DtaOut=inactive too early
                       ;  or C64 makes Atn=active    
      
        ldi r25,$eb    ;eb--
        rcall l13130

        out DdrA,r06   ;#$00  ClkOut:a->i   (DtaOut stays i)
        out PrtA,r07   ;#$ff
        rcall l10060   ;C64 made C64-DtaOut=inactive too early (=error?)
                       ;=> there will perhaps be no Dta-edge-IRQ
                       ;jump directly to pin-change-IRQ
                       ;-> l11890
        rjmp l12520

l12480: ldi r25,$02
        sts pcicr,r25  ;Pin Change Interrupt Control Register    enable PortB-IRQ
                       ;also flag that RTC-IEC-mainroutines (not -subroutine) is executed
       
        out DdrA,r06   ;#$00  ClkOut:a->i   (DtaOut stays i)
        out PrtA,r07   ;#$ff
        sei            ;enables IRQs...................................IRQ-enabled..............
                       ;             => all registers (exept r24) can be changed
                       ;-> l11890
        rjmp l12520    ;2

l12490: cpi r17,$06
        brne l12500 

        rcall l10060   ;=RTC-JD-LOAD from AVR-RAM 
        rjmp l12520

l12500: cpi r17,$07
        brne l12510 
                   
        rcall l10060   ;=RTC-JD-LOAD from SD-card 
        rjmp l12520     

l12510: ldi r25,$af    ;af--
        jmp freeze

l12520:                ;!!!! IEC-routines mustn't change r24 and r08 !!!!!!!!!
        wdr
        lds r24,airtmb ;AVR-internal-RTC-mode-bits
                       ;7=sleep-IRQ finished routine
                       ;6=reset-IRQ finished routine
                       ;5=watchdog time-out finished routine
                       ;4=IEC-error finished routine 
                       ;3=IEC-Atn-change finished routine (in databyte-mode but AtnIn=active)
                       ;2=IEC-Atn-change finished routn (in commandbyte-mode but AtnIn=inactive)
                       ;1=normal end of routine
                       ;0= 0=RTC-values changed by timer2-IRQ   (direct-IEC- & IRQ-RTC-mode)
                       ;   1=RTC-values changed by mainprogram  IRQ-IEC- & direct-RTC-mode
        cpi r24,$02
        brcs l12530    ;b.i.IRQ-routine not yet made

        rjmp l12620    ;IRQ made IRQ-routine and set endflag

l12530: lds r24,tifr2  ;Timer/Counter2 Interrupt Flag Register
        andi r24,04    ;masks output compare B IRQ
        breq l12520    ;b.i.RTC-timer2 not yet counted to end

        ldi r24,$07     ;clear all IRQ-bits of timer2 
        sts tifr2,r24   ;important because RTC-timer2 sleep-routine uses output compare A-IRQ 
      
        sts airthu,r06 ;clears AVRinternal hundredth  !!delete this    compute hundredth from
                       ;                                 TCNT2  Timer/Counter Register
                       ;                                 0-31 -> 3/100 - 96/100 in 3/100-steps      
        lds r24,airtse ;seconds--------
                       ;......................................................   
        cbi polert,bilert ;prt LED-RTC
        sbi ddlert,bilert ;= malkes LED-RTC=on=output         LED-RTC-on=default for odd           
        bst r24,0      ;copies even-/odd-bit of seconds to T-flag
        brts l12540    ;b.i.odd  

        cbi ddlert,bilert ;=even                              LED-RTC-off=even
        sbi polert,bilert ;prt LED-RTC pullupon      usually there is no LED at the debug-pin
                       ; => the pullup-resistor must be activated to prevent swinging 
l12540:                ;......................................................   
        subi r24,$100-06 ;add #$06 seconds  subroutines aren't allowed=>this routine exists twice
        sts airtse,r24
        cpi r24,$3c    ;60
        brcc l12560    ;b.i.60

l12550: rjmp l12610    ;=0-59

l12560: sts airtse,r06
     
        lds r24,airtmi ;minutes--------
        inc r24
        sts airtmi,r24
        cpi r24,$3c    ;60
        brcs l12550    ;b.i.0-59

        sts airtmi,r06
     
        lds r24,airtho ;hours---------
        inc r24
        sts airtho,r24
        cpi r24,$18    ;24
        brcs l12550    ;b.i.0-23

        sts airtho,r06
     
        lds r24,airtda ;days--------
        inc r24
        sts airtda,r24
        cpi r24,$1d    ;29
        brcs l12600    ;b.i.1-28

                       ;=day=29-32
        bst r24,0      ;copies bit0 to T-flag 30,32->T=low  29,31->T=high
        cpi r24,$1f    ;31
        lds r24,airtmo
        brcc l12570    ;b.i.31, 32
                       
                       ;=day=29-30
        cpi r24,$02
        brne l12600    ;b.i.not february

                       ;=february
        brtc l12590    ;b.i.30.02

        lds r24,airtyl ;year-low 0-255
        andi r24,$03
        breq l12590    ;b.i.29.02.2000,2004,2008,2012,2016...2100

        rjmp l12600

l12570:                ;=day=31,32
        brtc l12590    ;b.i.32.xx.20yy
                       ;                            1 2 3   5   7 8   10    12
                       ;=day=31  month with 30days:       4   6     9    11
        cpi r24,$08
        brcs l12580
                 
        dec r24        ;                                          7    9    11                                      
                       ;                                            8    10
l12580: andi r24,$01   ;masks even/odd-bit
        brne l12600    ;b.i.odd month (february branched before)
 
l12590: ldi r24,$01
        sts airtda,r24 ;day=1 
     
        lds r24,airtmo ;months--------
        inc r24
        sts airtmo,r24
        cpi r24,$0d    ;13
        brcs l12600    ;b.i.1-12

        ldi r24,$01
        sts airtmo,r24
     
        lds r24,airtyl ;year-low 0-255 (hexdec)  year:0-65535--------
        inc r24
        sts airtyl,r24        
        brne l12600

        lds r24,airtyh ;year-low 0-255 (hexdec)  year:0-65535
        inc r24
        sts airtyh,r24        

l12600: lds r24,airtwd ;weekdays (0-6)--------
        inc r24
        sts airtwd,r24
        cpi r24,$07    ;7
        brcs l12610    ;b.i.0-6

        ldi r24,$00
        sts airtwd,r24

l12610: rjmp l12520   ;---------

l12620: cli
        ldi r25,0b00111000
        sts wdtcsr,r25 ;Watchdog Timer Control Register
                       ;7:   wdif Watchdog Interrupt Flag
                       ;6:   WDIE Watchdog Interrupt Enable
                       ;5:   wdp3 Watchdog Timer Prescaler 3
                       ;4    WDCE Watchdog Change Enable
                       ;3:   WDE  Watchdog System Reset Enable
                       ;2-0: WDP2-0: Watchdog Timer Prescaler 2, 1 and 0
                       ;             pdp3-0=%0101 = 0.5s 
                       ;wdce=1 and wdw=1 => allows changig of the watchdog
        
        ldi r25,0b00100000
        sts wdtcsr,r25 ;disables watchdog-IRQs (this sts must be within 4cycles)

        sei            ;=> IRQ executed f9-- fa-- fb-- fc-- fd-- fe--

        ldi r25,$04
        sts timsk2,r25 ;Timer/Counter2 Interrupt Mask Register
                       ;bit0 = Timer/Counter2 Overflow Interrupt Enable
                       ;bit1 = Timer/Counter2 Output Compare Match A Interrupt Enable (sleep)
                       ;bit2 = Timer/Counter2 Output Compare Match B Interrupt Enable (awake)
                       ;=RTC-IRQ        

        ldi r25,$02
        sts timsk1,r25 ;Timer/Counter1 Interrupt Mask Register
                       ;bit1 = Timer/Counter1 Output Compare Match A Interrupt Enable
                       ;=100Hz-IRQ
                       ;=> IRQ is made at once here 
        ldi r25,$07
        sts iratin,r25 ;enabale AtnIn-IRQs (int2) 
                       ;if Atn-active-edge: IRQ is made at once (and DtaOut=active)
        pop r31        ;restore Z
        pop r30

        ;pop r08       ;restore r08
        pop r24        ;restore r24


/*
        ldi r25,$ee    ;ee--
        rcall l13130

        lds r25,airtmb ;----
        rcall l13130
    
        lds r25,airtmr ;----
        rcall l13130

        in r25,DdrA    ;xx-- DdrA
        call l13090 
        in r25,PrtA    ;xx-- PrtA 
        call l13090 
        in r25,PinA    ;xx-- PinA
        call l13090 
       
        in r25,DdrB    ;xx-- DdrB
        call l13090 
        in r25,PrtB    ;xx-- PrtB 
        call l13090 
        in r25,PinB    ;xx-- PinB
        call l13090 

                       ;if these toutines are made then the AVR is so slow
                       ;that it cannot detect that the C64 made Atn=inactive after having
                       ; sent the SA and waits at l????? in an endlesslopp
*/

        lds r25,airtmb ;AVR-internal-RTC-mode-bits
                       ;7=sleep-IRQ finished routine
                       ;6=reset-IRQ finished routine
                       ;5=watchdog time-out finished routine
                       ;4=IEC-error finished routine 
                       ;3=IEC-Atn-change finished routine (in databyte-mode but AtnIn=active)
                       ;2=IEC-Atn-change finished routn (in commandbyte-mode but AtnIn=inactive)
                       ;1=normal end of routine
                       ;0= 0=RTC-values changed by timer2-IRQ   (direct-IEC- & IRQ-RTC-mode)
                       ;   1=RTC-values changed by mainprogram  IRQ-IEC- & direct-RTC-mode
        cpi r25,$03
        breq l12690    ;b.i.normal end of IEC-routine
                
                       ;unnormal end of RTC-IEC-routine

        ldi r25,$ef    ;ef--
        rcall l13130

        lds r25,airtmb ;----
        rcall l13130
    
        lds r25,airtmr ;----
        rcall l13130
 
        lds r25,airtsl ;----
        rcall l13130

        lds r25,airtmb

        sts airtmb,r06 ;AVR-internal-RTC-mode-bits
        sts airtmr,r06 ;AVR-internal-RTC-mainroutine
        sts airtsl,r06 ;AVR-internal-RTC-stackpointer-low

        bst r25,7      ;copies sleep-IRQ-bit to T-flag
        brtc l12630    ;b.i.no sleep-irq

        rjmp l10130    ;sleep-routine

l12630: bst r25,3      ;copies IEC-Atn-change-IRQ-bit to T-flag
        brtc l12640    ;b.i.no IEC-Atn-change-irq

                       ;=in databyte-mode but AtnIn=active
                       ;= C64 changed Atn from inactive to active
        rjmp l10860    ;reads byte after Atn-edge  = change from data- to Atn-mode-------- 

l12640: bst r25,2      ;copies IEC-Atn-change-IRQ-bit to T-flag
        brtc l12650    ;b.i.no IEC-Atn-change-irq

                       ;=in commandbyte-mode but AtnIn=inactive
                       ;= C64 changed Atn from active to inactive
        rjmp l11320    ;to routine at end of Atn !!stack is at C64 wrong!!---------

l12650: bst r25,4      ;copies IEC-error-bit to T-flag
        brtc l12670    ;b.i.no IEC-error-irq

l12660:                ;=IEC-error or watchdog-timeout
        rjmp l11870    ;to main-waiting-loop = made at CBM-ICEOUT-error
                       ;at CBM-IECIN there is no IEC-error
                       ; so I don't know what to do at a watchdog timeout????????????
   
l12670: bst r25,5      ;copies watchdog-timeout-IRQ-bit to T-flag
        brts l12660    ;b.i.watchdog-timeout-irq

        bst r25,6      ;copies reset-IRQ-bit to T-flag
        brtc l12680    ;b.i.no reset-IRQ

        rjmp l10100    ;PD3 INT1 reset-pin  hardware reset

l12680: ldi r25,$f1    ;f1--
        rjmp freeze    ;-----------------------------------

l12690:                ;= normal end of IEC-routine
        ldi r25,$ee    ;ee--
        rcall l13130

        lds r25,airtmb ;----
        rcall l13130
    
        lds r25,airtmr ;----
        rcall l13130

        lds r25,airtsl ;----
        rcall l13130

        in r25,DdrA    ;xx-- DdrA
        call l13090 
        in r25,PrtA    ;xx-- PrtA 
        call l13090 
        in r25,PinA    ;xx-- PinA
        call l13090 
       
        in r25,DdrB    ;xx-- DdrB
        call l13090 
        in r25,PrtB    ;xx-- PrtB 
        call l13090 
        in r25,PinB    ;xx-- PinB
        call l13090 

        lds r25,airtmr ;AVR-internal-RTC-mainroutine               
                       ;     0=illegal
                       ;     1=illegal
                       ;     2=CBM-IECIN
                       ;     3=CBM-IECOUT
                       ;     4=JD-IECIN
                       ;     5=JD-IECOUT
                       ;     6=JD-LOAD
                       ;     7-ff=illegal
       
        sts airtmb,r06 ;AVR-internal-RTC-mode-bits
        sts airtmr,r06 ;AVR-internal-RTC-mainroutine
        sts airtsl,r06 ;AVR-internal-RTC-stackpointer-low

l12700: cpi r25,$06
        brne l12710
                      ;06 RTC-JD-LOAD from AVR-RAM
        rjmp l12320   ;to end of load

l12710: cpi r25,$07
        brne l12720

                      ;07 RTC-JD-LOAD from SD-card directly
        jmp l27360    ;to LOAD next sector from SD-card-routine

l12720: ret            ;02 CBM-IECIN: flags don't matter   r16=r17=IECIN-byte
                       ;03 CBM-IECOUT: flags don't matter
                       ;04 JD-IECIN: flags don't matter   r16=r17=IECIN-byte
                       ;05 JD-IECOUt: flags don't matter
                       
                                         
                       ;           return to routine which made 
                       ;                rcall IECIN, rcall l11430, rcall l11440 
                       ;           return to l10880, l13570, l13710
                       
                       ;problem at NLQHD-SD JD-LOAD-test:  
                       ;problem: when C64 makes Atn = active but leaves Clk = inactive
                       ; then NLQHD-SD makes the IECIN-rputine -> watchdog ends IECIN-routine ->
                       ; AVR goes toroutine after receive Atn-edge -> AVR wants to read next next
                       ; IECIN-byte _> AVR reads jumps endless to IECIN-routine
       #endif       
;------------------------------------------------------------------------------------------------
       #if ((partname >= 3) & (partname <= 7))
        #message 644-NLQ-HD/all
                       ;from l25710
                       ;r16 = - #$08 for swap with devicenumber 8
                       ;      - #$09 for swap with devicenumber 9   
l12730:                ;                                                              device-swap
        ldi r25,$ee    ;ee--
        rcall l13130

        mov r25,r16    ;----
        rcall l13130
     
        lds r25,acemen ;----
        rcall l13130

        lds r25,tadenu ;----
        rcall l13130
 
        lds r25,tadenu+2 ;----
        rcall l13130

        subi r16,$0100-$60 ;add #$60  #$08->$68   #$09->$69  
     
        mov r25,r16    ;----
        rcall l13130
 
        ldi r28,$09    ;table device numbers of HD in EEPROM
        ldi r29,$00
        rcall l13770   ;EEPROM read
        mov r25,r20    ;----
        rcall l13130

        ldi r28,$0b    ;table device numbers of HD in EEPROM
        ldi r29,$00
        rcall l13770   ;EEPROM read
        mov r25,r20    ;----
        rcall l13130

       #if partname == 3
        #message 644-NLQ-HD/SD2IEC
        lds r26,tadenu+2 ;table device numbers for SD
                             ;7 = 0=present 1=not present (this device entry)
                             ;6 = 0=no Talker (e.g.printer) 1=Talker
                             ;5 = 0=no Listener 1=Listener
                             ;4-0 =devicenumber (4/8-30)
  
        cp r16,r26
        brne l12740    ;b.i.wanted devicenumber <> actual devicenumber
        
                       ;=wanted devicenumber = actual devicenumber  
                       ;=a swap-command was before => the devicenumbers are already swapped
                       ;   => reswap to old values
   
        mov r26,r16    ;new devicenumber of external floppy #$08/09
        ldi r28,$0b    ;table device numbers of SD in EEPROM
        ldi r29,$00
        rcall l13770   ;EEPROM read
        mov r16,r20    ;new devicenumber of this AVR

l12740: sts tadenu+2,r16 ;table device numbers for SD
        mov r27,r26
        andi r26,$bf   ;$68->$28 $7e->3e    
        andi r27,$df   ;$68->$48 $7e->$5e
       #endif

       #if (partname == 4) | (partname == 5)
         #message 644-NLQ-HD/lite
        lds r26,tadenu ;table device numbers for HD
        cp r16,r26
        brne l12750    ;b.i.wanted devicenumber <> actual devicenumber
        
                       ;=wanted devicenumber = actual devicenumber  
                       ;=a swap-command was before => the devicenumbers are already swapped
                       ;   => reswap to old values
   
        mov r26,r16    ;new devicenumber of external floppy #$08/09
        ldi r28,$09    ;table device numbers of HD in EEPROM
        ldi r29,$00
        rcall l13770   ;EEPROM read
        mov r16,r20    ;new devicenumber of this AVR

l12750: sts tadenu,r16 ;table device numbers for HD
        mov r27,r26
        andi r26,$bf   ;$68->$28 $7e->3e    
        andi r27,$df   ;$68->$48 $7e->$5e
       #endif
 
       #if partname == 6    
        #message 644-NLQ-HD/SD
        lds r26,tadenu+2 ;table device numbers for SD
        cp r16,r26
        brne l12760    ;b.i.wanted devicenumber <> actual devicenumber
        
                       ;=wanted devicenumber = actual devicenumber  
                       ;=a swap-command was before => the devicenumbers are already swapped
                       ;   => reswap to old values
   
        mov r26,r16    ;new devicenumber of external floppy #$08/09
        ldi r28,$0b    ;table device numbers of SD in EEPROM
        ldi r29,$00
        rcall l13770   ;EEPROM read
        mov r16,r20    ;new devicenumber of this AVR

l12760: sts tadenu+2,r16 ;table device numbers for SD   
        mov r27,r26
        andi r26,$bf   ;$68->$28 $7e->3e    
        andi r27,$df   ;$68->$48 $7e->$5e
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
        lds r17,acemen ;actual emulated entry 0,1,2
        cpi r17,$00
        brne l12780      ;b.i.not HD

        lds r26,tadenu ;table device numbers for HD     
        cp r16,r26
        brne l12770    ;b.i.wanted devicenumber <> actual devicenumber
        
                       ;=wanted devicenumber = actual devicenumber  
                       ;=a swap-command was before => the devicenumbers are already swapped
                       ;   => reswap to old values
   
        mov r26,r16    ;new devicenumber of external floppy #$08/09
        ldi r28,$09    ;table device numbers of HD in EEPROM
        ldi r29,$00
        rcall l13770   ;EEPROM read
        mov r16,r20    ;new devicenumber of this AVR

l12770: sts tadenu,r16 ;table device numbers for HD
        rjmp l12800

l12780: lds r26,tadenu+2 ;table device numbers for SD
        cp r16,r26
        brne l12790    ;b.i.wanted devicenumber <> actual devicenumber
        
                       ;=wanted devicenumber = actual devicenumber  
                       ;=a swap-command was before => the devicenumbers are already swapped
                       ;   => reswap to old values
   
        mov r26,r16    ;new devicenumber of external floppy #$08/09
        ldi r28,$0b    ;table device numbers of SD in EEPROM
        ldi r29,$00
        rcall l13770   ;EEPROM read
        mov r16,r20    ;new devicenumber of this AVR

l12790: sts tadenu+2,r16 ;table device numbers for SD   
 
l12800: mov r27,r26
        andi r26,$bf   ;$68->$28 $7e->3e    
      
        andi r27,$df   ;$68->$48 $7e->$5e
       #endif     
   
        mov r25,r16    ;----
        rcall l13130
   
        mov r25,r26    ;----
        rcall l13130
   
        mov r25,r27    ;----
        rcall l13130
          
       #if partname == 6    
        #message 644-NLQ-HD/SD
        ldi r17,$05
        sts iratin,r17 ;disbale AtnIn-IRQs (int1) 
                       ;don't use cli, because this would disable 100Hz timer IRQs
                       ;100Hz IRQs are important for diskchangeswitch at sd2iec        ?????   
                       ;don't disable RTC-IRQ, RstIn-IRQ (int0), Sleep-IRQ (int2)          

       #else
        sts iratin,r06 ;#$00 makes no more IRQ = also flag for ATN-IRQ 
                       ;IRQ-register AtnIn-pin   162: PD2   644: PB2 (int2) 
                       ;   external interrupt 0/2 control mask register
                       ; different at 162 (PD2 IRQ0 bit6 of gicr) 
                       ;          and 644 (PB2 IRQ2 bit2 of eimsk)
                       ;=> NLQ-HD doesn't make an IRQ when NLQ-HD sets AtnOut=active
                       ;    and doesn't make AtnAck-emulation and doesn't make DtaOut=active
                       ;it's impossible to use the cli command, because there is a sei
                       ; at the end of the IECOUT routine 
       #endif
        
        ldi r25,$d0    ;d0--
        rcall l13130

        rcall l12990   ;makes all lines of IEC-bus inactive
                       ;mustn't change r16 
                       ;problem: at S-jiffydos the C64 reads the status after having
                       ; sent a command
                       ;C64 sends probably:
                       ;Listen to device-swap device 
                       ;SA
                       ;C64 switches to next device
                       ;Listen to next device 
                       ;SA
                       ;Unlisten
                       ;Talk to next device
                       ;SA
                       ;IECIN, IECIN, .... IECIN   (reads errormessage from next device)
                       ;Untalk
l12810: ldi r24,$2d    ;=45

l12820: in r17,piiema  ;     1 reads IECIN-port
       
       #if partname == 3
        #message 644-NLQ-HD/sd2iec
        andi r17,0b00000111 ;1 masks input-bits (!SrqIn isn't connected)
        cpi r17,0b00000111 ; 1 
       #endif

       #if partname == 6
        #message 644-NLQ-HD/SDonly
        andi r17,0b10101010 ;1 masks input-bits
        cpi r17,0b10101010 ; 1 
       #endif

       #if ((partname == 4) | (partname == 7))
        #message 644-NLQ-HD/all
        andi r17,0b10100110 ;1 masks input-bits
        cpi r17,0b10100110 ; 1 
       #endif

        brne l12810    ;     1 b.i.any IEC-line is active         
        
        dec r23        ;     1
        brne l12820    ;     2   7*256 = 1792 = 224µs

        dec r24        ;     1   224*44 = 10080µs = 10ms = 1/100s
        brne l12820    ;     2   waits until bus is 10000µs inactive
        
        ldi r25,$d1    ;d1--
        rcall l13130

        rcall l12940   ;AtnOut=active                                                     64:ed33
        rcall l12880   ;ClkOut=active                                                     64:ed37
                       ;DtaOut is already inactive
        ldi r25,$64    ;100
        rcall l10840   ;r25*10µs waiting loop  = 1000µs = 1ms                             64:ed3d

        ldi r17,$80    ;sets bit for Atn-mode (bit7)   clears bit for EOI (4)
        sts flicbb,r17 ;flag IECbus bits
                       ;important that IECOUT routine isn't left
        andi r16,$3f   ;$68->$28  $69->$29
        rcall l11710   ;CBM-IECOUT  (Listen)                                         64:ed40-edac
                       ;must jump to this place, because before the Atn-line is checked
        ldi r16,$6f    ;SA= commandchannel 15                                             64:edb9
        rcall l11710   ;CBM-IECOUT                                                        64:edbb

        rcall l13020   ;AtnOut = inactive                                                 64:edc3
        
        sts flicbb,r06 ;#$00 clears bit for Atn-mode (bit7)   clears bit for EOI (4)
                       ;important that IECOUT routine isn't left
        
        ldi r30,low(txdesw<<1)  ;text device-swap   m-w $77 $00 $02
        ldi r31,high(txdesw<<1) 

l12830: lpm r16,z+     ;reads command from flashrom
        rcall l11710   ;IECOUT
        cpi r30,low((txdesw<<1)+6)
        brne l12830    ;b.i.command not yet read to end

        mov r16,r26    ;new devicenumber #$28-3e
        rcall l11710   ;IECOUT

        mov r16,r27    ;new devicenumber #$48-5e
        rcall l11710   ;IECOUT

        ldi r16,$10    ;clears bit for Atn-mode (bit7)   sets bit for EOI (4)
        sts flicbb,r16 ;flag IECbus bits

        ldi r16,$0d    ;end-carriage-return
        rcall l11710   ;IECOUT
      
        rcall l12940   ;AtnOut=active                                                     
        rcall l12880   ;ClkOut=active                                                     
                       ;DtaOut is already inactive
        ldi r25,$64    ;100
        rcall l10840   ;r25*10µs waiting loop  = 1000µs = 1ms                             

        ldi r16,$80    ;sets bit for Atn-mode (bit7)   clears bit for EOI (4)
        sts flicbb,r16 ;flag IECbus bits
                       ;important that IECOUT routine isn't left
        ldi r16,$3f    ;Unlisten
        rcall l11710   ;IECOUT                                                            64:ee00
        rcall l13020   ;AtnOut = inactive                                                 64:ee03

        ldi r25,$06    ;
        rcall l10840   ;r25*10µs waiting loop  = 60µs                                     64:ee06

        rjmp l12990    ;makes all lines of IEC-bus inactive                          64:ee0d-ee10        
                       ; ret to l25710
                       ;at l25710 jmp to mainwaitingloop where the IRQ is enabled
       #endif
;================================================================================================
                       ;from l
l12840:                ;                                                   DtaOut = inactive e99c
       #if partname == 1    
        #message 162-IEC-ATA-V2
        sbi poiema,bidaou
        sbi ddiema,bidaou         
                       ;Atn-active-IRQ changes only poiema (doesn't change ddiema)
                       ; cbi poiema,bidaou ;PrtB4 = push to 0V
                       ; sbi ddiema,bidaou ;DdrB4 sets data to active as answer to C64-ATN=active 
                       ;=> even if there is a Atn-active IRQ between the two commands
                       ; there is no bug
        ret
       #endif
      
      #if partname == 3    
        #message 644-NLQ-HD/sd2iecl
        sbi ddiema,bidaou
        cbi poiema,bidaou ;DtaOut-AVR-pin=0V => inverted DtaOut-line = inactive         
                       ;Atn-active-IRQ changes only poiema (doesn't change ddiema)
                       ; sbi ddiema,bidaou ;DdrA = output  
                       ; sbi poiema,bidaou ;PrtA = +5V (outputs are inverted)
                       ;sets data to active as answer to C64-ATN=active
                       ;=> even if there is a Atn-active IRQ between the two commands
                       ; there is no bug
        ret
       #endif

       #if partname == 4
        #message 644-NLQ-HD/lite
        brid l12850    ;b.i.IRQ is disabled
       
        cli            ;disables IRQ      important because of AtnIn-IRQ        
        in r25,ddiema
        andi r25,0b11001111
        out ddiema,r25

        in r25,poiema
        ori r25,0b00110000
        out poiema,r25
        reti           ;enables IRQ again

l12850: in r25,ddiema
        andi r25,0b11001111
        out ddiema,r25

        in r25,poiema
        ori r25,0b00110000
        out poiema,r25
        ret            ;IRQ stays disabled

                       ;Atn-active-IRQ changes poiema and ddiema !both!
                       ;in r07,poiema   ;don't use rcall l12870 because this would change r25
                       ;clt
                       ;bld r07,bidaou ;copies t-flag -> bit4 of r07 DtaOut
                       ;bld r07,bidain ;                    5        DtaIn (and Out)
                       ;out poiema,r07 ;
                      
                       ;in r07,ddiema
                       ;set
                       ;bld r07,bidaou ;copies t-flag -> bit4 of r07 DtaOut
                       ;bld r07,bidain ;                    5        DtaIn (and Out)
                       ;out ddiema,r07 ;
                       ;  
                       ;if there is an Atn-active IRQ between the two commands here then
                       ; Prt-Dta and Ddr-Dta would both be high => the AVR would pull with
                       ; 2*20mA to +5V  
                       ;this must never happen; IEC-lines are open-collector 
       #endif

      #if partname == 6
        #message 644-NLQ-HD/SD
        brid l12860    ;b.i.IRQ is disabled
       
        cli            ;disables IRQ      important because of AtnIn-IRQ            
        in r25,DdrA
        andi r25,0b11000111
        out DdrA,r25

        in r25,PrtA
        ori r25,0b00111000
        out PrtA,r25
        reti           ;enables IRQ again
                   
l12860: in r25,DdrA
        andi r25,0b11000111
        out DdrA,r25

        in r25,PrtA
        ori r25,0b00111000
        out PrtA,r25
        ret            ;IRQ stays disabled
                   
                       ;Atn-active-IRQ changes po-dta and dd-dta !both! 
                       ;in r07,PrtA    ;don't use rcall l12870 because this would change r25
                       ;clt
                       ;bld r07,3      ;copies t-flag -> bit3 of r07 DtaOut
                       ;bld r07,4      ;                    4        
                       ;bld r07,5      ;                            
                       ;out PrtA,r07  ;
  
                       ;in r07,DdrA
                       ;set
                       ;bld r07,3      ;copies t-flag -> bit3 of r07 DtaOut
                       ;bld r07,4      ;                    4
                       ;bld r07,5 
                       ;out DdrA,r07   ;
  
                       ;if there is an Atn-active IRQ between the two commands here then
                       ; Prt-Dta and Ddr-Dta would both be high => the AVR would pull with
                       ; 2*20mA to +5V  
                       ;this must never happen; IEC-lines are open-collector 
       #endif
 
       #if partname == 7    
        #message 644-NLQ-HD/full
        sbi poiema,bidaou
        sbi ddiema,bidaou         
        ret
                       ;Atn-active-IRQ changes only poiema (doesn't change ddiema)
                       ;cbi poiema,bidaou ;PrtB = push to 0V
                       ;sbi ddiema,bidaou ;DdrB = output sets data to active as answer to C64-ATN=active 
                       ;    by making DDRB to output  
                       ;=> even if there is a Atn-active IRQ between the two commands
                       ; there is no bug
       #endif
;------------------------------------------------------------------------------------------------
l12870:                ;                                                   DtaOut = active   e9a5
       #if partname == 1    
        #message 162-IEC-ATA-V2
        cbi poiema,bidaou
        sbi ddiema,bidaou
       #endif

      #if partname == 3    
       #message 644-NLQ-HD/sd2iecl
        sbi ddiema,bidaou
        sbi poiema,bidaou ;DtaOut-AVR-pin=5V => inverted DtaOut-line = active         
       #endif

       #if partname == 4
        #message 644-NLQ-HD/lite
        in r25,poiema
        andi r25,0b11001111
        out poiema,r25

        in r25,ddiema
        ori r25,0b00110000
        out ddiema,r25
                       ;AtnIn-IRQ can only make DtaOut = active
                       ;=> no problem that this is made here twice
       #endif

      #if partname == 6
         #message 644-NLQ-HD/SD
        in r25,PrtA
        andi r25,0b11000111
        out PrtA,r25
    
        in r25,DdrA
        ori r25,0b00111000
        out DdrA,r25
                       ;AtnIn-IRQ can only make DtaOut = active
                       ;=> no problem that this is made here twice
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
        cbi poiema,bidaou
        sbi ddiema,bidaou
       #endif

        ret
;------------------------------------------------------------------------------------------------
l12880:                ;                                                   ClkOut = active   e9ae 
       #if partname == 1    
        #message 162-IEC-ATA-V2
        cbi poiema,biclou         
        sbi ddiema,biclou
       #endif

      #if partname == 3    
        #message 644-NLQ-HD/sd2iecl
        sbi ddiema,biclou
        sbi poiema,biclou ;ClkOut-AVR-pin=5V => inverted ClkOut-line = active         
       #endif

       #if partname == 4
        #message 644-NLQ-HD/lite
        brid l12890    ;b.i.IRQ is disabled
       
        cli            ;disables IRQ      important because of AtnIn-IRQ            
        in r25,poiema
        andi r25,0b01110111
        out poiema,r25

        in r25,ddiema
        ori r25,0b10001000
        out ddiema,r25
        reti           ;enable IRQ again

l12890: in r25,poiema
        andi r25,0b01110111
        out poiema,r25

        in r25,ddiema
        ori r25,0b10001000
        out ddiema,r25
       #endif

      #if partname == 6
        #message 644-NLQ-HD/SD
        brid l12900    ;b.i.IRQ is disabled
       
        cli            ;disables IRQ      important because of AtnIn-IRQ            
        in r25,PrtA
        andi r25,0b11111000
        out PrtA,r25
    
        in r25,DdrA
        ori r25,0b00000111
        out DdrA,r25
        reti           ;enable IRQ again 

l12900: in r25,PrtA
        andi r25,0b11111000
        out PrtA,r25
    
        in r25,DdrA
        ori r25,0b00000111
        out DdrA,r25
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
        cbi poiema,biclou         
        sbi ddiema,biclou
       #endif

        ret

;------------------------------------------------------------------------------------------------
l12910:                ;                                                   ClkOut = inactive e9b7 
                       ;                                    mustn't change carry-flag (l11720)
       #if partname == 1    
        #message 162-IEC-ATA-V2
        sbi poiema,biclou         
        sbi ddiema,biclou         
       #endif

      #if partname == 3    
        #message 644-NLQ-HD/sd2iec
        sbi ddiema,biclou
        cbi poiema,biclou ;ClkOut-AVR-pin=0V => inverted ClkOut-line = inactive         
       #endif

       #if partname == 4
        #message 644-NLQ-HD/lite
        brid l12920    ;b.i.IRQ is disabled
       
        cli            ;disables IRQ      important because of AtnIn-IRQ            
        in r25,ddiema
        andi r25,0b01110111
        out ddiema,r25

        in r25,poiema
        ori r25,0b10001000
        out poiema,r25
        reti           ;enable IRQ again 

l12920: in r25,ddiema
        andi r25,0b01110111
        out ddiema,r25

        in r25,poiema
        ori r25,0b10001000
        out poiema,r25
       #endif
 
      #if partname == 6
        #message 644-NLQ-HD/SD
        brid l12930    ;b.i.IRQ is disabled
       
        cli            ;disables IRQ      important because of AtnIn-IRQ                 
        in r25,DdrA
        andi r25,0b11111000
        out DdrA,r25

        in r25,PrtA
        ori r25,0b00000111
        out PrtA,r25     
        reti           ;enable IRQ again     
     
l12930: in r25,DdrA
        andi r25,0b11111000
        out DdrA,r25

        in r25,PrtA
        ori r25,0b00000111
        out PrtA,r25
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
        sbi poiema,biclou         
        sbi ddiema,biclou         
       #endif

        ret
;------------------------------------------------------------------------------------------------
       #if ((partname >= 3) & (partname <= 7))
         #message 644-NLQ-HD/all
l12940:                ;                                                          AtnOut = active 
       #endif
                       ;there is probably no space for swap command at mega162
                       ;=> AtnOut=active routines not necessary????  

      #if partname == 3    
        #message 644-NLQ-HD/sd2iecl
        sbi ddiema,biatou
        sbi poiema,biatou ;AtnOut-AVR-pin=5V => inverted AtnOut-line = active         
        ret
       #endif

       #if partname == 4
         #message 644-NLQ-HD/lite
        brid l12950    ;b.i.IRQ is disabled
       
        cli            ;disables IRQ      important because of AtnIn-IRQ        
        in r25,poiema
        andi r25,0b11111010 ;AtnOutIn=pullupsoff (later: 0V)
        out poiema,r25
     
        in r25,ddiema
        ori r25,0b00000101 ;AtnOutIn=output=0V
        out ddiema,r25   
        reti           ;enable IRQ again     
             
l12950: in r25,poiema
        andi r25,0b11111010 ;AtnOutIn=pullupsoff (later: 0V)
        out poiema,r25
     
        in r25,ddiema
        ori r25,0b00000101 ;AtnOutIn=output=0V
        out ddiema,r25
        ret
       #endif
 
      #if partname == 6
        #message 644-NLQ-HD/SD
        brid l12960    ;b.i.IRQ is disabled
       
        cli            ;disables IRQ      important because of RTC-LED        
        in r25,PrtD
        andi r25,0b11000111
        out PrtD,r25
    
        in r25,DdrD
        ori r25,0b00111000
        out DdrD,r25
        reti           ;enable IRQ again     

l12960: in r25,PrtD
        andi r25,0b11000111
        out PrtD,r25
    
        in r25,DdrD
        ori r25,0b00111000
        out DdrD,r25
        ret
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
        ldi r25,$ef    ;bitmask for I2C-port AtnOut       !!!changes r20, r25!!!
        jmp l23760     ;clears AtnOut-pin in I2C-port-chip = AtnOut=active
       #endif
;------------------------------------------------------------------------------------------------
       #if ((partname >= 3) & (partname <= 7))
         #message 644-NLQ-HD/all
l12970:                ;                                                        SrqOut = inactive  
       #endif

      #if partname == 3    
        #message 644-NLQ-HD/sd2iec
        sbi ddiema,bisrou
        cbi poiema,bisrou ;SrqOut-AVR-pin=0V => inverted SrqOut-line = inactive         
       #endif

       #if partname == 4
         #message 644-NLQ-HD/lite
        brid l12980    ;b.i.IRQ is disabled
       
        cli            ;disables IRQ      important because of AtnIn-IRQ                     
        in r25,ddiema
        andi r25,0b10111101
        out ddiema,r25

        in r25,poiema
        ori r25,0b01000010
        out poiema,r25
        reti           ;enable IRQ again     

l12980: in r25,ddiema
        andi r25,0b10111101
        out ddiema,r25

        in r25,poiema
        ori r25,0b01000010
        out poiema,r25
       #endif
   
      #if partname == 6
        #message 644-NLQ-HD/SD
        in r25,DdrB
        andi r25,0b10101101
        out DdrB,r25

        in r25,PrtB
        ori r25,0b01010010
        out PrtB,r25
                       ;SRQ=PortB different to DtaOut-port   different to RTC-LED-port
                       ;=> both IRQ can come while SRQ-change-routine 
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
        sbi poiema,bisrou         
        sbi ddiema,bisrou         
       #endif

        ret
;------------------------------------------------------------------------------------------------
l12990:                ;                                      makes all lines of IEC-bus inactive
                       ; a=active p=passive
       #if partname == 1    
        #message 162-IEC-ATA-V2
        ldi r25,0b01010111; = dataDirection
        out DdrB,r25   ;DDRB ClockOut=inactive DataOut=inactive SrqOut=inactive AtnOut=inactive
        ;ldi r25,0b11111111       
        out PrtB,r07   ;PrtB (#$ff)
                       ;                      DdrB  PrtB 
                       ;7 IEC-ATN Out       i  0     1  p5V  SCK  (Clock In at flashing) 
                       ;6 IEC-SRQ Out       o  1     1  a5V  MISO (same at flashing)
                       ;5 IEC-data In       i  0     1       MOSI (same at flashing)  
                       ;4 IEC-data Out      o  1     1  a5V
                       ;3 IEC-Clock In      i  0     1
                       ;2 IEC-Clock Out     o  1     1  a5V 
                       ;1 ATA-DOIR          o  1     1       (!not open collector!)
                       ;0 ATA-DOIW          o  1     1       (!not open collector!)
                       ;makes DtaOut, ClkOut, SrqOut active to +5V = IEC-inactive
                       ;makes AtnOut passive to +5V because this could be an input
                       ; when jumper C is changed 
       ret
       #endif ;162-IEC-ATA-V2
     
       #if partname == 3
        #message 644-NLQ-HD/sd2iec
        ldi r25,0b11110000; = dataDirection
        out DdrA,r25   ;DdrA ClockOut=inactive DataOut=inactive SrqOut=inactive AtnOut=inactive
        ;ldi r25,0b00000000 ; 
        out PrtA,r06  ;PrtA  #$00
                       ;                      DdrA  PrtA 
                       ;7 IEC-Srq Out       o  1     0  inverted
                       ;6 IEC-Clk Out       o  1     0  inverted
                       ;5 IEC-Dta Out       o  1     0  inverted   
                       ;4 IEC-Atn Out       o  1     0  inverted  
                       ;3 IEC-Srq In        i  0     0
                       ;2 IEC-Clk In        i  0     0
                       ;1 IEC-Dta In        i  0     0
                       ;0 IEC-Atn In        i  0     0
                               
        ;cbi DdrB,2     ;PB2 = input  (PB2 is perhaps connected to PA0 = AtnIn)             
        ;sbi PrtB,2     ;PB2 = pullups on (to prevent swinging if not connected to PA0)             
                       ; ??but what do if connected??)                           
        ret
       #endif ;644-NLQ-HD/sd2iec

       #if partname == 4
        #message 644-NLQ-HD/lite
        brid l13000    ;b.i.IRQ is disabled
       
        cli            ;disables IRQ      important because of AtnIn-IRQ                     
        out DdrB,r06   ;#$00 DDRB    ClockOut=inactive DataOut=inactive
        out PrtB,r07  ;#$ff PrtB   SrqOut=inactive AtnOut=inactive
        reti           ;enable IRQ again     

l13000: out DdrB,r06   ;#$00 DDRB    ClockOut=inactive DataOut=inactive
        out PrtB,r07  ;#$ff PrtB   SrqOut=inactive AtnOut=inactive
                       ;                      DdrB  PrtB 
                       ;7 IEC-Clk In       i/o 0     1     SCK  
                       ;6 IEC-Srq Out       o  0     1  p  MISO (AVR is slave while flashing)
                       ;5 IEC-Dta In       i/o 0     1     MOSI   
                       ;4 IEC-Dta Out       o  0     1  p  
                       ;3 IEC-Clk Out       o  0     1  p
                       ;2 IEC-Atn In       i/o 0     1     pinB2 makes Int2
                       ;1 IEC-Srq In       i/o 0     1     and debug switch
                       ;0 IEC-Atn Out       o  0     1  p   
        ret
       #endif ;644-NLQ-HD/lite-lite

      #if partname == 6
        #message 644-NLQ-HD/SD
        brid l13010    ;b.i.IRQ is disabled
       
        cli            ;disables IRQ      important because of AtnIn-IRQ  and RTC-LED-IRQ
        out DdrA,r06   ;#$00
        out PrtA,r07   ;#$ff DtaOut & ClkOut = inactive

        in r25,DdrB
        andi r25,0b10101101
        out DdrB,r25

        in r25,PrtB    ;SrqOut=inactive  
        ori r25,0b01010010
        out PrtB,r25
        rjmp l13040

l13010: out DdrA,r06   ;#$00
        out PrtA,r07   ;#$ff DtaOut & ClkOut = inactive

        in r25,DdrB
        andi r25,0b10101101
        out DdrB,r25

        in r25,PrtB    ;SrqOut=inactive  
        ori r25,0b01010010
        out PrtB,r25
       #endif

       #if partname == 7
        #message 644-NLQ-HD/full
        ldi r25,0b01011001; = dataDirection
        out DdrB,r25   ;DDRB ClockOut=inactive DataOut=inactive SrqOut=inactive
        ;ldi r25,0b11111111 ; 
        out PrtB,r07   ;#$ff PrtB
                       ;                      DdrB  PrtB 
                       ;7 IEC-Clk In        i  0     1     SCK  
                       ;6 IEC-Srq Out       o  1     1  a  MISO (AVR is slave while flashing)
                       ;5 IEC-Dta In        i  0     1     MOSI   
                       ;4 IEC-Dta Out       o  1     1  a  
                       ;3 IEC-Clk Out       o  1     1  a
                       ;2 IEC-Atn In        i  0     1     pinB2 makes Int2
                       ;1 IEC-Srq In        i  0     1
                       ;0 AVR-SPI-ClkOut    0  1     1  a   

                       ;I2C-pins have +3.3V only
                       ;NEVER pull active to +5V
                       ;NEVER activate internal pullup-resistor
                       ;I2C-pins have external 3.3V-pullup-restors
 
                       ;AVR-SPI-Outputs are push/pull-outputs and change from 5 to 3.3V is made
                       ; by 74LS07
                       
                       ;still change: make output to active +5V (instead of pullups-on only)
                       ;74LS07 would make sharper edges
       #endif ;644-NLQ-HD/full

                       ;at NLQ-HD/IEC-ATA and /HDonly AtnOut=inactice is made 
                       ; unneccessaryly double
                       ;at NLQ-HD/full this must be, because AtnOut is at the I2C-port-chip
;................................................................................................
       #if ((partname >= 3) & (partname <= 7))
        #message 644-NLQ-HD/all
l13020:                ;                                                        AtnOut = inactive 
       #endif          ;doesn't exist at 162
     
       #if partname == 3    
        #message 644-NLQ-HD/sd2iec
        sbi ddiema,biatou
        cbi poiema,biatou ;AtnOut-AVR-pin=0V => inverted AtnOut-line = inactive         
        ret
       #endif

       #if partname == 4
         #message 644-NLQ-HD/lite
        brid l13030    ;b.i.IRQ is disabled
       
        cli            ;disables IRQ      important because of AtnIn-IRQ
        in r25,DdrB
        andi r25,0b11111010
        out DdrB,r25

        in r25,PrtB
        ori r25,0b00000101
        out PrtB,r25
        reti           ;enable IRQ again     

l13030: in r25,DdrB
        andi r25,0b11111010
        out DdrB,r25

        in r25,PrtB
        ori r25,0b00000101
        out PrtB,r25
        ret
       #endif
 
      #if partname == 6
        #message 644-NLQ-HD/SD
        brid l13050    ;b.i.IRQ is disabled
       
        cli            ;disables IRQ      important because of AtnIn-IRQ  and RTC-LED-IRQ
l13040: in r25,DdrD
        andi r25,0b11000111
        out DdrC,r25

        in r25,PrtD
        ori r25,0b00111000
        out PrtC,r25
        reti           ;enable IRQ again     

l13050: in r25,DdrD
        andi r25,0b11000111
        out DdrC,r25

        in r25,PrtD
        ori r25,0b00111000
        out PrtC,r25
        ret
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
        ldi r25,$10    ;bitmask for I2C-port AtnOut       !!!changes r20, r25!!!
        jmp l23770     ;set AtnOut-pin in I2C-port-chip = AtnOut=inactive
       #endif
;================================================================================================
l13060: rcall l13130   ;                                     prints r25, r11-r15 into debugbuffer 
                       ;.........................................................................
l13070: mov r25,r11   ;                                           prints r11-r15 into debugbuffer 
        rcall l13160
        mov r25,r12 
        rcall l13160
        mov r25,r13
        rcall l13160
        mov r25,r14
        rcall l13160
        mov r25,r15
        rjmp l13160
;------------------------------------------------------------------------------------------------
l13080:                ;                          prints debugbyte and debugbyte-high into buffer    
        rcall l13090   ;prints debugbyte into buffer    

        push r24       
        in r24,Sreg    ;status register                                             
        push r24 
        lds r25,debyhi ;debug-byte-high               
        tst r25
        brne l13120    ;b.i.sending of debug-highbyte wanted
      
        rjmp l13340    ;=sending of debug-highbyte not wanted
;................................................................................................
l13090:                ;                                    r25= main-debugbytes into debugbuffer
                       ;routines are also used at IRQ-routines => r06 isn't always #$00
                       ; r07 isn't always #$ff
                       ;r06 r07 mustn't be changed

/*
        in r03,Sreg    ;status register                                             
        push r28       ;backup Ylow              (important that writing stops at once 
        push r29       ;backup Yhigh               when jumper d is closed, even if 
        mov r28,r04    ;set Y-register to debugbufferposition   
        ldi r29,$0d    ;debugbufferbegin
        st y+,r25      ;stores 
        in r25,PinB
        st y+,r25
        mov r04,r28
        pop r29        ;restores Y-register      
        pop r28 
        out Sreg,r03   ;restores status register
        ret
*/

/*
        rcall l13100
        in r25,DdrA
        rcall l13100
        in r25,PrtA
l13100:
*/

/*
        rcall l13110
        in r25,pinB    
l13110:
*/
        push r24       
        in r24,Sreg    ;status register                                             
        push r24 
       
l13120: bst r02,7
        brts l13190    ;b.i.save of mainbyte
        
        rjmp l13300    
;------------------------------------------------------------------------------------------------
       ;rcall l13130   ;3

l13130:                ;                                r25= not-main-debugbytes into debugbuffer
                       ;   37cycles at NLQHD-full = 5µs
/*      
        in r03,Sreg    ;status register                                             
        push r28       ;backup Ylow              (important that writing stops at once 
        push r29       ;backup Yhigh               when jumper d is closed, even if 
        mov r28,r04    ;set Y-register to debugbufferposition   
        ldi r29,$0d    ;debugbufferbegin
        st y+,r25      ;stores 
        in r25,PinB
        st y+,r25
        mov r04,r28
        pop r29        ;restores Y-register      
        pop r28 
        out Sreg,r03   ;restores status register
        ret
*/

/*
        rcall l13140
        in r25,DdrA
        rcall l13140
        in r25,PrtA
l13140:
*/

/*
        rcall l13150
        in r25,pinB    
l13150:
*/
        push r24       ;2     
        in r24,Sreg    ;1 status register                                             
        push r24       ;2
              
        bst r02,6      ;1
        brts l13190    ;2  b.i.save of not-mainbyte
        
        rjmp l13300    
;------------------------------------------------------------------------------------------------
l13160:                ;                                               r25= LBAs into debugbuffer
/*
        in r03,Sreg    ;status register                                             
        push r28       ;backup Ylow              (important that writing stops at once 
        push r29       ;backup Yhigh               when jumper d is closed, even if 
        mov r28,r04    ;set Y-register to debugbufferposition   
        ldi r29,$0d    ;debugbufferbegin
        st y+,r25      ;stores 
        in r25,PinB
        st y+,r25
        mov r04,r28
        pop r29        ;restores Y-register      
        pop r28 
        out Sreg,r03   ;restores status register
        ret
*/

        push r24     
        in r24,Sreg    ;status register                                             
        push r24 
              
        bst r02,5
        brts l13190    ;b.i.save of LBAs
                
        rjmp l13300    
;------------------------------------------------------------------------------------------------
/*
l13170: ldi r25,$00    ;                                               IEC-ports into debugbuffer
                       ;                                                     (changes r25) 
                       ;.........................................................................       
l13180: push r24       ;                           recognition-byte of IEC-ports into debugbuffer
        in r24,Sreg    ;status register                                                 
        push r24 
       
        bst r02,4
        brtc l13300    ;b.i.no save of IEC-ports
 
        cpi r25,$00
        brne l13190    ;b.i.recognition-byte (not IEC-port) is wanted

        in r25,DdrB    ;IECDdr (0=input=inactiv   1=output=activ)
        com r25        ;       (0=activ 1=inactiv)
        andi r25,$55   ;%01010101  masks output-bits (bit0 is wrong at M162)

        in r24,PinB    ;IECPort  
        andi r24,$2a   ;%00101010  masks input-bits (bit1 is wrong at M162)
 
        or r25,r24     ;(bit 7 allways low)   

;!!!!!!!!!this is still wrong at M644


        in r24,PinD    ;PrtD (IECAtn)
        bst r24,2      ;copies AtnIn-bit -> t-flag
        bld r25,7      ;copies t-flag -> bit7 of r25
        
        cp r03,r25     ;compares actual and old IECBus value
        brne l13300    ;b.i.no change

        mov r03,r25    ;actual IEC-bus value -> old value
*/
;................................................................................................
l13190: 
/*                     ;former: debugbytes were written only when the debugjumper was open
                       ;         (the debugjumper was connected to SrqIN
                       ;           so it could be read easyly)
                       ;now: the debugjumper is connected to:
                       ;     -IEC-ATA: error-LED: switch cannot be read when the LED is active
                       ;     -NLQHD-full: I2C-portexpanderchip: reading this would be too slow

        sbis pidesw,bidesw ;b.i.debugswitch is off/open 
                           ;162: PinE,Bit0
                           ;644-sd2iec: PC2
                           ;644; PinB,Bit1

        rjmp l13300    ;debug-jumper is close => don't change r02 r04 (and debug-buffer)
                       ;                         don't write anything into debug-buffer
*/       
        push r28       ;2 backup Ylow              (important that writing stops at once 
        push r29       ;2 backup Yhigh               when jumper d is closed, even if 
                       ;                              program still works)
                       ;                              not more possible snce switches are changed
/*                       ;-------------------------------------------------------------------------
        cpi r25,$54    ;this is a freeze when the system hangs and 54-- and 00-- is written
        breq l13200    ; permanently to debugbuffer

        cpi r25,$00
        brne l13210

l13200: lds r25,$0d00
        dec r25
        sts $0d00,r25
        brne l13240   ;or brne l13220????????????????????

        in r25,DdrA
        sts $0d01,r25
        in r25,PrtA
        sts $0d02,r25
        in r25,PinA
        sts $0d03,r25
        ldi r25,$f3    ;f3--
        jmp freeze

l13210: sts $0d00,r06  ;r06 isn't always #$00 !!!!!!!!!!!!!!!!!

l13220:
*/                     ;-------------------------------------------------------------------------

        mov r28,r04    ;1 set Y-register to debugbufferposition   
        ldi r29,high(debube) ;1 debugbufferbegin
         
        st y+,r25      ;2 stores IECPort / IeeeControllPort to buffer 01,03,05...
        
        mov r03,r25    ;1 important for 100Hz-IRQ-routine

        cpi r28,low(debuen) ;1 $b0
        brne l13230    ;2 b.i.not 10b0

        ldi r28,low(debube) ;$00 debugbuffervector is at end 
                
l13230: mov r04,r28    ;1 

l13240:     
                       ;------------------------------------------------------------------------- 
                       ;this area can be used for analysis
                       ; r24,r28,r29 can be used (r25 probably also??)
                       ;-------------------------------------------------------------------------
       #if partname == 6    
        #message 644-NLQ-HD/SD
        lds r24,airtmb ;AVR-internal-RTC-mode-bits
        tst r24
        brne l13290    ;b.i.mode where RTC-values are changed by mainprogram

        lds r24,airtmr ;AVR-internal-RTC-mainroutine
        tst r24
        brne l13290    ;b.i.mode where RTC-values are changed by mainprogram

        lds r24,airtsl ;AVR-internal-RTC-stackpointer-low   
        tst r24
        brpl l13290    ;b.i.mode where RTC-values are changed by mainprogram
                       ;it's important to return to the mainprogram 
                       ; because else the RTC-values could be changed partial only
       #endif
        ;----------------------------------------------------------------------------------------




        ;----------------------------------------------------------------------------------------
       #if partname == 1       
        #message 162-IEC-ATA-V2 
        in r24,mcucr
        tst r24
        brpl l13260    ;b.i.exmem is off

       #endif ;162-IEC-ATA-V2
       
        lds r24,amfrcl ;amount of free clusters  
        lds r28,amfrcl+1
        and r24,r28
        lds r28,amfrcl+2
        and r24,r28
        lds r28,amfrcl+3
        ori r28,$f0
        and r24,r28
        cpi r24,$ff
        brne l13260

l13250: ldi r25,$40    ;40--
        jmp freeze     ;freeze when amount of free clusters =ffffffff
                       ;is this correct??? or should be freezed if 00000000

l13260:
                       ;-------------------------------------------------------------------------



/*                       ;-------------------------------------------------------------------------  
        ld r24,-y
        cpi r24,$93
        brne l13270

        ld r24,-y
        cpi r24,$93
        brne l13270

        ld r24,-y
        cpi r24,$93
        brne l13270

        ld r24,-y
        cpi r24,$93
        breq l13270
        
        ldi r25,$41    ;41--
        jmp freeze     ;=freeze when four #$93 are written into debugbuffer
                      
l13270:
*/                       ;-------------------------------------------------------------------------
                          
/*                       ;-----------------------------------------------------------  
        in r24,PinC
        in r28,DdrC
        in r29,PrtC
        andi r29,$fc   ;masks off bit 1&0
        cpi r29,$fc
        in r29,PrtC
        breq l13280    ;b.i.still correct value

        sts $0c04,r25
        sts $0c05,r24
        sts $0c06,r28
        sts $0c07,r29
        ldi r25,$f4    ;f4--
        jmp freeze

l13280: sts $0c00,r25
        sts $0c01,r24
        sts $0c02,r28
        sts $0c03,r29
*/                       ;-----------------------------------------------------------
l13290: pop r29        ;2 restores Y-register      
        pop r28        ;2 

l13300: 
       #if partname == 4 
        #message 644-NLQ-HD/lite
        in r24,DdrB    ;Ddr IEC-port
        in r25,PrtB    ;Prt IEC-port
        and r24,r25
        breq l13310    ;b.i.all pins don't pull active to +5V

        ldi r25,$00
        out DdrB,r25
        ldi r25,$ff
        out Prtb,r25
        ldi r25,$f5   ;f5--   
        jmp freeze

l13310:
       #endif
 
       #if partname == 6    
        #message 644-NLQ-HD/SD
        in r24,DdrA    ;Ddr IEC-port DtaOut & ClkOut
        andi r24,$3f
        in r25,PrtA    ;Prt IEC-port
        and r24,r25
        brne l13320    ;b.i.any pins pull active to +5V

        in r24,DdrB    ;Ddr IEC-port
        andi r24,$fa   ;masks IEC-bus-pins
        in r25,PrtB    ;Prt IEC-port
        and r24,r25
        brne l13320    ;b.i.any pins pull active to +5V

        in r24,DdrD    ;Ddr IEC-port AtnOut
        andi r24,$38
        in r25,PrtD    ;Prt IEC-port
        and r24,r25
        breq l13330    ;b.i.all pins don't pull active to +5V

l13320: ldi r25,$00
        out DdrA,r25
        out DdrB,r25
        out DdrD,r25
        ldi r25,$ff
        out PrtA,r25
        out PrtB,r25
        out PrtD,r25
        ldi r25,$f5    ;f5--
        jmp freeze
l13330:
       #endif

l13340: pop r24        ;2
        out Sreg,r24   ;1 restores status register
        pop r24        ;2 
        
        ret            ;4
/*
l13350: ldi r25,$a0    ;a0--
        rjmp freeze
*/
;================================================================================================
                       ;from l11170
l13360:                ;action after Talk from C64                        action after Talk  e909
                       ;IRQ=enebaled  => AtnAck-emulation is switched on 
                       ;DataOut=inactive  ClockOut=active
                       ;                                                 C64 made IECAtn=inactive 

                       ;acpose actual pointer to SA-entry show to actual SS
                       ;acsscb actual SA in CBM-buffer contains actual SS
        ldi r25,$ad    ;ad----
        rcall l13090

        lds r17,icsawo ;IEC secundary address without bits for open/close/SA
        cpi r17,$0f    ;compares with command/errorchannel
        brne l13370    ;b.i.not errorchannel
      
        rjmp l13460    ;errorbuffer is at 0900-09ff better, faster, easier 

l13370: ldi r25,$ae    ;ae--
        rcall l13130

        lds r16,asfla1 ;actual SA flags1 (0-17)
        andi r16,$40   ;masks bit whether actual SA is opened for read
        brne l13380    ;b.i.opened for read

        ldi r25,$af    ;(af--)
        rcall l13130
        
        jmp l25290     ;actual SA isn't opened for read -> to main waiting loop              e915

l13380: lds r16,iccbjd ;iccbjd IEC CBM/JD
        cpi r16,$60 
        brne l13390    ;b.i.not JiffyDOS-LOAD
        rjmp l12090    ;=JiffyDOS-LOAD

l13390: ldi r25,$a9    ;a9--
        rcall l13130
        mov r25,r16    ;---- (iccbjd)
        rcall l13130  

l13400: lds r28,ascbve ;actual SA CBM-buffer vector
        ldi r29,high(cbbube) 

        mov r25,r28    ;----
        rcall l13130  
        mov r25,r29    ;----
        rcall l13130  

l13410: ld r16,y+      ;postincrements bufferpointer but doesn't store it

        mov r25,r16    ;----
        rcall l13130  

        lds r17,asflre+1
        lds r18,asflre+2
        or r17,r18
        lds r18,asflre+3
        or r17,r18
        brne l13420    ;b.i.remaining filelength > 255 bytes   

        lds r17,asflre ;actual filelength of actual SA  0 1 2-ff
        cpi r17,$01    ;carry                           c s not equal
        brcs l13450    ;b.i.remaining filelength=0  = error  to mainwaitingloop    
                       ;   necessary??? 

        brne l13420    ;b.i.remaining filelength=2-ff = no eoi

                       ;=remaining filelength=1 = sends last byte with eoi
        lds r17,flicbb ;flags IECBusBits
        ori r17,$10    ;sets flag f.EOI      
        sts flicbb,r17

l13420: ldi r25,$aa    ;aa--
        rcall l13130

        rcall l11700   ;IECOUT (from AVR to C64)  (no return if C64 makes Atn=active)   e916-e991
                       ; IRQ is enabled => AtnAck-emulation is switched on
                       ; = important because AVR-DataOut=inactive 
                         
                       ;if in future there should be a device where the IRQ must be disabled
                       ;because of timing, then it's perhaps necessary that AVR makes
                       ; AVR-DataOut= active while IRQ is disabled (and AtnAck-emulation 
                       ;  is switched off) 
                    
        ldi r25,$ab    ;ab--
        rcall l13130                        
                         
        lds r16,asflre ;actual filelength of actual SA
        subi r16,$01   ;decrements actual filelength by 1 
        sts asflre,r16
           
        lds r16,asflre+1
        sbci r16,$00
        sts asflre+1,r16
           
        lds r16,asflre+2
        sbci r16,$00
        sts asflre+2,r16
           
        lds r16,asflre+3
        sbci r16,$00
        sts asflre+3,r16

l13430: sts ascbve,r28 ;stores incremented actual SA CBM-buffer vector
        
        lds r16,flicbb
        andi r16,$10   ;masks EOI-bit
        brne l13450    ;b.i.last byte was sent

        cpi r29,high(cbbuen)
        brne l13410    ;b.i.actual CBM-buffer isn't sent to end

        ldi r25,$ad    ;ad--  =CBM-buffer is sent to end  read follow-CBM-sector
        rcall l13130   ;ascbve = #$00
       
        lds r16,asfla0 ;flag0 of actual SA
        andi r16,$03   ;masks directory-bits
        brne l13440    ;b.i.directory

        rcall l14770   ;read follow-256-CBM-sector of actual cluster
        rjmp l13400

l13440: call l21100    ;make next directory-block into CBM-buffer
        rjmp l13400    ;send actual block

l13450: jmp l25290     ;to main waiting loop                                                ?e999
        
                       ;reading errorchannel from AVRinternal not 100% compatibel to 1541
                       ;if read further than EOI-received: 1541 reads 00,ok,00,00
                       ;                                   AVRinternal: readerror at C64
                       ; but if talk-buffer wouldn't be close here then the AVR would read 
                       ; the next byte of 00,ok,00,00 would be read from IEEE-Floppy   
                       ;-------------------------------------------------------------------------
                       ;                                       reading from errorbuffer 0a00-0aff
l13460: lds r28,erbuve ;error-buffer vector
        ldi r29,high(erbube) ;errorbuffer begin 

        mov r25,r28    ;---- 
        rcall l13130  
        mov r25,r29    ;---- (erbube #$09)
        rcall l13130  

l13470: ld r16,y+      ;postincrements bufferpointer but doesn't store it

        mov r25,r16    ;----
        rcall l13130  
                       ;errorbuffer is at 0900-09ff  => maximal length: $0100=256 characters  
        lds r17,erbufi+1
        tst r17
        brne l13480    ;b.i.$0100 = 256 bytes in errorbuffer        

        lds r17,erbufi ;actual filelength of errorbuffer  0, 1, 2-$ff
        cpi r17,$00
        brne l13480    ;b.i.1-ff (no EOI, no error)
         
        ldi r16,$0d    ;carriage return    remaining filelength = 0
        lds r17,flicbb ;flags IECBusBits
        ori r17,$10    ;sets flag f.EOI      
        sts flicbb,r17

l13480: ldi r25,$aa    ;aa--
        rcall l13130

        rcall l11700   ;IECOUT (from AVR to C64)  (no return if C64 makes Atn=active)   e916-e991
                       ; IRQ is enabled => AtnAck-emulation is switched on
                       ; = important because AVR-DataOut=inactive 
                         
                       ;if in future there should be a device where the IRQ must be disabled
                       ;because of timing, then it's perhaps necessary that AVR makes
                       ; AVR-DataOut= active while IRQ is disabled (and AtnAck-emulation 
                       ;  is switched off) 
                    
        ldi r25,$ab    ;ab--
        rcall l13130                        
                         
        lds r16,erbufi ;actual filelength of errorbuffer
        subi r16,$01   ;decrements actual filelength by 1 
        sts erbufi,r16

        lds r16,erbufi+1
        sbci r16,$00
        sts erbufi+1,r16

        sts erbuve,r28 ;stores incremented error-buffer vector
        
        lds r16,flicbb
        andi r16,$10   ;masks EOI-bit
        breq l13470    ;b.i.not yet last byte was sent  -> send next byte
    
l13490: ldi r25,$ad    ;ad--  =error-buffer is sent to end
        rcall l13130
       
        rcall l13880   ;copy 00,ok into errorbuffer and set vectors for errorbuffer





        ldi r25,$ae    ;ae--  =error-buffer is sent to end
        rcall l13130

l13500: jmp l25290    ;to main waiting loop                                                 ?e999 
        
                       ;reading errorchannel from AVRinternal not 100% compatibel to 1541
                       ;if read further than EOI-received: 1541 reads 00,ok,00,00
                       ;                                   AVRinternal: readerror at C64
                       ; but if talk-buffer wouldn't be close here then the AVR would read 
                       ; the next byte of 00,ok,00,00 would be read from IEEE-Floppy   
;================================================================================================
l13510:                ;from l11130 - l11170 
                       ;action after Listen  read byte from C64         action after Listen  ea2e        
                       ;   C64 made IECAtn=inactive
                       ; DataOut=active  ClockOut=inactive 
                       ;IRQ is enabled 
                       ;IRQs must be enabled because software AtnAck

                       ;   ea48  jsr cfb7 ???)
                        
        ldi r25,$a8    ;a8----
        rcall l13090
  
        lds r16,icsaco ;IECSecundaryaddressComplete (all 7 bits) ($84)                       cfb7
                       ;   (SA)        SA     close  open
                       ;(00-0e,0f)  60-6e,6f  e0-ef  f0-ff
        andi r16,$8f   ;(00-0e,0f)  00-0e,0f  80-8f  80-8f
        cpi r16,$0f    ;  s- s, c    s- s, c    c      c
        brcs l13520    ;b.i.not commandchannel, open filename, (close)                       cfbd
    
        rjmp l13700    ;=commandchannel, open filename, (close)
                       
l13520:                ;=Listen to datachannel                                               cfbf
        ldi r25,$a9    ;a9--
        rcall l13130
     
        lds r16,asfity ;actual SA file-type (= ec,x at 1541)                        cfbf

       #if partname >= 2    
        #message 644-non-IEC-ATA
        cpi r16,$08
        brcs l13530    ;b.i.0-7

        cpi r16,$0c
        brcs l13540   ;b.i.8-b (nat, 41, 71, 81    =   d16, d64, d71, d81)
       #endif

l13530: cpi r16,$0e
        breq l13540    ;b.i.FOReign

        cpi r16,$04    ;          (set at l21890)                                            d12c
        brcs l13540    ;b.i.$01-03  b.i.DEL, SEQ, PEG, USR   ????                            cfc2
        
        rjmp l13680    ;$04-0f  b.i.REL, direct access???????                                cfc2
        
l13540:                ;=Listen to DEL, SEQ, PRG, USR                                        cfc4
                       ;  ea2e   jsr cfb7   jmp d19d   jsr cff1   jsr df93
        lds r16,asfla1 ;actual SA flags1 (0-17) = 022b,x                             ea2f/d110
        andi r16,$80   ;masks bit for opened for write                                  d113-d124
        brne  l13550   ;b.i.SA is opened for write (1541=very complicated)              ea32/cff5

        jmp l25290     ;mainwaitingloop                                                 ea4e-ea53
                       ;if there would be a 61-error then this would ovrwrite 
                       ; e.g.an file not found error
        ;ldi r16,$3d   ;61,file not open  61--                                               cff8  
        ;jmp l13980    ;print message + LED-blink + main waiting loop---------               cffa

l13550:                ;   f2,x don't understand                                             ea34
       
l13560: lds r26,ascbve ;actual SA CBM-buffer vector    ----listen-loop----
                       ; (initialized at l21860 at open for write)
                       ;vector shows to next to-write databyte
        ldi r27,high(cbbube) ;CBM-buffer begin                                         ?cffd-cffe
                       
l13570: rcall l11430   ;read 1 byte from C64  DataOut=active ClockOut=inactive               ea44
                       ;no return if C64 makes IECAtn=active 
                       ;changes perhaps r28/r29 Y-reg (when JiffyDOS-C64 and commandbyte)
                       ; at end of IecIn: IRQ is enabled
        sei            ;enable IRQs  => AtnAck-emulation is switched on                     ea47
                       ; (but AVR-DataOut is active anyway)
                       ; but is AtnIn-IRQ disabled by iratin=#$00????????????????????  
                       ;Atn-active-IRQ is enabled
                       ;important to set bit 0 of flated flag atn edge
        st x+,r16      ;stores read databyte into CBM-buffer                                 d000 
        sts ascbve,r26 ;stores vector to next to-write databyte                              d002

        cpi r26,$01
        brne l13610    ;b.i.not the first databyte is received

                       ;=the first databyte of a new CBM-buffer is received
                       ;=> allocate follow-cluster
                       ;ac..as still contain the values of the former sector

l13580: st x+,r06      ;#$00   clears $0801-08ff (not $0800)
        cpi r27,high(cbbuen); CBM-buffer end
        brcs l13580

        lds r16,asflre ;actual filelength of actual SA
        lds r17,asflre+1
        or r16,r17
        lds r17,asflre+2
        or r16,r17
        lds r17,asflre+3
        or r16,r17
        breq l13600    ;b.i.filelength = 0    = first byte of first sector of first cluster
                       ;    =first databyte at all  =  cluster is already allocated at 
                       ;      open routine -> don't allocate cluster again    

        lds r16,ashbsc ;actual (former) sector in this cluster of actual SA 
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        inc r16        ;makes next CBM-sector
        mov r17,r16
        lsr r17
        brcs l13590    ;b.i.this actual sector fits in second half of HD-sector
                       ;     not necessary to allocate new cluster       

        lds r18,sepecl ;sectors per cluster       
        cp r17,r18
        brcs l13590    ;b.i.there is at least one sector free in actual cluster

                       ;= a new cluster must be allocated
                       ;ac..as still contain the values of the former sector

        call l22050    ;search next free cluster                                             d1a6                           
                       ;allocate it as endcluster
                       ;-> geaccl contain found free cluster
                       ; (r12-r15 contain FAT-entry of geaccl)
                       ;pay attention that ascbve isn't changed

                       ;ashbcl contains the old endcluster
                       ;geaccl contains the new allocated cluster  

                       ;make follow link of actual-old file cluster (former endcluster) (=ashbcl)
                       ; to link-cluster-address of now-found cluster
                       ;1541: the link is in the file-sector (not in the BAM)
                       ;FAT32: the link is in the FAT (not in the file-sector/file-cluster)   
                       ;read FAT1-entry of ashbcl = so far last direntry
        call l18820   ;test whether actual FAT-entry is an endcluster, write new values for
                       ;follow-cluster to FAT-entry           

        call l19110   ;copy geaccl general actual cluster (=followcluster of file)
                       ; to  ashbcl actual SA HD-buffer cluster   
                       ; geaccl ->     ashbcl
                       ; $80/81 -> $06/07 - $0e/0f            
                       ;ashbcl - ashbcl+3 contain clusteraddress of new file cluster

        ldi r16,$00        

l13590: sts ashbsc,r16 ;actual SA HD-buffer sector in this cluster
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        
l13600: lds r26,ascbve ;#$01 actual SA CBM-buffer vector
                       ; vector to next to-write databyte
        ldi r27,high(cbbube) ;CBM-buffer begin 

l13610: ldi r17,$01
        lds r16,asflre ;actual filelength of actual SA
        add r16,r17    ; (initialized at l21860 at open for write)
        sts asflre,r16 ;increments filelength

        lds r16,asflre+1
        adc r16,r06    ;#$00 adds carry   
        sts asflre+1,r16

        lds r16,asflre+2
        adc r16,r06    
        sts asflre+2,r16

        lds r16,asflre+3
        adc r16,r06    
        sts asflre+3,r16

        cpi r27,high(cbbuen) ;CBM-buffer end
        brcc l13620    ;b.i.CBM-buffer is full ->write block to HD                           d1a0
        rjmp l13570    ;=CBM-buffer not yet full ->receive next byte from C64                d1a0

l13620:                ;=CBM-buffer is full with $100 = 256 databytes                        d1a3 
                       ; CBM-buffer must be copied into AVR-HD-buffer and written to HD       
        lds r16,ashbsc ;actual sector of this cluster of actual SA
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        lsr r16
        brcs l13650    ;b.i.CBM-buffer must be copied to second half of HD-buffer
           
                       ;=CBM-buffer must be copied to first half of HD-buffer
        ldi r28,low(cbbube)
        ldi r29,high(cbbube)
        
        ldi r26,low(hdbube)
        ldi r27,high(hdbube)
         
l13630: ld r16,y+      ;copies from CBM-buffer ($0500-05ff)
        st x+,r16      ; to first half of HD-buffer ($0600-06ff) 
        cpi r29,high(cbbuen)
        brne l13630                 

l13640: st x+,r06      ;#$00 clears second half of AVR-HD-buffer ($0700-07ff)
        cpi r27,high(hdbuen)
        brne l13640  

        rjmp l13670    ;----

l13650:                ;=CBM-buffer must be copied to second half of HD-buffer
        rcall l14790   ;read actual sector of actual cluster (again) (changes X, Y)
                       ;because first half of it contains a CBM-buffer 
                        
        ldi r28,low(cbbube)
        ldi r29,high(cbbube)
        
        ldi r26,low(hdbube+$100) ;vector to second half of HD-buffer
        ldi r27,high(hdbube+$100)

l13660: ld r16,y+      ;copies from CBM-buffer ($0500-05ff)
        st x+,r16      ; to second half of HD-buffer ($0700-07ff) 
        cpi r29,high(cbbuen)
        brne l13660              

l13670: rcall l14720   ;writes actual sector of actual SA HD-buffer cluster to HD           d1b8 
                       ;  in ashbcl (not r12-r15)

        rjmp l13560   
                       ;1541: when 1 buffer is full -> allocates follow-sector
                       ;    (this is necessary because the link to the follow-sector
                       ;     must be written in the actual sector which must be written to disk) 
                       ;     bad: if the file is closed exactly here then the follow-sector is
                       ;     allocated but not used
                       ;     (it is wronly allocated until the next validate command)
                       ;NLQ-HD: allocates the follow-cluster when the first databyte of a 
                       ;     CBM-buffer is received = better
                       ;  exeption: the first cluster of the file is always allocated,
                       ;   because its values must be written into the dir-entry
                       ;   and there is no CBM-file with a length of 0 bytes
                       ;    if the 1541 receives a close to a file with a length of 0 bytes
                       ;    then it adds a carriage return (db71)  
                       ;  => the new cluster is allocated when the first databyte (byte-no0)
                       ;      is received 
                       ;  => when the last databyte (byte-no$ff 255) is received = when the CBM-
                       ;      buffer is full then the (sector of the) cluster can be written to 
                       ;      HD (it's not necessary to allocate a new cluster again)
                       ;-------------------------------------------------------------------------   
l13680: brne l13690    ;b.i.not REL                                                          cfc9

        ldi r17,$60    ;60-- 96--   =Listen to REL                                           cfcb
        rjmp syserr    ;system error 
                       ;-------------------------------------------------------------------------
l13690: ldi r17,$61    ;61-- 97--   =Listen to probably direct access                        cfce
        rjmp syserr    ;system error                                                         cfd5
                       ;-------------------------------------------------------------------------
l13700:                ; = Listen to commandchannel, open filename, (close)                  cfd8
        lds r26,incove ;Xvector = writevector  inputcommandvector $a3
        ldi r27,high(inbube) ;#$03 inputbufferbegin               $a4  vector a3,a4 at 1541 
                       ;!!!!!!!!incove must be resetted to #$00   where??????????????
 
l13710: rcall l11430   ;read 1 byte from C64  DataOut=active ClockOut=inactive               ea44
                       ;no return if C64 makes IECAtn=active 
                       ;changes perhaps r28/r29 Y-reg (when JiffyDOS-C64 and commandbyte)
        sei            ;enable IRQs  => AtnAck-emulation is switched on                     
                       ; (but AVR-DataOut is active anyway)
                       ; but is AtnIn-IRQ disabled by iratin=#$00????????????????????  
   
        cpi r26,low(inbuen) ;$2a    ;=commandchannel                                         cfdf
        breq l13720    ;b.i.input buffer full
        
        st x+,r16      ;stores read byte to input buffer                                d000/dd02
        sts incove,r26 ;Xvector = writevector  inputcommandvector $a3                        dd02

l13720: lds r17,flicbb ;                                                                     cfe8
        andi r17,$08   ;masks IECEoiReceived bit
        breq l13740    ;b.i.no EOI        
      
l13730: sts avinco,r07 ;#$ff set flag f. AVR internal command present (l25290-l25300)        cfed
    
l13740: rjmp l13710    ;endlessloop until C64 makes Atn=active                              ?ea4b
;================================================================================================

;================================================================================================
                       ;from l23160, l25110, l25110, l25110
l13750:                ;                                                             EEPROM-write
        out eearl,r28  ;lowbyte address to eeprom address register low         r20=to write byte
        out eearh,r29  ;highbyte address                                       Y=r28,r29=address
                       ;                                                             changes r21     
        out Eedr,r20   ;eedr  write data (r16) to data register
        
        in r21,sreg    ;backups status register
        cli            ;disable IRQs

        sbi eecr,2     ;eemwe/eempe of eecr  Write logical one to EEMWE/eempe
        sbi eecr,1     ;eewe/eepe of eecr  start eeprom write by setting EEWE of eecr
                       ;if internal oscylator runs with too fast speed it must be set to 
                       ;correct speed before and to fast speed after ?????
        out SReg,r21   ;restore Status register (I-bit)                          

l13760: sbic eecr,1    ;eecr eeprom control register
        rjmp l13760    ;waits for completition of write
        mov r21,r20
;................................................................................................ 
                       ;from l13870, l23150, l24900, l24920, l24970, l24970
l13770:                ;                                                              EEPROM-read
        out eearl,r28  ;lowbyte address to eeprom address register low         Y=r28,r29=address
        out eearh,r29  ;highbyte address 

        sbi eecr,0     ;start eeprom read by writing EERE
        in r20,Eedr    ;eedr = eeprom data register   read data from data register

l13780: out eearl,r06  ;clears eepromaddress 
        out eearh,r06
        out eecr,r06   ;clears eecr    here are bits5-4 of eecr cleared = good at M644
        cp r20,r21     ;only at write: compares written and read value
        
        ret
;================================================================================================
l13790: ldi r28,low(inbube) ;inputbuffer begin = $0100                   clears inputbuffer  c1bd
        ldi r29,high(inbube)

l13800: st y+,r06      ;#$00  
        cpi r28,low(inbuen) ;inputbuffer end +1 = $012a  
        brne l13800
        ret
;================================================================================================
l13810: ldi r21,$2c    ;comma                      print comma and hexdec number into errorbuffer
        st x+,r21  

l13820: cpi r20,$64    ;print hexdec number into errorbuffer              r20=hexdec-number
        brcs l13840    ;b.i.0-99                                          !is changed!

        ldi r21,$31    ;                                                  X=errorbuffervector
        cpi r20,$c8    ;                                                  changes r21
        brcs l13830    ;b.i.100-199

        ldi r21,$32    ;=200-255
        subi r20,$64
         
l13830: subi r20,$64

        st x+,r21      ;prints hundred-position   prints 1 or 2 of 1.. 2..

l13840: ldi r21,$30    ;0

l13850: cpi r20,$0a    ;b.i.(remainder) 0-9
        brcs l13860
        
        inc r21        ;0->1   8->9
        subi r20,$0a
        rjmp l13850 

l13860: st x+,r21      ;prints ten-position
        ori r20,$30
        st x+,r20      ;prints one-position
        ret
;------------------------------------------------------------------------------------------------
l13870: ld r20,y+      ;just to increment Y                                             e767-e76b

        rcall l13770   ;eeprom read of address Y -> r20                                      e76d
        bst r20,7      ;$00-7f: T=clear=errortext   $80-ff: T=set=errornumber
                       ; NLQ-HD: T-flag   1541: Carry-flag
                       ;1541:bit7=flag for begin/end of errortext
                       ;NLQ-HD: bit7= flag for errortext/-number
        cpi r29,$02    ;end of eeprom: carry: -clear=end reached  -set=not yet reached  
        andi r20,$7f   ;masks of bit7=bit for errornumber
        ret            ;                                                                     e774
;------------------------------------------------------------------------------------------------
                       ;from l12350, l13490, l17150, l17280,
l13880: ldi r16,$00    ;                                        copy 00,ok,00,00 into errorbuffer

        rcall l10760   ;LED off
        ldi r17,$00    ;tracknumber of errormessage
                       ;.........................................................................
l13890: ldi r18,$00    ;sektornumber of errormessage
                       ;.........................................................................
                       ;from l13990, l17270 (scratch), l24840 (reset)
l13900: ldi r26,low(erbube)  ;#$00  X=0900                   copies errormessage into errorbuffer                                 
        ldi r27,high(erbube) ;#$09  errorbuffer 0900-09ff       changes r20-r21, r26-r29  
                       ;                                        r19:errornumber (hexdec not BCD)
        sts erbuve,r26 ;sets error-buffer vector to first byte

        mov r20,r16    ;                errornumber: 1541: BCD
        rcall l13820   ;prints errornumber         NLQ-HD: hexdec
                       ;!hexdec, not BCD!  
        ldi r21,$2c     
        st x+,r21      ;prints comma
  
        ldi r28,low(eeerbe-1) ;eeprom error begin-1 ($003f of eeprom)
        ldi r29,high(eeerbe-1)

l13910: rcall l13870   ;increment vector and read byte from eeprom                           e71d
        brcs l13920    ;b.i.end of eeprom ($0200) not yet reached

                       ; = end of eeprom ($0200) reached without finding errornumber
        ldi r20,$45    ;'e'
        st x+,r20
        rjmp l13960    ;----         

l13920: brtc l13910    ;b.i.errortext

l13930: cp r16,r20     ;                                                                     e718  
        brne l13910    ;b.i.different errornumber
                       ;empty eeprom contains $ff => errornumber $7f=127 mustn't exist      

                       ;=correct errornumber
l13940: rcall l13870   ;increment vector and read byte from eeprom 
        brts l13940    ;b.i.errornumber (overreads multiple errornumbers)

                       ;=begin of correct errortext
l13950: st x+,r20      ;stores errortext from eeprom into errorbuffer
        rcall l13870   ;increment vector and read byte from eeprom                       
        brtc l13950    ;b.i.still errortext

                       ;end if errornumber behind errortext reached
                       ;=> there must be at least 1 (#80 -) #$ff byte at the end
                       ;    of the errormessages
l13960: mov r20,r17
        rcall l13810   ;print ,errortrack

        mov r20,r18
        rcall l13810   ;print ,errorsector

        ;subi r26,low(erbube) ;-#$2a computes length of error-message
                       ; not necessary as long as errorbuffer bigins at $..00

        sts  erbufi,r26 ;error-buffer filelength (remaining) (for EOI-calculating)
        sts  erbufi+1,r06 ;#$00
        ret
;------------------------------------------------------------------------------------------------
l13970: ldi r17,$ff    ;ff-- 255-- tracknumber                   unsupported command system error
                       ;.........................................................................
syserr: ldi r18,$00    ;                                                system error (sector=#00)
syer18: mov r25,r17    ;SYstem ERror r18                                system error (sector=r18)
        rcall l13130   ;writes r17 (=systemerror) into debugbuffer 
        ldi r16,$4e    ;78,system error r17=tracknumber=system-error-number            
        rjmp l13990    ;----------

l13980: ldi r17,$00    ;tracknumber of errormessage                 print error+blink+waitingloop
        ldi r18,$00    ;sektornumber of errormessage

l13990: mov r25,r16    ;                                            print error+blink+waitingloop
        rcall l13130   ;xx-- writes r16 (=errornumber) into debugbuffer 
        rcall l13900   ;copy errormessage into errorbuffer 

       #if partname == 1    
        #message 162-IEC-ATA-V2
        rcall l10740   ;LED blink

       #else
        #message 644-non-IEC-ATA
        call l10740   ;LED blink
       #endif 

        rcall l13790   ;clear inputbuffer (don't know whether correct here)??????????????????
        
        lds r16,icsawo ;IECSecundaryAddress without bits whether open,close,SA ($83) 
        cpi r16,$0f
        breq l14000    ;b.i.command-/error-channel (Is it possible that there is an error
                       ; at the command/errorchannel?
        sts asfla1,r06 ;sets flag that actual SA is unused ?????????????????????????????????
                               ;               not opened for read   not opened for write
l14000: jmp l25290     ;to main waiting loop (resets stackpointer)
;================================================================================================
                       ;from l21520, l21540
l14010: ldi r19,$00    ;clears highbyte of divisor
                       ;.........................................................................
                       ;from l21490, l21500     
l14020: ldi r20,$30    ;loads result register with '0'             computes binary to ASCII-digit
                       ;                                      mustn't change T-flag
l14030: cp r17,r19     ;highbytes                                        r16,17=hexdec-number 
        brcs l14050    ;b.i.hexdec-number - actual remainder < divident  =end
        brne l14040    ;b.i.hexdec-number - actual remainder > divident

        cp r16,r18     ;lowbytes                            r18,19=divisor (10000,1000,100,10) 
        brcs l14050    ;b.i.hexdec-number - actual remainder < divident  =end

l14040: sub r16,r18  
        sbc r17,r19    ;subtracts 10000,1000,100,10                                r20=result
        inc r20        ;increments result 
        rjmp l14030
        
l14050: cpi r20,$30    ;equal='0' notequal='1'-'9' (ASCII)
        ret            ;r20 = result   r16,17=remainder
                       ;http://www.avr-asm-tutorial.net/avr_de/rechnen/konvert.html#asc2bin
;================================================================================================
       #if (partname == 1) | (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/HD-routines
l14060: ;ldi r25,$50    ;50----                                                 read ATA-register
        ;rcall l13090   ;                                    r16=address 

 
       #if partname == 1 ;                                   r18=DataInLow      
        #message 162-IEC-ATA-V2 ;                            r19=DataInHigh
        ldi r17,$02
        out Mcucr,r17   ;#$02 exmem off                      changes: r17
                        ;                                    about 24cycles = 3µs
        sbi poatdw,biatdw ;ATA diow high    IEC-ATA-V2 only
        sbi poatdr,biatdr ;ATA dior high    at NLQ-HD diow&dior is set together with PrtD 
    
        sbi ddatdw,biatdw ;ATA diow output
        sbi ddatdr,biatdr ;ATA dior output
       #endif ;162-IEC-ATA-V2
        
        out DdrA,r06    ;1 #$00 PrtA = input
        out DdrC,r06    ;1 #$00 PrtC = input
        out PrtA,r07    ;1 #$ff PrtA: enable pullups
        out PrtC,r07    ;1 #$ff PrtC: enable pullups
                        ;If I understand the IDE-book correctly, then:
                        ;HD pulls to 0V with 12mA (sink)
                        ;HD pulls to +5V with 0.4mA (source) ???
                        ; => support the pulling up to +5V with enabling the AVR-pullup-resistors
                        ; When the pullups were disabled at a 130MB-HD I tried then the AVR lost
                        ; $ffff byte sent from HD to AVR. The bug disappeared when I enabled the
                        ; pullups - strange ???
                        ;Perhaps first when the AVR made some wires of the commandregister
                        ; (PrtC) to 0V, then this inducted the 16 datawires to 0V.
                        ; Then when the HD makes all datawires to +5V ($ffff) then this inducted
                        ; the dior-wire to +5V, so that the HD thought that this is the 
                        ; acknowledge for this dataword and sends the next dataword??????
 
       #if partname == 1    
        #message 162-IEC-ATA-V2
        ldi r17,0b11111011 ;DdrD
                        ; IEC-ATA-V2 DdrD PrtD
                        ;7   /RD       1   1     
                        ;6   /WD       1   1
                        ;5 ATA-DA2     1   x        
                        ;4 ATA-DA1     1   x
                        ;3 ATA-DA0     1   x 
                        ;2 /IEC-ATN    0   1   input & pullup-on
                        ;1 /ATA-CS1    1   y
                        ;0 /ATA-CS0    1   y
                        
                        ;da0-2=register
                        ;cs0-1=command-block/......
       #endif


       #if partname == 4
         #message 644-NLQ-HD/lite
        in r17,DdrD
        ori r17,0b00111110
                        ;NLQ-HD/lite  DdrD PrtD
                        ;7 LED&switch  0/1  0     
                        ;6 LED&switch  0/1  0
                        ;5 ATA-DA2      1   x        
                        ;4 ATA-DA1      1   x
                        ;3 ATA-DA0      1   x 
                        ;2 ATA-DIOW     1   1
                        ;1 ATA-DIOR     1   1
                        ;0 ATA-RST&CS0  0   1
       #endif
 

       #if partname == 7    
        #message 644-NLQ-HD/full
        sbi poatdr,biatdr ;1 ATA dior high (B0)
        sbi ddatdr,biatdr ;1 ATA dior output

        ldi r17,0b00111110 ;1
                        ; NLQ-HD/full   DdrD PrtD
                        ;7 I2C-Dta        0   0     
                        ;6 I2C-Clk        0   0
                        ;5 ATA-DA2        1   x        
                        ;4 ATA-DA1        1   x
                        ;3 ATA-DA0        1   x 
                        ;2 ATA-DIOW       1   1
                        ;1 AVR-SPI-DtaOut 1   1
                        ;0 AVR-SPI-DtaIn  0   0
       #endif

        out DdrD,r17    ;1 DdrD

        out PrtD,r16    ;1 addresses register 

                        ;  125ns delay  (should be >=70ns) 
     
        ;in r25,PinB
        ;rcall l13130

        ;in r25,PinA
        ;rcall l13130

        ;in r25,PinC
        ;rcall l13130

        ;in r25,PinD
        ;rcall l13130

        cbi poatdr,biatdr ;1 dioR = active (=low)
                        ;= -read-pulse to HD
        nop             ;1
        nop             ;1
        nop             ;1 5*125ns=625ns delay (should be >=600ns)
        nop             ;1
        nop             ;1
 
        ;in r25,piatdr
        ;rcall l13130

        in r18,PinA     ;1 reads data0-7
        in r19,PinC     ;1 reads data8-15

        ;mov r25,r18
        ;rcall l13130

        ;mov r25,r19
        ;rcall l13130

        sbi poatdr,biatdr ;1 dioR =inactive (=high)
        
        ;in r25,piatdr
        ;rcall l13130

       #if partname == 1     
        #message 162-IEC-ATA-V2

        out PrtD,r07  ;addressregister to high (saves energy?)

       #endif ;162-IEC-ATA-V2

       #if (partname == 4) | (partname == 7)    
        #message 644-NLQ-HD/full

        ldi r16,idrecs ;1 IDE register command/status  = also value for inactive
        out PrtD,r16   ;1

       #endif ;644-NLQ-HD/lite-lite & full
        
       #if partname == 1       
        #message 162-IEC-ATA-V2 
        ldi r16,$82
        out Mcucr,r16   ;exmem on
       #endif ;162-IEC-ATA-V2

        ret            ;4
;------------------------------------------------------------------------------------------------
                       ;from l12140, l15140, l15220, l15310, l15430, l15460
                       ;     l26060,
l14070: ldi r25,$54    ;54----                                    wait until ATA-drive isn't busy
        rcall l13090   ;                                                 and read status register
                       ;               changes r00, r16, r17. r18, r19        
        mov r00,r07    ;#$ff =value which statusregister cannot be (when not busy) 
                       ;r00 = former value of status register
                       ;r00 is used as temporary register here

l14080: push r20
        push r21
        push r22

        ldi r22,$14    ;20

l14090: ldi r16,idrecs ;1 IDE register command/status
        rcall l14060   ;3 + 24 = 28cycles = 3.5µs read IDE-register
                       ;change r16, r17, r18, r19, r25

        cpi r18,$80    ;1 masks busy-bit
        brcs l14100    ;1 b.i.drive isn't busy  =  wait until drive isn't busy (b7=high  80-ff)
                       
                       ;  =bit7 = high  = b.i.busy-bit is set
                       ;  as long as drive is busy: bits 6-0 of status register can be uncorrect
        dec r20        ;1
        brne l14090    ;2 1loop = 32cycles = 4µs   256loops = 1000µs = 1ms
 
        dec r21
        brne l14090    ;256ms = 0.25s

        dec r22        ;20*0,25 = 5s      
        brne l14090

        ldi r17,$08    ;(08--)  (08--)
        rjmp syserr    ;no HD connected

l14100:                ;=busybit=low  b7=low = 00-7f 
        pop r22
        pop r21
        pop r20
       
        cp r18,r00     ;compares actual and former value of statusregister
        mov r00,r18    ;copies actual value to former value
        brne l14080    ;b.i.difference of former and actual statusbyte

                       ;there must be read twice the same statusbyte to end this routine
                       ;reason: a Quantum 40MB-HD made accidentially the DataRequest-bit
                       ;low after reading multiple sectors

        mov r25,r18    ;xx--  = drive isn't busy (usually #$50 or #$58)
        rcall l13130 
                       ;!!there are two different bits
                       ; bit 7 = busy
                       ; bit 6 = drive ready
                       ; busy isn't the same as not ready!!!!!!!!
        ret
;------------------------------------------------------------------------------------------------
l14110: rcall l14070   ;waits until drive isn't busy                   waits until drive is ready 
        andi r18,$40   ;masks DRDY drive-ready bit                      (to receive next command)   
        breq l14110    ;b.i.drive isn't ready = waits until drive is ready
                       ;=waits until HD can receive new/next command
        ret
;------------------------------------------------------------------------------------------------
l14120: ldi r19,$00    ;clears DataOutHigh (e.g.at commands)                   write ATA-register

l14130:; ldi r25,$52    ;52--                                                  write ATA-register
       ; rcall l13130   ;                                     r16=address                          

       #if partname == 1 ;                                    r18=DataOutLow    
        #message 162-IEC-ATA-V2 ;                             r19=DataOutHigh
        ldi r17,$02
        out Mcucr,r17   ;exmem off ($02)

    
        sbi poatdw,biatdw ;ATA diow high    IEC-ATA-V2 only
        sbi poatdr,biatdr ;ATA dior high    at NLQ-HD diow&dior is set together with PrtD 
    
        sbi ddatdw,biatdw ;ATA diow output
        sbi ddatdr,biatdr ;ATA dior output
       #endif ;162-IEC-ATA-V2

       #if partname == 1    
        #message 162-IEC-ATA-V2
        ldi r17,0b11111011 ;DdrD
                        ; IEC-ATA-V2 ddrD PrtD
                        ;7   /RD       1   1     
                        ;6   /WD       1   1
                        ;5 ATA-DA2     1   x        
                        ;4 ATA-DA1     1   x
                        ;3 ATA-DA0     1   x 
                        ;2 /IEC-ATN    0   1   input & pullup-on
                        ;1 /ATA-CS1    1   y
                        ;0 /ATA-CS0    1   y
                        
                        ;da0-2=register
                        ;cs0-1=command-block/......
       #endif


       #if partname == 4
         #message 644-NLQ-HD/lite
        in r17,DdrD
        ori r17,0b00111110
                        ;NLQ-HD/lite  DdrD PrtD
                        ;7 LED&switch  0/1  0     
                        ;6 LED&switch  0/1  0
                        ;5 ATA-DA2      1   x        
                        ;4 ATA-DA1      1   x
                        ;3 ATA-DA0      1   x 
                        ;2 ATA-DIOW     1   1
                        ;1 ATA-DIOR     1   1
                        ;0 ATA-RST&CS0  0   1
       #endif
 

       #if partname == 7    
        #message 644-NLQ-HD/full
        sbi poatdr,biatdr ;ATA dior high 
        sbi ddatdr,biatdr ;ATA dior output

        ldi r17,0b00111110         
                        ; NLQ-HD/full   DdrD PrtD
                        ;7 I2C-Dta        0   0     
                        ;6 I2C-Clk        0   0
                        ;5 ATA-DA2        1   x        
                        ;4 ATA-DA1        1   x
                        ;3 ATA-DA0        1   x 
                        ;2 ATA-DIOW       1   1
                        ;1 AVR-SPI-DtaOut 1   1
                        ;0 AVR-SPI-DtaIn  0   0
       #endif

        out DdrD,r17    ;DdrD

        out PrtD,r16   ;addresses register fe=Status
     
        out DdrA,r07    ;ATA-port low = output
        out DdrC,r07    ;ATA-port high = output

        out PrtA,r18   ;DataOutLow
        out PrtC,r19   ;DataOutHigh

                        ;125ns delay (should be >=70ns) 

        ;in r25,PinB
        ;rcall l13130

        ;in r25,PinA
        ;rcall l13130

        ;in r25,PinC
        ;rcall l13130

        ;in r25,PinD
        ;rcall l13130

        cbi poatdw,biatdw ;activates ATA-diow = writes into command register

        nop
        nop
        nop             ;5*125ns=625ns delay (should be >=600ns)
        nop
        nop
   
        ;in r25,piatdw
        ;rcall l13130
    
        ;in r25,PinA
        ;rcall l13130

        ;in r25,PinC
        ;rcall l13130

        sbi poatdw,biatdw

        ;in r25,piatdw
        ;rcall l13130

       #if partname == 1     
        #message 162-IEC-ATA-V2

        out PrtD,r07  ;addressregister to high (saves energy?)

       #endif ;162-IEC-ATA-V2

       #if (partname == 4) | (partname == 7)    
        #message 644-NLQ-HD/full

        ldi r16,idrecs ;IDE register command/status  %11111...  = also value for inactive
        out PrtD,r16

       #endif ;644-NLQ-HD/lite-lite & full

        out DdrA,r06    ;$00 PrtA = input
        out DdrC,r06    ;$00 PrtC = input
        out PrtA,r07   ;$00 PrtA: enable pullups
        out PrtC,r07   ;$00 PrtC: enable pullups
        
       #if partname == 1       
        #message 162-IEC-ATA-V2 
        ldi r16,$82
        out Mcucr,r16   ;exmem on
       #endif ;162-IEC-ATA-V2

        ret
       #endif          ;of l14060
;================================================================================================
       #if partname >= 2    
        #message 644-non-IEC-ATA
                       ;from l14210, l14310
l14140:                ;                                                    test legal swapfile & 
                       ;                                     compute correct sector of swapfile
        lds r16,acemen ;actual DEB for AVR-RAM
                       ;r16  00    01    02
        swap r16       ;     00    10    20       
        lsl r16        ;     00    20    40   =startsector of device-emulation-entry in swapfile
        or r17,r16     ;    00-1f 20-3f 40-5f
                       ;.........................................................................
                       ;from l14340, l14350
l14150: lds r15,seswfi+3 ;sector swapfile highest

        tst r15        ;this doesn't work if HDs with >128GB should be supported!!!!!!!!!!
        brpl l14170    ;b.i.sector swapfile is legal

                       ;=no swapfile or illegal swapfile
       #if partname == 3
        #message 644-NLQ-HD/SD2IEC
                       ;= hardware, where sawpfile is on SD-card
/* 
        push r16
        push r17
                
        call l18910   ;test whether the SD has been changed
        brcc l14160    ;b.i.SD isn't changed

                       ;=SD has been changed
        call l18950    ;free all buffers (without closing them)
                       

*/
       #endif

      
      
      
      
l14160: ldi r16,$46    ;70,no channel   70--
        jmp l13980     ;print message + LED-blink + main waiting loop----------------------------
        ;ldi r17,$68    ;68--  104--
        ;rjmp syserr



        lds r15,seswfi+3  


l14170: lds r12,seswfi ;sector swapfile 
        lds r13,seswfi+1 
        lds r14,seswfi+2 ;                                     r17=wanted SA of swapfile

        add r12,r17    ;adds offset for old CBM-buffer
        adc r13,r06    ;#$00 adds carry
        adc r14,r06
        adc r15,r06 
        
        ret            ;r12-r15 contain sectoraddress of correct sector of swapfile
       #endif          ;of l14140 
;------------------------------------------------------------------------------------------------
                       ;from l17170
l14180: lds r16,icsawo ;SA-only without bits whether open/close/SA = $83 at 1541 
                       ;.........................................................................
                       ;from l11130, l20950, l16990, l18720, l21650
                       ;     l21930, l21940, l21940 
l14190:                ;    save old CBM-buffer to swapfile and load new CBM-buffer from swapfile
        lds r17,acsacb ;actual SA in CBM-buffer (00-0e, $11-$12 0-14, 17-18) 
                       ; pay attention that it's never $0f,10 15,16 = command/error
                               
        ldi r25,$77    ;77----
        rcall l13090   

        mov r25,r16
        rcall l13130   ;---- (wanted, new SA loaded from swapbuffer)
                       
        mov r25,r17
        rcall l13130   ;---- (old SA saved to swapbuffer)

        ldi r25,$78    ;78--
        rcall l13130  

        lds r18,c6frre ;C64-freeze-register 
        cpi r18,$02
        brne l14200    ;b.i.not freeze at swapfile

        lds r18,c6cor0 ;C64-communication register 0 
        cp r16,r18     ;compares to-freeze SA and to-backup SA
        brne l14200    ;b.i.not to freeze SA is swapped
        
        ldi r25,$a1    ;a1--
        jmp freeze       

l14200: cpi r16,$13
        brcs l14210    ;b.i.SA 0-$12 wanted (=legal)
 
                       ;perhaps also test whether SA $0f and $10 = illegal????????????

        ldi r17,$67    ;(67--)  (103--)
        rjmp syserr

l14210: cp r16,r17     ;             r16=new, wanted CBM-buffer   r17=actual (now old) CBM-buffer
        breq l14320    ;wanted SecundaryaddresS is already in CBM-buffer

                       ;swapbuffer must be changed

       #if partname == 1    
        #message 162-IEC-ATA-V2
        sts acsacb,r16 ;actual SA in CBM-buffer (00-$11 0-17)      this is the new wanted SA
                       ;this is later written to swaparea (but later not read)
                       ;=> the value acsacb (01be (08be)) of the HD-sector doesn't contain
                       ;    the SA of the backuped CBM-swapbuffer but the SA of the wanted one

                       ;                                          save old CBM-buffer to swaparea
        ;cpi r17,$ff
        ;breq l14230    ;b.i.there is no actual data in CBM-buffer = don't save to swaparea
                       
                       ;                                                  save buffer to swaparea
        ldi r30,low(swbube) ;swap buffer begin ($0ae0)
        ldi r31,high(swbube) 

        ldi r28,$e0
        mov r29,r17    ;00 01 ... 0f 10 11 12  (ff)
        lsl r29        ;00 02 ... 1e 20 22 24  (fe)  
        subi r29,$e0   ;20 22 ... 3e 40 42 44  (1e) uses RAM $2000 - $45ff as swaparea
                       ;                                      8192 - 17919
l14220: ld r18,z+      ;copies swapbuffer to swaparea
        st y+,r18      ;       $0ae0-0bff    $2000-45ff
        cpi r31,high(swbuen) ;swap buffer end (+1)
        brne l14220
             
l14230: ldi r25,$7c    ;7c--                                    load new CBM-buffer from swaparea
        rcall l13130

        ldi r30,low(tasach) ;table secundaryaddress -> channel
        ldi r31,high(tasach)
        add r30,r16    ; adds new wanted SA = vector to entry in table of new wanted SA
        ld r17,z
        cpi r17,$ff
        set            ;default for SA is opened 
        brne l14240    ;b.i.wanted SA is opened
        
        clt            ;flag that SA isn't opened
l14240: ldi r30,$e0
        mov r31,r16    ;00 01 ... 0f 10 11 12  (ff)
        lsl r31        ;00 02 ... 1e 20 22 24  (fe)  
        subi r31,$e0   ;20 22 ... 3e 40 42 44  (1e) uses RAM $2000 - $45ff as swaparea
                       ;                                      8192 - 17919  
        ldi r28,low(swbube) ;swap buffer begin ($0ae0)
        ldi r29,high(swbube) 

l14250: ld r16,z+      ;copie swaparea to swapbuffer
        brts l14260    ;b.i.SA is opened 
     
        ldi r16,$00    ;SA isn't opened

l14260: st y+,r16      ;      $2000-45ff  $0ae0-0bff
        cpi r29,high(swbuen) ;swap buffer end (+1)
        brne l14250
       #else           ;of l14210  

       #if partname == 3
        #message 644-NLQ-HD/SD2IEC
/*
        lds r18,sdfldc ;SD flag disk change                             (bit0-3=$1c at 1541)
                       ;                                                (bit4-7=$1e at 1541)
        andi r18,$01
        breq l14270    ;b.i.SD-card not changed

        push r16

        call l18240    ;initialize SD-card 
                       ;important that swapbuffer can be stored to swapfile
                       ;sdfldc stay #$01 =statys that flag that disk is changed
        pop r16
        lds r17,acsacb ;actual SA in CBM-buffer (00-$12 0-18)         
*/
l14270:
       #endif

        sts acsacb,r16 ;actual SA in CBM-buffer (00-$12 0-18)   this is the new wanted SA
                       ;this is later written to HD nlq-swap.sys (but later not read)
                       ;=> the value acsacb (01be (08be)) of the HD-sector doesn't contain
                       ;    the SA of the backuped CBM-swapbuffer but the SA of the wanted one

                       ;                                          save old CBM-buffer to swapfile
        cpi r17,$ff
        breq l14280    ;b.i.there is no actual data in CBM-buffer = don't save to swapfile
                       
                       ;                                                  save buffer to swapfile
     
        rcall l14140   ;test legal swapfile & compute correct sector of swapfile
                       ;r17=wanted SA of swapfile
      
        ldi r16,$07 | obhasf ;%00...... / %10...... override bits hardware of swapfile
                       ;sets override-function for swap-buffer 0
                       ;%00=IDE-HD  %10=SD-card

        sts ovhbtw,r16 ;actual SA HD-buffer-transfer write-overwrite

        ldi r17,$30    ;write sectors with retry  
        rcall l14930   ;send block-write-command to HD
    
        lds r16,acsacb ;this is the new wanted SA
             
l14280: ldi r25,$7c    ;7c--                                    load new CBM-buffer from swapfile
        rcall l13130

        ldi r30,low(tasach) ;table secundaryaddrsee -> channel
        ldi r31,high(tasach)
        add r30,r16    ; adds new wanted SA = vector to entry in table of new wanted SA
        ld r17,z
        cpi r17,$ff
        brne l14310    ;b.i.wanted SA is opened

l14290: ldi r30,low(swbube) ;swap buffer begin = wanted SA isn't opened
        ldi r31,high(swbube) ;$09e0

l14300: st z+,r06      ;clears swapbuffer (important at least that flags for SA opened for 
        cpi r31,high(swbuen) ;read or write (bit 7&6 of asfla1) aren't set from a before used command)
        brne l14300    ;swap buffer end
        rjmp l14320

l14310: lds r17,acsacb ;actual new SA for CBM-buffer (stored to old acsacb at l14270)

        rcall l14140   ;test legal swapfile & compute correct sector of swapfile
                       ;r17=wanted SA of swapfile

        ldi r16,$07 | obhasf ;%00...... / %10...... override bits hardware of swapfile
                       ;sets override-function for swap-buffer 0

        sts ovhbtr,r16 ;overwrite HD-buffer-transfer read
                       ;still set override-flag for correct hardware where swapfile is???
                       ;or make this at sector read/write-routine???
                                             
        rcall l14920   ;send block-read-command to HD
       #endif          ;of l14210  

l14320: ret
;------------------------------------------------------------------------------------------------
;        swapfile:
;                             there are 32 buffers for every device
;                  sector     there are 3 device-emulations
;        0000-3fff  00-1f     32 buffers (512bytes) for devicemulation0 (HD)
;        4000-7fff  20-3f     32 buffers (512bytes) for devicemulation1 (CD)
;        8000-bfff  40-5f     32 buffers (512bytes) for devicemulation0 (SD)
;        c000-cfff  60-67     device-buffer for emulation0 (HD)  (2kb of 4kb used) 
;        d000-dfff  68-6f     device-buffer for emulation0 (CD)  (2kb of 4kb used) 
;        e000-efff  70-77     device-buffer for emulation0 (SD)  (2kb of 4kb used) 
;        f000-ffff  78-7f     unused
;------------------------------------------------------------------------------------------------
       #if partname == 7    
        #message 644-NLQ-HD/full
   
l14330: ldi r25,$87    ;87----                                 save old device-buffer to swapfile
        rcall l13090   ;                                 and load new device-buffer from swapfile

        mov r25,r16    ;          DEB=device-emulation-buffer 0600-0dff
        rcall l13130   ;---- (wanted, new deviceemulation loaded from swapfile)

        lds r25,acemen
        rcall l13130   ;---- (old deviceemulation saved to swapfile)

        ldi r25,$88    ;88--
        rcall l13130  

        cpi r16,$03
        brcs l14340    ;b.i.DEB 0-2 wanted (=legal)

        ldi r17,$67    ;(67--)  (103--)
        rjmp syserr

l14340: lds r17,acemen ;actual emulated entry 0,1,2 in AVR RAM 0-2
        cp r16,r17     ;             r16=new, wanted DEB   r17=actual (now old) DEB
        breq l14360    ;b.i.wanted DEB is already in AVR-RAM

        sts acemen,r16 ;actual DEB in AVR_RAM (0-2)                      save old DEB to swapfile
                       ;r17  00  01  02
        lsl r17        ;     00  02  04       60=sector$60 of swapfile (512 bytes per sector)
        lsl r17        ;     00  04  08       $60*512 = $c000
        lsl r17        ;     00  08  10       $68*512 = $d000
        ori r17,$60    ;     60  68  70       $70*512 = $e000
                       ;                            
        rcall l14150   ;test legal swapfile & compute correct sector of swapfile
                       ;r17=vector to wanted DEB of swapfile
      
        ldi r16,$06 | obhasf ;%00...... / %10...... override bits hardware of swapfile
                       ;sets override-function for DEB
                       ;%00=IDE-HD
                       ;08= use DEB device-emulation-buffer 0600-0dff

        sts ovhbtw,r16 ;actual SA HD-buffer-transfer write-overwrite

        ldi r17,$30    ;write sectors with retry  
        ldi r16,$04    ;read 4 sectors 4*512=2048 = 2kb = length of DEB $0800 - 0fff  
        rcall l14940   ;send block-write-command to HD

l14350: ldi r25,$8c    ;8c--                                           load new DEB from swapfile
        rcall l13130

        lds r17,acemen ;actual new DEB for AVR-RAM (stored to old acemen at l14340)
                       ;r17  00  01  02
        lsl r17        ;     00  02  04       60=sector$60 of swapfile (512 bytes per sector)
        lsl r17        ;     00  04  08       $60*512 = $c000
        lsl r17        ;     00  08  10       $68*512 = $d000
        ori r17,$60    ;     60  68  70       $70*512 = $e000

        rcall l14150   ;test legal swapfile & compute correct sector of swapfile
                       ;r17=vector to wanted DEB of swapfile

        ldi r16,$06 | obhasf ;%00...... / %10...... override bits hardware of swapfile
                       ;sets override-function for DEB

        sts ovhbtr,r16 ;overwrite HD-buffer-transfer read

        ldi r17,$20    ;read sectors with retry  
        ldi r16,$04    ;read 4 sectors 4*512=2048 = 2kb = length of DEB $0800 - 0fff   


        ldi r16,$03    ;read 3 sectors only !!!temporary $0800 - 0dff  
                       ;for storeing of HD-access-sector-datas 0e00-0fff!!!!!!!!!!!!!!!!!!!!!


        rcall l14940   ;send block-read-command to HD

l14360: ret

#endif
;------------------------------------------------------------------------------------------------


                       ;from l21950 (free cluster), l22000 (allocate cluster), 
                       ;     l22110 (search next free cluster)
l14370: lds r12,geaccl ;                                 read FAT-entry of general actual cluster
        lds r13,geaccl+1 ;                       loads general actual cluster   =  $80/81 at 1541
        lds r14,geaccl+2 ;reads from FAT1 
        lds r15,geaccl+3 
        rjmp l14390    ;-------------------------------------------------------------------------
                       ;from l14440 (read followcluster)
l14380: lds r12,ashbcl ;                            read FAT-entry of actual SA HD-buffer cluster                                        
        lds r13,ashbcl+1 ;     loads actual cluster secundary address  =  $06/07 - $0e/0f at 1541
        lds r14,ashbcl+2 ;reads from FAT1 
        lds r15,ashbcl+3 ;.......................................................................
                       ;from l18840 (writes into FATentry of actual endcluster the followcluster)
                       ;     l18610 (test whether NLQ-SWAP.SYS is unfragmented)
l14390:                ;                                      read FAT-entry of cluster in r12-15
                       ;T-flag=clear: don't compare FAT1 and FAT2
                       ;T-flag=set: compare FAT1 and FAT2
        lds r16,flfbch ;flags FAT-buffer changed
                       ; (if few RAM then perhaps together with acenfb??)      
                       ;bit7: FAT-buffer changed (doesn't matter whether allocate or free)
                       ;bit6: FAT-buffer changed by allocate cluster
                       ;bit5: FAT-buffer changed by free cluster
                       ;bit4: 0=use FAT1   1=use FAT2 (not used)
                       ;bit3: 0=don't compare FAT1 and FAT2   1=compare FAT1 and FAT2
                       ;bit2: 0=actual FAT isn't compared with FAT2 1=actual FAT is compared
                       ;bit1: 0=actual FATs are identical   
                       ;      1=difference of actual FAT1 and FAT2 
                       ;bit0:
        bld r16,3      ;clears/sets bit for compare FAT1 and FAt2
        sts flfbch,r16         

        lds r16,sbpaf1 ;sectorbegin partition FAT1
        lds r17,sbpaf1+1
        lds r18,sbpaf1+2 ;reads from FAT1 
        lds r19,sbpaf1+3
                       ;correct way: multiply FAT by 4 (because 1 FATentry = 4 bytes (at FAT32)
                       ;             divide by 512 (because 512 bytes per sector)
                       ;easier way: multiply FAT by 2
                       ;            divide by 256 
        ldi r25,$cc    ;cc-- xx-- xx-- xx-- xx-- xx-- 
        rcall l13060   ;(actual cluster which followcluster is wanted of)

        lsl r12        ;multiplies by 2
        rol r13
        rol r14
        rol r15
        brcc l14400    ;b.i.no overflow error at multiplication
        rjmp l14870    ;overflow error at multiplication

l14400: mov r11,r12    ;=remainder of divission by 256 = later vector in buffer to FATentry

        mov r12,r13    ;divission by 256
        mov r13,r14
        mov r14,r15
        clr r15        ;divission by 256

        add r12,r16    ;adds begin of FAT1 (=adds reserved sectors+sectors before partitonbegin)
        adc r13,r17
        adc r14,r18
        adc r15,r19    ;=sector where FATentry of actual cluster is

        ldi r25,$cd    ;cd-- xx-- xx-- xx-- xx-- xx-- 
        rcall l13060   ;(sector where FATentry of actual cluster is)

        lds r16,acsefb ;actual sector FAT-buffer (values of FAT1)
        lds r17,acsefb+1    
        lds r18,acsefb+2
        lds r19,acsefb+3  

        tst r19
        brmi l14420    ;b.i.FAT-buffer doesn't contain (valid) data
        
        cp r12,r16
        brne l14410
        cp r13,r17
        brne l14410
        cp r14,r18
        brne l14410
        cp r15,r19
        breq l14430

l14410: push r12      ;backups lba addres of new wanted FAT-buffer
        push r13
        push r14
        push r15

        rcall l14610   ;writes back (old-) actual FAT-buffer if it's changed
                       ;writes to FAT1 and to FAT2
                       ;mustn't change r11
        pop r15
        pop r14        ;restores lba addres of new wanted FAT-buffer
        pop r13
        pop r12

l14420: rcall l14740   ;tests legal sector and loads FAT-sector (mustn't change r11) <-----------
                       ;bit3 of flfbch flags FAT-buffer changed
                       ; 0=don't compare FAT1 and FAT2   1=compare FAT1 and FAT2

l14430: mov r28,r11    ;=former remainder of divission by 256 = vector in buffer to FATentry
        lsl r28        ;multiplies by 2
        ldi r29,high(fabube) ;fat buffer begin
        adc r29,r06    ;#$00  adds carry

        ldi r25,$ce    ;ce--
        rcall l13130
        mov r25,r28
        rcall l13130   ;---- (Y-vector where r12-r15 is read from)
        mov r25,r29
        rcall l13130   ;----
       
        clr r11        ;clears sector in this cluster (because r12-r15 contain new 
                       ;calculated cluster and r11 is overwritten with temporary remainder) 
        ld r12,y+      ;reads follow-cluster of actual cluster from correct FAT-sector
        ld r13,y+      ; and correct FAT-entry position
        ld r14,y+
        ld r15,y
        ldi r16,$0f
        and r15,r16    ;masks off bit 31-29
        
        andi r28,$fc   ;%11111100 makes vector to first byte of FAT-entry

        rcall l13070   ;xx-- xx-- xx-- xx-- xx-- (follow cluster of old actual cluster is)

        lds r16,flfbch ;flags FAT-buffer changed
        andi r16,$02   ;bit1: 0=actual FATs are identical   
                       ;      1=difference of actual FAT1 and FAT2 
        ret            ;Y=vector to first byte of FAT-entry
                       ;r12-r15=FAT-entry of actual cluster (=follow-cluster)
                       ;equal=FATs are identical   notequal=difference of actual FAT1 and FAT2   
;------------------------------------------------------------------------------------------------
                       ;from l14800 (read sector...), l15720 (read dirsector at directory)
l14440:                ;             reads FAT-entry of actual-cluster (=values of followcluster)
                       ;                  in ashbcl actual cluster secundary address (not r12-r15)
        clt            ;=flag for don't compare FAT1 and FAT2
        rcall l14380   ;reads FAT-entry of actual cluster (=values of followcluster) 
                       ;.........................................................................        
                       ;from l17720
l14450:                ;                checks whether cluster is bad / end- / notend-cluster
                       ;                                          <00000002 -> sysetmerror,38
                       ;                                          bad ->systemerror,42
                       ;                                          notendcl.->carryclear notequal    
                       ;                 f......                  endclust.->carryset   equal
        ldi r16,$0f    
       ;and r15,r16    ;masks off bits 31-28
        cp r15,r16     ;#$0f
        brne l14470    ;b.i not cluster 0f......
        
        cp r14,r07     ;#$ff
        brne l14470    ;b.i.not cluster ..ff....
        
        cp r13,r07
        brne l14470    ;b.i.not cluster ....ff..
       
                       ;=0fffff..
        mov r16,r12
        cpi r16,$f7    ;#$f7
        brne l14460    ;b.i.not 0ffffff7 = not bad cluster

                       ;=0ffffff7 = bad cluster
        ldi r17,$2a    ;2a--  42--
        rjmp syserr    ;system error----------------

l14460: cp r12,r07     ;#$ff
        sec            ;flag for actual cluster is an endcluster
        breq l14500    ;b.i.0fffffff = end

l14470:                ;=not bad-cluster, not end-cluster
        mov r16,r13    ;test whether cluster 00000000 or 00000001
        or r16,r14
        or r16,r15
        brne l14480    ;b.i.not 000000..

        mov r16,r12
        cpi r16,$02
        brcc l14480    ;b.i. 00000002 - 000000ff

        ldi r17,$26    ;26-- 38--
        rjmp syserr    ;system error----------------

l14480: lds r16,amtocl ;amount of total clusters      00001000: 00000002-00000fff/00001001
        sub r16,r12
        lds r16,amtocl+1
        sbc r16,r13
        lds r16,amtocl+2
        sbc r16,r14
        lds r16,amtocl+3
        sbc r16,r15
        brcc l14490    ; 

        ldi r17,$27    ;27-- 39--
        rjmp syserr    ;system error----------------

l14490: ;clc           ;flag for actual cluster has a follow-cluster
                       ;carry is cleared

l14500: ret            ;carry = clear=not-endcluster=notequal / set=endcluster=equal
                       ;                               1541:     NLQ-HD 
                       ;follow-track:                  lda $80   r12-r15
                       ;                                         rcall l14450 
                       ;b.i.there is a follow-sector:  bne       brne
                       ;b.i.it is an endsector:        beq       breq
;------------------------------------------------------------------------------------------------
                       ;from l22100
l14510: lds r11,sepecl ;sectors per cluster             compute last sector of cluster in r12-r15
        dec r11
        lsl r11
        ;sts ashbsc,r11 ;makes actual SA HD-buffer sector in this cluster to last sector
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        rjmp l14530         
                       ;.........................................................................
                       ; from l18590
l14520:                ;                               compute first sector of cluster in r12-r15 
        clr r11        ;#$00 clears actual SA HD-buffer sector in this cluster
        ;sts ashbsc,r11 ;#$00 clears actual SA HD-buffer sector in this cluster
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
                       ;.........................................................................
                       ; from l14720, l14850
l14530:                ;        compute actual sector of cluster in r11-r15   actual cluster->LBA
        ldi r25,$91    ;91-- xx-- xx-- xx-- xx-- xx-- (clusteraddress (not sectoraddress))
        rcall l13060   ;prints r25, r12-r15 into debugbuffer 

        ldi r16,$02  
        sub r12,r16    ;subtracts #$02 (without carry) from clusteraddress
        sbc r13,r06    ;#$00 subtracts carry
        sbc r14,r06
        sbc r15,r06    ;decrements startcluster by 2
        ldi r25,$98    ;(98--)   (152--)
        brcs l14550    ;b.i.error = cluster 00000000 or 00000001 cluster
        
        lds r16,sepecl ;sectors per cluster (1,2,4,8,16,32,64)
l14540: lsr r16
        brcs l14560    ;b.i end of multiplication (r12-r15 contains sectors from begin of
                       ;                                    data area)
        lsl r12        ;multiplies by 2 (x times)
        rol r13
        rol r14
        rol r15
        brcc l14540    ;b.i.no overflow error at multiplication

        ldi r25,$99    ;(99--)  (153--)
l14550: mov r17,r25
jmp freeze
.db 0

        rjmp syserr    ;(9x--)  system error (9x--)
        
l14560: ldi r25,$92    ;92--
        rcall l13130

        mov r16,r11    ;actual SA HD-buffer sector in this cluster 
                       ;important that r11 isn't changes because later needed for
                       ; computing highbyte vector where to copy from HD-buffer to CBM-buffer  
        lsr r16        ;256-bytes-CBM-sectors -> 512-bytes-HD-sectors
        add r12,r16
        adc r13,r06
        adc r14,r06
        adc r15,r06
        ldi r25,$9a    ;(9a--)  (154--)
        brcs l14550          

        ldi r25,$93    ;93--
        rcall l13130
        
        lds r16,sbpada ;sectorbegin partition data (from begin of MBR)
        add r12,r16    ;                 (not from begin of partition)
        lds r16,sbpada+1
        adc r13,r16
        lds r16,sbpada+2
        adc r14,r16
        lds r16,sbpada+3
        adc r15,r16
        ldi r25,$9b    ;(9b--)  (155--)
        brcs l14550    ;b.i.overflow error at addition

        ldi r25,$94    ;94-- xx-- xx-- xx-- xx-- xx-- (sectoraddress (not clusteraddress))
        rcall l13060   ;prints r25, r12-r15 into debugbuffer 

        ret            ;r12-r15 contains sectoraddress in LBA (not clusteraddress)
;------------------------------------------------------------------------------------------------
l14570: ldi r16,$04    ;%....1100 =read from HD into AVR-HD-buffer         identify-drive-command  
        sts ashbtr,r16 ;actual SA HD-buffer-transfer read

        ldi r17,$ec    ;identify-drive-command...................................................
                       ;from l                 
l14580: ldi r16,$01
        sts idcore,r17 ;IDE-command-register                        (r12-r15=sector in LBA0-3) 
        sts idscre,r16 ;IDE-sector count register
    
        sts acsehb+3,r07 ;#$ff clears actual sector in HD-buffer (legal value is $00-$0f)

        clr r12
        clr r13        ;rjmp l14930 is bad because LBA -> CHS computing doesn't work
        clr r14        ; because CHS-values of HD aren't yet set
        clr r15
        rjmp l15140
;------------------------------------------------------------------------------------------------
                       ;from l17740, l17750, l18870, l19280, l19320, l19450, l21810
                       ;from l21980, l21980, l22020, l22020
l14590:                ;                             writes last-read/actual HD-buffer back to HD
        lds r12,acsehb ;actual sector HD-buffer                writes last read sector back to HD  
        lds r13,acsehb+1 ;always in LBA-format              (uses LBA-address of last HD-command
        lds r14,acsehb+2 ; (sector    not cluster)           => pay attention that this isn't
        lds r15,acsehb+3 ;                                      changed!!!) 

        ldi r25,$d0    ;d0--
        rcall l13130

       #if partname == 1    
        #message 162-IEC-ATA-V2
        ldi r16,$c4    ;makes override-function for write from AVR-HD-buffer to actual hardware
        rjmp l14700    

       #else    
        #message not-IEC-ATA-V2                 
        lds r16,acenhb ;actual emulation(entry)number (of sector) in HD buffer
        ldi r17,$04    ;flag for HD-buffer
        rjmp l14680 
       #endif
;------------------------------------------------------------------------------------------------
                       ;from l21950 (free cluster)
l14600:                ;      writes back actual FAT-buffer if a cluster is changed by allocating

        ldi r25,$d1    ;d1--
        rcall l13130

        lds r16,flfbch ;flags FAT-buffer changed
        andi r16,$40   ;bit6: FAT-buffer changed by allocate cluster
        rjmp l14620    ;-------------------------------------------------------------------------
                       ;from l14410 (read FAT-sector), l17690 (sctarch), l21650 (close) 
l14610:                ;                            writes back actual FAT-buffer if it's changed
        lds r16,flfbch ;flags FAT-buffer changed
                       ;bit7: FAT-buffer changed (doesn't matter whether allocate or free)
                       ;bit6: FAT-buffer changed by allocate cluster
                       ;bit5: FAT-buffer changed by free cluster
        andi r16,$80   
                       ;............................... 
l14620: brne l14630    ;b.i.FAT-buffer is changed
        
        ret            ;=FAT-buffer isn't changed => no need to write it to HD
                       ;-------------------------------------------------------------------------    
l14630:                ;           writes last-read/actual FAT-buffer back to FAT1 and FAT2 of HD
        lds r12,acsefb ;actual sector FAT-buffer               writes last read sector back to HD
        lds r13,acsefb+1 ;always in LBA-format              (uses LBA-address of last HD-command
        lds r14,acsefb+2 ; (sector    not cluster)           => pay attention that this isn't
        lds r15,acsefb+3 ; must be values of FAT1 (not FAT2)     changed!!!)

        ldi r25,$d2    ;d2--
        rcall l13130

        lds r16,flfbch
        andi r16,$1f
        sts  flfbch,r16 ;clears flag that FAT-buffer is changed

       #if partname == 1    
        #message 162-IEC-ATA-V2
        ldi r16,$c3    ;makes override-function for write from AVR-FAT-buffer to actual hardware
        rcall l14700   ;write-back FAT1
                       ;changes r12-15 if LBA->CHS-computing
                       ;if no LBA->CHS-computing, then r12-r15 stay perhaps same???
                       ; perhaps then (IEC-ATA-V2) not necessary to reload r12-r15????
   
       #else    
        #message not-IEC-ATA-V2                 
        ldi r17,$03    ;flag for FAT-buffer
        rcall l14670   ;write-back FAT1
                       ;changes r12-15 if LBA->CHS-computing
                       ;if no LBA->CHS-computing, then r12-r15 stay perhaps same???
                       ; perhaps then (IEC-ATA-V2) not necessary to reload r12-r15????
       #endif 

        ldi r25,$d3    ;d3--
        rcall l13130

        lds r12,acsefb ;actual sector FAT-buffer
        lds r13,acsefb+1 ;always in LBA-format    
        lds r14,acsefb+2 ; (sector    not cluster)
        lds r15,acsefb+3 ; must be values of FAT1 (not FAT2)  

       #if partname == 1    
        #message 162-IEC-ATA-V2
        lds r16,lefahd ;length FAT of HD 
        lds r17,lefahd+1 ; important to store not in device emulation buffer because it's
        lds r18,lefahd+2 ; possible that it must be rewritten when the active device is
        lds r19,lefahd+3 ; changed
       #endif

       #if (partname == 3) | (partname == 6)
        #message 644-NLQ-HD/SD-card
        lds r16,lefasd ;length FAT of SD 
        lds r17,lefasd+1 ; important to store not in device emulation buffer because it's
        lds r18,lefasd+2 ; possible that it must be rewritten when the active device is
        lds r19,lefasd+3 ; changed
      #endif

       #if (partname == 4) | (partname == 5)    
        #message nlq-hd/HD-routines
        lds r16,lefahd ;length FAT of HD 
        lds r17,lefahd+1 ; important to store not in device emulation buffer because it's
        lds r18,lefahd+2 ; possible that it must be rewritten when the active device is
        lds r19,lefahd+3 ; changed
        lds r28,acenfb ;actual emulation(entry)number (of sector) in FAT buffer
                       ; 0,1,2  0=HD  1=CDROM  2=SD-card          
        ;cpi r28,$00
        ;breq l14640    ;b.i.HD   still make for CD  
                         
        ;lds r16,lefasd ;length FAT of SD 
        ;lds r17,lefasd+1 ; important to store not in device emulation buffer because it's
        ;lds r18,lefasd+2 ; possible that it must be rewritten when the active device is
        ;lds r19,lefasd+3 ; changed

l14640:
       #endif

       #if partname == 7    
        #message nlq-hd/full
        lds r16,lefahd ;length FAT of HD 
        lds r17,lefahd+1 ; important to store not in device emulation buffer because it's
        lds r18,lefahd+2 ; possible that it must be rewritten when the active device is
        lds r19,lefahd+3 ; changed
        lds r28,acenfb ;actual emulation(entry)number (of sector) in FAT buffer
                       ; 0,1,2  0=HD  1=CDROM  2=SD-card          
        cpi r28,$00
        breq l14650    ;b.i.HD  
   
        lds r16,lefasd ;length FAT of SD 
        lds r17,lefasd+1 ; important to store not in device emulation buffer because it's
        lds r18,lefasd+2 ; possible that it must be rewritten when the active device is
        lds r19,lefasd+3 ; changed

l14650:
       #endif

        add r12,r16
        adc r13,r17
        adc r14,r18
        adc r15,r19    ;writes back FAT2

l14660: 
       #if partname == 1    
        #message 162-IEC-ATA-V2
        ldi r16,$c2    ;makes override-function for write from AVR-FAT-buffer to actual hardware

       #else    
        #message not-IEC-ATA-V2                 
        ldi r17,$02    ;flag for FAT-buffer
       
l14670: lds r16,acenfb ;actual emulation(entry)number (of sector) in FAT buffer
                       ;........................
                       ;from l14590
l14680: lds r18,acemen ;actual emulated entry 0,1,2
        cp r16,r18     ;
        breq l14690    ;b.i.the sector is written to the actual device               
                       
                       ;sector is written not to the actual device
                       ;still make for CD?
       #if (partname == 3) | (partname == 6) | (partname == 7)    
        #message nlq-hd/SD-card
        cpi r16,$02
        brne l14690    ;b.i.not SD

                       ;=SD (possibility that SD is changed)
        lds r18,sdfldc ;SD flag disk change                             (bit0-3=$1c at 1541)
                       ;                                                (bit4-7=$1e at 1541)
        andi r18,$01   
        brne l14710    ;b.i.SD was changed (or removed)            
       #endif

l14690:                ; 00,01,02  0=HD  1=CDROM  2=SD-card
        swap r16       ; 00,10,20                     
        lsl r16        ; 00,20,40             
        lsl r16        ; 00,40,80
        or r16,r17     ; 02,42,82  0c,4c,8c
                       ;makes override-function for write from AVR-FAT-buffer to hardware
                       ; of FAT-buffer / HD-bufer
       #endif          ;of l14660
                       ;........................................................................
                       ;from l14590
l14700: sts ovhbtw,r16 ;sets override function
        ldi r17,$30    ;write sectors with retry  
        rjmp l14930    ;send block-write-command to HD (write 1 sector only)
                       ;write FAT-sector with allocted enty to HD
                       ; write sector-address

                       ;at end when FAT1 and FAT2 is written:
                       ;acsefb contaisn values for FAT2
                       ;=>AVR reloads FAT1 again because it thinks that the wrong FATbuffer 
                       ;   is loaded
                       ; recompute clusteraddres for FAT1 could be faster, but would need more
                       ;  RAM
l14710: ret
;------------------------------------------------------------------------------------------------
l14720: lds r11,ashbsc ;                       write actual sector of actual SA HD-buffer cluster 
                       ;actual sector in cluster of actual SA             in ashbcl (not r12-r15)
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        lds r12,ashbcl 
        lds r13,ashbcl+1;loads actual cluster secundary address         
        lds r14,ashbcl+2
        lds r15,ashbcl+3 

        ldi r25,$98    ;98----        
        rcall l13090
        
        ldi r16,$0f
        and r15,r16    ;masks off bit 31-29 of cluster 

        rcall l14530   ;clusteraddress -> sectoraddress
                
        sec            ;!sec => subtracts one more         test legal sector 
        lds r16,sbpaen ;sectorbegin partition end (+1)       (r12-r15=sector in LBA0-3)
        sbc r16,r12    ;mustn' change r12-r15                 (not cluster)
        lds r16,sbpaen+1
        sbc r16,r13
        lds r16,sbpaen+2
        sbc r16,r14
        lds r16,sbpaen+3
        sbc r16,r15
        ldi r25,$9d    ;9d--
        brcc l14730    ;b.i.actual sector is not over end of partition 

        ldi r17,$33    ;33--  51--
        rjmp syserr    ;system error
       
l14730: ldi r25,$99    ;99--
        rcall l13130

        ldi r17,$30    ;write sectors with retry
        rjmp l14930    ;write 1 sector
;------------------------------------------------------------------------------------------------
                       ;from l14420 (read FAT-sector)
l14740:                ;                                          read FAT-sector into FAT-buffer
                       ;                      r12-15 must contain sectoraddress of FAT-buffer
        ldi r25,$d4    ;d4--
        rcall l13130

        ldi r16,$c3    ;flag for copy into FAT-buffer $0e00-$0fff
        sts ovhbtr,r16 ;makes flag that HD-sector is copied to 512bytes FAT-buffer 
                       ;      overwrite HD-buffer-transfer read
        rcall l14860   ;reads FAT1 into FAT-buffer (if not yet in FAT-buffer)
                       ; reads only if different FAT-sector wanted
                       ; doesn't save old FAT-buffer to HD
                       ; stores r12-15 to acsefb
                       ;if the FATsector is loaded: clears bits that FATs are compared   
                       ; else: doesn't change the FAT-compared-bits
        ldi r25,$d5    ;d5--
        rcall l13130
                                                    
        lds r16,flfbch ;flags FAT-buffer changed
                       ;bit7: FAT-buffer changed (doesn't matter whether allocate or free)
                       ;bit6: FAT-buffer changed by allocate cluster
                       ;bit5: FAT-buffer changed by free cluster
                       ;bit4: 0=use FAT1   1=use FAT2 (not used)
                       ;bit3: 0=don't compare FAT1 and FAT2   1=compare FAT1 and FAT2
                       ;bit2: 0=actual FAT isn't compared with FAT2 1=actual FAT is compared
                       ;bit1: 0=actual FATs are identical   
                       ;      1=difference of actual FAT1 and FAT2 
                       ;bit0:
        bst r16,3      ;copies FAT-compare-bit to T-flag
        andi r16,$1f   ;clears flags for FAT-buffer changed
                       ;doesn't change flags for FATs-compared        
        brtc l14750    ;b.i.don't compare FAT1 with FAT2
        
                       ;= compare FAT1 with FAT2            

        ldi r25,$d6    ;d6--
        rcall l13130

        bst r16,2      ;copies FAT-compared-bit to T-flag
        brts l14750    ;b.i.FAT1 and FAT2 is already compared

        lds r12,acsefb ;actual sector FAT-buffer
        lds r13,acsefb+1 ;always in LBA-format    
        lds r14,acsefb+2 ; (sector    not cluster)
        lds r15,acsefb+3 ; must be values of FAT1 (not FAT2)  

        lds r16,sbpaf1   ;subtracts secttorbegin of FAT1
        sub r12,r16
        lds r16,sbpaf1+1
        sbc r13,r16
        lds r16,sbpaf1+2
        sbc r14,r16
        lds r16,sbpaf1+3
        sbc r15,r16

        lds r16,sbpaf2  ;adds secttorbegin of FAT2
        add r12,r16
        lds r16,sbpaf2+1 ;=> computes the same FAT-sector of FAT2
        adc r13,r16
        lds r16,sbpaf2+2
        adc r14,r16
        lds r16,sbpaf2+3
        adc r15,r16    ;

        ldi r16,$c2    ;flag for compare FAT-buffer $0e00-$0fff
        sts ovhbtr,r16 ;makes flag that HD-sector is copied to 512bytes FAT-buffer 
                       ;      overwrite HD-buffer-transfer read
        rcall l14860   ;compares FAT2 with FAT-buffer
                       ;r05=equal/notequal

        ldi r25,$d7    ;d7--
        rcall l13130

        lds r16,flfbch ;flags FAT-buffer changed
        andi r16,$19   ;clears flags for FAT-buffer changed
                       ;makes default-bit for no compare error
        ori r16,$04    ;makes flags for FATs compared        
        tst r05    
        breq l14750    ;b.i.no difference in FAT1 and FAT2
                       
                       ;= difference in FAT1 and FAT2
        ori r16,$02    ;sets bit that difference in FAT1 and FAT2 at compare
        
l14750: sts flfbch,r16 ;flags FAT-buffer changed
        andi r16,$02   ;masks bit for FAT1/FAT2-compare error

        ldi r25,$d8    ;d8--
        rcall l13130

        ret            ;equal= FAT1=FAT2  notequal=difference of FAT1 and FAT2
;------------------------------------------------------------------------------------------------
                       ; from l21780
l14760: lds r16,ashbsc ;actual sector of actual SA    read follow-512-HD-sector of actual cluster
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        ori r16,$01    ;makes CBM is last half of HD-buffer
        rjmp l14780    ; =>is later increased to (first half of) follow-512-HD-sector
;................................................................................................
                       ; from l18560
l14770: lds r16,ashbsc ;actual sector of actual SA   read follow-256-CBM-sector of actual cluster
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
l14780: inc r16        ;increments actual sector (increments first: first/second half of 
        sts ashbsc,r16 ;   HD-buffer     then: HD-sector in this cluster) 
                       ;!counts 256-bytes-cbm-sectors          =    $06/07 - $0e/0f at 1541
                       ; doesn't count 512-bytes-hd-sectors
                       ;......................................................................... 
                       ; from l21120
l14790: lds r11,ashbsc ;                             read actual sector of actual cluster (again)
        mov r16,r11    ;                                       of cluster in ashbcl (not r12-r15)
                       ;!counts 256-bytes-cbm-sectors          =    $06/07 - $0e/0f at 1541
                       ; doesn't count 512-bytes-hd-sectors
        lsr r16        ;flag for CBM-sector is first/second half of HD-sector into carry
                       ;r16 contains now actual HD-sectror of this cluster 
                       ;  in same format as sepecl   

        lds r17,sepecl ;sectors per cluster

        lds r12,ashbcl ;loads actual cluster secundary address
        lds r13,ashbcl+1
        lds r14,ashbcl+2
        lds r15,ashbcl+3
        
        cp r16,r17
        brcs l14850    ;b.i.still sectors in this cluster to read

        breq l14800    ;b.i.1 sector after last sector in this cluster

        ldi r17,$80    ;80--  128--  =more than 1 sector after last sector in this cluster
jmp freeze
        rjmp syserr    ;system error =illegal value of sector-in-this-cluster

l14800: rcall l14440   ;computes follow-cluster of actual cluster
                       ;!changes buffers and actual cluster???
        brcc l14820    ;b.i.not endcluster

        ret            ;old-actual cluster was end-cluster (carry is set?)  
;................................................................................................
                       ;from l21840
l14810: lds r12,ashbcl ;                         reads startsector of actual SA HD-buffer cluster 
        lds r13,ashbcl+1;loads actual cluster secundary address
        lds r14,ashbcl+2
        lds r15,ashbcl+3 ;.......................................................................
                       ;from l20960, l18440
l14820: clr r11        ;clear sector in this cluster        read startsector of cluster (r12-r15)
                       ;.........................................................................
                       ;from l
l14830: ldi r25,$90    ;90----                               read sector-r11 of cluster (r12-r15)
        rcall l13090   ;                                       and store values as ashbcl ashbsc
        
        ldi r16,$0f
        and r15,r16    ;masks off bit 31-29 of cluster 

        cp r12,r07     ;#$ff
        brne l14840    ;b.i.not EOC (end of clusterchain)
        cp r13,r07
        brne l14840
        cp r14,r07     ;#$ff
        brne l14840
        cp r15,r16     ;#$0f
        brne l14840    ;b.i.not EOC
                       
                       ;error: try to load EOC-cluster
        ldi r25,$9d    ;9d--
        rjmp l14870

l14840: sts ashbcl,r12 ;stores actual cluster of SA
        sts ashbcl+1,r13
        sts ashbcl+2,r14
        sts ashbcl+3,r15
        sts ashbsc,r11 ;sector within this cluster (#$00 = first sector if call l14820)
                       ;!counts 256-bytes-cbm-sectors          =    $06/07 - $0e/0f at 1541
                       ; doesn't count 512-bytes-hd-sectors
                       ;.........................................................................
                       ;from l19240
                       ;               cluster in r11-15: test whether legal and load 1 HD-sector
l14850: rcall l14530   ;clusteraddress -> sectoraddress
                
l14860: sec            ;!sec => subtracts one more         test legal sector and load 1 HD-sector
        lds r16,sbpaen ;sectorbegin partition end (+1)       (r12-r15=sector in LBA0-3)
        sbc r16,r12    ;mustn' change r12-r15                 (not cluster)
        lds r16,sbpaen+1
        sbc r16,r13
        lds r16,sbpaen+2
        sbc r16,r14
        lds r16,sbpaen+3
        sbc r16,r15
        ldi r25,$9c    ;(9c--)
        brcc l14880    ;b.i.actual sector is not over end of partition 

                       ;??? test whether sector is in front of actual partition???

l14870: ldi r17,$2b    ;(2b-- 43--)
        jmp syserr     ;system error
       
l14880: ldi r25,$95    ;95--
        rcall l13130
;................................................................................................        
l14890:                ;                       read 1 HD-/FAT-buffer if not yet in HD-/FAT-buffer
                       ;                                       reads in sectors (not in clusters)
        rcall l15510   ;loads actual SA HD-buffer-transfer read to r16
                       ;r16 = correct HD-buffertransfer-value
                       ;at NLQ-HD/full: r17 contains wanted device-emulation-number 0-2
        cpi r16,$03    ;compares whether #$03 wheather sector is read into or written from
                       ;FAT-buffer
        brne l14910    ;b.i.not #$03= not FAT-buffer 

        lds r16,acsefb ;actual sector in FAT-buffer     read 1 FAT-buffer if not yet in HD-buffer
        cp r12,r16     ;                                      reads in sectors (not in clusters) 
        brne l14900    ;b.i.wanted sector isn't already in FAT-buffer
        lds r16,acsefb+1 
        cp r13,r16
        brne l14900
        lds r16,acsefb+2 ;0138-013b 
        cp r14,r16
        brne l14900
        lds r16,acsefb+3
        andi r16,$ff
        brmi l14900    ;b.i.actual sector contains perhaps wrong datas after an error 

        cp r15,r16
        brne l14900    ;b.i.wanted sector not yet in HD-buffer

       #if partname == 7
        #message 644-NLQ-HD/full
        lds r16,acenfb ;actual emulation(entry)number (of sector) in FAT buffer 0,1,2     
        cp r16,r17     ;compares wanted and FAT-buffer device-emulation-number
        brne l14900    ;b.i.sector of different emulationentry is in FAT-buffer     
       #endif

        rjmp l15380    ;wanted sector is already in FAT-buffer

l14900:                ;=FAT-sector must be read from HD
        lds r16,flfbch ;flags FAT-buffer changed
                       ;bit7: FAT-buffer changed (doesn't matter whether allocate or free)
                       ;bit6: FAT-buffer changed by allocate cluster
                       ;bit5: FAT-buffer changed by free cluster
                       ;bit4: 0=use FAT1   1=use FAT2 (not used)
                       ;bit3: 0=don't compare FAT1 and FAT2   1=compare FAT1 and FAT2
                       ;bit2: 0=actual FAT isn't compared with FAT2 1=actual FAT is compared
                       ;bit1: 0=actual FATs are identical   
                       ;      1=difference of actual FAT1 and FAT2 
                       ;bit0:
        andi r16,$f9   ;makes flags for not-compared        
        sts flfbch,r16 ;flags FAT-buffer changed
                       ;it's important that bit 2 is cleared only if a FAT-sector is read
                       ;if the FATsector is already in the FAT-buffer then bit 2 and 1 mast stay
        rjmp l14920 

l14910: 
                       ;!!!! must here be a compare of hdbt.. with #$04/#$05????????????
    
;/* 
        lds r25,acsehb ;xx-- (acsehb)  (before: 95-- from l14880?)
        rcall l13130
        lds r25,acsehb+1 ;xx--
        rcall l13130
        lds r25,acsehb+2 ;xx--
        rcall l13130
        lds r25,acsehb+3 ;xx-- (acsehb+3)
        rcall l13130
    
       #if partname >= 2    
        #message 644-non-IEC-ATA
        lds r25,acenhb ;actual emulation(entry)number (of sector) in HD buffer 0,1,2     
        rcall l13130
       #endif
.db 0
;*/

        lds r16,acsehb ;actual sector in HD-buffer       read 1 HD-buffer if not yet in HD-buffer
        cp r12,r16     ;                                      reads in sectors (not in clusters) 
        brne l14920    ;b.i.wanted sector isn't already in HD-buffer
        lds r16,acsehb+1 
        cp r13,r16
        brne l14920
        lds r16,acsehb+2 
        cp r14,r16
        brne l14920
        lds r16,acsehb+3
        andi r16,$ff
        brmi l14920    ;b.i.actual sector contains perhaps wrong datas after an error 

        cp r15,r16
        brne l14920    ;b.i.wanted sector not yet in HD-buffer
    
       #if partname == 7
        #message 644-NLQ-HD/full
        lds r16,acenhb ;actual emulation(entry)number (of sector) in HD buffer 0,1,2     
        cp r16,r17     ;compares wanted and HD-buffer device-emulation-number
        brne l14920    ;b.i.sector of different emulationentry is in HD-buffer     
       #endif

        rjmp l15380    ;wanted sector is already in HD-buffer

l14920: ldi r17,$20    ;read sectors with retry                                  read 1 HD-sector
                       ;.........................................................................
                       ;from l14210, l14700, l14730, l22850, l22860
l14930: ldi r16,$01    ;read 1 sector only                                read,write,??? 1 sector
                       ;reads always  doesn't check before whether the wanted
                       ; sector is already in AVR-RAM

l14940: sts idcore,r17 ;IDE-command-register                        (r12-r15=sector in LBA0-3) 
        sts idscre,r16 ;IDE-sector count register
  
        ldi r25,$60    ;60---- xx-- xx-- xx-- xx-- xx--                     changes: r16-19, r28-31
        rcall l13060

        push r26       ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        push r27
        
        lds r26,$0e00
        lds r27,$0e01
        cpi r27,$00
        brne l14950    ;b.i.vector not yet initialized
        
        ldi r27,$0e    ;initialize vector                                  0e00-0fff
        ldi r26,$10

l14950: st x+,r12      ;00 lba0 
        st x+,r13
        st x+,r14
        st x+,r15      ;03 lba3

        lds r16,ovhbtr ;04 overwrite HD-buffer-transfer read of actual SA
        st x+,r16
        lds r16,ashbtr ;   actual SA HD-buffer-transfer read 
        st x+,r16
        lds r16,ovhbtw ;   overwrite HD-buffer-transfer write of actual SA
        st x+,r16
        lds r16,ashbtw ;07 actual SA HD-buffer-transfer write of actual SA 
        st x+,r16 

        st x+,r17      ;08 $20=read / $30=write  (0918->0919)

        lds r16,acemen
        st x+,r16      ;09 actual emulation entry

        st x+,r06      ;0a
        st x+,r06      ;0b

        lds r16,amfrcl   ;0c amount of free clusters  
        st x+,r16
        lds r16,amfrcl+1 ;0d amount of free clusters  
        st x+,r16
        lds r16,amfrcl+2 ;0e amount of free clusters    
        st x+,r16
        lds r16,amfrcl+3 ;0f amount of free clusters  
        st x+,r16

        cpi r27,$10
        brcs l14960    ;b.i.end of temporary buffer reached

        ldi r27,$0e
        ldi r26,$10

l14960: sts $0e00,r26
        sts $0e01,r27  ;                                                   0e00-0fff

        pop r27
        pop r26        ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        cpi r17,$20
        brne l14970    ;b.i.not read
        
        rcall l15510   ;loads actual SA HD-buffer-transfer read to r16
                       ;r16 = correct HD-buffertransfer-value
                       ;at NLQ-HD/full: r17 contains wanted device-emulation-number 0-2
        rjmp l14980    ; and swaps and masks active bits (-/full: changes r17!!!)

l14970: cpi r17,$30
        brne l15000    ;b.i.not write

        rcall l15520   ;loads actual SA HD-buffer-transfer write of actual SA to r16
                       ; and swaps and masks active bits (-/full: changes r17!!!)
                       ;r16 = correct HD-buffertransfer-value
                       ;at NLQ-HD/full: r17 contains wanted device-emulation-number 0-2

l14980:                ;r16 = correct HD-buffertransfer-value
                       ;at NLQ-HD/full: r17 contains wanted device-emulation-number 0-2

                       ;r16= override-funktion-bits
                       ;NLQ-HD/full: r17=wanted deviceemulationnumber 0-2
        cpi r16,$03    ;compares whether #$03 wheather sector is read into or written from
                       ;FAT-buffer
        brcs l15000    ;b.i.hdbt.. =0-2
        
        brne l14990    ;b.i.not #$03=FAT-buffer isn't changed => don't change acsefb

        sts acsefb,r12 ;stores to actual sector FAT-buffer  =#$03 
        sts acsefb+1,r13 ;stores allways in LBA-format
        sts acsefb+2,r14 ;must be stored here because r12-r15 could be changed from LBA to CHS
        sts acsefb+3,r15
         
       #if (partname == 3) | (partname == 6)   
        #message nlq-hd/SD-card ;is this necessary????
        lds r17,acemen ;actual emulated entry 0,1,2
        sts acenfb,r17 ;actual emulation(entry)number (of sector) in HD buffer
                       ; 0,1,2     
       #endif

       #if (partname == 7)   
        #message nlq-hd/full
        sts acenfb,r17 ;actual emulation(entry)number (of sector) in HD buffer
                       ; 0,1,2     
       #endif
        rjmp l15000

l14990: 
                       ;=4-5 (IEC-ATA)     IEC-ATA: only 0-5 is possible
                       ;=4-7 (non-IEC-ATA) non-IEC-ATA: 0-7 is possible  
       #if partname >= 2    
        #message 644-non-IEC-ATA
        cpi r16,$06    ;compares whether #$04-05 wheather sector is read into or written from
                       ;HD-buffer
        brcc l15000    ;b.i.$06-$07=HD-buffer isn't changed => don't change acsehb
       #endif 

        sts acsehb,r12 ;stores to actual sector HD-buffer   =0c-0f
        sts acsehb+1,r13 ;stores allways in LBA-format
        sts acsehb+2,r14 ;must be stored here because r12-r15 could be changed from LBA to CHS
        sts acsehb+3,r15
                
       #if (partname == 3)  | (partname == 6)      
        #message nlq-hd/SD-card ;is this necessary????
        lds r17,acemen ;actual emulated entry 0,1,2
        sts acenhb,r17 ;actual emulation(entry)number (of sector) in HD buffer
                       ; 0,1,2     
       #endif

       #if (partname == 7)   
        #message nlq-hd/full
        sts acenhb,r17 ;actual emulation(entry)number (of sector) in HD buffer
                       ; 0,1,2     
       #endif

                       ;at identify-device-command: flag for wrong datas in acsehb is already set                       
                       ;at verify: HD-buffer isn't changed
                       ;flag for illegal sector must be at acsehb+3 (not at acenhb),
                       ; because acenhb isn't used at IEC-ATA-V2 (because of memory-reasons)

l15000:                ;                                         (send sector-read command to HD)
       #if partname == 1    
        #message 162-IEC-ATA-V2
        lds r16,hdcafl ;HD-capabilities flags
       #endif
        
       #if (partname == 3)  | (partname == 6)   
        #message 644-NLQ-HD/SD-card
        lds r16,sdcafl ;SD-capabilities flags    
       #endif

       #if (partname == 4) | (partname == 5)
        #message 644-NLQ-HD/lite&outputdriver
        lds r16,hdcafl ;HD-capabilities flags    
                       ;still make for CD
       #endif

       #if partname == 7
        #message 644-NLQ-HD/full 
        lds r16,hdcafl ;HD-capabilities flags    
        cpi r17,$00    ;=actual device emultion number 00-02
        breq l15010    ;b.i.HD is actual wanted hardware

        lds r16,sdcafl ;SD-capabilities flags          
                       ;still make for CD
l15010:
       #endif
        
        lds r18,idcore ;IDE command register
        cpi r18,$30
        brne l15020    ;b.i.not write sector (it's too dangerous to write to a not-accessable HD)

        andi r16,$82   ;masks bit 7 and 1 
        brmi l15020    ;b.i.HD is accessable (bit7=high)
        
        jmp l16660     ;HD isn't accessable -> drive not ready error

l15020:       
       #if (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/HD-routines (without IECATA)
        andi r16,$02   ;masks LBA-bit
        breq l15030    ;b.i.not LBA-mode  (=CHS-mode)

        rjmp l15140    ;=LBA-mode

l15030: push r20       ;------------------------------------------begin LBA->CHS-computing
        push r21
        push r22       ;backups register r20-r23
        push r23   
       
        lds r18,chsphs ;CHS-product heads sectors-per-track low= divisor low
        lds r19,chsphs+1 ;CHS-product heads sectors-per-track high= divisor high

                       ;divission of 32(28) bit LBA-address by 16 bit 
l15040: ldi r20,$01    ;result low =counter
        ldi r21,$00    ;result high
        ldi r22,$00    ;result higher 
        ldi r23,$00    ;result highest

        ldi r16,$00    ;clears temporary register   
        ldi r17,$00
;        ldi r30,$00
;        ldi r31,$05  

;        ldi r25,$00
;        st z+,r25
;        st z+,r25
;        st z+,r25
;        st z+,r25
;        st z+,r12 
;        st z+,r13
;        st z+,r14
;        st z+,r15
;        st z+,r16
;        st z+,r17
;        st z+,r18
;        st z+,r19
;        st z+,r20
;        st z+,r21
;        st z+,r22
;        st z+,r23
    
                       ;r12-r15=sectoraddress in lba (divident)
                       ;r16,r17=temporary register
                       ;r18-r19=CHS-product heads*sectors-per-track (divisor)
                       ;r20-r22=result (cylinder)

l15050: lsl r12        ;multiplicates divident by 2
        rol r13 
        rol r14
        rol r15
        rol r16        ;rotates into temporary register
        rol r17
        brcs l15060    ;b.i.a highbit is carried ot (divident>divisor)
                       ;                                                        high
        cp r17,r19     ;compares LBA-remainder and (product heads*sectrors-per-track)
        brcs l15070    ;b.i.LBA-remainder < (product heads*sectrors-per-track) high
        brne l15060    ;b.i.LBA-remainder > (product heads*sectrors-per-track) high
                       
                       ;LBA-remainder = (product heads*sectrors-per-track)
        cp r16,r18     ;=> compare next lower byte low
        brcs l15070
 
l15060: sub r16,r18    ;higher 
        sbc r17,r19    ;highest  subtracts temp.reg minus divisor chsphs
        
        sec            ;-> carries 1 into result
        rjmp l15080    ;

l15070: clc            ;-> carries 0 into result

l15080: rol r20        ;rotate carry-bit into result
        rol r21
        rol r22
        rol r23

;        ldi r25,$00
;       st z+,r25
;       st z+,r25
;       st z+,r25
;       st z+,r25
;       st z+,r12 
;       st z+,r13
;       st z+,r14
;       st z+,r15
;       st z+,r16
;       st z+,r17
;       st z+,r18
;       st z+,r19
;       st z+,r20
;       st z+,r21
;       st z+,r22
;       st z+,r23
    
        brcc l15050    ;b.i.counter not at end
    
;       ldi r25,$00
;       st z+,r25
;       st z+,r25
;       st z+,r25
;       st z+,r25
;       st z+,r12 
;       st z+,r13
;       st z+,r14
;       st z+,r15
;       st z+,r16
;       st z+,r17
;       st z+,r18
;       st z+,r19
;       st z+,r20
;       st z+,r21
;       st z+,r22
;       st z+,r23
      
        ldi r25,$61    ;61--
        rcall l13130
        
        mov r25,r20    ;----   cylinder
        rcall l13130
        
        mov r25,r21    ;----
        rcall l13130
        
        mov r25,r22    ;----
        rcall l13130
        
        mov r25,r23    ;----   cylinder
        rcall l13130
                       ;r20-r23 contains result (=cylinder)
                       ;r16-r17 contains remainder
        or r22,r23     ;higherbyte cylinder or highestbyte cylinder
        breq l15090    ;b.i.computed cylinder in legal range  
        rjmp l15190    ;computed cylinder too big

                       ;r20-r21 contains cylinder (at end computed)
                       ;r16-r17 contains product heads*sectors-per-track

                       ;begin divission ---------------------------------------------
                       ;http://www.avr-asm-tutorial.net/avr_de/rechnen/division.html#rolror
                       ;r16-r17 = divident = old remainder actual product-heads*sectors-per-track 
                       ;r18 = temporary register
                       ;r19 = divisor sectors per track of HD  
                       ;r22-r23 = result = actual head

l15090: ldi r18,$00    ;temporary register
        lds r19,chsspt ;divisor sectors-per-track
          
        ldi r22,$01    ;result =$0001
        ldi r23,$00    ;result register is also counter-register
               
l15100: lsl r16
        rol r17
        rol r18
        brcs l15110
        
        cp r18,r19     ;compares temporary-register and divisor
        brcs l15120
        
l15110: sub r18,r19    ;temporary-register minus divisor (without carry)
        sec
        rjmp l15130

l15120: clc

l15130: rol r22
        rol r23
        brcc l15100    ;end divission ---------------------------------------------

                       ;r22-23 contains actual head (result)
                       ;r18 contains sector (remainder)
        inc r18        ;increments sector (because it's 1-xx instead of 0-xx)
      
        ldi r25,$62    ;62--
        rcall l13130

        mov r25,r22    ;----  CHS-head
        rcall l13130

        mov r25,r18    ;----  CHS-sector
        rcall l13130
  
        cpi r23,$00
        brne l15190    ;b.i.head too big
    
        mov r13,r20    ;cylinder low
        mov r14,r21    ;cylinder high
        mov r15,r22    ;head
        mov r12,r18    ;sector

        pop r23        ;
        pop r22
        pop r21        ;restores r20-r23
        pop r20        ;-----------------------------------------end LBA->CHS-computing
       #endif
                       ;from l14570
l15140: 

       #if (partname == 3) | (partname == 6)   
        #message nlq-hd/sd-card
        jmp l26820     ;=sector read/write of SM-card
       #endif

       #if partname == 7    
        #message nlq-hd/full
        lds r16,ovhbtr ;overwrite HD-buffer-transfer read
     
        lds r17,idcore ;IDE-command-register 

        cpi r17,$30
        brne l15150    ;b.i.not write

        lds r16,ovhbtw ;overwrite HD-buffer-transfer write

l15150: tst r16        ;HD-buffertransfer-override (read or write)
        breq l15160    ;b.i.no override of hardwaretype is wanted (%00000000)               
       
        andi r16,$c0   ;masks override-bits for hardwaretype
        cpi r16,$c0
        breq l15160    ;b.i.no override of hardwaretype is wanted (%11......)
        
        swap r16       ;   = override of hardwaretype is wanted
        lsr r16        ;moves override bits for hardware to correct position 
        lsr r16
        rjmp l15170

l15160: lds r16,acemen ;actual emulated entry 0,1,2
                       ; 0=IDE-HD    master
                       ; 1=IDE-CDROM slave (not supported)
                       ; 2=SD/MMC-card
l15170: cpi r16,$02
        brne l15180    ;b.i.not SM-card

        jmp l26820     ;=sector read/write of SM-card
       #endif
   
       #if (partname == 1) | (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/HD-routines        
l15180: rcall l14070   ;wait until drive isn't busy (important) 
                       ; (54-- (50--))
        andi r18,$40   ;masks DRDY drive-ready bit
        breq l15180    ;b.i.drive isn't ready = waits until drive is ready
                       ;=waits until HD can receive new/next command
                        
;        ldi r16,idrepe ;IDE register precompensation/error %..001...  
;        lds r18,c6cor0 ;
;        rcall l14120
       
;        mov r25,r18    ;----  
;        rcall l13130
  
        ldi r16,idresc ;IDE register sector count  %..010...
        lds r18,idscre ;read 1 sector only (or more at free blocks computing
        rcall l14120   ;                    and at swap device-emulation-buffer)
        mov r25,r18    ;----  (usually: 01--) 
        rcall l13130
 
        ldi r16,idrel0 ;IDE register LBA0  %..011... 
        mov r18,r12    ;LBA0:  0-$ff  (CHS: Sector: 1-$ff (not 0-$ff))    
        rcall l14120
        mov r25,r18    ;----  (LBA0)
        rcall l13130
 
        ldi r16,idrel1 ;IDE register LBA1  %..100... 
        mov r18,r13    ;LBA1   0-$ff  (CHS: Cylinder low)        0-$ff
        rcall l14120
        mov r25,r18    ;----  (LBA1)
        rcall l13130
 
        ldi r16,idrel2 ;IDE register LBA2  %..101...   
        mov r18,r14    ;LBA2   0-$ff  (CHS: Cylinder high)       0-$ff
        rcall l14120
        mov r25,r18    ;----  (LBA2)
        rcall l13130
 
                       ;LBA3 register        (CHS: Head)   
        mov r18,r15    ;LBA3          0-$0f
    
        cpi r18,$10
        brcs l15200    ;b.i.lba3/head 0-$0f = legal

l15190: ldi r16,$43    ;67,illegal t/s 67--
        rjmp l13980    ;print message + LED-blink + main waiting loop

l15200: ori r18,$a0    ;sets bit7, bit6:LBA=off, bit5, bit4:device0/1
        
        lds r16,idmasl ;IDE-master/slave
                       ;!!!! change that emulation0=master
                       ;                 emulation1=salve!!!!!!!!!!!!!!!!  
        or r18,r16     ;makes bit4=device0/1 master/slave dependent of idmasl 
    
        lds r16,hdcafl ;HD-capabilities flags
        andi r16,$02   ;masks LBA-bit
        breq l15210    ;b.i.CHS-mode

        ori r18,$40    ;sets bit6 = LBA-mode

l15210: ldi r16,idrel3 ;IDE register LBA3  %..110...     
                       ;LBA3 register        (CHS: Head)   

        rcall l14120
        mov r25,r18    ;----  (LBA3/Head + bit7-4=HD-access-bits) 
        rcall l13130
        
        ldi r16,idrecs ;IDE register command/status  %..111...
        lds r18,idcore ;IDE-command-register
                       ; $20 read sector with retry command
                       ; $30 write sector with retry command
                       ; $40 verify
                       ; $e6 sleep
                       ; $ec identify device
        rcall l14120
       
        mov r25,r18    ;----  (command)
        rcall l13130

        ldi r25,$63    ;63--
        rcall l13130
        
        lds r18,idcore ;IDE-command-register
        cpi r18,$e6    ;sleep-command
        breq l15240    ;b.i.sleep-command
    
        cpi r18,$30
        brne l15220    ;b.i.not write-command 
        rjmp l15420    ;=write-command 

l15220:                ;                               =read, verify, identify device
        rcall l14070   ;wait until drive isn't busy and read status (important)
                       ;=waits until HD read/verified sector

                       ;what happens if there is e.g. at computing free clusters
                       ; only one sector requested at last loop 
                       ;is after this first read-status the datarequest bit cleared
                       ; so that the second read status would receive a datarequest low
                       ; and would make an error?????????????   

        andi r18,$01   ;masks error-bit
        breq l15230    ;b.i.ok 
        rjmp l15490    ;=error 
        
l15230: ldi r25,$64    ;64--
        rcall l13130

        lds r16,idcore ;IDE-command-register
        cpi r16,$40
        brne l15250    ;b.i.not verify-command

l15240: rjmp l15400    ;=verify-command (don't copy anything)

                       ;                      = read, identify device 
l15250: ldi r17,$51    ;51-- 81--
        cpi r16,$ec    ;identify device
        breq l15260

        cpi r16,$20    ;read sector
        brne l15240    ;this shouldn't happen = error = what to do????
        
l15260: rcall l15510   ;actual SA HD-buffer-transfer read -> r16
                       ;and swaps and masks active bits
                       ;r16 = correct HD-buffertransfer-value
                       ;at NLQ-HD/full: r17 contains wanted device-emulation-number 0-2

       #if partname >= 2   
        #message not-iec-ata
        mov r25,r16
        rcall l13130   ;xx-- (correct hd-buffertransfer-value)
       #endif

        cpi r16,$02
        brcs l15240    ;#$01-02 = don't copy (important not to change r30,31)

                       ;r12-r15 still contain lba/chs; (this is important for the verify!!!
                       ;                                 at save)   
                       ;r20-r23 is used for something (because they must be backuped at 
                       ;         LBA->CHS-computing)
                       ;
                       ;r30     amount of requested sectors in this loop  at free cluster-calcul.
                       ;           = lowbyte requested sectors
     
                       ;=0c-0f = copy into/over HD-buffer 
                       ;perhaps load values for the copy command from a table of the flash??????  
                       ;!!! but this would change always r30,r31        
                       ;still make swapbuffer and buffer at 0800 0a00!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                      
        ldi r25,$56    ;56--    -------------------------------read from ATA to HD-buffer--------
        rcall l13130

        rcall l14070   ;(50-- 58--) wait until drive isn't busy  changes r00, r16-18, r25
        sec            ;flag for error
        andi r18,$08   ;masks DRQ data-request-bit 
        brne l15280    ;b.i.data present

l15270: rjmp l15410    ;no data present = error

l15280: ldi r25,$57    ;57--
        rcall l13130
                       ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        ;push r26
        ;push r27

        ;ldi r26,$00
        ;ldi r27,$04
                       ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        rcall l15510   ;actual actual SA HD-buffer-transfer read -> r16 
        rcall l15580   ;sets Z to begin of correct tabt02-tabt0d 
                 
l15290: clr r05        ;default for no error at compare           ----loop----
                       ;is this correct to clear this 
                       ;within the loop
                       ;is thsi wrong?
                       ;doesn't this matter,because FAT-verify reads  one complete sector always?
       
        rcall l15620   ;reads next action from tabt02-tabt0d  reads from Z 
                       ;                                      writes to Y
l15300: ldi r16,idreda ;IDE register data %..000...
        out PrtD,r16   ;addresses register c6=dataregister    
      
        ldi r25,$59    ;59--
        rcall l13130

       #if partname == 1       
        #message 162-IEC-ATA-V2 
        ldi r19,$82
       #endif ;162-IEC-ATA-V2

l15310:
       #if partname == 1 ;                                   r16=DataInLow      
        #message 162-IEC-ATA-V2 ;                            r17=DataInHigh
        ldi r17,$02
        out Mcucr,r17   ;exmem off ($02)                     changes: r00,r01,r18,r19
                        ;make this perhaps shorte by using a unused register
                        ;(similar to r19???)
       #endif ;162-IEC-ATA-V2                                uses     r28/29 r30,31

                       ;125ns delay  (should be >=70ns) 

        ;in r25,PinB
        ;rcall l13130

        ;in r25,PinA
        ;rcall l13130

        ;in r25,PinC
        ;rcall l13130

        ;in r25,PinD
        ;rcall l13130

        cbi poatdr,biatdr ;   1  dioR = active (=low)

        nop
        nop
        nop            ;5*125ns=625ns delay (should be >=600ns)
        nop
        nop            ; 1 NOP can be probably be deleted     
        
        ;in r25,piatdr
        ;rcall l13130

        in r16,PinA    ;reads data0-7     = lowbyte first
        in r17,PinC    ;reads data8-15

        ;mov r25,r18
        ;rcall l13130

        ;mov r25,r19
        ;rcall l13130

        sbi poatdr,biatdr ;dioR =inactive (=high)
        
        ;in r25,piatdr
        ;rcall l13130

       #if partname == 1       
        #message 162-IEC-ATA-V2 
        out Mcucr,r19  ;exmem on
       #endif ;162-IEC-ATA-V2
                       ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        ;st x+,r16
        ;st x+,r17
                       ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        brts l15340    ;b.i.write into HD-buffer (not skip/compare)
   
        tst r05        ;=skip/compare (don't write into HD-buffer)
        brne l15320    ;b.i.already former compare error detected

        ld r05,y+
        eor r05,r16
        brne l15330    ;b.i.not equal  b.i.compare-error

        ld r05,y+
        eor r05,r17
        rjmp l15350    ;r05=equal/notequal

l15320: ld r16,y+      ;=skip/compare (don't write into HD-buffer)
l15330: ld r16,y+      ;just to increment Y
        rjmp l15350

l15340: st y+,r16      ;      2                  = lowbyte first
        st y+,r17      ;      2

l15350: dec r00        ;decrements counter low
        dec r00        ;must be decremented twice,because at SMC there is 1byte read only (not 2)
        brne l15310

        dec r01        ;decrements counter high
        brne l15310

        tst r18        ;tests end-flag of 1 HD-sector     read from table
        brpl l15290    ;b.i.not yet 1 complete HD-sector read until end
                       ;at IEC-ATA-V2 the read sector command always reads 1 sector only
    
       #if (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/HD-routines
 
 rcall l14070   ;54-- 58-- wait until drive isn't busy  changes r00, r16-18, r25  temporary


        lds r16,idscre ;amount of to-write sectors (usually 1, 4 at swap device-emulation-buffer)
        dec r16
        breq l15360    ;b.i.last sector written    idscre stays #$01 at end
                       ;is r23 free to be used as at sector write??
        sts idscre,r16

                       ;only possibility at sector-read: swap device-emulation-buffer
                       ;=> bit5 of r18 needn't be checked
        rcall l14070   ;54-- 58-- wait until drive isn't busy  changes r00, r16-18, r25
        sec            ;flag for error
        andi r18,$08   ;masks DRQ data-request-bit 
        breq l15270    ;b.i.no data present = error

        mov r00,r06    ;#$00 counter low 
        ldi r18,$02
        mov r01,r18    ;counter high

        ldi r25,$5b    ;5b-- 
        rcall l13130
 
        lds r25,idscre ;----  (idscre)
        rcall l13130         
      
        mov r25,r00    ;----  (counter low)
        rcall l13130
      
        mov r25,r01    ;----  (counter high)
        rcall l13130
      
        mov r25,r28    ;----  (vector low  (unchanged))
        rcall l13130

        mov r25,r29    ;----  (vector high  (unchanged))
        rcall l13130

        ldi r18,$e0    ;job: b7:HD-status-check at end of this loop
                       ;    (b6: write into AVR-memory (not compare))
                       ;     b5:continue with next sector without changing (incremented) HDvector
        set            ;flag for write (not compare)
        rjmp l15300    ;=data present -> next sector
                       ;                          Y=r28,29 must stay unchanged!!!!!
l15360:
       #endif

       #if partname == 1     
        #message 162-IEC-ATA-V2
        out PrtD,r07  ;addressregister to high (saves energy?)
       #endif ;162-IEC-ATA-V2

       #if (partname == 4) | (partname == 7)    
        #message 644-NLQ-HD/full
        ldi r16,idrecs ;IDE register command/status  %11111...  = also value for inactive
        out PrtD,r16
       #endif ;644-NLQ-HD/lite-lite & full

       #if (partname == 4) | (partname == 7)    
        #message 644-NLQ-HD/full
                       ;IEC-ATA-V2: there is no swap device-emulation-buffer
                       ;            => never multiple sectors read

       #endif ;644-NLQ-HD/lite-lite & full
                       ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        ;in r25,Sreg    ;backups status register

        ;pop r27
        ;pop r26

        ;mov r16,r12
        ;cpi r16,$0b  ;at special HD: swapfile-sector of SA2 (where to freeze)
        ;brne l15370

        ;mov r16,r13
        ;cpi r16,$7e
        ;brne l15370

        ;ldi r25,$61   ;61--
        ;jmp freeze

l15370: ;out Sreg,r25 ;restores carry
        ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       #endif ;of l15180

l15380: ldi r25,$65    ;65--
        rcall l13130

        rcall l15510   ;actual SA HD-buffer-transfer read -> r16
                       ; and swaps and masks active bits
        cpi r16,$05    
        brne l15400    ;b.i.dont read also from AVR-HD-buffer into CBM-buffer
                      
        ldi r30,low(cbbube) ;copy from 512-bytes-HD-buffer into 256-bytes-CBM-buffer
        ldi r31,high(cbbube) ;CBM-buffer-begin

        ldi r28,low(hdbube) 
        ldi r29,high(hdbube) ;HD-buffer-begin
        mov r16,r11    ;actual SA HD-buffer sector in this cluster        
        andi r16,$01   ;masks bit for first/second half of HD-buffer
        add r29,r16    ;Y shows to correct half of HD-buffer 

l15390: ld r16,y+
        st z+,r16
        cpi r31,high(cbbuen) ;CBM-buffer end (+1)
        brne l15390    ;copy correct (first/second) half of 512-bytes-HD-buffer into 
                       ;    256-bytes-CBM-buffer
        sts ascbve,r06 ;sets actual SA CBM-buffer vector to first databyte 
                       ;when the 1541 reads one sector (e.g.dc57 jsr d098) then at 
                       ;d0a9 jsr d137 the follow (track- and) sector is read and the bufferpointer
                       ;is set to first databyte 0302, 0402...0702
                       ; not shure whether this is correct here??????????????

l15400: clc            ;flag for ok

l15410: sts ovhbtr,r06 ;#$00 clears overwrite HD-buffer-transfer read
        sts ovhbtw,r06 ;#$00 clears overwrite HD-buffer-transfer write
      
        ldi r25,$66    ;66--
        rcall l13130

        ret            ;
                       ;at compare FAT: r05 = equal=no difference 
                       ;                      notequal=difference of FAT1 and FAT2 
;------------------------------------------------------------------------------------------------
                       ;PioIn (SCSI-Bus und IDE-Schnittstelle P.59)
                       ;  BSY           Busy = bit7 of status register 
                       ;                 0=controller can be accessed by AVR
                       ;                    bit5-0 of status register are valid
                       ;                 1=controller cannot be accessed by AVR
                       ;                    bit5-0 of status register are not valid
                       ;                    e.g. when controller reads sector?      
                       ;      RDY       Drive ReadY = bit6 of status register
                       ;                 0=controler cannot receive command 
                       ;                   (still executes former command)
                       ;                 1=controler can receive command 
                       ;                   (execution of former command finished)
                       ;          RQT   Data ReQuest = bit3 of status register
                       ;                 0=drive hasn't datas for exchange with AVR
                       ;                 1=drive has datas for exchange with AVR
                       ;  BSY RDY RQT    
                       ;0  1   x   x    controller itself accesses status register
                       ;                 => bit6-0 of status register aren't valid
                       ;                 => AVR must wait
                       ;1  0   0   ?    controller still executes former command
                       ;                 => AVR must wait
                       ;2  0   1   0    controller is ready to receive command from AVR
                       ;                 AVR writes first: Feature-, LBA0-3-,drive-register
                       ;                 AVR writes then: Command-register ($20=read sector)
                       ;3  1   0   0    => controller reads sector 
                       ;                 as long as it reads Busy is set?
                       ;                 as long as the transfer isn't finished: Ready is cleared
                       ;4  0   0   1    controller has read sector from HD                    
                       ;                 -> clears busy  set dataRequest
                       ;                AVR reads status register and tests error-bit (bit0)
                       ;5  0   0   1    AVR reads 512 bytes from controller
                       ;.........................................................................
                       ;                if there are multiple sctors requested:
                       ;6  1   0   0    At end of 512 bytes transmission:   = same as (3)
                       ;                 controller makes RQT = 0
                       ;                 controller makes BSY = 1 (while it loads next sector)                                                   
                       ;7  0   0   1    controller has read sector from HD  = same as (4)                   
                       ;                 -> clears busy  set dataRequest
                       ;                AVR reads status register and tests error-bit (bit0)
                       ;8  0   0   1    AVR reads 512 bytes from controller = same as (5)
                       ;                (6) - (8) is repeated for amount of requested sectors
                       ;.........................................................................
                       ;                if now the last sector will be transmitted
                       ;9  1   0   0    At end of 512 bytes transmission:   = same as (3)
                       ;                 controller makes RQT = 0
                       ;                 controller makes BSY = 1 (while it loads next sector)                                                   
                       ;a  0   0   1    controller has read sector from HD  = same as (4)                   
                       ;                 -> clears busy  set dataRequest
                       ;                AVR reads status register and tests error-bit (bit0)
                       ;b  0   1   1    at last sector: controller makes RDY = 1
                       ;                AVR reads 512 bytes from controller = same as (5)
;.........................................................................
                       ;                if now the last sector is transmitted
                       ;c  0   1   0    At end of 512 bytes transmission:   = same as (3)
                       ;                 controller makes RQT = 1
                       ;                 controller makes BSY = 0
;------------------------------------------------------------------------------------------------
       #if (partname == 1) | (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/HD-routines        
l15420: ldi r25,$68    ;68----                                     write AVR-HD-/FAT-buffer to HD
        rcall l13090
        
        lds r23,idscre ;amount of to-write sectors (usually 1   1-$0100 only at clear sector)
                       ;                                        4 at swap device-emulation-buffer

l15430: rcall l14070   ;wait until drive isn't busy and read status register
        andi r18,$08   ;masks DRQ dataReQuest-bit (54-- 58--)
    
       #if partname == 1    
        #message 162-IEC-ATA-V2   
        breq l15490    ;b.i. HD makes DRQ = inactive   = error
       
       #else
        breq l15470    ;b.i. HD makes DRQ = inactive   = error
       #endif     

        ldi r25,$69    ;69--
        rcall l13130

        rcall l15520   ;actual SA HD-buffer-transfer write of actual SA -> r16
                       ;swaps and masks active bits 
        cpi r16,$02
        brcs l15400    ;#$01-02 = don't copy 

        rcall l15580   ;sets Z to begin of correct tabt02-tabt0d 
                       ;r16 still contain active actual SA HD-buffer-transfer write of actual SA

l15440: ldi r25,$6a    ;6a--          ----loop----
        rcall l13130

        rcall l15620   ;reads next action from tabt02-tabt0d
                       ;sets r28,29 = Y correctly  / Z incremented by 4 to next entry

l15450: ldi r17,idreda ;IDE register data %..000...
        out PrtD,r17   ;addresses data-register
  
        out DdrA,r07   ;ATA-port low = output
        out DdrC,r07   ;ATA-port high = output
                 
       #if partname == 1       
        #message 162-IEC-ATA-V2 
        ldi r19,$82
       #endif ;162-IEC-ATA-V2

l15460: ld r16,y+       ;DataOutLow    ----loop----
        ld r17,y+       ;DataOutHigh

       #if partname == 1    
        #message 162-IEC-ATA-V2 
        ldi r25,$02
        out Mcucr,r25   ;exmem off ($00)
       #endif ;162-IEC-ATA-V2

        out PrtA,r16   ;DataOutLow
        out PrtC,r17   ;DataOutHigh
                        ;at write HD-buffer to HD: it's always written, never skipped
                        ; it doesn't matter what is in the HD-nlq-swap.sys    
                        ; it's only important to skip at reading from HD into AVR-buffer
                        ;it's not necessray to skip at writining into swapfile
                         
                        ;125ns delay (should be >=70ns) 

        ;in r25,PinB
        ;rcall l13130

        ;in r25,PinA
        ;rcall l13130

        ;in r25,PinC
        ;rcall l13130

        ;in r25,PinD
        ;rcall l13130

        cbi poatdw,biatdw ;activates ATA-diow = writes into data register

        nop
        nop
        nop             ;5*125ns=625ns delay (should be >=600ns)
        nop
        nop
   
        ;in r25,piatdw
        ;rcall l13130
    
        ;in r25,PinA
        ;rcall l13130

        ;in r25,PinC
        ;rcall l13130

        sbi poatdw,biatdw

        ;in r25,piatdw
        ;rcall l13130
        
       #if partname == 1       
        #message 162-IEC-ATA-V2 
        out Mcucr,r19   ;#$80 exmem on
       #endif ;162-IEC-ATA-V2

        dec r00        ;decrements counter low
        dec r00        ;must be decremented twice,because at SMC there is 1byte read only (not 2)
        brne l15460

        dec r01        ;decrements counter high
        brne l15460

        tst r18        ;tests end-of 1 HD-sector-flag
        brpl l15440    ;b.i.not yet 1 complete HD-sector written until end

        out DdrA,r06   ;$00 PrtA = input
        out DdrC,r06   ;$00 PrtC = input
        out PrtA,r07   ;$00 PrtA: enable pullups
        out PrtC,r07   ;$00 PrtC: enable pullups

       #if partname == 1     
        #message 162-IEC-ATA-V2
        out PrtD,r07  ;addressregister to high (saves energy?)
       #endif ;162-IEC-ATA-V2

       #if (partname == 4) | (partname == 7)    
        #message 644-NLQ-HD/full
        ldi r16,idrecs ;IDE register command/status  %..111...  = also value for inactive
        out PrtD,r16
      
        mov r01,r18     ;backups job 
       #endif ;644-NLQ-HD/lite-lite & full

        ldi r25,$6a     ;6a--
        rcall l13130
  
        rcall l14070    ;[54-- 50--] wait until drive isn't busy and read status
        andi r18,$01    ;masks errorbit    changes r00, r18 (FULL: r18 must be backuped to r01)
l15470: brne l15490     ;b.i.error

        ;mov r25,r23     ;(r23--)
        ;rcall l13130
    
       #if partname == 1     
        #message 162-IEC-ATA-V2 
        dec r23         ;counter for amount of to-write sectors 1-$ff  #$00=#$0100
        brne l15430     ;b.i.not yet all wanted sectors cleared
       #endif           ;IEC-ATA-V2: write multiple sectors is clear sectors always

       #if (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/HD-routines
        dec r23
        breq l15480    ;b.i.last sector written 
      
                       ;=not yet all wanted sectors written 
        bst r01,5      ;backuped r18 (= andi r18,$20)
                       ;copies bit for leave vector unchanged  (necessary at sector-write) 
        brtc l15430    ;b.i.reread counter and vector from flash-table (= clear sectors) 

                       ;=leave vector (incremented to new value) unchanged (=swap DEB)
        rcall l14070   ;wait until drive isn't busy  changes r00, r16-18, r25
        andi r18,$08   ;masks DRQ dataReQuest-bit (54-- 58--)
        breq l15490    ;b.i. HD makes DRQ = inactive   = error

        mov r00,r06    ;#$00 counter low 
        ldi r18,$02
        mov r01,r18    ;counter high
      
        ldi r25,$6b     ;6b-- 
        rcall l13130

        mov r25,r23    ;----  (idsere)
        rcall l13130

        mov r25,r00    ;----  (counter low)
        rcall l13130
      
        mov r25,r01    ;----  (counter high)
        rcall l13130
      
        mov r25,r28    ;----  (vector low)
        rcall l13130

        mov r25,r29    ;----  (vector high)
        rcall l13130

        ldi r18,$e0    ;job: b7:end after this loop
                       ;     b5:continue with next sector without changing (incremented) HDvector 
        rjmp l15450    ;b.i.data present -> first job of next sector
                       ;                          Y=r28,29 must stay unchanged!!!!!

l15480:
                       ;problem:
                       ;at format-hd: 1-255 times the same buffer (filled with #$00)
                       ;              is written
                       ;at swap device-emulation-buffer: 4 different sectors must be written
                       ;=> different routine for format-hd and for swap device-emulation-buffer
       #endif

        ldi r25,$6c     ;6c--   =no error
        rcall l13130

        ;lds flag for verify on off
        ;broff l15400    ;important to clear override bits and to clc

        ldi r17,$40     ;read verify sectors with retry   
        sts idcore,r17
        rjmp l15180     ;verifies (r12-r15 still contain sector address (LBA or CHS)-------------
;----------------------------------------------------------------------------------------------
l15490: ldi r25,$6e    ;6e----                                                 ATA-error received
        rcall l13090
        
        ldi r16,idrepe ;IDE register precompensation/error %..001...              
        rcall l14060

        sts aterre,r18 ;ATA error register  (can be read with m-r command) 
        mov r25,r18    ;------
        rcall l13090

        ldi r16,$17    ;23,read error  23--            
        bst r18,6      ;copies bit6 (unc) to T-flag---uncorrectable data error  
        brts l15500    ;b.i.unc bit set

        ldi r16,$14    ;20,read error  20--
        bst r18,4      ;copies ID-not-found bit to T-flag
        brts l15500    ;b.i. ID-not-found error


        ldi r16,$16    ;22,read error  22--
        bst r18,0      ;copies addressmark-not-found bit to T-flag     --- 0 istead of 4
        brts l15500    ;b.i. addressmark-not-found error

        ldi r16,$15    ;21,read error  21--
        
l15500: ldi r25,$6f    ;6f--
        rcall l13130
   
        sts acsehb+3,r07 ;flag for illegal sector in actual sector hd buffer  
                       ; #$ff is illegal, because highestbyte can be $00-0f only

        jmp l13980     ;print error + LED-blink + mainwaitingloop
       #endif           ;of l15420
;------------------------------------------------------------------------------------------------
                       ;from l14890, l14940, l15260, l15280, l15380, l26920, l26930  
l15510: lds r16,ovhbtr ;overwrite HD-buffer-transfer read of actual SA    read active hdbtr. -> r16
        tst r16
        brne l15550    ;b.i.override function is wanted    

        lds r16,ashbtr ;actual SA HD-buffer-transfer read 
        rjmp l15530    ;---------

                       ;from l14970, l15430, l27040
l15520: lds r16,ovhbtw ;overwrite HD-buffer-transfer write   read active ashbtw -> r16     
        tst r16
        brne l15550    ;b.i.override function is wanted    

        lds r16,ashbtw ;actual SA HD-buffer-transfer write of actual SA 
    
l15530: tst r16        ;=normal function  no override-function
        brne l15560    ;b.i.any bit set
                       
                       ;=no bit set
l15540: ldi r17,$53    ;53-- 83--
        rjmp syserr    ;system error 

l15550: 
       #if partname == 7    
        #message 644-NLQ-HD/full
        mov r17,r16    ;                   still test whether r17 can be used here!!!!!!!!!!!! 
        andi r17,$c0   ;masks bits for override-function of hardware
                       ;00. 40. 80. c0.   bit7&6 of ovhbtr & ovhbtw = wanted hardware
        lsl r17        ;00c 80c 00s 80s
        rol r17        ;00c 00s 01c 01s
        rol r17        ;00  01  02  03
        cpi r17,$03
        brne l15570    ;b.i.override-function of hardware is wanted =00,01,02 (former 00,40,80)
       
                       ;=override-function of hardware isn't  wanted =03 (former c0)
       #endif 
l15560:     
       #if partname == 7    
        #message 644-NLQ-HD/full
                       ;= override-function of hardware isn't wanted
        lds r17,acemen ;actual emulated entry 0,1,2 

                       ;at NLQ-HD/full: r17 contains wanted device-emulation-number 0-2  
l15570:
       #endif 

        andi r16,$3f   ;masks off override bits for hardware
    
       #if partname == 1    
        #message 162-IEC-ATA-V2
        cpi r16,$06

       #else
        #message 644-non-IEC-ATA
        cpi r16,$08

       #endif 

        brcc l15540    ;b.i.illegal (06/08-3f)
        
                       ;= legal (1-$05/07)
        ret            ;r16 = correct HD-buffertransfer-value
                       ;at NLQ-HD/full: r17 contains wanted device-emulation-number 0-2
;------------------------------------------------------------------------------------------------
l15580: ldi r25,$5e    ;5e--                              set Z to begin of correct tabt02-tabt0d 
        rcall l13130   ;                    dependant of r16 (r16 must contain ashbtr or hdbutwr)  

        ;mov r25,r16    ;---- (ashbtr/wr (correctly (swapped))
        ;rcall l13130
        
/*
        lsl r16        ;*2

        ldi r30,low((tabtst-2)<<1) ;table buffertransfer starttable
        ldi r31,high((tabtst-2)<<1)

        add r30,r16
        adc r31,r06    ;#$00 adds carry
                       ;Z shows now to the table of the begin of the correct tabt02-tabt0d 
       
        ;mov r25,r30    ;---- (table of the begin of the correct tabt02-tabt0d low)
        ;rcall l13130
        ;mov r25,r31    ;---- (table of the begin of the correct tabt02-tabt0d high)
        ;rcall l13130
        
        lpm r28,z+
        lpm r29,z

        ;mov r25,r28    ;---- (table of the correct tabt02-tabt0d low)
        ;rcall l13130
        ;mov r25,r29    ;---- (table of the correct tabt02-tabt0d high)
        ;rcall l13130

        tst r29        ;a correct highbyte can never show at pos $00..
        brne l15590 

        ldi r17,$55    ;55-- 85--
        rjmp syserr    ;dos-error  wrong value in table of buffer-values at reading/writing

l15590: mov r30,r28    ;Z shows now to the begin of the correct tabt02-tabt0d
        mov r31,r29
                              ;tabtst can be saved
                              ; if there would be more than 1 command with 2 or 3 entries
                              ;   then the table tabtst would still be necessary

*/
        cpi r16,$02
        brcs l15600    ;b.i.0-1 = illegal
 
        cpi r16,$08
        brcs l15610    ;b.i.2-7 = legal
        
                       ;=8-$ff = illegal 
l15600: ldi r17,$55    ;55-- 85--
        rjmp syserr    ;dos-error  wrong value in table of buffer-values at reading/writing

l15610:                ;                02 03 04 05 06 07
        lsl r16        ;*2              04 06 08 0a 0c 0e
        lsl r16        ;*4 (ashbtr/wr)  08 0c 10 14 18 1c
    
        ldi r30,low((tabt02-4)<<1) ;table buffertransfer 02 =begin of tabt02-07-tables
        ldi r31,high((tabt02-4)<<1)

        add r30,r16
        adc r31,r06    ;#$00 adds carry
                       ;Z shows now to the begin of the correct tabt02-tabt0d

        ;mov r25,r30    ;---- (table of the correct tabt02-tabt07 low)
        ;rcall l13130
        ;mov r25,r31    ;---- (table of the correct tabt02-tabt07 high)
        ;rcall l13130

        ret
;------------------------------------------------------------------------------------------------        
                        ;from l15290, l15440, l26940, l27060
l15620: ldi r25,$5f    ;5f--                                 reads next action from tabt02-tabt0d
        rcall l13130

        lpm r00,z+     ;loads first,fifths... byte of table    counter low
        lpm r29,z+     ;loads second,sixth... byte of table    counter high

        mov r25,r00    ;---- (counter low)
        rcall l13130
        mov r25,r29    ;---- (counter high & jobs)
        rcall l13130

        mov r18,r29    ;bit7-2 = job
                       ;   b7: 0=no HD-status-check after this job 
                       ;            (= 1 HD-sector (512bytes) not yet written)
                       ;       1=HD-status-check after this job
                       ;            (= 1 HD-sector (512bytes) completely written)
                       ;   b6: 0=skip & compare (don't write)   1= write into buffer
                       ;   b5: 0=reread counter and vector from flash-table at jobend
                       ;           used at clear multiple sectors 
                       ;            (writeing 1-256 times the same #$00-buffer)
                       ;       1= leave vector unchanged (incremented to end of old job)
                       ;          and use counter for 1 sector = 512 bytes
                       ;           used at load/save device-swap-area 
                       ;       at end (not at begin) of this job      
                       ;   b4-2:unused
                       ; bit1-0 of highbyte & bit7-0of lowbyte: counter
                       ;            ! 01ff = 255bytes
                       ;            ! 0100 = 256bytes
                       ;            ! 0201 = 257bytes
        andi r29,$03   ;bit1-0 = counterhigh (one can count max. $0200 (512) bytes 
        mov r01,r29    ;                      because of sector length)

        lpm r28,z+     ;loads third,seventh... byte of table    vector low
        lpm r29,z+     ;loads fourth,eighth... byte of table    vector high

        mov r25,r28    ;---- (vector low)
        rcall l13130
        mov r25,r29    ;---- (vector high)
        rcall l13130
                       ;counterbytes must be read first from table, vectorbytes must be
                       ; read afterwards
        
        bst r18,6      ;copies bit6 (skip/copy) from r18 to T-flag
        ret
;================================================================================================
                       ;from l20960, l21020, l21090, l16990, l17900, l20310, l20310
l15630:                ;- l16440                          read first direntry of actual directory
                       ;l15630 read first direntry of actual directory
                       ;l15640 read first direntry of actual directory            
                       ;l15660 read next direntry of actual directory
                       ;
                       ; writes dirline into dibube directory buffer begin 08e8
                       ;
                       ;reads every legal entry (empty, occupied, volume id, dot, dotdot...) 
                       ; doesn't read illegal entries (long-filename orphans)
                       ;problem: if there is an deleted entry, then an orphan, then an deleted
                       ; entry: the routine l19980 l20310 l20320 (create and compare shortnames 
                       ; and search 3 free direntries) doesn't see the orphan and could think
                       ; that there are three free direntries in a row.
                       
                       ;changes:
                       ;r00         = bytecounter at loading a sector from HD  
                       ;r01         = bytecounter at loading a sector from HD  
                       ;(r02-r04)
                       ;r05         = compare at reading sector
                       ;(r06,r07)
                                           
                       ;r10         = flag whether orphandirentry between old and actual direntry
                       ;              pay attention that r10 isn't changed at many subroutines!!
                       ;r11         = at computing folllow-cluster
                       ;r12-r15     = clusteraddress   
                       ;r16
                       ;r17
                       ;r18         = ordernumber ??
                       ;r19         = ordernumber ??
                       ;r20         = vector low read
                       ;r21         = fileextension
                       ;r22         = attribute-byte ??
                       ;r23         = directory file type ?? 
      
                       ;r25         = debugbytes 
                       ;r26,r27 = X = write into directorybuffer dubube
                       ;r28,r29 = Y = read from HD-buffer
                       ;r30,r31 = Z = ROM-tables for characters, filextension 

                       ;copies direntry to dibube directory buffer begin 
                       ;at end of routine (not at end of dir):
                       ; - notequal: there is a direntry
                       ;   equal: there is no direntry = end of dir reached
                       ;     '--->  -carry = reason for end of dir:
                       ;                -clear = a direntry with first char = #$00 is found
                       ;                -set   = endcluster found (= dir ends exactly at the end
                       ;                                             of a cluster)
                       ; -plus/minus=flag whether orphandirentry between old and actual direntry
                       ;   plus = no orphan   minus = orphan between old and actual direntry
   
                       ;                                                      read first direntry
                       ;                                                    of actual directory
/*
        ldi r16,$11    ;SA=$11 =internal-read-address                                       ?d47a                       
        rcall l14190   ;save old CBM-buffer to swapfile
                       ;and load new CBM-buffer from swapfile
                       ;!!! where must the old SA-buffer be reloaded?????????????????????
        
        lds r16,asfla0 ;flag0 of actual SA    = load "$" 
        andi r16,$fc   ;clears dir-bits  
        ori r16,$02    ;sets flag for directory

                       ;still make: load short dir only = ori r16,$01!!!!!!!!!!!!!!!!!!!!!!!!!!!!  
    
        sts asfla0,r16  

        ldi r16,$0c    ;....1100 makes flag for don't copy 512-HD-buffer to 256-CBM-buffer
        sts ashbtr,r16 ;actual SA HD-buffer-transfer read 
       
        call l18760    ;sets flag that actual SA is opened for read
                       ;sets tasach table SA->channel for SA 00-0e that actual SA is opened
                       
                       ;still test when the actual SA must stay and 
                       ;when internal read-address must be used

*/

                       ;.........................................................................  
                       ;from l20960, l21020, l21090, l16990, l17900, l17900, 
l15640:                ;                                  read first direntry of actual directory
                       ;                                   write to dibube directory buffer begin
       #if partname == 1    
        #message 162-IEC-ATA-V2
        lds r12,cbadd0 ;clusterbegin actual directory drive0 
        lds r13,cbadd0+1 ;                                                   
        lds r14,cbadd0+2 
        lds r15,cbadd0+3

       #else
        #message 644-non-IEC-ATA
        push r26
        push r27

        ldi r26,low(cbadd0)
        ldi r27,high(cbadd0) ;              $10c8                
        lds r25,acemen ;actual emulated entry $00,  $01,  $02
        swap r25       ;                      $00,  $10,  $20    
        or r26,r25     ;                    $10c8,$10d8,$10e8

        ld r12,x+      ;clusterbegin actual directory of actual deviceemulation
        ld r13,x+
        ld r14,x+
        ld r15,x

        pop r27
        pop r26
       #endif 

        sts ashbve,r06 ;#$00 actual SA HD-buffer vector = vector to read from HD-dir 
        sts ashbsc,r06 ;#$00 actual SA HD-buffer sector in this cluster 
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        sts ashbcl,r12 ;actual SA HD-buffer cluster
        sts ashbcl+1,r13
        sts ashbcl+2,r14
        sts ashbcl+3,r15

        ldi r28,low(hdbube) ;HD-dir-read-vector to begin of HD-buffer
        ldi r29,high(hdbube) 
        
        sts ornuld,r07 ;#$ff clears order number long directory entry (lde)
        
        clr r10        ;default-flag for no orphan-direntry between former-old and actual-new
                       ; direntry

        lds r16,c6frre ;C64-freeze-register 
        cpi r16,$01
        brne l15650

        sts c6cor3,r06 ;#$00---------------------------------------------------------------------
        
        
l15650: rjmp l15680    ;write next dirline into dibube directory buffer begin         
                       ;still test carry-error-flag!!!!!!!!!!!!!!!!!!!!!!!!!    
;------------------------------------------------------------------------------------------------
                       ; from l13440, l20980, l21160, l17070, l20320
                       ;                                  read next direntry of actual directory?
l15660: lds r28,ashbve ;actual SA HD-buffer vector = vector to read from HD-dir
        
        ldi r29,high(hdbube) ;HD-buffer begin #$04 ($0400)
        lds r16,ashbsc
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual sectorhalf
        andi r16,$01   ;masks bit for first/second half of HD-buffer (r16= #$00 or #$01)
        add r29,r16    ;Y shows now to correct half of HD-buffer ($0a or $0b)
        clr r10        ;default-flag for no orphan-direntry between former-old and actual-new
                       ; direntry
                       ;.........................................................................
                       ;X=write into dibube-buffer
                       ;Y=read from HD-buffer
                       ; from l16020; l16030 
l15670: ori r28,$1f    ;0a00-0a1f->0a1f  0a20-0a3f->0a3f  0be0-0bff->0bff
        ld r16,y+      ;           0a20             0a40             0c00
                       ;increments HD-dir-read-vector to begin of next entry                        
                       ;.........................................................................
                       ; from l15650
l15680: ldi r25,$70
        rcall l13130   ;70--

        lds r16,c6frre ;C64-freeze-register 
        cpi r16,$01
        brne l15700

        lds r16,c6cor3 ;-------------------------------------------------------------------------
        inc r16
        brne l15690
        ldi r16,$01
l15690: sts c6cor3,r16 ;-------------------------------------------------------------------------


l15700: 
        andi r28,$e0
l15710: sts ashbve,r28 ;actual SA HD-buffer vector = vector to read from HD-dir
        cpi r29,high(hdbuen) ;HD-buffer-end (06 0600)
        brne l15760    ;b.i.HD-buffer not yet read to end

        lds r16,ashbsc ;actual sector of actual SA
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        ori r16,$01    ;makes last half (second) of HD-buffer
        inc r16        ;makes next sector in this sectors-per-FAT and first half of HD-sector
l15720: sts ashbsc,r16
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        ldi r25,$1f    ;1f--  temporary!!!!!!!!!!!!
        rcall l13130
        
        mov r25,r16    ;xx-- (sepecl)   temporary!!!!!!!!!!!!
        rcall l13130

        lsr r16        ;flag for sectorhalf is first/second half of HD-sector into carry
                       ;r16 contains now actual HD-sectror of this cluster 
                       ;  in same format as sepecl   
        lds r17,sepecl ;sectors per cluster

        cp r16,r17
        brne l15780    ;b.i.still sectors in this cluster to read
        
        rcall l14440   ;computes follow-cluster of actual cluster (ashbcl (not geaccl))
                       ;!changes buffers and actual cluster if FAT must be read???
        brcc l15740    ;b.i.there is a follow sector
                       ;---------------------------------------------------------------end of dir
                       ;=old-actual cluster is/was an endcluster
                       ;(= there is no direntry with #$00-endflag) 
                       ;ashbcl stays at old cluster 
                       ;but acseac shows already wrongly to not-existing over-the-end sector
                       ; in this cluster => acseac must show to last sector in this cluster
                       ; of old cluster
        lds r16,ashbsc
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual sectorhalf
        dec r16
        sts ashbsc,r16 ;ashbsc shows now to last half of last sector in this cluster

                       ;check if this is also at different places important!!!!!!!!!!!!!!!!!!!!!!

                       ;here:  carry = set = flag that reason for end of dir is an endcluster
l15730:                ;l15770 carry = clear = flag that reason for end of dir is a #$00-direntry
        ;tst r10        ;flag whether orphandirentry between old and actual direntry
                       ;plus = no orphan   minus = orphan between old and actual direntry
                       ;the plusminusflag is destroyed at the parentroutine
                       ; (the parentroutine makes a test r10 again)
                       ; => this command isn't necessary
      
        clz            ;=not equal = flag for end of dir reached 
;ldi r25,$70       ;70--
;jmp freeze
        ret            ;end of dir (still compare with 1541 which flag is used
                       ;if there is an error then the routine doesn't come to this point
                       ; it jumps to the error routine before
                       ;carry = clear (#$00-direntry)  set (endcluster)
                       ;---------------------------------------------------------------end of dir
l15740: sts ashbcl,r12 ;actual SA HD-buffer cluster
        sts ashbcl+1,r13 ;sets values for new sector
        sts ashbcl+2,r14 ;but doesn't load new sector
        sts ashbcl+3,r15
 
l15750: sts ashbsc,r06 ;#$00 actual SA HD-buffer sector in this cluster 
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
                       ;=actual CBM-sector = first half of actual HD-sector
                       ;                   = first HD-sector in actual sectors-per-FAT-cluster 
        ldi r29,high(hdbube) ;#$04
         
l15760:                ;compute HD-dir-read-vector-high -> ashbsc (actual sector in this cluster
                       ;  of actual SA)
        lds r16,ashbsc ;actual sector of actual SA
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        andi r16,$fe   ;masks off old bit for first/second half of HD-buffer
                       ;r29=vectorhigh of HD-dir-read #$04/#$05
        subi r29,high(hdbube) ;r29=first(00)/second(01) half of HD-buffer   
        or r16,r29
l15770: sts ashbsc,r16 ;changes r29 Y (before: HD-vector    now=#$00/01)
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector

l15780: rcall l14790   ;read actual sector of cluster of actual SA (=actual directory)
                       ; changes Y, Z => r28-r31 must be backuped before and restored after

                       ;ashbve = actual SA HD-buffer vector = vector to read from HD-dir 
                       ;ashbsc = actual SA HD-buffer sector in this cluster = 
                       ;ashbcl = actual SA HD-buffer cluster

        lds r28,ashbve ; ->l15710 actual HD(buffer)pointer  Y=read from HD-buffer 
                       ; shows now to begin of (former-next) now-actual HD-dir-entry
            
                       ;compute  ashbsc (actual SA HD-buffer sector in this cluster) ->
                       ;  HD-dir-read-vector-high   
        ldi r29,high(hdbube) ;HD-buffer begin #$04 ($0400)
        lds r16,ashbsc ; -> l15720, l15750, l15770 ??? 
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        andi r16,$01   ;masks bit for first/second half of HD-buffer (r16= #$00 or #$01)
        add r29,r16    ;Y shows now to correct half of HD-buffer ($0a or $0b)
       
        ldi r27,high(dibube);08e8 directory buffer begin 
                       ;X=write into directory-buffer

        andi r28,$e0   ;0a1x->0a00  0a3x->0a20  0bfx->0be0

        lds r16,c6frre ;C64-freeze-register------------------------------------------------------ 
        cpi r16,$01
        brne l15790

        lds r16,c6cor0 ;------------------------------------------------------------------------- 
        lds r17,c6cor3
        cp r16,r17
        brne l15790

        ldi r25,$a9    ;a9--
        jmp freeze
l15790:                ;-------------------------------------------------------------------------

        ld r17,y       ;first character of filename
        cpi r17,$00
        clc            ;flag that reason for end of dir is an entry with #$00
                       ;---------------------------------------------------------------end of dir
        breq l15730    ;b.i.end of dir reached
                       ;---------------------------------------------------------------end of dir
        cpi r17,$e5
        brne l15810    ;b.i.used, not free directory-entry

        lds r16,ornuld ;order number of long dir-entry (#$ff at beginning)
        cpi r16,$ff
        breq l15800    ;b.i.before this empty direntry there was no lde-entry (no orphan)
           
                       ;=lde-entry (orphan) before this empty direntry
        mov r10,r07    ;#$ff =flag that orphan-direntry is between former-old and actual-new
                       ;       direntry  -> minus
                       ;this would also be necessary for the end of the dir
                       ;but so far: at the end of dir the next file is always made to the
                       ; end of the dir not to 1 or 2 direntries in front even if they are empty

l15800: ldi r23,$00    ;sets flag for empty dir-entry 
        sts difity,r23 ;directory filetype
                       ;#$00 = empty direntry
                       ;#$80 = DEL-file
                      
        rjmp l16440    ;=display this free unused direntry 

l15810: ldi r25,$20    ;20--
        rcall l13130

        mov r25,r17    ;---- (first char of dirname)
        rcall l13130

        ori r28,$0b    ;vector = attribute-byte
        ld r22,y+      ;reads attribute-byte   (Y=0a0b->0a0c...0beb->0bec)

        mov r25,r22    ;---- (attribute-byte)
        rcall l13130

        andi r22,$3f   ;masks off bit 7,6
        cpi r22,$0f 
        breq l15820    ;b.i.long filename entry
        rjmp l16040    ;not long filename entry      r17 = first char of shortname

l15820: ldi r25,$21    ;21--                                            =long filename entry
        rcall l13130
/*
        lds r16,c6frre ;C64-freeze-register------------------------------------------------------ 
        cpi r16,$01
        brne l15830

        lds r16,c6cor0 ;------------------------------------------------------------------------- 
        lds r17,c6cor3 ;counter for freeze
        cp r16,r17
        brne l15830

        ldi r25,$a2    ;a2--
        jmp freeze
l15830:                ;-------------------------------------------------------------------------
*/

                       ;ordernumber long directory entry lde (lde=long directory entry) 
                       ; #$ff = so far no lde found = search first lde
                       ; bit6 0=follow lde  1 = first lde
                       ; bit5-0 = counter for ldes (counts decrementing) 

                       ;microsoft saves the end of a lde first in the dir
                       ;and the beginning of a lde at the end of the dir
        
        andi r28,$e0   ;0a0c->0a00  0a2c->0a20  0bec->0be0
        
        ld r18,y       ;order number of actual lde (lde = long directory entry)
        lds r19,ornuld ;order number of long dir-entry (#$ff at beginning)        0a00

        ori r28,$1a    ;0a00->0a1a  0a20->0a3a   0be0->0bfa
        
        ldi r25,$30    ;(30--)   
        ld r16,y+      ;0a1a must be #$00
        cpi r16,$00
        brne l15860    ;b.i.illegal = error -> display short entry (skip this long entry)

        ld r16,y       ;0a1b must be #$00
        cpi r16,$00
        brne l15860    ;b.i.illegal = error -> display short entry (skip this long entry)
                       
        subi r28,$0f   ;0a1b->0a0c   0a3b->0a2c  0bfb->0bec
      
        ld r16,y+      ;0a0c must be #$00
        cpi r16,$00
        brne l15860    ;b.i.illegal = error -> display short entry (skip this long entry)

        ld r16,y       ;checksum 0a0d
        andi r28,$e1   ;Y=0a0d->0a01   0a2d->0a21  0bed->0b01 (read)
       
        ldi r26,low(dibube) ;08e8 directory buffer begin 
                       ; 08e8 (writes first 13 chars)
        
        ldi r25,$31    ;(31--)
        cp r18,r19     ;#$01 compares (expected) order number of lde and real one from HD-entry
        breq l15850    ;b.i.expected ornuld read from next dir-entry (#$01 only possible) 
 
        cpi r18,$41
        breq l15840    ;b.i.namelength 1-13 chars

        cpi r18,$42    ;=this is the first lde of the actual HD-filename  
        brne l15860    ;b.i.not namelength 14-26 chars  (.PRG / .DEL001 included) 

        ldi r26,low(dibube)+$0d ;directory buffer begin 
                       ; 09f5 (writes chars 14-26)

l15840:                ;                          =start-LFN-dir-entry found  ($41,$42)
        mov r17,r18    ;read ordernumber
        andi r17,$3f   ;masks amount of direntries belonging to this long entry
        sts ldstle,r17 ;long-directory-start-length = amount of partentries of complete direntry
                       ; 0/1/2 (if a filename is longer than this (file generated at Windows
                       ; (not NLQ-HD)) then ldstle = 0)

        mov r17,r28    ;vector of actual direntry (begin) 
        andi r17,$e0   ;0a00  0a20  0be0
        sts ldstve,r17 ;longdirectory-start-vector

        lds r17,ashbsc ;actual SA HD-buffer sector in this cluster 
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        sts ldstsc,r17 ;long-directory-start sector in this cluster               

        lds r12,ashbcl ;cluster of actual direntry (begin of complete entry      
        lds r13,ashbcl+1 ;which could be over several sectors
        lds r14,ashbcl+2
        lds r15,ashbcl+3  
        
        sts ldstcl,r12 ;long-directory-start-cluster
        sts ldstcl+1,r13 ;stores the first dirpartentry-values
        sts ldstcl+2,r14 ;doesn't store the last dir-partentry             
        sts ldstcl+3,r15
                               
        sts ldchsu,r16 ;stores checksum   
                       ;(rjmp l15870 isn't necessary)

l15850: ldi r25,$32    ;(32--)
        lds r17,ldchsu
        cp r16,r17
l15860: brne l15910    ;b.i.not same checksum in both ldes -> error

                       ;Y=0a01 read
                       ;X=0908/0915  (last/first LDE) 
                       ;                                               -----------loop----------- 
l15870: ld r16,y+      ;unicode low  0601 03 05 07 09   0e 10 12 14 16 18   1c 1e 
        ld r17,y+      ;unicode high 0602 04 06 08 0a   0f 11 13 15 17 19   1d 1f
        
        mov r20,r28    ;ylow  HD-read-low
        andi r20,$1f
    
        cpi r20,$0d  
        brne l15880    ;b.i.not attribute- and type-byte are read (0a0b&0a0c)
              
                       ;attribute is #$0f = long dir entry (tested before)
        ld r16,y+      ;checksum over MS-DOS-name   just to increase Y (0a0d->0a0e 0bed->0bee)  
        rjmp l15870    ;next unicode char (0a02 0a2e 0bee)
    
l15880: cpi r20,$1c    ;Ylow'  read-low'
        breq l15870    ;b.i.0a1a&0a1b  0a3a&0a3b  0bfa&0bfb read -> next char (0a1c 0a3c 0bfc)

        ldi r25,$33    ;(33--)

        cpi r17,$00    ;checks unicode-page
        brne l15940    ;b.i.not unicodepage $00
 
        cpi r16,$00
        brne l15890    ;b.i.LFN-$0000 = end of filename not yet reached 
        rjmp l16000    ;LFN-$0000 = end of filename reached 

l15890: ldi r30,low(tacilf<<1)  ;table character import longfilename  (load)
        ldi r31,high(tacilf<<1) ;$14 (20) characters length (but $13 (19) used only)
   
l15900: lpm r17,z+     ;reads character from table
        cp r16,r17
        brne l15920    ;b.i.actual read LFN-character isn't in table

        ldi r25,$22    ;22--
        call l13130

        mov r25,r16    ;----
        call l13130

        subi r30,$15   ;changes vector from LFN- to CBM-table ($14 (20) chars in front)
        sbci r31,$00   ;tacicb   table character import CBM

        lpm r16,z      ;reads CBM-char from CBM-table

        mov r25,r16    ;----
        call l13130

        cpi r16,$00    ;#$00 is here the flag for an illegal character
        brne l15980    ;b.i.legal char -> print it into LFN-buffer
        
l15910: rjmp l16030    ;=illegal LFN-char -> print shortname only

l15920: cpi r30,low((tacilf<<1)+$13)
        brne l15900

        cpi r16,$20
        brcs l15910    ;b.i.$00-$1f = illegal
        
        cpi r16,$60
        brcs l15980    ;b.i.$20-5f -> no change
        
        cpi r16,$7f
        brcs l15930    ;b.i.$60-$7e

        cpi r16,$a0
        brcs l15910    ;b.i.$7f-$9f = illegal

        cpi r16,$e0
        brcs l15980    ;b.i.$a0-df -> no change

l15930: subi r16,$20   ;= $60-$7e   $e0-$fe
        rjmp l15980    ;  $40-$5e   $c0-$de   lower case -> upper case         

l15940: cpi r17,$02    ;checks unicode-page
        brne l15960    ;b.i.not unicodepage $02

        cpi r16,$50
        brcs l16030    ;b.i. unicode 0200-024f -> error

        cpi r16,$90
        brcc l15950    ;b.i.unicode 0290-02ff

        subi r16,$f0   ;= 0250-028f   
        rjmp l15980    ;-> $60-$9f

l15950: cpi r16,$b0
        brcs l16030    ;b.i.unicode 0290-02af -> error

        cpi r16,$d0
        brcc l16030    ;b.i.unicode 02d0-02ff -> error

        subi r16,$d0   ;= 02b0-02cf
        rjmp l15980    ;-> $e0-$ff

l15960: cpi r17,$04    ;checks unicode-page
l15970: brne l16030    ;b.i.not unicodepage $04 (=error, because no legal NLQ-HD-unicode-page)
       
        cpi r16,$10
        brcs l16030    ;b.i. unicode 0400-0410 -> error

        cpi r16,$30
        brcc l16030    ;b.i.unicode 0430-04ff

        subi r16,$10   ;= 0410-042f   
        rjmp l15980    ;-> $00-$1f
                      
l15980: ldi r25,$34    ;34--
        cpi r26,low(dibube)+$17 ;=$09ff Xlow directory buffer begin
        breq l16030    ;b.i.behind last longest possible character would be written   
                       ;if there is written behind last possible position
                       ;then the filename is too long = error
                       ;b.i.filename >23 chars    (16filename 1dot 3PRG (1#$a0))              
                       ;"----------------" del001 (16filename 1dot 6DEL001 (1#$a0))

        st x+,r16      ;stores unicode-char into directory-buffer 08e8-08fe

        cpi r20,$00    ;there is an overflow of Y (read from HD) from $1f to $20
                       ; but andi r20,$1f makes #$20 to #$00                             
        breq l15990    ;b.i.this HD-partdir entry is read to end
        rjmp l15870    ;this HD-dir entry isn't yet read to end--------------loop----------------

l15990: cpi r18,$41
        brne l16020    ;b.i.not one lde only and not filled with chars up to end
        
                       ;=there is 1 lde only and it is filled with 13 chars 
                       ;   until end of lde => the lde-entry doesn't have an end-#$00
                       ;         => make end-#$a0 here   
       
l16000: ldi r16,$a0    ;flag for end of filename   same as 1541
        
l16010: st x+,r16      ;fills end of filename with #$a0
        mov r20,r26
        andi r20,$1f
        brne l16010    ;at the end there is an overflow into the next shortentry (0a1f->0a20)
        
        ld r16,-x      ;undo this overflow   

l16020: ld r16,-y      ;important to decrement Y because it could show to the next HD-shortentry
                       ;if first of two LDEs then there is always an overflow of X from 1f to 20
                       ; at the end of LDE1 when 13th character is read
                       ;if there is one LDE only (e.g. BIGLETER.prg #$00) then there is one LDE
                       ;with 13 characters. When the end-#$00 is copied then there is
                       ; an overflow of X from 1f to 20  
        
                       ;it would be perhaps more logical to increment Y not at reading the 
                       ;character from the HD-entry, but to increment it only if all checks were
                       ;ok
        
        andi r18,$3f   ;masks off bit for first lde = remains counter
        dec r18        ;makes ordernumber for next expected lde
                       ;after last lde it's #$00 = flag for search short enty after ldes     

        sts ornuld,r18 ;order number of long dir-entry      
        andi r26,$e0   ;Zlow to begin of cbm-line

        rjmp l15670    ;this HD-long-dir entry is read to end -> make next HD-dir-entry 
                       ;---------------------------------------------------------
l16030: call l13130   ;3x-- =error at long directory entry lde = print shorentry only
                       ; = also: an orphan-direntry found 
        ;ldi r25,$80   ;80--
        ;jmp freeze    ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                

        mov r10,r07    ;#$ff =flag that orphan-direntry is between former-old and actual-new
                       ;       direntry  -> minus
                               
                       ;CBM-dir-write-vector isn't incremented to next entry
        sts ornuld,r07 ;#$ff clears order number lde 
        rjmp l15670    ;illegal long dir-entry
                       ;------------------------------------------------------------------------- 
l16040: cpi r17,$2e    ;'.'    r17 = first char of shortname
        brne l16050    ;b.i.not dot, dotdot entry

        ldi r23,$cd    ;filetype = dot dotdot (closed, scratch-protected)
        sts difity,r23 ;directory filetype
        
        rjmp l16420    ;----

l16050: mov r17,r22    ;T-flag would perhaps be shorter???
        andi r17,$08
        breq l16060    ;b.i.not volume-ID (=name of this dir)

        ldi r23,$8f    ;sets flag for volume id of root dir 
        sts difity,r23 ;directory filetype (scratch potected would perhaps be good???)

                       ;if it's volume id then it must be printed into dirnamebuffer????????







        rjmp l16440    ; ->ret

l16060: 
        
/*
        lds r16,c6frre ;C64-freeze-register------------------------------------------------------
        cpi r16,$01
        brne l16070

        lds r16,c6cor0 ;------------------------------------------------------------------------- 
        lds r17,c6cor3
        cp r16,r17
        brne l16070

        ldi r25,$aa    ;aa--
        jmp freeze
l16070:                ;-------------------------------------------------------------------------
*/
 
                       ;r21 = noCBM- /CBM-fileextension-------------------
                       ;r22 = attribute-byte ($060b...07eb)---------------
                       ;r23 = pos of first filename-character-------------

        ldi r21,$00    ;default for no CBM-fileextension    
       
        ldi r23,$86    ;filetype directory
        bst r22,4      ;copies bit 4 of attributebyte to T-flag
        brts l16130    ;b.i.directory
 
        ldi r30,low(optatf<<1) ;open table type FAT
        ldi r31,high(optatf<<1) ;open table type FAT
        
        ldi r23,$80    ;filetype   default and counter

l16080: andi r28,$e0   ;0a0c->0a08  0a2c->0a28  0bec->0be8 
        ori r28,$08    ;pos of fileextension

        ldi r18,$03    ;counter for 3 characters to compare

l16090: ld r16,y+
        lpm r17,z+

        ;ldi r25,$23    ;23--
        ;rcall l13130
        
        ;mov r25,r16    ;--
        ;rcall l13130

        ;mov r25,r17    ;--
        ;rcall l13130

        cp r16,r17
        breq l16120

l16100: dec r18
        breq l16110

        lpm r17,z+
        rjmp l16100

l16110: inc r23
        cpi r23,$8c
        brcs l16080

        ldi r23,$8e    ;flag for FOReign-filetype
        rjmp l16130    ;r21 is still #$00 = no CBM-file-extension

l16120: dec r18
        brne l16090    ;b.i.not yet all 3 characters compared -> compare next character

        ldi r21,$80    ;flag for CBM-fileextension (D16, D64, D71, D81, DEL, SEQ, PRG, USR, REL)

l16130: bst r22,0      ;copies bit 0 of attributebyte to T-flag (=read-only flag)
        brtc l16140    ;b.i.not scratch protected   not write-protected   not read-only

        ori r23,$40    ;sets bit for scratch-protected
        
l16140: sts difity,r23 ;directory file type
        
        ldi r26,low(dibube) ;08e8 directory buffer begin 
        ldi r27,high(dibube)

        cpi r21,$80    ;noCBM- /CBM-fileextension 
        breq l16150    ;b.i.CBM-file (=show longname)

        mov r16,r22    ;attribute-byte
        andi r16,$10   ;masks directory-bit
        breq l16160    ;b.i.not directory-entry = b.i.FOR
        
                       ;=CBM-file or DIR (=show longname)
                       ;r21 = noCBM- /CBM-fileextension-------------------
                       ;r22 = attribute-byte-------------------------------
l16150: lds r16,ornuld ;ordernumber lde
        sts ornuld,r07 ;#$ff clears ordernumber lde
        cpi r16,$00
        breq l16170    ;b.i.lds computed to end and now waiting for correct short-entry

                       ;=MS-DOS-shortentry only
l16160: sts ldstle,r06 ;#$00 long-directory-start-length 

        mov r17,r28    ;vector of actual direntry (begin) 
        andi r17,$e0   ;0a00  0a20  0be0
        sts ldstve,r17 ;longdirectory-start-vector

        lds r17,ashbsc ;actual SA HD-buffer sector in this cluster 
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        sts ldstsc,r17 ;long-directory-start sector in this cluster               

        lds r12,ashbcl ;cluster of actual direntry (begin of complete entry      
        lds r13,ashbcl+1 ;which could be over several sectors
        lds r14,ashbcl+2
        lds r15,ashbcl+3  
        
        sts ldstcl,r12 ;long-directory-start-cluster
        sts ldstcl+1,r13
        sts ldstcl+2,r14            
        sts ldstcl+3,r15

        rjmp l16300    ;error at LDE entries before -> display shortentry only-------------------
        
l16170: ldi r25,$24    ;24--                             shortnameentry after long filename entry
        call l13130   ;                                 mustn't change r22=attribute.byte
        mov r25,r21    ;---- (noCBM/CBM-fileextension)
        call l13130
        mov r25,r22    ;---- (attribute-byte)
        call l13130
                       ;=display long    
        andi r28,$e0   ;0a0b->0a00  0a2b->0a20  0beb->0be0 shows to short filename
        
        ldi r17,$00    ;clears checksum
        
l16180: ld r16,y+      ;reads filename char 0-10 /1-11  8+3chars
        lsr r17        ;shifts checksum right
        brcc l16190    ;b.i.(old bit0) now carry is low (=don't add #$80)
        
        subi r17,$80   ;adds #$80
        
l16190: add r17,r16    ;adds actual char to checksum
        mov r16,r28
        andi r16,$1f
        cpi r16,$0b
        brne l16180    ;b.i.end of filename not yet reached
                       ;             Y=HD-read at end = 0a0b 0a2b 0beb      
        ldi r25,$38    ;38--
        lds r16,ldchsu ;lde-checksum
        cp r16,r17     ;compares lde- and short-entry- checksum
        breq l16200    ;b.i.equal
        rjmp l16280    ;checksum-error        

l16200: ldi r25,$26    ;26--
        call l13130
  
        subi r28,$03   ;Y=HD-readvector = 0a08 0a28 0be8 = pos of file-extension
                       ;why this command ??? delete it???----------------------------




        ldi r26,low(dibube+$17);=$09ff Xlow directory buffer begin
                       ;CBM-buffer  writevector changes to readvector
                       ;shows to begin of former made long filenameentry
                       ;long filename entry is 08e8-08ff 
                       ; and at end filled with #$a0 (but $a0 can also be in middle of name)
                       ; $0bff is always #$a0        

l16210: ld r16,-x      ;reads char of long filename
        cpi r16,$a0    ;     searches end of long-filename  
        breq l16210    ;X shows at end to last character of filename

        ld r16,x+      ;X shows at end to last character of filename+1
                       ; (=first #$a0 after filename)

        cpi r21,$80
        brne l16230    ;b.i.DIR (no CBM-file) (there is no dot&fileextension at dir)

        ldi r17,$08    ;               loop-number: 0 1 2 3 4 5 6 7 8             
                       ;perhaps here: make 8 at DEL only
                       ;              make 5 at PRG, SEQ USR REL...
        ldi r18,$a0

l16220: ld r16,-x      ;at begin: reads end-#$00   $1 0 0 l e d . - ="-----...----.del001
                       ;                r17before:  8 7 6 5 4 3 2 1 
        dec r17        ;                 r17after:  7 6 5 4 3 2 1 0
        breq l16280    ;b.i.fileextension > 6 chars (max.allowed is del001) = error- del999)

        st x,r18       ;fills end of filename from end to begin with #$a0

        cpi r16,$2e    ;dot .  searches last for of filename
        brne l16220    ;X shows at end to last character of filename+1
                       ; (=first #$a0 after filename)

l16230: ldi r25,$39    ;39--
        cpi r26,low(dibube)+$11;=$09f9 Xlow directory buffer begin  
                       ;vector to end of lde+end-#$00+1
                       ;compares with max.length of long filename
        brcc l16280    ;b.i.filename > 16 chars  = error 

l16240: ldi r25,$27    ;27--
        call l13130
  

l16250:         
l16260: 
                       ;r22 must still contain attribute-byte  

l16270: rjmp l16380    ;print end-" and so on-----
                       ;----------
l16280: call l13130    ;3x-- =error at long directory entry lde 

                       ;!!!! make start of complete entry (ldstcl...) to actual sector!!!!!


;        ldi r25,$90   ;90--
;        jmp freeze     ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

l16290:                        ;                                                     end lfe----
l16300: andi r28,$e0   ;0a0b->0a00  0a2b->0a20  0beb->0be0
        
        ldi r26,low(dibube);=$08e8 Xlow directory buffer begin  
        
l16310: ld r16,y+      ;copies (short-)filename 
        cpi r16,$20    ;space
        breq l16360    ;b.i.space = b.i.end of shortname

        ldi r17,$d5
        cpi r16,$05    ;only possible at first position as substitute for $e5
        breq l16340    

        ldi r17,$3c    ;<
        cpi r16,$7b    ;{
        breq l16340

        ldi r17,$3e    ;>
        cpi r16,$7d    ;}
        breq l16340
        
        ldi r17,$c0    ;×-
        cpi r16,$7e    ;~
        breq l16340

        cpi r16,$60
        brcs l16350    ;b.i.$20-5f

        mov r17,r16
        andi r17,$d0   ;$60->$40  $61->$41  $7f->$5f still check exeption chars here!!!!!!!!!!!!
        cpi r16,$80
        brcs l16340    ;b.i.$60-7f

        ldi r30,low(tashna<<1) ;table shortname CBM-$a0-df -> DOS-ASCII
        ldi r31,high(tashna<<1)

l16320: lpm r17,z+     ;reads byte from table
        cp r16,r17     ;   table begin: 00  00  80  80  fe  fe                                             
        brne l16330    ;   pos of char: 00  3f  00  3f  00  3f                                            
                       ;  Zlow (after): 01  40  81  c0  ff  3e                                         
        mov r16,r30    ;           r16: 01  40  81  c0  ff  3e                                            
        subi r16,low((tashna<<1)+$61) ; a0  df  a0  df  a0  df
        rjmp l16350
        
l16330: cpi r30,low((tashna<<1)+$40)
        brne l16320    ;b.i.end of table not yet reached  

        ldi r17,$5f    ;underscore _
        
l16340: mov r16,r17

l16350: st x+,r16
        cpi r26,low(dibube)+$08
        brne l16310

l16360: andi r28,$e0
        ori r28,$08    ;pos of fileextension
        
        mov r16,r22    ;attribute-byte
        andi r16,$10   ;masks directory-bit
        brne l16370    ;b.i.directory-entry (print fileextension here)

        cpi r21,$80
        breq l16380    ;b.i.CBM-file-extension (don't print fileextension here)
        
l16370: ld r16,y+      ;first char of fileextension
        ld r17,y+
        ld r18,y+      ;third char of fileextension 

        cpi r16,$20
        breq l16380    ;b.i.space
 
        ldi r19,$2e    ;dot
        st x+,r19
       
        st x+,r16

        cpi r17,$20 
        breq l16380    ;b.i.space
        
        st x+,r17      ;writes non-CBM-fileextension directly behind filename

        cpi r18,$20 
        breq l16380    ;b.i.space

        st x+,r18  

l16380: ldi r16,$a0

l16390: st x+,r16      ;fills end of filename with #$a0
        mov r20,r26    ; (important to overwrite illegal long filename)
        andi r20,$1f
        brne l16390    ;at the end there is an overflow into the next shortentry (0a1f->0a20)
        
        ld r16,-x      ;undo this overflow   

l16400:
l16410:

                       ;Y=read from HD-buffer   X=write into CBM-buffer
l16420: ori r28,$1f    ;Y shows to end of actual read HD-dir-entry  0a1f  0a3f  0bff 
                       ;important if HD-entry is read partially only 

l16430:                
        sts ashbve,r28 ;actual SA HD-buffer vector = vector to read from HD-dir
                       ; shows now to end of now-actual HD-dir-entry
                   
                       ;values for restoring r29 = Yhigh (ashbcl - ashbcl+3, ashbsc) are 
                       ; already stored
                         
 
        andi r28,$e0      
        ori r28,$14    ;0a14  0a34   0bf4
        ld r14,y+      ;0a14  startcluster higher of actual direntry
        ld r15,y+      ;0a15  startcluster highest of actual direntry
        subi r28,$fc   ;adds #$04  0a16->0a1a
        ld r12,y+      ;0a1a  startcluster low of actual direntry
        ld r13,y+      ;0a1b  startcluster high of actual direntry
    
        ldi r16,$0f
        and r15,r16    ;masks off bits 7-4 of startcluster highest

        ld r20,y+      ;0a1c filelength low
        ld r21,y+      ;0a1d
        ld r22,y+      ;0a1e 
        ld r23,y       ;0a1f filelength highest (don't use ld r23,y+ because Y would show to next 
                       ;    HD-dir-entry)            
        lds r16,difity ;directory filetype
        andi r16,$0f   ;masks filetype
        breq l16440    ;b.i.DEL-file (there is no not-closed DEL-file)
                       ;     (DEL-file is closed even if filelength is 0 bytes)
        cpi r16,$04    
        brcc l16440    ;b.i.REL- or non-CBM-file (there is no not-closed REL- or non-CBM-file)
          
        mov r16,r20    ;    =SEQ, PRG, USR
        or r16,r21
        or r16,r22
        or r16,r23
        brne l16440    ;b.i.filelength > 0 bytes (=closed CBM-file)

        lds r16,difity ;directory filetype
        andi r16,$7f   ;makes bit that file isn't closed (clears file-closed bit)
        sts difity,r16
                       ;definition:                  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                       ; SEQ-, PRG- and USR-files with a filelength of 0 bytes aren't closed 
                       
l16440: andi r28,$e0   ;Y shows to first byte of actual read HD-dir-entry (=short filename-entry)
        ldi r26,low(dibube) ;#$e8 X shows to begin of directory buffer begin (long filename)
        
        lds r16,difity ;directory filetype
      
        ;tst r10        ;flag whether orphandirentry between old and actual direntry
                       ;plus = no orphan   minus = orphan between old and actual direntry
                       ;the plusminusflag is destroyed at the parentroutine
                       ; (the parentroutine makes a test r10 again)
                       ; => this command isn't necessary
/*
        lds r25,dibube 
        cpi r25,$41    ;'a'
        brne l16450

        lds r25,dibube+1 
        cpi r25,$42    ;'b'
        brne l16450

        lds r25,dibube+5 
        cpi r25,$31    ;'1'
        brne l16450

        ldi r25,$b0    ;b0--
        jmp freeze     ;='abcd~1'
        .db 0 
l16450:
*/
        sez            ;=equal = flag for end of dir not yet reached 
        
        ldi r25,$2f    ;2f--
        call l13130
  
        mov r25,r16    ;--  (difity   directory filetype)
        call l13130
                       ;if empty direntry: difity=#$00 (allways, bit 7-4 is also cleared)
                       ;if volume-ID of rootdir: difity =#$8f (allways, bit 6-4 is always cleared
                       ;          even if the read-only or attribute-bit would be set)
        ret            ;-------------------------------------------------------------------------
                       ;X r26/27 begin of dibube directory buffer begin
                       ;Y r28/92 begin of HD-dir-entry (short filename-entry?)
                       ;Z r30/31 a Flash-table for a compare-operation
                       ;if there is an error then the routine doesn't come to this point
                       ; it jumps to the error routine before                end of l15630/l15660
;================================================================================================
                       ;begin of inputbuffer must be at $0100, $0200, $0300...
                       ; lowbyte of inputbufferbegin must be #$00

                       ;$027a = cfpobc command/filename position of begin/commands = 027a,x at41
                       ;$027b = cfpoco command/filename position of commas = 027b,x at1541  
                       ;...
                       ;$027f
                       
                       ; there are 5 filenames possible in one inputsring (name 0 - name4)

                       ;$027a = begin of filename0  
                       ;$027b = end of filename 0 = begin of filename 1
                       ;$027c = end of filename 1 = begin of filename 2
                       ;$027d = end of filename 2 = begin of filename 3
                       ;$027e = end of filename 3 = begin of filename 4
                       ;$027f = end of filename 4
                       
                       ;first 027b-027f contain the position of the commas+1 (or of colon)?????????
                       ;after jsr c312 / jsr c320: 027a-027e contain the position
                       ;          of the begin of the filename itself (without drivenumber and :)          


                       ;drivenumbers:
                       ;0 = use old drivenumber
                       ;1 = drive not ready error
                       ;2-ff 2-255 = use partition 2-255
                       ;if there is no drivenumber in filename: same as drivenumber 0                             

                       ;problem: AVR has no lda(94),y command
                       ; usage:
                       ;  X-register: vector to dirfilename      
                       ;  Y-register: vector in inputbuffer (lda 0200,x at 1541
                       ;                                     lda (a3),y at 1541)
                       ;             => Y is always vector to inputbuffer)
                       ;  Z-register: vector to tables with displacement (lda e2,x  
                       ;                                                 (lda 027a,x)   
                       ;              vector to direntry-buffer (lda (94),y at 1541)
                       ;=>Z-reg is mostly vector to tables. If it is used as anything different
                       ;    then the table-vectors must be backuped and restored later 
;------------------------------------------------------------------------------------------------
                       ;Y-reg r28/r29 must show to correct pos of inputbuffer
                       ;Z-reg r30/r31 must show to open-tables
l16460: lds r20,incoen ;inputcommand end+1        c268          search a character in inputbuffer                  
                       ;mustn't change r22 (used at l17360)                                  c268 

l16470: cp r28,r20     ;compares vector and end                 r16 = actual character       c26b
        brcc l16510    ;b.i.end of CF reached                   r17 = searched character     c26e

        ld r16,y+      ;loads actual character                  r18 = actual flag for joker  c270
        cp r16,r17     ;compares actual and searched character         = 028a at 1541 
        breq l16520    ;b.i.searched character found                                         c276

        cpi r16,$2a    ;compares with '*'-joker                 r28 = Y at 1541  
        breq l16480         
 
        cpi r16,$3f    ;compares with '?'-joker                 r30 = X at 1541
        brne l16490    ;b.i.not '?'

l16480: lds r18,cm028a ;loads flag for joker of actual filename (cleared at initialize tables)
        inc r18        ;sets flag for joker (ori r18,$01 would perhaps be better                                                  c280
        sts cm028a,r18 ;                     see declaration of label cm028a)  
                       ;bit7-0 = counter for jokers in this part-filename
                       ;increments counter for jokers in this filename 
                       ; = set flag that there is a joker in this part-filename  

l16490: cpi r16,$2c    ;compares with comma
        brne l16470    ;b.i.not comma -> next character of inputbuffer
                       ;=end of one filename
        std z+low(cfpoco),r28 ;stores position+1 of found comma to table of comma-positions  c288

        lds r16,cm028a ;loads flag for joker of actual part-filename
        andi r16,$7f   ;masks actual bits for joker
        breq l16500    ;b.i.no joker in this part-filename

        ldi r16,$80    ;= flag for joker                                                     c292
        std z+low(cffljo),r16 ;stores joker-flag for actual filename                         c294
        sts cm028a,r16 ;flag for joker                                                       c296
                       ; clears counter for jokers (=bit6-0) for next part-filename 

l16500: inc r30        ;increments amount of commas = amount of filenames                    c299
        cpi r30,$04    ;                                                                     c29a
        brcs l16470    ;b.i.not maximum of 4 commas reached -> next filename                 c29c

l16510: ldi r28,$00    ;flag that searched character isn't found                             c29e
                       ;  (within the first 4 or 5 inputnames???)
                        
l16520: std z+low(cfpoco),r20 ;stores position+1 of end-of-CF to table of comma-positions    c2a3

        lds r16,cm028a ;loads flag for joker of actual filename                              c2a6
        andi r16,$7f   ;masks actual bits for joker
        breq l16530    ;b.i.no joker in actual filenamepart                                  c2ab

        ldi r16,$80    ;= flag for joker
        std z+low(cffljo),r16 ;stores joker-flag for actual filename                         c2af

l16530: mov r16,r28    ;#$00=searched character not found  #$01-#$2a=pos of searched character+1
        cpi r16,$00    ;equal=searched character not found  notequal=searched character found
        ret            ;r30=Zlow=amount of found commas                                      c2b2
                       ;1541: x=amount of found commas
                       ;the routine returns (ends) when the wanted char is found
                       ;=> r30 (1541-Xreg) contains only commas (',') found before the wanted
                       ;                   chars was found
                       ;r16 = 41-A position+1 of searched character (#$00 if not found)
                       ;r30 = 41-X Zlow perhaps counter for found part-filenames
                       ;r28 = 41-Y Ylow position+1 of searched character (#$00 if not found)
;------------------------------------------------------------------------------------------------
l16540: lds r16,opamco ;open amount of commas (=0278 at 1541)                                c312
        sts cm0277,r16 ;CBM-memory $0277 
        
        ldi r16,$01
        sts opamco,r16 ;open amount of commas (=0278 at 1541) 
                       ; makes flag that one drivenumber only is copied  
        sts cm0279,r16 ;CBM-memory $0279 
                       ;.........................................................................
                       ;from l17610 (scratch), l18000 (rename)    
l16550:                ;                                  take drivenumbers from inputbuffer c320
        ;lds r18,opladr ;open last drive =last used drivenumber no sense???                  c320
        ldi r30,$00   ;vector to filecounter in inputbuffer                                  c323 
        ldi r31,high(cfmebe) ;command/filename memory begin
        ldi r29,high(inbube)

l16560: ldd r28,z+low(cfpobc) ;command/filename position of begin/commands = 027a,x at1541
                      ;=begin of leading drivenumber of filename
                      ;r28 = Xreg at 1541 = temporary $d3 at 1541
        rcall l16570
        std z+low(cfpobc),r28 ;command/filename position of begin/commands = 027a,x at1541
                      ;begin of filename itself without leading drivenumber                  c32f  
        std z+low(cfdrno),r18 ;command/filename drive number
        inc r30        ;increments filecounter                                               c335
        lds r16,opamco ;open amount of commas (=0278 at 1541) 
        cp r30,r16
        brcs l16560    ;search drivenumber for next (of maximal 5) filenames
        
        ret            ;                                                                     c33b

                       ;at begin of this routine: $027a-027e shows to begin of drivenumber of 
                       ;                           the filename
                       ;at end of this routine: $027a-027e shows to begin of filename itself
                       ;                           without drivenumber 
;------------------------------------------------------------------------------------------------
                       ;                           extracts drivenumber out of one inputpart c33c
l16570: ldd r16,y+$01  ;loads character one position behind table value                      c33c
        lds r18,adspch ;additional special chars
                       ;00 = no additional special chars   (for WTE)    ----WTE----
                       ;01 = '/' has same meaning as ':' (CD-command (for WTE)
        cpi r18,$01
        brne l16580    ;b.i.don't use additional special chars

        cpi r16,$2f    ;'/'
        breq l16590    ;b.i.'/' ----WTE----  

l16580: cpi r16,$3a  
        brne l16600    ;b.i.not colon ':'                                                    c344  

l16590: ld r18,y+      ;loads character before colon = drivenumber                           c352
                       ;Y shows now to pos of :                                              c355
            
        cpi r18,$30    ;'0'
        breq l16620    ;b.i.drivenumber 0    0:xyz
        
        cpi r18,$31    ;'1'
        breq l16620    ;b.i.drivenumber 1    1:xyz
        
        rjmp l16610    ;                     x:xyz

l16600: ldi r18,$80    ;default for no drivenumber and no colon                              c362
        ld r16,y       ;loads character at position of table value                           c346
        cpi r16,$3a
        brne l16630    ;b.i.first character of filename isn't colon

l16610: ldi r18,$00    ;drivenumber 0

l16620: inc r28        ;Y shows now to begin of filename itself without leading drivenumber  c34b
        andi r18,$01   ;masks off ASCII-bits                                                 c34d

l16630: ret            ;r18 (Y at 1541) contains drivenumber 
                       ;r28 Y shows to begin of filename itself without drivenumber before 
                       ;if filename     then drivenumber
                       ;'xyz'           $80
                       ;':xyz'          $00
                       ;'0:xyz'         $00
                       ;'1:xyz'         $01
                       ;'x:xyz'         $00
;------------------------------------------------------------------------------------------------
l16640:                ;                  if necessary then initialize drive & switch on LED c3ca
        lds r30,opamco ;open amount of commas  = $0278 at 1541$05                            c3ca
                       ;counter for filenames in inputbuffer
        dec r30            
                       ;I don't understand what the 1541 routine makes
        
        ldi r31,high(cfmebe) ;command/filename memory begin               

l16650: ldd r16,z+low(cfdrno) ;command/filename drive number                
        cpi r16,$01
        brne l16670    ;b.i.not drive 1

l16660: ldi r16,$4a    ;74,drive not ready 74--                                              c41b
        jmp l13980     ;print message + LED-blink + main waiting loop                        c41d

l16670: dec r30        ;decrements filename-amount-counter                                   c3dd  
        brpl l16650    ;                                                                     c3de
                       ;.........................................................................
                       ;from l
l16680:         
       #if partname >= 2    
        #message 644-non-IEC-ATA
l16690: rcall l17090   ;if necessary then initialize drive                                   c434
        brne l16660    ;b.i.drive not accessable                                             c437
       #endif

       #if partname == 1    
        #message 162-IEC-ATA-V2
        jmp l10750     ;single-LED on & ret                                                  c439

       #else
        #message 644-non-IEC-ATA
        jmp l10780     ;active-LED on & ret                                                  c439
       #endif 
;------------------------------------------------------------------------------------------------
                       ;from l18000
l16700:                ;                              search all files of inputbuffer in dir c44f
        ldi r25,$21    ;21-- 'r'
        call l13080

        rcall l16640   ;initialize drive & switch on LED                                     c44f

        ldi r25,$22    ;22-- 'r'
        call l13080

        sts ofdeve,r06 ;#$00 open free dir entry vector                   = $0292 at 1541   c454
                       ;makes flag for search used direntries 
                       ; before a free direntry is found: 0,2-ff=search used direntry
                       ;                                  1     =search free direntry
                       ; after a free direntry is found: position/vector of free direntry
                       ;         00,20,40,60,80,a0,c0,e0
                       ;         if 3 free direntries aren't found and
                       ;            no #$00-endflag-direntry => ofdeve = #$f0    
                       ;probably important: #$01 or not#$01  cmp #$01      
        rcall l16990   ;read first direntry into dibube directory buffer begin               c457

        ldi r25,$23    ;23-- 'r'
        call l13080

        brne l16720    ;b.i.any used direntry found (name not yet compared)                  c45a

        ldi r25,$24    ;24-- 'r'
        call l13080


                       ;switch to next drive
                       ;routine l16700 c4ff is used 3 times at 1541
                       ;the flags at return doesn't matter????
        ret            ;                                                                     c461                                

l16710: rcall l17070   ;read next direntry (actual dir is in buffer)                         c470
                       ;changes r26-r31 X-Z
                       ;at end:
                       ;X r26/27 begin of dibube directory buffer begin
                       ;Y r28/92 begin of HD-dir-entry (short filename-entry?)
                       ;Z r30/31 a Flash-table for a compare-operation
        breq l16730    ;b.i.no used direntry found                                           c473
 
l16720: 
        ldi r25,$25    ;25-- 'r'
        call l13080

        rcall l16840   ;compares all (5) filenames of inputbuffer with actual direntry       c475
                       ;must set X, Y, Z because at this subroutine they are different to
                       ; those ones of rcall l17070?? 

        ldi r25,$26    ;26-- 'r'
        call l13080

        lds r25,cm028f ;xx--
        call l13080

        lds r16,cm028f ;CBM-memory $028f  flag f.inputfilenames still to search / all found  c478
        tst r16        ;cm028f: 00 = at least one inputfilename still to search 
                       ;        ff = all inputfilenames found
        brne l16740    ;b.i.all filenames of inputbuffer found                          c47b/c47d
        
        ldi r25,$27    ;27-- 'r'
        call l13080

        lds r16,opfifo ;flag for open filename found  = $0253 at 1541                        c47e
        tst r16        ;0-5 = found and number of filename in inputbuffer
                       ;$ff = so far not found  
        brmi l16710    ;b.i.actual direntry doesn't fit to any inputname                     c481  
                       ;   -> read next direntry      

        ldi r25,$28    ;28-- 'r'
        call l13080

        rjmp l16720    ;=actual direntryname fits to any inputname                           c483
                       ;   -> compare with next inputfilename
                       ;perhaps: compare the direntryname with all inputnames?

l16730: ;lds r16,cm028f ;CBM-memory $028f  flag f.inputfilenames still to search / all found c485
                       ;cm028f: 00 = at least one inputfilename still to search 
                       ;        ff = all inputfilenames found
        ;tst r16
        ;breq l        ;1541 switches to next drive

l16740: 
        ldi r25,$29    ;29-- 'r'
        call l13080

        ret            ;                                                                     c48a  
;------------------------------------------------------------------------------------------------
                       ;c49d / c48b / c4b5 (-c4d7)  search next to inputname fitting dirnameentry
                       
                       ;c49d l16770 search first to inputname fitting dirnameentry
                       ;c48b l16750 search next to inputname fitting dirnameentry and 
                       ;             load dirblock from disk
                       ;c4b5 l16790 search next to inputname fitting dirnameentry 
                       ;             without loading dirblock from disk
                                                                    
                       ;search the filenames of the inputbuffer in the dir of the disk
                       ;the main-begin of this routine is 
                       ;rcall l16770 
                       ;jsr $c49d
                       ;- set flag for search of a closed file
                       ;- loads first direntry                          c4a2 jsr c5ac
                       ;- compares whether this direntry is one of the 
                       ;   wanted ones of the inputbuffer               c4ba jsr c4d8
                       ;- searches as long as all wanted inputfilenames
                       ;   are found
                       ;- even switches the drive 
                       ;-at end: -plus = one of the inputfilenames fits to a dirname
                       ;         -minus = no (further) fitting dirname found 
                       ;1541:   stores direntries in buffer of internal-read-SA $11                        
                       ;NLQ-HD: stores direntries in directory-buffer

                       ;from l17680 (scratch),          
l16750:                ;            continue of find to-input-filename matching dir-filename c48b
                       ;  loads as long entries from HD until it finds a matching one 
        rcall l17060   ;read next dir-entry (actual dirsector must be read from HD)          c48b 
        rjmp l16800    ;at NLQ-HD it's important to set vector Y & Z first--------------c48e/c490
                       ;-------------------
l16760: ldi r16,$01    ;swap to next drive                                                   c492
        sts cm028d,r16 ;???????
                       ;swap drivenumber
                       ;switch LED on
                       ;.........................................................................
                       ;from l17610, l19650 - l19660
l16770:                ;               begin of find to-input-filename matching dir-filename c49d 
                       ;  loads as long entries from HD until it finds a matching one
        sts ofdeve,r06 ;#$00 open free dir entry vector  = $0292 at 1541                    c49d
                       ; makes flag for search used direntry
        rcall l16990   ;reads first used direntry  of actual directory                       c4a2
                       ;  changes Y and Z r28-r31       
                       ;1541:++++ internal readaddress ($11) is opened here ++++
        ldi r29,high(inbube) ;inputbufferbegin
        ldi r31,high(cfmebe) ;command/filename memory begin

        brne l16810    ;b.i.wanted (used (not free)) direntry found (no test for filename)  

        sts cm028f,r06 ;#$00 flag that there are still filename to search for                c4a7
                       ;cm028f: 00 = at least one inputfilename still to search 
                       ;        ff = all inputfilenames found

l16780: lds r16,cm028f ;inputfilenames: still to search ($00) / all found ($ff)              c4aa
        tst r16
        brne l16830    ;b.i.all filenames found  end: (notequal &) minus
        
        lds r19,cm028c ;counter for access of drives
        dec r19
        brpl l16760    ;b.i.access to different drive necessary

                       ;(not equal?  (r19=#$ff)) 
        ret            ;minus = flag that no (further?) dirfilename has matched--------------c4b4
                       ;any inputfilename?????

l16790: rcall l17070   ;read next used direntry AVR                                          c4b5
                       ;  changes Y and Z r28-r31       
l16800: ldi r29,high(inbube) ;inputbufferbegin
        ldi r31,high(cfmebe) ;command/filename memory begin

        breq l16780    ;b.i.dir read to end at this drive (-> next drivenumber)              c4b8

l16810: rcall l16840   ;compares all (5) filenames of inpubuffer with actual direntry        c4ba
                       ;Zhigh must contain vector to table to number of which inputname
                       ;  of inputbuffer

        lds r30,opfifo ;flag f.direntry found (00-04 / ff)
        andi r30,$ff
        brpl l16820    ;b.i.actual direntry matches to one inputfilename
                       ;  Z=r30 shows to number of matching inputfilename
                       
                       ;=actual direntryfilename doesn't match to any of the 5
        lds r16,cm028f ;inputfilenames: still to search ($00) / all found ($ff) 
        andi r16,$ff   ;           inputfilenames???
        breq l16790    ;b.i.not yet all (5) input-filenames found
                      
                       ;= all inputfilenames found  
        rjmp l16830    ;end: (notequal &) minus                                              c4c7

l16820: lds r16,opfity ;filetype   0296 at 1541
        andi r16,$ff
        breq l16830    ;b.i.filetype isn't set = search any filetype ((equal &) plus)
                       ;=> display DEL-files only isn't possible??

        ldd r17,z+low(cffljo) ;read filetype of inputname x (0-4)                            c4ce
        andi r17,$0f   ;masks filetypebits (0-f for d,s,p,u,r...)
        cp r16,r17
        brne l16790    ;b.i.wrong filetype

                       ;=end: (equal &) plus

l16830: ret            ;plus equal = flag that actual dirfilename matches                    c4d7
                       ;             any inputfilename

                       ;perhaps: equal    = there are still direntries to check
                       ;         notequal = the end of the dir (/dirs at all drives) is reached

                       ;         plus     = actual dirfilename matches any inputfilename
                       ;         minus    = dirfilename doesn't match a any inputfilename 
;------------------------------------------------------------------------------------------------
                       ;from l16720, l16810
                       ;Yhigh r29 is set to inputbufferbegin
                       ;Zhigh r31 is set to inputfilename-table 
                       ;Ylow and Zlow are set at this routine
                       ;X is set at this routine (dibube directory buffer begin)
l16840:                ;compares all (5) filenames of inpubuffer with actual direntry        c4d8
        ldi r29,high(inbube) ;input buffer begin    important from l16720?        
        ldi r31,high(cfmebe) ;command/filename memory begin    important from l16720?

ldi r25,$d0    ;d0--
call l13130

        sts opfifo,r07 ;#$ff makes flag for open filename not found  = $0253 at 1541         c4da
        sts cm028a,r06 ;#$00 clears flag for jokers                                          c4de 
        rcall l16950   ;;checks whether                                                      c4e1
                       ; - all inputfilenames found and no joker in inputfilenames (notequal)
                       ;              =end of search
                       ; - not yet all filenames found or a joker in inputfilenames (equal)
                       ;              =continue search

ldi r25,$d1    ;d1--
call l13130

        breq l16870    ;b.i.not all input-filenames found or joker in filename

ldi r25,$d2    ;d2--
call l13130
                  
                       
l16850: ret            ;not equal = flag that all filenames found -----------                c4e6
                       ;not equal = same at 1541 = good

l16860: 


ldi r25,$d3    ;d3--
call l13130


        rcall l16960   ;set vector for next filename of inputstring                          c4e7
                       ;must set Z r30,r31 to number of filename in inputstring
        brne l16850    ;b.i.no more file???

l16870: ;lds r16,acdrnu ;actual drivenumber (7f at 1541)
                       ;swap drive???????????????????????????
                       ;no swap drive at AVR????


ldi r25,$d4    ;d4--
call l13130


                        
l16880: ldd r28,z+low(cfpobc) ;command/filename position of begin/commas = 027a,x at1541     c4fe
        rcall l17540   ;searches end of actual filename+1 -> cm0276 and                      c502
                       ;    computes length of actual filename -> cm024b

        ldi r26,low(dibube) ;directory buffer begin $08e8!!
        ldi r27,high(dibube)
                       ;X shows to first character of long filename
        rjmp l16910    ;----------                                                           c507

l16890: ld r16,y       ;loads character of inputstring                      $0200,x at 1541  c50a                
        ld r17,x       ;loads character of direntry                         ($94),y at 1541   
  
  
ldi r25,$d5    ;d5--
call l13130

  
mov r25,r16    ;xx--
call l13130

  
mov r25,r17    ;xx--
call l13130

  
        cp r16,r17     ;                                                                     c50d      
        breq l16900

        cpi r16,$3f
        brne l16860    ;b.i.not ?-joker                                                      c513

        cpi r17,$a0    ;filename-end-character at 1541: #$a0  shift space                    c517  
                       
        breq l16860    ;b.i.end of dir-filename but not end of input-filename                c519

l16900: inc r28        ;increments input-buffer-vector                                       c51b
        inc r26        ;increments directory-buffer-vector                                   c51c 

l16910: lds r16,cm0276 ;end of actual input-filename+1
        cp r28,r16     ;                                                                     c51d
        brcc l16920    ;b.i.end of input-filename reached                                    c520

ldi r25,$d6    ;d6-
call l13130



        ld r16,y       ;loads character of inputstring                                       c522
        cpi r16,$2a
        breq l16930    ;b.i.*-joker = end of compare = filenames matter
        rjmp l16890    ;compare next character-----                                          c529 

l16920: ;cpi r26,low(dibube)+$10 ;at the AVR there is always an end-#$a0 (even if the        c52b
        ;brcc l16930   ; dir-filename has a length of 16 characters                          c52d

        ld r17,x       ;loads character of dir-filename                                      c52f
        cpi r17,$a0    ;tests whether end of input-filename is also end of dir-filename      c531 
        brne l16860    ;b.i.dir-filename is longer than input-filename (=wrong filename)     c533

l16930:                ;                               =  input-filename matches dir-filename

ldi r25,$d7    ;d7--
call l13130



                        ;!!!!! nonsense delete it???????????????????? 

;        lds r30,ashbve ;actual SA HD-buffer vector 061f 063f 07ff
;        lds r31,ashbsc ;actual SA HD-buffer sector in this cluster  = HD-direntry
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
;        andi r31,$01   ;masks bit for first/second half of HD-buffer 
;        subi r31,$100-high(hdbube) ; Z-high shows to correct half of HD-buffer (#$06/07)
                        
                        ;!!!!! nonsense delete it???????????????????? 
                        
                        
                                               
                       ;registers still contain these values:
                       ;r12-r15=startcluster of file of actual direntry
                       ;r20-r23=filelength of file of actual direntry
                       ;pay attention that they aren't overwritten
                       
        lds r30,cm0279 ;number of found input-filename-entry                                 c535
        sts opfifo,r30 ;flag for open filename found  = $0253 at 1541                        c538
                            ;0-5 = found and number of filename in inputbuffer
                            ;$ff = so far not found  
        ldi r31,high(cfmebe) ;command/filename memory begin    ??necessary???????

        ldd r16,z+low(cffljo) ; command/filename flag for joker = e7,x at 1541               c53b
        andi r16,$80   ;masks joker-bit??
        sts cm028a,r16 ;stores to joker-flag-byte??

        lds r16,ldstle ;long-directory-start-length of direntries for this complete direntry
        std z+low(cfdile),r16 ;cmd/flnm length of direntry of actual file inputbuffer (d8,x/dd,x)

        lds r16,ldstve ;longdirectory-start-vector of direntry in dir-sector 0600 0620 07e0  c542
        std z+low(cfdive),r16 ;cmd/flnm vector of direntry of actual file inputbuffer   dd,x

        lds r16,ldstsc ;long-directory-start sector in this cluster of direntry in dir-sector              
        std z+low(cfdisc),r16 ;command/filename sector in this cluster of direntry of   d8,x
                            ;          actual file inputbuffer
               
        lds r16,ldstcl ;long-directory-start-cluster  of direntry in dir-sector  
        std z+low(cfdicl),r16 ;cmd/flnm cluster of direntry of actual file inputbuffer  d8,x
    
        lds r16,ldstcl+1 
        std z+low(cfdicl)+$05,r16 ;             d8,x
    
        lds r16,ldstcl+2 
        std z+low(cfdicl)+$0a,r16 ;             d8,x
    
        lds r16,ldstcl+3 
        std z+low(cfdicl)+$0f,r16 ;             d8,x
    
        lds r16,difity ;directory file type
                       ; bit7:before: 0=not closed 1=closed  (closed-bit)
                       ;      after : joker-flag-bit of inputstring (not of direntry)
                       ; bit6:0=can be scratched  1=scratch-protected=read-only (stays unchanged)
                       ; bit5: before: not used (perhaps temporary at save&replace??)
                       ;       after: 0=closed 1=not closed (former bit7, but opposite value)
                       ;                                     (not-closed-bit)
                       ; bit4: unused #%0 (at 1541: bit4-3 unused)
                       ; bit3-0: filetype 16 possible (at 1541: bit2-0) (stay unchanged)
        bst r16,7      ;copies bit7 of r16 to t-flag    
        andi r16,$4f   ;clears bit 7,5,4
        brts l16940    ;b.i.file is closed 
                       ;perhaps: A file with a CBM-extension and a length of 0bytes isn't closed?
        ori r16,$20    ;sets bit5  sets flag for not closed

l16940: ldd r17,z+low(cffljo) ;command/filename flag for joker          e7,x at 1541         c564
        andi r17,$80   ;masks joker-flag-bit  masks off all other bits                       c562
        or r16,r17     ;adds bit7 from inputstring-filname and bit6-0 from direntry-filename
        std z+low(cffljo),r16 ;command/filename flag for joker          e7,x at 1541         c568

        ldd r16,z+low(cfdrno) ;command/filename drive number            e2,x at 1541         c56a
        andi r16,$80   ;masks bit for????????
        lds r17,acdrnu ;actual drive number  =$007f at 1541
        or r16,r17     ;adds bit7 from inputstring-filname and bit6-0 from actual drive
        std z+low(cfdrno),r16 ;command/filename drive number            e2,x at 1541         c570

        ori r30,$20    ;the maximal displacement for the std-command is $3f
                       ;=> the displacement for the last table (fillength) would be too big
                       ;=> one must add #$20 to the Z-register => the displacement is #$20 bytes
                       ;    smaller => access to this table is possible 

        std z+low(cfstcl)-$20,r12 ;command/filename startcluster of file   0280,x/0285,x    c572-
        std z+low(cfstcl)-$20+$05,r13 ;                                                      c57a
        std z+low(cfstcl)-$20+$0a,r14 ;                                                     c572-
        std z+low(cfstcl)-$20+$0f,r15 ;command/filename startcluster of file 0280,x/0285,x   c57a
      
        std z+low(cffile)-$20,r20 ;command/filename filelength      
        std z+low(cffile)-$20+$05,r21 
        std z+low(cffile)-$20+$0a,r22 
        std z+low(cffile)-$20+$0f,r23 ;command/filename filelength      
                       ;the filelength must be stored here, because at FAT32 it's impossible to
                       ;calculate the length of the last block from the last block itself
        andi r30,$07   ;retores old, correct value for number of filename in inputstring

                       ;recordlength????????????????????????????
                       ;.........................................................................
                       ;from l16840 
                       ;checks whether 
                       ; - all inputfilenames found and no joker in inputfilenames (notequal)
                       ;              =end of search
                       ; - not yet all filenames found or a joker in inputfilenames (equal)
                       ;              =continue search
l16950: sts cm028f,r07 ;#$ff sets default-flag for all inputstring-filenames found           c589
       
        lds r16,opamco ;open amount of commas  = $0278 at 1541                               c58e
        sts cm0279,r16 ;temporary counter for amount of commas  
                       ;.........................................................................
                       ;from l16860
                       ;decrement vector to next input-filename in inputbuffer
l16960: lds r30,cm0279 ;temporary counter for amount of commas                               c594
        dec r30        ;
        sts cm0279,r30 ;important to store r30 because r30.r31 is later set to 
                       ;dir-HD-buffer and vector to inputfilenametable must be restored 

        brpl l16970    ;b.i.still input-filename to search
        ret            ;notequal = flag that all input-filenames found                       c599

l16970: ;lds r30,cm0279 ;CBM-memory $0279 amount of to search input-filenames??
        ldd r16,z+low(cffljo) ;command/filename flag for joker =                e7,x at 1541      
        andi r16,$ff
        brmi l16980    ;b.i.joker-flag-bit is set
        
        ori r30,$20    ;the maximal displacement for the std-command is $3f
                       ;=> the displacement for the last two tables would be too big
                       ;=> one must add #$20 to the Z-register => the displacement is #$20 bytes
                       ;    smaller => access to this table is possible 

        ldd r16,z+low(cfstcl)-$20+$0f ;command/filename startcluster highest
                       ;                                    of file 0280,x/0285,x            c5a1
                       ;!! opposite value at 1541
                       ;1541: 0=not yet found
                       ;      1-$23/28= already found (and starttrack) 
                       ;AVR:  ff=not yet found
                       ;      0-0f= already found (and startcluster highest) 
      
                       ;=> must be filled with correct values at initializing 
                       ; (#$ff instead of #$00)
   
        andi r30,$07   ;restores old, correct value for number of filename in inputstring
                       ;(0-4)   
        andi r16,$ff   
        brpl l16960    ;b.i.this input-filename is already found
        
l16980: sts cm028f,r06 ;#$00 set flag that there are still input-filenames to search
        sez            ;equal
        ret            ;equal = flag for continue to search                                  c5ab
                       ;cm028f: 00 = at least one inputfilename still to search 
                       ;        ff = all inputfilenames found
                       ;Z must contain vector to number of which inputname of inputbuffer
                            ;at end  or Zlow r28 must be stored to opfifo
;------------------------------------------------------------------------------------------------
                       ;c5ac / c604 / c617         search next deleted / not-deleted dirnameentry
                       
                       ;c5ac l16990 search first deleted / not-deleted dirnameentry
                       ;c604 l17060 search next deleted / not-deleted dirnameentry and 
                       ;             load dirblock from disk
                       ;c617 l17070 search next deleted / not-deleted dirnameentry 
                       ;             without loading dirblock from disk
                       
                       ;doesn't read volume-ID- and dot/dotdot-entries
                       ;from l16770
l16990:                ;                                                 read first direntry c5ac
                       ;reads wanted (empty/used) direntry
                       ;doesn't compare any filename
                       ;write to dibube directory buffer begin
                                              
                       ;initialize counter for $FFFF (65535) direntries
                       ;    (=maximal allowed length of FAT32 directory)
                       ;from l16770 (if wedge wouldn't be                read first direntry c5ac
        sts ofdecl+3,r07 ;#$ff open free dir entry cluster = $0291 at 1541 (but opposite value)
                       ; makes flag that no free direntry found before                       c5ac
        sts opfifo,r07 ;#$ff  clears flag for open filename found           = $0253 at 1541  c5b2

        ldi r25,$e0    ;e0----
        call l13090

                       ;1541 loads one 256bytes sector and analyses then 8 direntries
                       ;this is at AVR not possible because: It's not possible to make all 
                       ; start-clusters (4 bytes) and the filelength /4bytes, must be stored,
                       ; because length of last sector cannot be read from last sector) into
                       ; one $20 32bytes direntry
                       ; => the AVR makes a combination of a CBM-direntry from 05e8-05ff and
                       ; the short-direntry of IBM anywhere from $0600-$07ff

                       ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                       ;set cluster-values for actual directory
                       ;this is made at call l15630        
                       ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        ;ldi r16,$11    ;SA$11 SA17 = internal read-SA
        ;rcall l14190   ;backup old-actual CBM-buffer to swapfile and load new-actual one from SF
                       ;there should be no disadvantage if the AVR uses the normal SA,
                       ;which it received from the C64 as SA for open 
                       ;(the 1541 uses SA$11=17 = internal channel for read for open)

        lds r16,asfla0 ;flag0 of actual SA                      
        ori r16,$03    ;makes flag for directory and display also empty entries
        sts asfla0,r16 ;changed!!!! still necessary???????????????
                       
        ldi r16,$40    ;%01000000  sets flag that actual SA is opened for read
        sts asfla1,r16 ;actual SA flags1

        ldi r16,$04    ;%....1100 makes flag for read into AVR-HD-buffer but not into CBM-buffer
        sts ashbtr,r16 ;HD-buffer-transfer read of actual SA (0-17) 
        
        rcall l15640   ;write first dirline into cbm-buffer      without using SA$11         c5c1   
                       ;(uses ashbcl)
                       ;1541: ++++ internal readaddress ($11) is opened here ++++
                       ;still test carry-error-flag!!!!!!!!!!!!!!!!!!!!!!!!!    
                       ;still test whether cbm buffer is full
                       ;-----------------------------------------------------------
                       ;from l17070 (c62c)      loop
l17000: ldi r25,$e1    ;e1--
        call l13130
                       ;r16=difity
                       ;r12-r15=startcluster of file of actual direntry
                       ;r20-r23=filelength of file of actual direntry
l17010: breq l17020    ;b.i.not yet end of dir reached                                       c5c7
        
        sez            ;=equal=flag that wanted direntry wasn't found
                       ;equal=same as at 1541  (good)
        ret            ;                                                                     c5c9
;.........................................................................
l17020:                ;r16=directory file type    
                       ;X r26/27 begin of dibube directory buffer begin
                       ;Y r28/92 begin of HD-dir-entry (short filename-entry?)
                       ;Z r30/31 a Flash-table for a compare-operation

        cpi r16,$8f    ;difity=#$8f = volume-ID of root-dir
        breq l17040    ;b.i.volume-ID-entry -> skip = read next direntry
  
        cpi r16,$cd    ;difity=#$cd = dot-, dotdot-entry
        breq l17040    ;b.i.dot-, dotdot-entry -> skip = read next direntry

        cpi r16,$00    ;tests whether empty direntry
        brne l17030    ;b.i.not unused,not free direntry                                     c5e1
       
        lds r16,ofdecl+3 ;open free dir entry cluster = $0291 at 1541
        andi r16,$ff    ;tests whether legal cluster
                       ;00-0f=cluster already found + highest byte direntrycluster
                       ;ff=first free direntry not yet found
        brpl l17070    ;b.i.a free direntry was already found before                         c5e6

        lds r16,ashbsc ;actual SA HD-buffer sector in this cluster                           c5eb
                            ;!counts 256-bytes-cbm-sectors
                            ; doesn't count 512-bytes-hd-sectors
                            ;bit7-1=512-bytes-hd-sectors
                            ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector
                            ;                               is actual cbm sector
        sts ofdesc,r16 ;open free dir entry sector in this cluster

                       ;it's not possible to store the length of several free dir-enties in one
                       ;chain here, because you can only find the first free (of perhaps many)
                       ;free direntries here
                       ;=> read them from 
                       ;ldstle,r17 ;long-directory-start-length 
                       ;ldstve,r17 ;longdirectory-start-vector
                       ;ldstsc,r17 ;long-directory-start sector in this cluster               
                       ;ldstcl,r12 ;long-directory-start-cluster
                       ;ldstcl+1,r13
                       ;ldstcl+2,r14            
                       ;ldstcl+3,r15
                       ;isn't possible
                       
        lds r16,ashbcl ;actual SA HD-buffer cluster
        sts ofdecl,r16 ;open free dir entry cluster = $0291 at 1541
                          
        lds r16,ashbcl+1  
        sts ofdecl+1,r16  
                          
        lds r16,ashbcl+2
        sts ofdecl+2,r16
                      
        lds r16,ashbcl+3 ;actual SA HD-buffer cluster  highest byte (only $00-0f possible)
        sts ofdecl+3,r16 ;open free dir entry cluster = $0291 at 1541                        c5ed
                       ; if ofdecl+3 (=highest cluster) >$0f then no free direntry found before
                       ; if ofdecl+3 (=highest cluster) <=$0f then a free direntry was found before
       
        lds r17,ofdeve ;open free dir entry vector  = $0292 at 1541                         c5f2
                             ; before a free direntry is found: 0,2-ff=search used direntry
                             ;                                  1     =search free direntry
        subi r28,$fe   ;0600->0602  0620->0622   
                       ;is this necessary??
                       ; or isn't it only important whether ofdeve is #$01 or not
        sts ofdeve,r28 ;open free dir entry vector  = $0292 at 1541
                       ; after a free direntry is found: position of free direntry

        cpi r17,$00
        breq l17070    ;b.i.search for a used direntry

                       ;=unused direntry wanted and unused direntry found
                
                       ;r12-r15=startcluster of file of actual direntry
                       ;r20-r23=filelength of file of actual direntry

        ret            ;notequal=flag that wanted direntry (free/used) found                 c5fa
                       ;notequal=same as at 1541  (good)
 
l17030: lds r17,ofdeve ;open free dir entry vector  = $0292 at 1541 =used direntry found    c5fb     
        cpi r17,$01    ;tests whether search for free direntry                               c5fd
        brne l17080    ;b.i.search for used direntry and used entry found                    c600
                       
                       ;=search for free direntry but used entry found
l17040: rjmp l17070    ;->read next direntry                                                 c602
;------------------------------------------------------------------------------------------------
                       ;from l17060, l17730
l17050:                ;                      loads actual dirsector again and sets pointer 
        lds r16,opudes ;open used dir entry sector in this cluster          = $0290 at 1541  c609
        sts ashbsc,r16 ;actual SA HD-buffer sector in this cluster                           c60c                   
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
                       ;stores to 06/07-0e/0f better would be $80/81     
                                                          
        lds r16,opudec ;open used dir entry cluster                         = $0290 at 1541  c604
        sts ashbcl,r16 ;actual SA HD-buffer cluster               = $06/07 - $0e/0f at 1541  c607
                       ;stores to 06/07-0e/0f better would be $80/81     
    
        lds r16,opudec+1 ;open used dir entry cluster                       = $0290 at 1541  c604
        sts ashbcl+1,r16 ;actual SA HD-buffer cluster             = $06/07 - $0e/0f at 1541  c607

        lds r16,opudec+2 ;open used dir entry cluster                       = $0290 at 1541  c609
        sts ashbcl+2,r16 ;actual SA HD-buffer cluster             = $06/07 - $0e/0f at 1541  c60c

        lds r16,opudec+3 ;open used dir entry cluster                       = $0290 at 1541  c609
        sts ashbcl+3,r16 ;actual SA HD-buffer cluster             = $06/07 - $0e/0f at 1541  c60c

        call l14790    ;reads actual sector of actual cluster (again)                        c60e
        
        lds r26,opudep ;open used dir entry position                        = $0294 at 1541  c611
                       ;shows to begin of first dirpartentry of direntry
        sts ashbve,r26 ;actual SA HD-buffer vector = vector to read from HD-dir   c614                             
        ret            ;(r26 is used because at l17730 it's used for writing)
;------------------------------------------------------------------------------------------------                        
                       ;from l16750
l17060:                ;         read next dir-entry (actual dirsector must be read from HD) c604
        rcall l17050   ;reads actual dirsector again and sets pointer                   c604-c614 
                   
                       ;!! this shows to the begin of the former direntry 
                       ;    (even first dir-partentry)   
                       ;   rcall l15660 increments the vector to the next direntry
                       ;   (can be the second dir-partentry of former direntry)
                       ;   but sees then that this is a corrupted direntry 
                       ;   and loads as long partentries until it finds a legal complete entry   
                       ;   it's possible that a former disk-block is read again unneccesaryly
                       ;-------------------------------------------------------------------------
                       ;from l16790
l17070:                ;                        read next direntry (actual dir is in buffer) c617
                       ; not necessary to read actual dir-block
                       ;1541 reads one dirblock                                              c617
                       ;AVR reads one direntry only 
        sts opfifo,r07 ;#$ff  clears flag for open filename found           = $0253 at 1541  c617

                       ;reads one CBM-direntry only 
                       ;=> cannot increment vector in 1 dirsector
                       ; must always use routine which decides whether next direntry can be
                       ; read from actual dirsctor or whether it must be read from HD

        ldi r25,$e2    ;e2--
        call l13130

        rcall l15660   ;write next dirline into cbm-buffer at vector ashbve                  c629
                       ;X r26/27 begin of dibube directory buffer begin
                       ;Y r28/92 begin of HD-dir-entry (short filename-entry?)
                       ;Z r30/31 a Flash-table for a compare-operation
                
        rjmp l17000    ;check whether last direntry = blocks free  & analyse-----------------c62c

l17080:                ;=search for used direntry and used direntry found                    c62f

                       ;r12-r15=startcluster of file of actual direntry
                       ;r20-r23=filelength of file of actual direntry
        
        lds r16,ldstle ;long-directory-start length 
        sts opudel,r16 ;open used dir entry length 
                            ;=amount of dirpartentries of actual complete direntry
                            ;complete direntry consists of:
                            ;0= only short direntry 
                            ;1= short direntry + 1 londdirentry
                            ;2= short direntry + 2 londdirentry
                            ;(3= short direntry + 3 londdirentry  (not possible?))

        lds r16,ldstve ;longdirectory-start-vector
        sts opudep,r16 ;open used dir entry position                        = $0294 at 1541  c631
                       ;shows to begin of first dirpartentry of actual direntry
                                              
        lds r16,ldstsc ;long-directory-start sector in this cluster                          
                            ;!counts 256-bytes-cbm-sectors
                            ; doesn't count 512-bytes-hd-sectors
                            ;bit7-1=512-bytes-hd-sectors
                            ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector
                            ;                               is actual cbm sector
        sts opudes,r16 ;open used dir entry sector in this cluster          = $0290 at 1541  c639
                          
        lds r16,ldstcl ;long-directory-start cluster
        sts opudec,r16 ;open used dir entry cluster                         = $0290 at 1541  c639
                          
        lds r16,ldstcl+1  
        sts opudec+1,r16 ;                                                  = $0290 at 1541  c639
                          
        lds r16,ldstcl+2
        sts opudec+2,r16 ;                                                  = $0290 at 1541  c639
                      
        lds r16,ldstcl+3 ;long-directory-start-cluster
        sts opudec+3,r16 ;open used dir entry cluster = $0290 at 1541       = $0290 at 1541  c639
                       ;this is not the actual vector (of the short-direntry)
                       ;this is the vector to the first long-direntry of the complete direntry

                       ;r12-r15=startcluster of file of actual direntry
                       ;r20-r23=filelength of file of actual direntry

        clz            ;notequal = flag that wanted direntry (free/used) found               c63c
                       ;notequal=same as at 1541  (good)
                       ;this is the end if a used entry is wanted and a used entry is found
                       ;the values of the actual dirsector / -entry are stored to
                       ; $0294/0290  opude.
                       ;=> these values can be used to continue search with the next 
                       ;     (used) direntry 
        ret            ;not equal                                                            c63c

                       ;not shure??? 
                       ;X r26/27 begin of dibube directory buffer begin
                       ;Y r28/92 begin of HD-dir-entry (short filename-entry?)
                       ;Z r30/31 a Flash-table for a compare-operation
                       ;not shure???
;------------------------------------------------------------------------------------------------
       #if partname >= 2    
        #message 644-non-IEC-ATA
                       ;from l16670
l17090:                ;                                 if necessary then initialize drive  c63d
        ldi r16,$00    ;default that HD is always accessable
        lds r17,acemen ;actual emulated entry 0,1,2
                       ; 0=IDE-HD    master
                       ; 1=IDE-CDROM slave (not supported)
                       ; 2=SD/MMC-card
        cpi r17,$02
        brne l17140    ;b.i.not SD (still make for CD)  (a HD cannot be changed)
                       ;-----------------------------------------------------begin SD-change-test    
       #if (partname == 3) | (partname == 6) | (partname == 7)
        #message nlq-hd/SD-routines
        lds r19,sdfldc ;SD flag disk change                             (bit0-3=$1c at 1541)
                       ;                                                (bit4-7=$1e at 1541)
        andi r19,$01
        brne l17100    ;b.i.SD was changed                                                   c645
        
                       ;!! the disc-change bit isn't cleared!!
                       ;!! bit 7-4 is also used !!
       #if partname == 3
        #message 644-NLQ-HD/SD2IEC
        in r20,pisdcd  ;AVR-pin SD-CardDetect
        ldi r18,$ff    ;
        andi r20,1<<bisdcd ;bit AVR-SD-CardDetect
        brne l17120    ;b.i.no SD inserted  = not accessable  
       #endif

       #if partname == 6
        #message 644-NLQ-HD/SD
        in r20,pisdcd  ;AVR-pin SD-CardDetect
        ldi r18,$ff    ;
        andi r20,1<<bisdcd ;bit AVR-SD-CardDetect
        brne l17120    ;b.i.no SD inserted  = not accessable  
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
        call l23810   ;reads I2C-parallel-port to r20
        ldi r18,$ff
        andi r20,1<<bisdcd ;bit AVR-SD-CardDetect
        brne l17120    ;b.i.no SD inserted  = not accessable 
       #endif

        set            ;flag for deactivate SPI-CS at end
        call l26530    ;send send-status-command and read status and deactivate SPI-CS at end
                       ;if there is no SD inserted, then this routine needs 2secs = very long
                       ;to avoid this long time: it's checked whether there is a SD inserted
                       ;before
        ldi r25,$11    ;11----
        call l13090
        mov r25,r16    ;-- (R1-response)
        call l13090

        brcc l17130    ;b.i.no error at receiving R1-response = no SD changed
                       ;-------------------------------------------------------end SD-change-test    
l17100:                ;=SD changed / new SD inserted


                       ;perhaps clear all SAs of SD without closing them?????????????
 
        lds r16,sdfldc
        andi r16,$02
        breq l17110    ;b.i.don't clear actual dir of SD

        ;ldi r16,$02    ;r16 is accidentially #$02
        sts cbadd2,r16  ;clusterbegin actual directory drive2 SD  
        sts cbadd2+1,r06
        sts cbadd2+2,r06 ;clear actual dir of SD
        sts cbadd2+3,r06

l17110: sts sdfldc,r06 ;clears SD flag disk change (changes also bit 7-4)                   c643

                       ;set flag for error??
        
        rcall l17970   ;test whether there is a disk in the drive                            c64c
        ldi r18,$ff    ;default for not accessable                                           c64f
        cpi r16,$03    ;sync not found response
        breq l17120    ;b.i.sync not found = b.i.no SD inserted

        ldi r18,$00    ;default for ok                                                       c65d
   
l17120: sts sddrac,r18 ;SD drive accessable     $00/$ff                        =$ff at 1541  c662
        tst r18
        brne l17130    ;b.i.drive not accessable   b.i.no SD in drive                        c664
        
        rcall l18240   ;initialize device                                                    c666

l17130: lds r16,sddrac ;SD drive accessable                               =$ff at 1541  c669/c66b
       #endif          ;of l17090

l17140: tst r16        ;00=drive accessable ff=drive not accessable
        ret   
       #endif          ;of l17090
;------------------------------------------------------------------------------------------------
                       ;from l25300
l17150:                ;analyse & execute new AVR-internal command / open                    c146
        ldi r25,$10    ;10----
        call l13090

        call l13880    ;print OK message to errorbuffer                                      c150 
     
        lds r16,icsawo ;IEC secundary address without bits for SA,open,close  ($83)          c153
        cpi r16,$0f   
        breq l17170    ;b.i.commandchannel $0f=15 
        
l17160: rjmp l19560    ;=not commandchannel $0f=15  =open
;------------------------------------------------------------------------------------------------
l17170:                ; = command (not open)                                                c160
        lds r16,inbube ;first char of inputbuffer
        cpi r16,$41    ;'a'
        brne l17180    ;open internal address at all commands beeing not 'additional'

        lds r16,inbube+1 ;second char of inputbuffer
        cpi r16,$52      ;'r'
        breq l17200      ;b.i.'ar'-command additional read

l17180: 
       #if partname >= 2    
        #message 644-non-IEC-ATA
        rcall l18910   ;test whether the SD has been changed and if so then free all buffers
        rcall l16680   ;if necessary then initialize drive & switch on LED
       #endif

        sts tasach+$11,r07 ;#$ff makes that SA$11 isn't opened 
                       ;in table secundaryaddress -> channel
                       ;=> SA-buffer is cleared with #$00 
                       ;and not the values of a former acces loaded from swapfile
        lds r16,acsacb ;actual SA in CBM-buffer
        cpi r16,$11    
        brne l17190    ;b.i.SA$11 isn't already in SA-buffer
        
        sts acsacb,r07 ;clears => CBM-buffer is cleard with #$00
         
l17190: ldi r16,$11    ;internal read-address                                                d47a
        sts icsawo,r16 ;SA-only without bits whether open/close/SA = $83 at 1541             d47c  
                       ;important that at rcall l18760 SA$11 is made as occupied
                       ;important that the correct place of tasach is allocated
        call l14190    ;save old CBM-buffer to swapfile and load new CBM-buffer from swapfile
                       ;77-- xx-- xx-- 78-- 

        ldi r16,$04    ;%....1100 for read and write: use HD-buffer only (not CBM-buffer)
        sts ashbtr,r16 ;HD-buffertransfer-read
        sts ashbtw,r16 ;actual SA HD-buffer-transfer write

        rcall l18760    ;sets flag that actual SA is opened for read
                       ;why read and not (also) write??
                       ; it's important that the byte in tasach for SA$11 isn't #$ff
                       ; (opened for read or write doesn't matter???)         

                       ;some commands use the CBM-buffer
                       ;here it's necessary to load the correct buffer from the swapfile
                       ;do perhaps the same as at open: initialize the disk if it is changed?????

                       ;even at command which use the HD-buffer only it can be necessary
                       ;to laod SA$11 because they overwrite CBM-values of actual cluster..

l17200: rcall l17440   ; (xx-- xx--) initialize command/filename-tables/values               c160
                       ;Y shows to begin of inputbuffer
        ld r19,y       ;loads first character of inputbuffer                                 c163
                       ;store to cm0275????
    
        sts debyhi,r19 ;debug-byte-high  

        ldi r25,$18    ;18----
        call l13090
   
        mov r25,r19    ;-- (first char of command)
        call l13130

        ldi r30,low((tacoch<<1)+$10) ;table command chars fe89 at 1541 
        ldi r31,high((tacoch<<1)+$10) ;                   db78 at 1581  
        ldi r17,$10    ;                                                                     c168

l17210: lpm r16,z      ;loads character of command table                                     c16a
        cp r16,r19     ;compares with inputbuffer                                            c16d
        breq l17230    ;b.i.same char                                                        c170 
        
        ld r16,-z      ;decrement vector, but 16bit-decrement (not 8bit-decrement)           c172 
        dec r17        ;                                                                     c172 
        brpl l17210    ;b.i.end of table not yet reached                                     c173

l17220: ldi r16,$1f    ;31,syntax error  31--                                                c175
        jmp l13980     ;syntax error into errorbuffer                                        c177
        
l17230: mov r25,r17    ;-- (number of command)
        call l13130

        sts cocono,r17 ;command commandnumber  =022a at 1541                                 c17a
        cpi r17,$09
        brcs l17240    ;b.i.0-8

        cpi r17,$0c
        brcc l17240    ;b.i.0c-10

        rcall l17340   ;analyse command (rename, scratch, new)                               c181
                       ;not copy!!! (is made later)

l17240: lds r17,cocono ;                                                                     c187
        ldi r30,low(tacolo<<1) ;table command lowbyte fe95
        ldi r31,high(tacolo<<1)
        add r30,r17
        adc r31,r06    ;#$00 adds carry
        lpm r16,z

        ldi r17,((tacohi-tacolo)*2) ;difference in bytes (not words from low-
        add r30,r17    ;              to high-byte table)
        adc r31,r06    ;#$00
        lpm r17,z

        mov r30,r16
        mov r31,r17
                         ;$0200   a aa a a a a a a a aa 
        lds r16,inbube+1 ;$0201   c hh h h e e r r f +-
        lds r17,inbube+2 ;$0202   a ii r w r w r w r 
        lds r12,inbube+3 ;$0203     01                            LBA0 (sector?)          
        mov r28,r12
        lds r13,inbube+4 ;$0204                                   LBA1 (!hexdez  not ASCII)  
        mov r29,r13
        lds r14,inbube+5 ;$0205                                   LBA2  lowbyte first   
        lds r15,inbube+6 ;$0206                                   LBA3  highbyte-last

        ijmp           ;jumps to vector r30,r31                                              c191 
                       ;00 validate
                       ;01 initialize
                       ;02 / cd-1581
                       ;03 memory
                       ;04 block
                       ;05 user          l23510
                       ;06 position
                       ;07 &
                       ;08 copy cd       l17770
                       ;09 rename        l18000
                       ;0a scratch       l17590
                       ;0b new
                       ;0c get
                       ;0d lock/unlock
                       ;0e time          l22200
                       ;0f write-protect 
                       ;10 additional    l22800
;------------------------------------------------------------------------------------------------
l17250:                ;end of a command                                                     c194
                       ;.........................................................................
                       ;from l20710
l17260: lds r16,floker ;flag ok / error     errorflag   026c at 1541                         c199
        andi r16,$ff   
        brne l17310    ;b.i.error                                                            c19c

        ldi r18,$00    ;                                                                     c19e
        mov r16,r18    ;errornumber (0=ok)                                                   c1a0          
        sts geactr,r18 ;general actual track                                  = $80 at 1541  c1a1
                       ;.........................................................................
                       ;from l17690 (scratch)
l17270: sts geacse,r18 ;general actual sector                                 = $80 at 1541  c1a3
        sts incove,r06 ;#$00 clears inputcommandvector  = $a3 at 1541                        c1a5 
        
        cpi r16,$01    ;errornumber
        brne l17280    ;b.i.not scratch

                       ;01, files scratched (r16 = #$00)             
        lds r17,geactr ;general actual track                                  = $80 at 1541          
        call l13900   ;copies text into errorbuffer                                 
        jmp l17290
        
l17280: call l13880    ;00,ok,00,00 & LED off                                           c1a7/c1aa

l17290: call l10760    ;clears flag ok / error to error-blink 026c at 1541     LED off
                  
                       ;set default drive
l17300:
                       ;clear flag for drive active???
                       
        call l13790    ;clears inputbuffer                                                   c1b7
        
        rjmp l19100    ;close internal SAs (SA $11=17 $12=18)                                c1ba
;------------------------------------------------------------------------------------------------
l17310:                ;clear track and sector and create errormessage                       c1c8
                       ;r16 = errornumber
        ldi r17,$14    ;14--   /   20
        jmp syserr     ;!!!!!!!!!!!!!!!!!!!
;------------------------------------------------------------------------------------------------
                       ;from l17340, l19610
l17320: ldi r17,$3a    ; ':' colon = searched character (= accu at 1541)             search colon    

l17330: ldi r28,low(inbube) ;#$00 begin of search-position                          
        ldi r29,high(inbube) ;Y = vector to inputbuffer (= a3,a4 at 1541)                    c1e5
                       ;=search begins at begin of inputbuffer   

        ldi r30,$00    ;amount of commas = amount of input-parts (= Xreg at 1541)
        ldi r31,high(cfmebe) ;command/filename tables-memory

        rjmp l16460    ;                                                                     c1eb
;------------------------------------------------------------------------------------------------
l17340: ldi r25,$19    ;19--
        call l13130

        rcall l17320   ;searches colon ':'                           analyse command-string  c1ee        
                       ;searches only until it finds :
                       ;(doesn't search all the command until end)
        brne l17360    ;b.i.colon : found                                                    c1f1

l17350: ldi r16,$22    ;34,syntax error 34--                                                 c1f3
        jmp l13980     ;                                                                     c1f5

                       ;from l17790 (cd/)
l17360: dec r28        ; r28 = Y at 1541                                                     c1f8 
        dec r28
        sts cfpobc,r28 ;command/filename position of begin/commas =     027a,x at1541        c1fa
                       ;position of command (in front of :)
        tst r30        ; r30 = X at 1541                                                     c1fd
        brne l17350    ;b.i.comma ,  found in front of colon : (=error)                           c1fe

                       ;from l20920..............................................................
l17370: ldi r17,$3d    ;'='                                                                  c200
        rcall l16460   ;search a character (=) in inputbuffer                                c202
        mov r22,r30    ;r30 (=X at 1541) = amount of found commas (=filenames)               c205
        tst r22        ;r22 = 028b at 1541
        breq l17380    ;b.i.no , in front of =                                               c206

        ldi r22,$40    ;there is a , in front of =                                           c208
                       ;--bit6: 0=no , in front of =
                       ;        1= , in front of = 

l17380: ori r22,$21    ;#$21/61                                                              c20a
        inc r30        ;increments counter for inputnames                                    c20f
        sts cm0277,r30 ;amount of inputnames in front of = ???                               c210
                       ;length of filename0????                                              
                       ;memory for storing old amount of commas/filenames?
        sts opamco,r30 ;amount of commas = amount of filenames in inputbuffer =0288at41      c213
        lds r16,cm028a ;bit7 = joker in former inputname                                     c216
        tst r16        ;bit6-0 = joker in actual inputname
        breq l17390    ;b.i.no joker in front of =                                           c219

        ori r22,$80    ;                                                                c21b-c220
        sts cm028a,r06 ;#$00 clears flag(s) for joker                                   c223-c225
                       ;--bit7: 0=no joker in front of =
                       ;        1= joker in front of = 
                       
                       ;bit 76543210
                       ;   %j,100001

l17390: tst r28        ;position of = in inputstring                                         c228
        breq l17420    ;b.i.there is no = in inputstring                                     c229

        std z+low(cfpobc),r28 ;command/filename position of begin/commands = 027a,x at1541   c22b
                       ;stores position of =
                       ;this is perhaps the end of the first inputname
                       ;the end of the first inputname is determined by the =
        lds r16,cm0277 ;=amount of input-names/-parts in front of =                          c22e
        sts cm0279,r16 ;backups amount of input-names/-parts in front of =                   c231
        ldi r17,$8d    ;shift-return (probably a char that is never in inputstring)          c234
        rcall l16460   ;search a character in inputbuffer (until end)                        c236
                       ; (analyses inputstring behind = )
        inc r30        ;increments amount of input-names/-parts                              c239
        sts opamco,r30 ;open amount of commas/input-names/-parts              =0278 at 1541  c23a
        dec r30        ;decrements amount of input-names                                     c23d
        lds r16,cm028a ;bit7 = joker in former inputname                                     c23e
        tst r16        ;bit6-0 = joker in actual inputname
        breq l17400    ;b.i.no joker in input-names/-parts behind =                          c241

        ldi r16,$08    ;                                                                     c243
                       ;--bit3: 0=no joker behind =
                       ;        1= joker behind = 
 
l17400:                ;r16 = #$00/#$08 
        lds r17,cm0277 ;amount of commas/inputnames/-parts in front of = 
        cp r30,r17     ;compares with total amount of commas/inputnames/-parts               c245
        breq l17410    ;b.i.no additional comma/inputnames/-parts found behind =             c248

        ori r16,$04    ;                                                                     c24a
                       ;--bit2: 0=no , behind =
                       ;        1= , behind = 
 
l17410: ori r16,$03    ;                                                                     c24c
        eor r22,r16    ;r22 = 028b at 1541                                                   c24e
        
l17420: mov r16,r22    ;r22 = 028b at 1541                                                   c254
        ;sts cm028b,r16 ;is important at copy command
    
        mov r25,r22    ;-- (028b at 1541)
        call l13130

        lds r17,cocono ;                                                                     c2577
        ldi r30,low((tacoma<<1)-8) ;table command mask fea5/fead
        ldi r31,high((tacoma<<1)-8)
        add r30,r17
        adc r31,r06    ;#$00 adds carry
        lpm r19,z      ;                                                                     c25a
  
        mov r25,r19    ;-- (mask) 
        call l13130
  
        and r16,r19    ;                                                                     c25a
        brne l17430    ;b.i.there is anything illegal in inputstring                         c25d

        ret            ;                                                                     c25f

l17430: sts floker,r16 ;sets flag ok / error to error-blink     errorflag  026c at 1541      c260 
        rjmp l19630    ;30 syntax error                                                 c263-c265

                       ;--bit7: 0=no joker in front of =
                       ;        1= joker in front of = 
                       ;--bit6: 0=no , in front of =
                       ;        1= , in front of = 
                       ;--bit5: always 1??
                       ;--bit4: always 0??
                       ;--bit3: 0=no joker behind =
                       ;        1= joker behind = 
                       ;--bit2: 0=no , behind =
                       ;        1= , behind = 
                       ;--bit1: 0=no = in inputstring 
                       ;        1= = in inputstring
                       ;--bit0: 0= = in inputstring
                       ;        1= no = in inputstring
;------------------------------------------------------------------------------------------------
l17440:                ;from l17170, l19560  
                       ;initialize command/filename-tables/values                            c2b3
        lds r28,incove ;Y-vector = writevector  inputcommandvector $a3 at1541                c2b3
                       ;is set at receive bytes after Talk
                       ;shows to end+1 of command/filename
        ldi r29,high(inbube) ;=$a4 at 1541
 
        mov r25,r28    ;xx--
        call l13130
      
        cpi r28,$02    ;
        brcs l17450    ;b.i.length of CF is 0 or 1 bytes                                c2b5/c2b8

        dec r28        ;=length of CF > 1 (2-42)                                             c2b7

        ld r16,y       ;loads last character of command                                      c2ba
        cpi r16,$0d    ;                                                                     c2bd
        breq l17450    ;b.i.last character is carriage return                                c2bf

        dec r28        ;perhaps: last character is a $0a=line-feed?????                      c2c1

        ld r16,y       ;loads second-last character of command                               c2c2
        cpi r16,$0d    ;                                                                     c2c5
        breq l17450    ;b.i.second-last character is carriage return                         c2c7
 
        inc r28        ;this routine probably deletes the end-carriage-return or             c2c9
        inc r28        ;   the end-carriage-return&line-feed                                 c2ca
                       ;deletes this also at filename => perhaps wrong if open rel-file
                       ;is with length of 13 ($0d)???????

l17450: sts incoen,r28 ;stores lowbyte input command end (+1)  = $0274 at 1541               c2cb
                       ;still look whether it's the correct place here!!!!!!!!!!!!!!
       
        mov r25,r28    ;xx--
        call l13130

        cpi r28,low(inbuen) ;#$2a length of inputbuffer                                      c2ce     
        brcs l17460    ;b.i.length of command/filename is ok                                 c2d2

        ;sts cocono,r07 ;clears command commandnumber  =022a at 1541                         c2d4 
        ldi r16,$20    ;32,syntax error 32--
        jmp l13980    ;syntax error into errorbuffer 
                      
                      ;from l20910...............................................................                      
l17460: ldi r28,$00   ;Y shows to begin of inputbuffer (important at l17170)                 c2df
                      ;r29 still shows to begin of inputbuffer 
        ldi r30,low(cfmebe) ;command/filename memory begin                                   c2df
        ldi r31,high(cfmebe)

l17470: st z+,r06      ;#$00 clears command/filename memory
                       ;still test whether correct memories are cleared
        cpi r30,low(cfmeen) ;command/filename memory end (+1)              
        brne l17470    ;first clears complete values with #$00
                       ;.......................
                       ;then clears cfstcl-highestbyte with #$ff
        ldi r30,low(cfstcl)+$0f ;command/filename startcluster highest of file  
      
l17480: st z+,r07      ;#$ff clears startcluster highest = flag that this 
                       ;filestringentry isn't found so far
                       ;FAT32 is not 32 but 28 bit
                       ;=> startcluster highest is 00-0f possible only
                       ;=> 10-ff is impossible => can be used for flag for 
                       ;so far not found
        cpi r30,low(cfstcl)+$0f+$05
        brne l17480    ;                                                                     c30f 
        ldi r30,$00    ;Z shows to first inputpartfilename (important at da8b l20910?)
        ret            ;                                                                     c311
                       ;at end:
                       ; 1541-A = #$00 (!! r16 isn't #$00 !!)  (perhaps not important?)
                       ; 1541-X = r30 = #$00 (important at da8b l20910?)  e7,x
                       ; 1542-Y = r28 = #$00 (important at l17170)  $0200,y
                       ;Y-reg r28/29 shows to begin inputbuffer
                       ;Z-reg r30/31 shows to begin of open-tables
;------------------------------------------------------------------------------------------------
l17490:                ;                                      take filetype from inputbuffer c398
        ldi r29,high(inbube) ;input buffer begin  (a3),y at 1541
        ldi r31,high(cfmebe) ;command/filename memory begin  (1541 doesn't change X!!)
        
        ldi r18,$00    ; Y at 1541                            take filetype from inputbuffer c398
        lds r16,cm0277 ;old amount of commas/filenames  amount of parts in front of '='      c39a 
        lds r19,opamco ;open amount of commas (=0278 at 1541)
        cp r16,r19     ;                                                                     c39d       
        breq l17510    ;b.i.amount of inputparts in front of '=' is same to                  c3a0
                       ;    amount of total inputparts  
                       ;   (=> nothing behind '='   => no filetype set in inputstring
        
                       ;= the filetype is set in the inputstring
        dec r19        ;decrements amount of inputparts                                      c3a2                                              
        sts opamco,r19 ;necessary?
        mov r30,r19    ;                                                                     c3a5
        ldd r28,z+low(cfpobc) ;command/filename position of begin/commands = 027a,x at1541   c3a8
                       ;Y r28/29 shows now to last part of inutstring (=filetype) s:abc*=p 
        ld r16,y       ;loads filetype from inputbuffer                                      c3ac
        ldi r30,low((optats<<1)+$0f) ;open table type: Del Seq Prg Usr reL 
        ldi r31,high((optats<<1)+$0f) ;(Cbm=dir Image=diskimage)    
        ldi r18,$0f    ;                                                                     c3ae

l17500: lpm r19,z      ;loads char from ROM-table                                            c3b0
        cp r16,r19     ;                                                                     c3b0
        breq l17510    ;b.i.filetype found                                                   c3b3

        ld r19,-z      ;just to decrement Z in 16bit (not 8bit)                              c3b5  
        dec r18        ;                                                                     c3b5
        brne l17500    ;b.i.table not yet serached to end                                    c3b6
        
l17510: mov r16,r18    ;necessary???                                                         c3b8
        tst r16        ;necessary???                                                         c3b8
        sts opfity,r16 ;open-file-type  0296 at 1541 0=not set 1-e=filetype                  c3b9
        ret            ;                                                                     c3bc
;------------------------------------------------------------------------------------------------
l17520: cpi r16,$30    ;                        test whether a contains a legal drivenumber  d3bd
        breq l17530    ;b.i.'0'
        
        cpi r16,$31 
        breq l17530    ;b.i.'1'

                       ;=illegal drivenumber (not 0, not 1)
        ori r16,$80    ;sets bit 7 as flag for illegal drivenumber                           c3c5

l17530: andi r16,$81   ;masks off unused bits ??
        ret          
;------------------------------------------------------------------------------------------------
                       ;from l16880
l17540:                ;                              searches end of actual filename and    c6a6
                       ;                                computes length of actual filename
                       ;                      !! Y (r28,29) must show to begin of inputname!!
        ldi r19,$00    ;#$00 clears length of actual filename                                c6a6 
                       
        mov r17,r28    ;r17 contains vector to begin of actual filename in inputstring      

l17550: ld r16,y       ;1541 is x-vectored but r28,29 of AVR is about X-reg                  c6ad
        cpi r16,$2c
        breq l17560    ;b.i.comma

        cpi r16,$3d
        breq l17560    ;b.i.'='

        inc r19        ;increments length of filename                                        c6b8
        inc r28        ;increments vector to next char of inputpartname                      c6bb
      
        cpi r19,$10    ;compares length of file                                              c6be
        brcc l17560    ;b.i.length of file >=16 

        lds r16,incoen ;inputcommand end =0274 at 1541
        cp r28,r16     ;compares vector and end of inputstring
        brcs l17550    ;b.i.end of inputstring not reached 

l17560: sts cm024b,r19 ;length of actual filename 
                       ;perhaps necessary for $c677
        sts cm0276,r28 ;endvecor (+1) of actual filename                                          c6c8
                       ;r17 still contains vector to begin of actual filename
        mov r28,r17    ;restore vector to begin of filename                                  c6cc
        ret  
;------------------------------------------------------------------------------------------------
l17570: jmp l13080     ;prints debugbyte and debugbyte-high into buffer      
;------------------------------------------------------------------------------------------------
l17580:                ;                                    create header-line of directory  c7b7
                       ;1541:
                       ;- reads BAM (if neccessary)
                       ;   uses channel13 $0d (if drive0)
                       ;   uses buffer of channel $0d (opens it if neccessary)
                       ;- clears dir-buffer
                       ;- copies the first dirline (header-dirline) into dirbuffer 02b0-02d4
                       ;   the dirbuffer is later copied at 
                       ;    daa7 jsr ec9e 
                       ;             ecd9 jsr ed59
                       ;   into the actual buffer
                       ; the routine at ec9e fills one complete buffer (256bytes) with dirlines
                       ;  before it goes to the talk-routine and sends it to the C64
;------------------------------------------------------------------------------------------------
                       ;from l17240
l17590:                ;                                                             scratch c823
        rcall l17570   ;20-- 's'--              
                       ;the 1541 activated SA$11 at c830 jsr $c49d
                       ;still test where this is at nlq-hd better (here or l17610 rcall l17570) 

        rcall l17490   ;take filetype from inputbuffer
        cpi r16,$05 
        brcs l17610    ;b.i.0-4 del/not-set, seq, prg, usr, rel 
        
        cpi r16,$0e
        breq l17610    ;b.i.$0e FOReign
        
        ldi r16,$40    ;64,file type mismatch error 64--
l17600: jmp l13980     ;print message + LED-blink + main waiting loop

l17610: rcall l16550   ;take drivenumbers from inputbuffer                                   c826
        rcall l16640   ;initialize drive & switch on LED                                     c829
        sts cm0086,r06 ;clears CBM-memory 0086; at scratch: counter for deleted files        c82e

        ldi r25,$21    ;21--'s'
        rcall l17570   ;prints debugbyte and debugbyte-high into buffer    

                       ;c830 jsr c49d read first direntry
                       ;         c4a2 jsr c5ac
                       ;                  c5c1 jsr d475
                       ;                           d47a lda#$11 SA for internal read
                       ;                                sta $83  
        sts erbufl,r07 ;#$ff makes flags (bit7&6) that:
                       ; %11=SA$0f-buffer contains internal-read/write-buffer at CBM-buffer
                       ;important that the SA$0f-scratchbuffer is reloaded from swapfile
                       ; (and not cleared) after a direntry is loaded.
                       ; change this from SA$0f-buffer to SA$11-buffer !!!!!!!!!!!!

        rcall l16770   ;begin of find to-input-filenames matching dir-filename               c830
                       ;  loads as long entries from HD until it finds a matching one
                       ;jsr c49d 
                       ;    c4a2 jsr c5ac reads 1 used direntry (doesn't compare names)
                       ;    c4ba jsr c4d8 compares inputfilenames and direntryfilename
                       ;                  if filename matches then stores values to table
                       ;                   (e.g.e2,x  0280,x  0285,x)? 
                       ;at end:
                       ;opfifo flag for open filename found contains:         = $0253 at 1541        
                            ;0-5 = found and number of filename in inputbuffer
                            ;$ff = so far not found  
  
       #if partname == 1    
        #message 162-IEC-ATA-V2
        brmi l17690    ;b.i.no fitting file found

       #else
        #message 644-NLQ-HD/all
        brpl l17620    ;b.i.fitting file found

        rjmp l17690    ;=no fitting file found
       #endif

l17620: ldi r25,$22    ;22--'s'
        rcall l17570   ;prints debugbyte and debugbyte-high into buffer    

       #if partname >= 2    
        #message 644-non-IEC-ATA
        ldi r28,low(dibube) ;08e8 directory buffer begin
        ldi r29,high(dibube)
        
        ldi r30,low(nansds<<1)  ; <<1 means: shifted left one bit 
        ldi r31,high(nansds<<1) ;initialize Z pointer      
        
l17630: ld r16,y+      ;loads actual dirname
        lpm r17,z+     ;loads NLQ-SWAP.SYS
        cp r16,r17
        brne l17640    ;b.i.dirname isn't NLQ-SWAP.SYS...
 
        cpi r28,low(dibube)+$0c ;it's impossible to make 1 routine for scratch and rename
        brne l17630    ; because at rename the filename of the to rename direntry isn't        
                       ; in dibube at end of search 

        ld r16,y       ;char behind diskname
        cpi r16,$a0
        breq l17680    ;b.i.shift-space  b.i.filename is nlq-swap.sys (not nlq-swap.sysx)
       #endif

l17640: call l21910   ;tests whether found file is actually opened                                   c835
                       ;!!! this can change the HD-buffer
                       ;   => after this it's possible that the HD-buffer     
                       ;      doesn't contain the dirsector

        brcc l17680    ;b.i.matching file is actually also opened -> no scratch              c838    
       
        lds r16,difity ;directory file type                                                  c83c
                       ; is set at l15660 read next direntry of actual directory
        bst r16,6      ;scratch-protect bit -> T-flag                                        c83e
        brtc l17650    ;b.i. not scratch protected        

        lds r17,inbube+1 ;char behind 's'        =scratch protected     
        cpi r17,$50    ;'sp' 'Scratch Protected files also'
        brne l17680    ;b.i.not 'sp'-command                                                 c840
    
l17650: andi r16,$0f   ;masks bits for filetype
        cpi r16,$05 
        brcs l17660    ;b.i.0-4 del/not-set, seq, prg, usr, rel 
        
        cpi r16,$0e
        brne l17680    ;b.i.not $0e FOReign
        
l17660: ldi r25,$23    ;23--'s'
        rcall l17570   ;prints debugbyte and debugbyte-high into buffer    

        rcall l17730   ;clears all sub-direntries of matching direntry                       c842
                       ;!! it's possible that the HD-buffer doesn't contain the dirsector       

                       ;at NLQ-HD there are no side sectors
     
        ldi r31,high(cfmebe) ;$ff = so far not found  
/*
        lds r30,opfifo ;flag for open filename found  = $0253 at 1541                        c855
                       ;0-5 = found and number of filename in inputbuffer


        ldd r16,z+low(cffljo) ; command/filename flag for joker = e7,x at 1541               c85a 
                       ;          of matching file
        andi r16,$20   ;masks bit 5 = not-correctly-close-bit (former inverted bit7)         c858 
        brne l17670    ;b.i.file isn't correctly closed                                      c85c
                       ;     => the FAT-link could show to a cluster that was allocated
                       ;         but perhaps not written to the HD. So the next program
                       ;         could allocate this cluster a second time
                       ;         => this cluster could be allocated by a different file as 
                       ;            the one which is to be deleted
                       ;            => don't free this cluster

                       ;this flag is set only at SEQ, PRQ, USR filetypes 
                       ; but it's also possible that different files are written wrongly to HD
                       ; => don't scratch perhaps always if filelength = $00000000 bytes?????????
*/
        
        lds r30,opfifo ;flag for open filename found  = $0253 at 1541                        c855
                       ;0-5 = found and number of filename in inputbuffer
        ori r30,$20    ;the maximal displacement for the std-command is $3f
                       ;=> the displacement for the last two tables would be too big
                       ;=> one must add #$20 to the Z-register => the displacement is #$20 bytes
                       ;    smaller => access to this table is possible 
                      
                       ;don't scratch if filelength = $00000000 bytes
                       ;at all files (also FOR)
   
        ldd r16,z+low(cffile)-$20 ;command/filename filelength      
        ldd r17,z+low(cffile)-$20+$05 
        or r16,r17
        ldd r17,z+low(cffile)-$20+$0a 
        or r16,r17
        ldd r17,z+low(cffile)-$20+$0f ;command/filename filelength      
        or r16,r17
        breq l17670    ;b.i.filelength=00000000 

        ldi r25,$24    ;24--'s'
        rcall l17570   ;prints debugbyte and debugbyte-high into buffer    
        
        ;ori r30,$20    ;the maximal displacement for the std-command is $3f
                       ;already made before
                       ;=> the displacement for the last two tables would be too big
                       ;=> one must add #$20 to the Z-register => the displacement is #$20 bytes
                       ;    smaller => access to this table is possible 

        ldd r12,z+low(cfstcl)-$20 ;command/filename startcluster of file  0280,x/0285,x c85e/c863
        ldd r13,z+low(cfstcl)-$20+$05 ;startcluster high
        ldd r14,z+low(cfstcl)-$20+$0a ;startcluster higher           
        ldd r15,z+low(cfstcl)-$20+$0f ;startcluster highest                             c85e/c863

        sts geaccl,r12 ;general actual cluster low                = $80/81 at 1541      c861/c866
        sts geaccl+1,r13 ;general actual cluster high
        sts geaccl+2,r14 ;general actual cluster higher
        sts geaccl+3,r15 ;general actual cluster highest                                c861/c866

        mov r16,r12    ;at FAT32: there are files with filelength 0
        or r16,r13     ;these files have no cluster 
        or r16,r14     ;=> the startclusterentry in dir is 00000000 
        or r16,r15
        breq l17670    ;b.i.startcluster of file in direntry =$00000000
                       ;or is this already made anywhere?????

        rcall l17700   ;clears all FAT-entries of file (in accl-general ($80/81))            c868 

l17670: lds r19,cm0086 ;CBM-memory 0086 at scratch: counter for deleted files                c86b
        inc r19
        breq l17680    ;b.i.already 255 files scratches

        sts cm0086,r19 ;increments CBM-memory 0086 at scratch: counter for deleted files     c86b
        
l17680: rcall l16750   ;continue of find to-input-filename matching dir-filename             c86d

       #if partname == 1    
        #message 162-IEC-ATA-V2
        brpl l17620    ;b.i.matching file found                                              c870
    
       #else
        #message 644-NLQ-HD/all
        brmi l17690    ;b.i.no matching file found  

        rjmp l17620    ;=matching file found                                                 c870
       #endif

l17690: call l14610    ;writes back actual FAT-buffer if it's changed
                       ;necessary because this isn't made at freeing clusters  
        call l22120   ;writes first free cluster and free clusters driveX to FSInfo-block
        lds r16,cm0086 ;CBM-memory 0086 at scratch: counter for deleted files                c872
        sts geactr,r16 ;general actual track                                  = $80 at 1541  c874
        ldi r16,$01    ;error-number                                                         c876
        ldi r18,$00    ;sectornumber                                                         c878  

        sts acsacb,r07 ;clears actual SA in CBM-buffer
                       ;important at end of every command (exeption: m-r and result is in
                       ; swapbuffer) to avoid that this unused SA-buffer is backuped??
  
        ldi r25,$25    ;25--'s'
        rcall l17570   ;prints debugbyte and debugbyte-high into buffer    
       
        rjmp l17270    ;end of command                                                       c87a
;------------------------------------------------------------------------------------------------
                       ;from l17660     
l17700:                ;          clears all FAT-entries of file (in accl-general ($80/81))  c87d 
        lds r12,geaccl ;general actual cluster
        lds r13,geaccl+1
        lds r14,geaccl+2 
        lds r15,geaccl+3
        rjmp l17720    ;test first whether the cluster isn't an endcluster-----
                
l17710: call l21950   ;free general actual cluster in FATs (first cluster of file)          c87d
                       ;r12-15 = (former) follow-cluster of geaccl
                       
                       ;open internal read-channel?
                       ;if there is no buffer to this internal read-channel then ?

        sts geaccl,r12 ;general actual cluster low                = $80/81 at 1541      c89c/c8a1
        sts geaccl+1,r13 ;general actual cluster high       makes follow-cluster ->
        sts geaccl+2,r14 ;general actual cluster higher      to actual cluster  
        sts geaccl+3,r15 ;general actual cluster highest                                c89c/c8a1

l17720: call l14450    ;checks whether cluster (r12-r15) is illegal / end- / notend-cluster  c8a3
                       ;equal = it was an endblock   notequal = there is a followblock
                       ;endcluster=0fffffff
        brne l17710    ;b.i.the actually cleared cluster has a follow-cluster                                          c8a5
   
                       ;= the actually cleared cluster was an endcluster 
                       ;write FAT (is so far written at each single block free
                       ;free internal read channel              
        ret            ;                                                                     c8b3
;------------------------------------------------------------------------------------------------
                       ;from l17610
l17730:                ;                           clears all part-direntries of 1 direntry  c8b6
                       ;it's possible that the HD-buffer doesn't contain the dirsector
        rcall l17050   ;reads actual dirsector again and sets pointer                   c604-c614 
                       ;copies values of dirsector to ac..as (06/07 - 0e/0f)
                       ; ($80/81 would perhaps be better?) 
                       ;r26 shows to first dir-partentry (!! r27 doesn't)
             
         
        lds r27,ashbsc ;%.......0/%.......1 actual SA HD-buffer sector in this cluster
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        andi r27,$01   ;             00 / 01  masks bit for first/second half of HD-buffer 
        subi r27,$100-high(hdbube) ;-fa  -fa  X-high shows to correct half of HD-buffer (#$06/07)
                                   ;  6    7
l17740: ldi r16,$e5    ;flag for empty direntry
        st x,r16       ;writes into dirsector 0600 0620 07e0                                 c8b9
        
        ori r26,$1f     ;                      061f 063f 07ff
        ld r16,x+      ;just to increment X 16bit (not 8bit) 

        lds r16,opudel ;open used dir entry length 
                       ;=amount of dirpartentries of actual complete direntry
                       ;complete direntry consists of (0-2)
        
        cpi r27,high(hdbuen) ;HD-buffer end ($0800)
        brcs l17750    ;b.i.still space for next direntry in actual dirsector

                       ;=no space for next direntry in actual dirsector
                       ;=write this direntry to HD and read follow dirsector

        call l14590    ;writes last read sector back to HD using acsehb                      c8bb
                       ; actual sector in HD-buffer (in lba)        

        call l14760   ;read follow-512-HD-sector of actual SA HD-buffer cluster

        ldi r26,low(hdbube) ;HD-buffer begin
        ldi r27,high(hdbube)

        lds r16,opudel ;open used dir entry length 
                       ;=amount of dirpartentries of actual complete direntry
                       ;complete direntry consists of (0-2)
        cpi r16,$00    
        brne l17750    ;b.i.not last dir-partentry is written

                       ;=last dir-partentry is written and dirsector is written to HD here
                       ;  => it's not necessary to write it a second time to disk again
        ldi r16,$ff    ;flag that dirsector needn't be written to HD again
                       ;  (is decremented to $fe)

l17750: dec r16        ;decrements amount of dirpartentries of actual complete direntry
        sts opudel,r16
        brpl l17740    ;b.i.there are still dir-partentries to free            

        cpi r16,$ff    ;=flag for write 
        brne l17760    ;b.i.last dir-sector is already written to disk

        call l14590    ;writes last read sector back to HD using acsehb                      c8bb
                       ; actual sector in HD-buffer (in lba)        
l17760: ret            ;                                                                   (c8be) 
;------------------------------------------------------------------------------------------------
l17770: lds r16,inbube+1 ;second char of inputbuffer                      c-commands copy cd c8f0  
        cpi r16,$44    ;'d'
        breq l17780    ;b.i.'cd'
        
        ldi r17,$88    ;88-- 136--
        jmp syserr  

l17780: ldi r16,$11    ;command number for cd                                 cd change directory
        sts cocono,r16 ;command commandnumber                               = 022a at 1541

        ldi r16,$11    ;internal read-address
        call l14190    ;save old CBM-buffer to swapfile and load new CBM-buffer from swapfile
 
        ldi r16,$04    ;read from HD into AVR-HD-buffer but not in CBM-buffer  
        sts ashbtr,r16 ;actual SA HD-buffer-transfer read
       
       ldi r16,$01
       sts adspch,r16  ;additional special chars
                       ;00 = no additional special chars   (for WTE)
                       ;01 = '/' has same meaning as ':' (CD-command (for WTE)

        lds r16,inbube+2 ;third char of inputstring
        cpi r16,$5f    ; '<-'  cd<- without ':' is legal (and cd:<-)
        breq l17870    ;b.i.cd<-

        cpi r16,$2f    ;'/'    --------demand of WTE: support cd// and '/' instead of ':'--------
        brne l17790    ;b.i.not 'cd/'
        
        lds r16,inbube+3 ;fourth char of inputstring
        cpi r16,$2f    ;'/'
        brne l17790    ;b.i.not 'cd//'
        
        lds r19,incoen ;inputcommand end+1   
        cpi r19,$04
        brne l17820    ;b.i.command is longer than 'cd//'
        
        rcall l17940   ;set actual dir = rootdir                   cd//
        rjmp l17260    ;end of command--------
        
l17790: ldi r17,$2f    ;'/'
        rcall l17330   ;search '/' in inputname (instead of ':')

        breq l17800    ;b.i.colon ':' not found   

        rcall l17360   ;analyse command (rest of routine, after ':' has been found)
        rjmp l17810    ;       --------demand of WTE: support cd// and '/' instead of ':'--------   

l17800: rcall l17340   ;analyse command (cd)

l17810: lds r16,opamco ;open amount of commas  = $0278 at 1541
        cpi r16,$01
        breq l17830    ;b.i.exactly 1 filename behind CD:

l17820: rjmp l17350    ;34, syntax error       

l17830: lds r28,cfpobc ;command/filename position of begin/commas            = 027a at1541         
                       ; = position in front of :
        subi r28,$fe   ;add r28,$02 = position behind :
        ldi r29,high(inbube)

        ld r16,y       ;loads first char of filename behind 'cd:'
        cpi r16,$5f
        breq l17870    ;b.i.'cd:<-'

        rcall l16550   ;take drivenumbers from inputbuffer ???
        rcall l16640   ;initialize drive & switch on LED  ???
      
        rcall l16770   ;begin of find to-input-filenames matching dir-filename  
                       ;  loads as long entries from HD until it finds a matching one
                       ;at end:
                       ;opfifo flag for open filename found contains:         = $0253 at 1541        
                            ;0-5 = found and number of filename in inputbuffer
                            ;$ff = so far not found  
        rjmp l17850    ;----

l17840: rcall l16750   ;continue of find to-input-filename matching dir-filename 

l17850: brmi l17880    ;b.i.fitting file not found = end of dir reached without finding partition
 
        lds r16,difity ;directory file type                    
                       ; is set at l15660 read next direntry of actual directory
        andi r16,$0f   ;masks bits for filetype
        cpi r16,$06
        breq l17860    ;b.i.06 directory

        cpi r16,$08
        brcs l17840    ;b.i.01-05,07

        cpi r16,$0c
        brcc l17840    ;b.i.0c-0f
                       
                       ;=emulation-partitions
                
l17860: ldi r30,low(cfmebe)+$20 ;command/filename memory begin (necessary because of +$20)
        ldi r31,high(cfmebe) ; ?necessary??
        
        ldd r12,z+low(cfstcl)-$20 ;command/filename startcluster of file 
        ldd r13,z+low(cfstcl)-$20+$05 ;startcluster high
        ldd r14,z+low(cfstcl)-$20+$0a ;startcluster higher           
        ldd r15,z+low(cfstcl)-$20+$0f ;startcluster highest              

        rjmp l17930    ;------------------------------------------------------------------------- 

l17870: rcall l17900   ;search dotdot-entry...                         cd<-  change to parent dir 
        breq l17890    ;b.i.dotdot-entry found
       
l17880: ldi r16,$4d     ;77,selected partition illegal 77--
        jmp l13980      ;print message + LED-blink + main waiting loop---------------------------

l17890: sts acsacb,r07 ;clears actual SA in CBM-buffer
                       ;important at end of every command (exeption: m-r and result is in
                       ; swapbuffer) to avoid that this unused SA-buffer is backuped??
       
        rjmp l17260    ;end of command
;------------------------------------------------------------------------------------------------
                       ;from l17870 (cd:<-), l21020 (read dirname from parent-dir)
l17900:                ;         searches dotdot-entry of actual dir and stores clusteraddress of
                       ;                              parent-dir to clusterbegin actual directory drive0
        call l15640    ;read first direntry                             
        rjmp l17920    ;of actual dir

l17910: rcall l15660   ;reads next direntry
                       ;Y shows to first byte of actual read HD-dir-entry (=short filename-entry)
l17920: 
;/*       
        lds r25,ashbve  ;xx-- ashbve ?1f 3f  .. ff?
        call l13130
.db 0       
;*/    
        brne l17960    ;b.i.end of dir reached without finding dot dotdot-entry (notequal)
        cpi r16,$cd    ;dot-, dotdot-entry
        brne l17910    ;b.i.not dot-, dotdot-entry
             
                       ;=dot-, or dotdot-entry   
        inc r28        ;makes readvector from first to second char of shortname
        ld r16,y       ;loads second char of fileshortname
        cpi r16,$2e    ;'.'
        brne l17910    ;b.i.not '..' dotdot
        
l17930: mov r16,r12
        or r16,r13
        or r16,r14
        or r16,r15
        brne l17950    ;b.i.clusteraddress of upper dir not 00000000    b.i.not rootdir
                       ;     (00000000 = flag for rootdir)  
         
                       ;=rootdir
                       ;from l17780 
l17940: ldi r16,$02
        mov r12,r16    ;clusterbegin partition root-directory 
        clr r13
        clr r14
        clr r15

l17950: 
       #if partname == 1    
        #message 162-IEC-ATA-V2
        sts cbadd0,r12 ;clusterbegin actual directory drive0 low              
        sts cbadd0+1,r13 ;clusterbegin actual directory drive0 high
        sts cbadd0+2,r14 ;clusterbegin actual directory drive0 higher
        sts cbadd0+3,r15 ;clusterbegin actual directory drive0 highest        

       #else
        #message 644-non-IEC-ATA
        push r26
        push r27

        ldi r26,low(cbadd0)
        ldi r27,high(cbadd0) ;              $10c8                
        lds r25,acemen ;actual emulated entry $00,  $01,  $02
        swap r25       ;                      $00,  $10,  $20    
        or r26,r25     ;                    $10c8,$10d8,$10e8

        st x+,r12      ;clusterbegin actual directory of actual deviceemulation
        st x+,r13
        st x+,r14
        st x,r15

        pop r27
        pop r26
       #endif 

        ldi r25,$8d    ;8d-- xx-- xx-- xx-- xx-- xx--
        call l13060    ;new clusteraddress of selected parent-dir

        sez            ;equal

l17960: ret            ;equal=dotdot-entry found    notequal=dotdot-entry not found     
;------------------------------------------------------------------------------------------------
       #if partname >= 2    
        #message 644-non-IEC-ATA
                       ;                        test whether there is a SD card in the drive d00e  
                       ;                        and read header-ID 
                       ;from l17100
l17970:
                       ;take a buffer to the BAM
     
       #if partname == 3
        #message 644-NLQ-HD/SD2IEC
        in r20,pisdcd  ;AVR-pin SD-CardDetect
        andi r20,1<<bisdcd ;bit AVR-SD-CardDetect
       #endif

       #if partname == 6
        #message 644-NLQ-HD/SD
        in r20,pisdcd  ;AVR-pin SD-CardDetect
        andi r20,1<<bisdcd ;bit AVR-SD-CardDetect
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
        lds r16,acemen ;actual emulated entry 0,1,2
        cpi r16,$00
        breq l17980    ;b.i.HD
        
        call l23810    ;reads I2C-parallel-port to r20
        andi r20,1<<bisdcd ;bit AVR-SD-CardDetect
       #endif

                       ;still make header ID

        ldi r16,$03    ;error-response (sync not found) = no SD inserted
        brne l17990    ;b.i.no SD inserted           

l17980: ldi r16,$01    ;ok-response

l17990: ret
       #endif
;------------------------------------------------------------------------------------------------
                       ;from l17240
l18000:                ;                                                             rename  ca88
        ldi r25,$20
        call l17570    ;20-- 'r'--              

       #if partname >= 2    
        #message 644-non-IEC-ATA
        lds r28,cfpobc+1 ;command/filename position of begin/commas of inputname behind '='
        ldi r29,high(inbube);                                            = 027a,x at1541  
        
        ldi r30,low(nansds<<1)  ; <<1 means: shifted left one bit 
        ldi r31,high(nansds<<1) ;initialize Z pointer      
        
l18010: ld r16,y+      ;load char of second inputname (at rename jokers aren't allowed) 
        lpm r17,z+     ;load NLQ-SWAP.SYS
        cp r16,r17
        brne l18020    ;b.i.dirname isn't NLQ-SWAP.SYS
 
        cpi r30,low((nansds<<1)+$0c) ;it's impossible to make 1 routine for scratch and rename
        brne l18010    ; because at rename the filename of the to rename direntry isn't        
                       ; in dibube at end of search 
        lds r16,cfpoco+1 ;command/filename position of end/commas of inputname behind '='
                       ;                                                 = 027b,x at1541  
        cp r16,r28 
        brne l18020    ;b.i.inputname behind '=' is longer than NLQ-SWAP.SYS    
        
        ldi r16,$30    ;48,illegal job,00,00
        rjmp l17600
       #endif

l18020: rcall l16550   ;take drivenumbers from inputbuffer                                   ca88
                       ;standard-drive??? not understood
        
        rcall l16700   ;search all files of inputbuffer in dir                               ca99
                       ;X r26/27 begin of dibube directory buffer begin
                       ;Y r28/92 begin of HD-dir-entry (short filename-entry?)
                       ;Z r30/31 a Flash-table for a compare-operation
                       ;not shure whether this is correct when at end of dir  
        ldi r25,$2a 
        call l17570    ;2a-- 'r'--          
    
        rcall l18110   ;test whether all files behind '=' exist in dir and                   ca9c
                       ; all files in front of '=' don't exist in dir
                       ; sets cm024a open actual filetype (important for rcall l19980)
                       ;1541: use drivenumber of first name behind '=' as actual drive  
        ldi r25,$2b 
        call l17570    ;2b-- 'r'--          

        rcall l19980   ;create and compare shortname of first inputbuffername
                       ;search three free direntries in a chain
                       ;CBM & DIR: 3 free direntries in a chain
                       ;FOR: 1 free direntry  
        ldi r25,$2c 
        call l17570    ;2c-- 'r'--          

        lds r16,natac0 ;name-tail-counter0 (set at rcall l19980)
                       ;value of the new wanted inputbuffername (not the old of diskname)
        bst r16,5      ;copies flag for real-short-name / part of long-name to t-flag
                       ;must be same command as at l19140          
        brtc l18030    ;b.i.FOReign-file = real short-name (write 1 direntry only)

        lds r16,cfdile+1 ;cmd/flnm length of direntry of inputfilename behind '='  (d8,x/dd,x)
                       ;       0= length = 1 entry (1 shortentry)
                       ;       1= length = 2 entries (1 shortentry + 1 longentry)
                       ;       2= length = 3 entries (1 shortentry + 2 longentries)      
                       ;amount of dir-partentries
        cpi r16,$02
        brne l18040    ;b.i.old direntry consists of less than of 3 partentries

l18030:                ;new direntry fits into old direntry (same amount of partentries) 
                       ;CBM & DIR: old direntry has 3 partentries 
                       ;FOR: old direntry has 1 partentry (or more, but LFN-partentries are
                       ;      unchanged -> LFN-partentries become orphan-partentries) 
        lds r10,cfdive+1 ;cmd/flnm vector of direntry of inputname behind '='      dd,x
                       ;$00, $20, $40, $60, $80, $a0, $c0, $e0
        lds r11,cfdisc+1 ;command/filename sector in this cluster of direntry of   d8,x
                       ;          inputname behind '='
        lds r12,cfdicl+1 ;cmd/flnm cluster of direntry of inputname behind '='     d8,x
                       ; shows to first (of three) partentries
        lds r13,cfdicl+$05+1 
        lds r14,cfdicl+$0a+1 
        lds r15,cfdicl+$0f+1 

        sts ofdeve,r10 ;=position where new direntry is made
        sts ofdesc,r11
        sts ofdecl,r12
        sts ofdecl+1,r13
        sts ofdecl+2,r14
        sts ofdecl+3,r15

        ldi r16,$80    ;flag for rename and same direntry
        rjmp l18070          
                   
l18040:                ;=old direntry consists of 1 or 2 partentries
                       ;  but new direntry is always 3 partentries
                       ;=> write it at position of first three free direntries in a row
        ldi r25,$2d 
        call l17570    ;2d-- 'r'--          

        rcall l19180   ;create dir-entry (part1 search or make 3 free direntries)
                       ;ofdeve, ofdesc & ofdecl show now to first of 3 free direntries
                       ;!! these values mustn't be changed until l18070!!

        lds r11,cfdisc+1 ;command/filename sector in this cluster of direntry of   d8,x
                       ;          inputname behind '='
        lds r12,cfdicl+1 ;cmd/flnm cluster of direntry of inputname behind '='     d8,x
                       ; shows to first (of three) partentries
        lds r13,cfdicl+$05+1 
        lds r14,cfdicl+$0a+1 
        lds r15,cfdicl+$0f+1 

        call l14830   ;read sector-r11 of cluster (r12-r15) and store values as ashbcl ashbsc
                      ;load first dirpartentry of old inputfilename (behind '=')

        lds r26,cfdive+1 ;cmd/flnm vector of direntry of inputname behind '='      dd,x
                       ;$00, $20, $40, $60, $80, $a0, $c0, $e0
                       ; (must this be stored to ashbve actual SA HD-buffer vector??)  
                    
        lds r27,ashbsc ;%.......0/%.......1 actual SA HD-buffer sector in this cluster
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        andi r27,$01   ;             00 / 01  masks bit for first/second half of HD-buffer 
        subi r27,$100-high(hdbube) ;-fa  -fa  X-high shows to correct half of HD-buffer (#$06/07)
                                   ;  6    7
                       ;X shows to first dirpartentry of old inputname (behind '=')        

        lds r16,cfdile+1 ;cmd/flnm length of direntry of inputfilename behind '='  (d8,x/dd,x)
                       ;       0= length = 1 entry (1 shortentry)
                       ;       1= length = 2 entries (1 shortentry + 1 longentry)
                       ;       2= length = 3 entries (1 shortentry + 2 longentries)      
                       ;amount of dir-partentries
        cpi r16,$00
        breq l18050    ;b.i.old direntry consists of 1 partentry = MSDOS-entry only
                       ; (3partentries branched already at l18030)    

                       ;=cfdile+1 = #$01 = 2partentries
                       ;this is the only-partentry with longfilenames
        ldi r16,$e5
        st x,r16       ;flag that this direntry is free 
        
        rcall l19150   ;increment x by #$0020 and test whether hdbuffer is at end: 
                       ;if so then write it back to HD and read followsector and 
                       ;make X-vector to begin of HD-buffer
    
l18050: ldi r16,$e5
        st x,r16       ;flag that this direntry is free 

        ori r26,$0b    ;0600->060b 07e0->07eb begin of direntryarea behind filename
       
        ldi r28,low(tmvade) ;temporary memory values of direntry
        ldi r29,high(tmvade) ;contains unchanged values of a direntry at rename

l18060: ld r16,x+      ;copies unchanged parts of old direntry to
        st y+,r16      ; temporary memory values of direntry
        cpi r28,low(tmvade+$15)
        brne l18060    ;copies 060b-061f

        call l14590    ;write sectors with retry  actual sector HD-buffer = dir-sector  
                       ;send block-write-command to HD (write 1 sector only)
                       ;write dir-sector with allocted enty to HD
                       ; write sector-address  
        ldi r16,$c0    ;flag for rename and different direntry

l18070: 
        ldi r25,$2e    ;ofdeve, ofdesc & ofdecl show now to first of 3 free direntries
        call l17570    ;2e-- 'r'--          
     
        rcall l19240   ;create direntry part2  (r16 contains flag)

        ldi r25,$2f 
        call l17570    ;2f-- 'r'--       

        rjmp l17250    ;end of a command                                                     cac9
.db 0
;------------------------------------------------------------------------------------------------
                       ;from l18110 
l18080:                ;test whether all files behind '=' exist in dir                       cacc
        lds r16,cffljo+1 ;command/filename flag for joker & filetype         = e7,x at 1541  cacc   
                       ; load cffljo of second inputfilename                 = e8 at 1541
                       ;                =first inputfilename behind '='
                       ; bit7: 0=no joker          1=joker                  
                       ;       bit 7 is taken from inputfilename
                       ;       bit6-0 is taken every time from dirfilename    
                       ; bit6: 0=can be scratched  1=scratch-protected
                       ; bit5: 0=not closed        1=closed
                       ; bit4: unused?
                       ;bit3-0: filetype  !!!!!change to bit4-0!!!!!!!!!!!!!!!!!!!!
        andi r16,$1f   ;masks filetype                                                       cace
        sts cm024a,r16 ;open actual filetype (bit7-4 is always %0000)                        cad0
                       ;                     (change that bit7-5 is always %000)
        ldi r31,high(cfmebe) ;command/filename memory begin   neccessary???
        lds r30,opamco ;open amount of commas  = $0278 at 1541                               cad3
                       ;= amount of filenames in inputbuffer
l18090: dec r30        ;                                                                     cad6

        lds r19,cm0277 ;CBM-memory $0277 length of filename0???????????????????????????? 
                       ;           amount of filenames in front of '=' in inputbuffer???             
        cp r30,r19     ;                                                                     cad7
        brcs l18100    ;b.i.all filenames behind '=' are tested                              cada
        
        ori r30,$20    ;the maximal displacement for the std-command is $3f
                       ;=> the displacement for the last two tables would be too big
                       ;=> one must add #$20 to the Z-register => the displacement is #$20 bytes
                       ;    smaller => access to this table is possible 

        ldd r16,z+low(cfstcl)-$20+$0f ;command/filename startcluster highest                 cadc
                       ;                                    of file 0280,x/0285,x            
                       ;!! opposite value at 1541
                       ;1541: 0=not yet found
                       ;      1-$23/28= already found (and starttrack) 
                       ;AVR:  ff=not yet found
                       ;      0-0f= already found (and startcluster highest) 
        andi r30,$07   ;retore old, correct value for number of filename in inputstring
                       ;(0-4)   
        tst r16   
        brpl l18090    ;b.i.this input-filename has been found                               cadf

        rjmp l19810    ;62,file not found                                               cae1-cae3   

l18100: ret            ;                                                                     cae6  
;------------------------------------------------------------------------------------------------
                       ;from l18000
l18110:                ;                  test whether all files behind '=' exist in dir and cae7
                       ;                        all files in front of '=' don't exist in dir
        rcall l18080   ;test whether all files behind '=' exist in dir                       cae7       
                       ; sets r30,r31 to command/filename-table
                       ; sets cm024a open actual filetype

l18120: ori r30,$20    ;correct displacement for the ldd-command
        ldd r16,z+low(cfstcl)-$20+$0f ;command/filename startcluster highest                 caea
                       ;               of file in front of '='   of file 0280,x/0285,x
                       ;!! opposite value at 1541
                       ;1541: 0=not yet found
                       ;      1-$23/28= already found (and starttrack) 
                       ;AVR:  ff=not yet found
                       ;      0-0f= already found (and startcluster highest) 
        andi r30,$07   ;retores old, correct value for number of filename in inputstring
                       ;(0-4)   
        tst r16   
        brmi l18130    ;b.i.this input-filename (in front of '=') is wasn't found            caea

        rjmp l19730    ;63,file exists                                                  caef-caf1     

l18130: dec r30        ;decrements vector to previous name in inputbuffer                    caf4
        brpl l18120    ;b.i.not yet all names in front of '=' tested                         caf5 

        ret            ;                                                                     caf7
                       ;                                              end of rename-routines
;================================================================================================
                       ;from l17240
l18140:                ;                                                     memory-routines caf8
                       ;r16 = inbube+1 ;$0201  -
                       ;r17 = inbube+2 ;$0202  r
                       ;r12 = inbube+3 ;$0203  adrs low
                       ;r28,r12
                       ;r13 = inbube+4 ;$0204  adrs high
                       ;r29,r13
                       ;r14 = inbube+5 ;$0205  amount of bytes 
                       ;r15 = inbube+6 ;$0206
  
        cpi r16,$2d    ; '-'                                                                 cafb
        brne l18180    ;b.i.not 'm-' 

        cpi r17,$52    ; 'r'                                                                 cb0e
        brne l18190    ;                                                                     cb10

                       ;= m-r command
        ldi r18,$01    ;default for 1 byte to read
        lds r16,incoen ;input command end (+1)  = $0274 at 1541                              cb24
        cpi r16,$06    ;                                                                     cb27     
        brcs l18150    ;b.i.command is shorter than 6 chars                                  cb29

        mov r18,r14    ;amount of to-read bytes
        
l18150: ldi r19,$01    ;default highbyte remaining errorlength
        cpi r18,$00 
        breq l18160    ;b.i.length = $0100

        ldi r19,$00    ;= length = $0001-$00ff

l18160: sts erbufi,r18 ;error-buffer filelength (remaining) (for EOI-calculating)            cb37
        sts erbufi+1,r19 ;#$0001-$0100 

        ldi r26,low(erbube) ; error-buffer begin
        ldi r27,high(erbube)

l18170: st x+,r06      ;clears error-buffer (m-r-command reads always #$00)
        dec r18
        brne l18170
                       ;end-#$0d is made from IEC-OUT routine
        ;ldi r16,low(erbube) ;   
        ;sts erbuve,r16 ;sets error-buffer vector to first byte   
        sts erbuve,r06 ;#$00 sets error-buffer vector to first byte
        ret            ;----                                                                 cb48

l18180: rjmp l17220    ;31,syntax error  31--                                           cb4b-cb4d

l18190: cpi r17,$57    ; 'w'                                                                 cb15
        brne l18220

        cpi r28,$77
        brne l18220

        cpi r29,$00
        brne l18220

                       ;still compare whether r14 is #$02
                       ;still compare whether bit 4-0 of $0206 is ame as $0207
 
        mov r16,r15    ;
        ori r16,$40 


       #if partname == 1    
        #message 162-IEC-ATA-V2
        sts tadenu,r16 ;table device numbers HD
       #endif
     
       #if partname == 3
        #message 644-NLQ-HD/SD2IEC
         sts tadenu+2,r16 ;table device numbers SD    
       #endif

       #if (partname == 4) | (partname == 5)
         #message 644-NLQ-HD/lite
        sts tadenu,r16 ;table device numbers HD
       #endif
 
       #if partname == 6    
        #message 644-NLQ-HD/SD
        sts tadenu+2,r16 ;table device numbers SD   
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
        lds r17,acemen ;actual emulation entry
        cpi r17,$00
        brne l18200

        sts tadenu,r16 ;table device numbers HD   
        rjmp l18210

l18200: sts tadenu+2,r16 ;table device numbers SD 

l18210:
       #endif

        ret


l18220: jmp l13970     ;unsupported command system error                                     cb50
                       ;                                              end of memory-routines cb5b
;================================================================================================
l18230:                ;                                                  initialize-command d005 
                       ;jsr $c1d1 extract drivenumber from inputbuffer and switch LED on
       #if partname == 1    
        #message 162-IEC-ATA-V2
        call l10750     ;single-LED on                                                       d005

       #else
        #message 644-non-IEC-ATA
        call l10780     ;active-LED on                                                       d005
       #endif 
                
        rcall l18240    ;initialize                                                          d008
        rjmp l17250     ;end of a command + rts                                              d00b                 
;------------------------------------------------------------------------------------------------
                       ;from l17120, l25240
l18240:                ;initialize                                                        ?? d042

                       ;a C64-program could send the initialize-command while it is
                       ; executed in a subdirectory
                       ;=>the I-command mustn't reset cbaddX clusterbegin actual directory driveX

                       ;-clear track of which the BAM is in t02a1-02a3
        rcall l18880   ;free all SAs, channels, buffers of actual drive                      d045
                       ; without closing them
                       ;-allocated buffer for BAM-sector and search ( not load) BAM-sector
                       ;  = probably test whether disk is accessable???

       #if (partname == 3) | (partname == 6) 
        #message 644-NLQ-HD/SD-routines 
        ldi r25,$b0    ;b0----
        call l13090

        lds r25,acemen ;actuall emulation entry
                       ; 0=IDE-HD
                       ; 1=IDE-CDROM (not supported)
                       ; 2=SD/MMC-card
        call l13130    ;xx-- (acemen)
 
        call l26570    ;initialize SM-card      = SD
     
        ldi r16,$04    ;%....1100 read into AVR-HD-buffer but not into CBM.buffer                      
        sts ashbtr,r16 ;#$00 HD-buffer-transfer read of actual SA (0-17) 
                       ;at IEC-ATA-V2 this is made at the identify drive command
        ldi r16,$82    ;sets flag that SMC is accessable and LBA-mode (not CHS) 
        sts sdcafl,r16 ;SD-capabilities flags
        
        rjmp l18320    ;=there is no identify drive command at SD-cards
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
        ldi r25,$b0    ;b0----
        call l13090

        lds r16,acemen ;actuall emulation entry
                       ; 0=IDE-HD
                       ; 1=IDE-CDROM (not supported)
                       ; 2=SD/MMC-card
        mov r25,r16    ;xx-- (acemen)
        call l13130
      
        cpi r16,$00
        breq l18260    ;b.i.HD
        
        cpi r16,$02
        breq l18250    ;b.i.SD    

        ldi r17,$fe    ;fe-- 254--   
        jmp syserr     ;CDROM-access-error (not supported)

l18250: call l26570    ;initialize SM-card      = SD
     
        ldi r16,$04    ;%....1100 read into AVR-HD-buffer but not into CBM.buffer                      
        sts ashbtr,r16 ;#$00 HD-buffer-transfer read of actual SA (0-17) 
                       ;at IEC-ATA-V2 this is made at the identify drive command
        ldi r16,$82    ;sets flag that SMC is accessable and LBA-mode (not CHS) 
        sts sdcafl,r16 ;SD-capabilities flags
        
        rjmp l18320    ;=there is no identify drive command at SD-cards
       #endif

       #if (partname == 1) | (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/HD-routines
l18260: call l14570    ;identify drive command++++++++++++++++++
        brcc l18280    ;b.i.datas read (=ok)

                       ;=no datas read (=error)
l18270: rjmp l16660    ;74,drive not ready             
                       ;print message + LED-blink + main waiting loop

l18280: ldi r29,high(hdbube)         
     
        ldi r28,$63    ;Ylow   highbyte capabilities
        ld r21,y       ;capabilities
        andi r21,$02   ;masks LBA-bit

       #if partname == 1    
        #message 162-IEC-ATA-V2
        ldi r17,$09    ;09-- 09-- HD doesn't support LBA-mode
        brne l18290

        rjmp l18430

l18290:

       #else
        #message 644-non-IEC-ATA
        ldi r28,$02
        ld r18,y+      ;cylinders low
        sts chscyl,r18
        ld r17,y       ;cylinders high
        sts chscyh,r17
        or r18,r17       
        breq l18270    ;b.i.cylinders=#$0000 (=error)

        ldi r28,$06
        ld r18,y+      ;heads low
        cpi r18,$11
        brcc l18270    ;b.i.illegal heads ($11-$ff 17-255)
        sts chshea,r18 ;heads=0-$10 0-16 (heads=0 is tested in next command)
                       ;$10 (16) heads means head 0-$0f (0-15)          

        ld r19,y       ;heads high
        cpi r19,$00
        brne l18270    ;b.i.>255 heads
        or r19, r18
        breq l18270    ;b.i.heads=#$0000 (=error)
                       ;at extended-CHS: 256 heads are possible!!!!!!!!!!!!!
                       ;(but then LBA should be supported???)
        ldi r28,$0c
        ld r19,y+      ;sectors per track low
        sts chsspt,r19
        cpi r19,$00 
        breq l18270    ;b.i.spt = #$00 (=error)

        ld r17,y       ;sectors per track high
        cpi r17,$00
        brne l18270    ;b.i. >=256 spt = error

        ldi r16,$00    ;result low
        ldi r17,$00    ;result high
        ldi r20,$00    ;temporary register

l18300: lsr r18        ;heads = multiplicator2 
        brcc l18310    ;b.i.0-bit shifted out
        
        add r16,r19    ;adds multiplicator1-low and result
        adc r17,r20    ;adds multiplicator1-high (=temporary register) and result
        
l18310: lsl r19        ;double multiplicator1-low (=sectors per track)
        rol r20        ;double multiplicator1-high (=temporary register)
        
        cpi r18,$00
        brne l18300    ;b.i.there are still bit in multiplicator2 = continue multiplication
                       ;http://www.avr-asm-tutorial.net/avr_de/rechnen/mult8.html
        sts chsphs,r16 ;chs product heads * sectors-per-track  low
        sts chsphs+1,r17 ;chs product heads * sectors-per-track high-----------------------------
       #endif          ;of l18290

        ori r21,$80    ;sets bit that hd can be accessed  sets HD-access-flag
        sts hdcafl,r21 ;HD-capabilities flags

       #if partname >= 2    
        #message 644-non-IEC-ATA
                       ;WD1210 (210MB): $20-read-command works only when 
                       ; initialize drive parameters command was sent before 
 
                       ; if there were LBA-HDs which need the initialize drive parameters command
                       ; then these two conditional assembler-parts must be activated again

        call l14110    ;waits until drive is ready (to receive next command)   
                       ;important at Quantum 40MB: Else sector is sometimes $00 and cylindr $ffff 

        lds r18,chsspt ;CHS sectors per track
        ldi r16,idresc ;IDE register sector count  %11010...
        call l14120    ;write register
    
        lds r18,chshea ;CHS heads 01-$10 (1-16)
        dec r18        ;          00-$0f (0-15)
        ori r18,$a0    ;sets bits for master CHS    !!!!still make for slave!!!
        ldi r16,idrel3 ;IDE register LBA3  %11110...   
                       ;drive&LBA3/head register        (CHS: Head)   
        call l14120
        
        ldi r18,$91    ;command $91 initialize drive parameters
        ldi r16,idrecs ;IDE register command/status  %11111...
                       ;this command is important that 1 of 11 HDs work at all  
        call l14120    ;++++++++++++++++++++-----------------------------------------------------
       #endif          ;of l18310
       #endif          ;of l18260 

l18320: clr r12        ;LBA0 = 0    (CHS: Sector)                       --------reads MBR--------
                       ;LBA0=0 must be changed from routine 
                       ; to CHS-sector=1                      ;                                                               
        clr r13        ;LBA1 = 0    (CHS: Cylinder low)
        clr r14        ;LBA2 = 0    (CHS: Cylinder high)
        clr r15        ;LBA3 = 0    (CHS: Head
        call l14920    ;read master boot record of HD (don't test whether actual sector is
                       ; already in buffer
                       ;what happens if error???????????????

        ldi r28,$c2    ;P-type of first P-entry (1.P: 01be-01cd)
        ldi r29,high(hdbube)+$01 
            
l18330: ld r16,y       ;P-type
        andi r16,0b11101111 ; masks bit for hidden entry => AVR can use hidden FAT32 Ps

        cpi r16,$0b   
        breq l18340    ;b.i.FAT32-P with cylinder <1024

        cpi r16,$0c    
        breq l18340    ;b.i.FAT32-P with cylinder >1023

        ldi r16,$10
        add r28,r16    ;$c2->$d2  =to nextP-entry   
        cpi r28,$02
        brne l18330    ;b.i.not yet all four P-entries made
 
                       ;=MBR searched, but no FAT32-partition found
                       ;problem at SMC: possible that there is no MBR
                       ;even if file_format_grp and file_format of CSD  Card Specific Data
                       ;shows that there is a HD-like-MBR there can be at once the PBR 
                       ; (partition-boot-record) in sector 00000000
       #if (partname == 3) | (partname == 6) | (partname == 7)    
        #message nlq-hd/SD-card
        sts sbpabo+3,r07 ;#$ff  = flag, that partition-begin/-end not read from MBR
                       ;           => must be read from PBR
        rjmp l18350    ; test whether the PBR is in cluster 00000000 
       #endif


        ldi r24,$00    ;00--
        rjmp l18420    ;all four P-entries made--------------------------------------------

l18340: ori r28,$04    ;c2->c6  (01c6-c9 contain start of P in LBA)
        ld r12,y+      ;begin of partition in LBA            (in MasterBootRecord)
        sts sbpabo,r12 ;sectorbegin partition bootsector
        ld r13,y+      ;lowbyte first
        sts sbpabo+1,r13 
        ld r14,y+
        sts sbpabo+2,r14 
        ld r15,y+
        sts sbpabo+3,r15
        
        ld r20,y+      ;length of P in LBA (01ca-cd contain length of P (not end of P))
        sts sbpaf1,r20 ;overwrites temporary sectorbegin partition FAT1 (with length)
        add  r20,r12   ;without carry
        sts sbpaen,r20 ;sectorbegin partition end (+1)
        ld r20,y+      ;lowbyte first
        sts sbpaf1+1,r20
        adc r20,r13
        sts sbpaen+1,r20     
        ld r20,y+    
        sts sbpaf1+2,r20
        adc r20,r14
        sts sbpaen+2,r20     
        ld r20,y+  
        sts sbpaf1+3,r20
        adc r20,r15
        sts sbpaen+3,r20     

        call l14890   ;read bootrecord of P (r12-r15 contain address) ------
                      ;............................................
l18350: ldi r29,high(hdbube)
 
        ldi r24,$0b
        lds r16,hdbube+$0b ;read bytes per sector low
        cpi r16,$00
        brne l18370    ;b.i.not 512 ($0200) bytes per sector
 
        lds r16,hdbube+$0c ;read bytes per sector high
        cpi r16,$02
        brne l18370    ;b.i.not 512 ($0200) bytes per sector
 
        ldi r24,$10
        lds r16,hdbube+$10 ;amount of FATs
        cpi r16,$02
        brne l18370    ;b.i.not 512 ($0200) bytes per sector
 
        ldi r24,$11
        ldi r28,$11    
l18360: ld r16,y+      ;read entries in root-dir (0011-12) and FAT16-count of sectors (0013-14)
        cpi r16,$00    ;(must be #$00 at FAT32)  
        brne l18370    ;b.i.illegal value
        cpi r28,$15
        brne l18360 
 
        ldi r24,$15
        lds r16,hdbube+$15 ;read media byte
        cpi r16,$f8
        brne l18390    ;b.i.not HD
 
        ldi r24,$16
        lds r16,hdbube+$16 ;read FAT16-FATsize low
        cpi r16,$00    ;(must be #$0000 at FAT32)
        brne l18390    ;b.i.illegal value
    
        lds r16,hdbube+$17 ;read FAT16-FATsize high
        cpi r16,$00
        brne l18390    ;b.i.illegal value

                       ;Hidden sectors ($1c-1f) aren't 100% defined => don't compare
 
        ldi r24,$28
        lds r16,hdbube+$28 ;read FAT-mirroring-flags
        andi r16,$80   ;masks bit for FAT-mirroring 
l18370: brne l18390    ;b.i.not both FATs are mirrored at runtime
 
        ldi r24,$2a
        lds r16,hdbube+$2a ;read FAT32 version
        cpi r16,$00
        brne l18390    ;b.i.not V0.0

        lds r16,hdbube+$2b ;read FAT32 version
        cpi r16,$00
        brne l18390    ;b.i.not V0.0

        ldi r24,$2b
        lds r16,hdbube+$30 ;sectornumber of FileSystem Info Block
        cpi r16,$01
        breq l18380    ;b.i.sector 0001 of partition

        rjmp l18420    ;= not sector 0001 of partition

l18380: lds r16,hdbube+$31 ;
        cpi r16,$00
l18390: brne l18420    ;b.i.not 0001

        ldi r24,$2c
        lds r16,hdbube+$0d ;sectors per cluster
        sts sepecl,r16 ;sectors per cluster     
        cpi r16,$65
        brcc l18420    ;b.i.128 sectors per cluster (clustersize 64kB) = illegal
                       ;=1,2,4,8,16,32,64 sectors per cluster
    
       #if (partname == 3) | (partname == 6) | (partname == 7)    
        #message nlq-hd/SD-card
        lds r16,sbpabo+3 ;flag whether partition-begin/-end not read from MBR
        tst r16
        brpl l18400    ;b.i.partition-begin/-end set at MBR

        sts sbpabo,r06 ;#$00 sectorbegin partition bootsector
        sts sbpabo+1,r06 
        sts sbpabo+2,r06 
        sts sbpabo+3,r06  ;necessary?? are set at 00000000 at clear RAM????????

        ldi r28,$20
        
        ld r20,y+      ;length of P in LBA (0020-23 contain length of P (not end of P))
        sts sbpaen,r20 ;sectorbegin partition end (+1)
        ld r20,y+      ;lowbyte first
        sts sbpaen+1,r20     
        ld r20,y+    
        sts sbpaen+2,r20     
        ld r20,y+  
        sts sbpaen+3,r20     

        rjmp l18440
       #endif
    
l18400: ldi r24,$20    ;20--
        ldi r30,low(sbpaf1) ;Z=sectorbegin P-FAT1 (contains temporary length of P)
        ldi r31,high(sbpaf1) ;(0834-0837)   (written at l18340) 
        ldi r28,$20    ;Y=begin of length of partition in PBR???     

        mov r25,r28
        call l23560

        mov r25,r29
        call l23560

        mov r25,r30
        call l23560
        
        mov r25,r31
        call l23560

        clc
        ldi r18,$04

l18410: ld r16,y+      ;read P-length (0020-0023) from P-boot record 
        ld r17,z+      ;read values of master boot record (MBR)
    
        mov r25,r16
        call l23560

        mov r25,r17
        call l23560
    
        sbc r17,r16    ;subtracts P-length of MBR minus P-length of P-boot-record 

        dec r18        ;must be a command which doesn't change the carry flag   
        brne l18410
 
        brcc l18440    ;b.i.P-length of P-boot-record smaller-same than P-length of MBR   
                       ;20--  =P-length of P-boot-record greater than P-length of MBR
                       ;at partitions with several sectors-per-cluster it's possible that
                       ;the P-length of the MBR is greater than the P-length of the P-boot-recrod

l18420: ldi r25,$a0    ;a0----
        call l13090
                       ;       $00 no FAT32 partition found
                       ;       $10 not two FATs
                       ;       $11 FAT16-rootdirentries <>#$00 
        mov r25,r24    ;----   $15 wrong mediabyte (not HD) 
        call l23560   ;       $16 FAT16-size not $0000
                       ;       $20 differnce of partition-length in MBR and bootrecord of partit.
        ldi r25,$a1    ;a1--   $28 not both FATs are mirrorde at runtime
        call l23560   ;       $2a not FAT32 version 0.0 

        ldi r17,$0a    ;=illegal FAT32               
l18430: jmp syserr     ;system error  0a-- 10--  -------------------------------------------

l18440: lds r15,hdbube+$0e ;reserved sectors low             =correct FAT32  
        lds r16,sbpabo ;sectorbegin partition boot low
        add r16,r15    ;compute begin of FAT1
        sts sbpaf1,r16 ;sectobegin partition FAT1

        lds r15,hdbube+$0f ;reserved sectors high
        lds r17,sbpabo+1 ;sectorbegin partition boot
        adc r17,r15
        sts sbpaf1+1,r17

        lds r18,sbpabo+2
        adc r18,r06    ;#$00 (adds carry)
        sts sbpaf1+2,r18

        lds r19,sbpabo+3
        adc r19,r06
        sts sbpaf1+3,r19 ;FAT1

        
        lds r12,hdbube+$24 ;length of 1 FAT low
        add r16,r12    ;computes begin of FAT2
        sts sbpaf2,r16 ;sectorbegin partition FAT2

        lds r13,hdbube+$25 ;length of 1 FAT
        adc r17,r13
        sts sbpaf2+1,r17

        lds r14,hdbube+$26
        adc r18,r14
        sts sbpaf2+2,r18

        lds r15,hdbube+$27
        adc r19,r15
        sts sbpaf2+3,r19 ;sectorbegin partition FAT2

       #if partname == 1    
        #message 162-IEC-ATA-V2
        sts lefahd,r12 ;length FAT of HD 
        sts lefahd+1,r13 ; important to store not in device emulation buffer because it's
        sts lefahd+2,r14 ; possible that it must be rewritten when the active device is
        sts lefahd+3,r15 ; changed 
       #endif

       #if (partname == 3) | (partname == 6) 
        #message 644-NLQ-HD/SD-routines 
        sts lefasd,r12 ;length FAT of SD 
        sts lefasd+1,r13 ; important to store not in device emulation buffer because it's
        sts lefasd+2,r14 ; possible that it must be rewritten when the active device is
        sts lefasd+3,r15 ; changed 
       #endif

       #if (partname == 4) | (partname == 5)
        #message nlq-hd/lite
        lds r20,acemen ;actual emulated entry 0,1,2
                       ; 0=IDE-HD    master
                       ; 1=IDE-CDROM slave (not supported)
                       ; 2=SD/MMC-card
        ;cpi r20,$00
        ;brne l18450    ;b.i.not HD
         
        sts lefahd,r12 ;length FAT of HD 
        sts lefahd+1,r13 ; important to store not in device emulation buffer because it's
        sts lefahd+2,r14 ; possible that it must be rewritten when the active device is
        sts lefahd+3,r15 ; changed 
        ;rjmp  l18460   
                         ;still make for CD 
l18450: ;sts lefasd,r12 ;length FAT of SD 
        ;sts lefasd+1,r13 ; important to store not in device emulation buffer because it's
        ;sts lefasd+2,r14 ; possible that it must be rewritten when the active device is
        ;sts lefasd+3,r15 ; changed 
l18460:
       #endif
       
       #if partname == 7    
        #message nlq-hd/full
        lds r20,acemen ;actual emulated entry 0,1,2
                       ; 0=IDE-HD    master
                       ; 1=IDE-CDROM slave (not supported)
                       ; 2=SD/MMC-card
        cpi r20,$00
        brne l18470    ;b.i.not HD
         
        sts lefahd,r12 ;length FAT of HD 
        sts lefahd+1,r13 ; important to store not in device emulation buffer because it's
        sts lefahd+2,r14 ; possible that it must be rewritten when the active device is
        sts lefahd+3,r15 ; changed 
        rjmp  l18480   
   
l18470: sts lefasd,r12 ;length FAT of SD 
        sts lefasd+1,r13 ; important to store not in device emulation buffer because it's
        sts lefasd+2,r14 ; possible that it must be rewritten when the active device is
        sts lefasd+3,r15 ; changed 
l18480:
       #endif
        
        add r16,r12    ;computes begin of dataarea
        sts sbpada,r16 ;sectorbegin partition data

        adc r17,r13
        sts sbpada+1,r17

        adc r18,r14
        sts sbpada+2,r18

        adc r19,r15
        sts sbpada+3,r19 ;sectorbegin partition data

        lds r20,sbpaen  ;sectorbegin partition end of partition (+1)
        lds r21,sbpaen+1
        lds r22,sbpaen+2
        lds r23,sbpaen+3

        sub r20,r16     ;compute length of dataarea
        sbc r21,r17
        sbc r22,r18
        sbc r23,r19     ;r20-r23 = length of dataarea

        lds r16,sepecl  ;sectors per cluster for every device 1, 2, 4, 8, 
        rjmp l18500

l18490: lsr r23         ;divide by 2
        ror r22
        ror r21
        ror r20

l18500: lsr r16
        brne l18490
 
        subi r20,$100-$01 ;add #$01
        sbci r21,$ff
        sbci r22,$ff
        sbci r23,$ff
                       ;one must add #$02 because cluster 00000000 and 00000001 don't exist??
                       ;add #$02 => amtocl would be amouut+1
                       ;add #$01 => amtocl is amount
                       ;              #$01 is easier to subtract at l14450

        sts amtocl,r20 ;amount of total clusters
        sts amtocl+1,r21 ;must this be stored in not-cleared RAM??? 
        sts amtocl+2,r22           
        sts amtocl+3,r23               
        
        lds r12,hdbube+$2c ;cluster root-dir low (cluster. not sectors)
        lds r13,hdbube+$2d
        lds r14,hdbube+$2e
        lds r15,hdbube+$2f ;cluster root-dir highest (cluster. not sectors)

        mov r16,r12
        cpi r16,$02
        breq l18520      ;b.i.rotdir starts at cluster 00000002
        
l18510: ldi r16,$0b      ;system error  0b-- 11--   
        rjmp l18430      ;rootdirectory doesn't start at cluster 00000002
                   
l18520: mov r16,r13
        or r16,r14
        or r16,r15
        brne l18510
.db 0
         
        ldi r25,$30    ;30----
        call l13090

                       ;IEC-ATA-V2: no swapfile, 6 buffers, then 70,no channel
                       ;SD2IEC: search swapfile:
                       ;        -not found => 6 buffers, then 70,no channel
                       ;        -found => 15 buffers
                       ;NLQ-HD/lite&driver: search swapfile:
                       ;        -not found => 6 buffers, then 70,no channel
                       ;        -found => 15 buffers
                       ;NLQ-HD/full: search swapfile
                       ;        -not found => system error
                       ;                      make drives to disable writing
                       ;        -found => 15 buffers
                       ;        swapfile must be there because of swapping emulations


       #if partname == 7
        #message 644-NLQ-HD/full
        lds r16,acemen ;actual emulated entry 0,1,2
                         ; 0=IDE-HD    master
                         ; 1=IDE-CDROM slave (not supported)
                         ; 2=SD/MMC-card
        cpi r16,$00
        breq l18530    ;b.i.HD
         
        rjmp  l18650   ;= CD & SD = don't search swapfile there at NLQ-HD/full
       #endif 

       #if partname >= 3
        #message 644-NLQ-HD/ >=3
l18530: sts seswfi+3,r07 ;#$ff  makes sector swap file illegal
        call l14820   ;read root-dir first sector r12,r13,r14,r15

l18540: ldi r28,low(hdbube) ;HD buffer begin
        ldi r29,high(hdbube) ;vector to filename
        
        ldi r25,$31    ;31----
        call l13090

l18550: ldi r30,low(nanlsw<<1)  ; <<1 means: shifted left one bit 
        ldi r31,high(nanlsw<<1) ;initialize Z pointer      
        

        mov r25,r28
        call l23560
        mov r25,r29
        call l23560


        mov r25,r30
        call l23560
        mov r25,r31
        call l23560




        ld r16,y       ;first character of dir filename
        cpi r16,$00
        brne l18560    ;b.i.not end of dir
        
        ldi r25,$3f    ;3f--
        call l23560

        mov r25,r28
        call l23560
        mov r25,r29
        call l23560


        mov r25,r30
        call l23560
        mov r25,r31
        call l23560

        ldi r17,$0c    ;0c--  12--  NLQ-SWAP.SYS not found   
        rjmp l18630    ;system error  0c-- 12-- (and make swapfile illegal)

l18560: ld r16,y+      ;dirfilename
        lpm r17,z+      ;wanted filename

        mov r25,r16
        call l23560
        mov r25,r17
        call l23560

        cp r16,r17
        breq l18570    ;b.i.so far correct filename
            
        andi r28,$e0   ;masks off bit 4-0  0600-060a->0600  07e0-07ea->07e0
        ldi r16,$20
        add r28,r16    ;0600->0620 07e0->0800
        adc r29,r06    ;#$00 adds carry
        cpi r29,high(hdbube)+2 ;end of hd-buffer 512bytes=2blocks long
        brne l18550    ;b.i.not yet end of hd-sector reached
        
        ldi r25,$32    ;32--
        call l23560

        call l14770   ;read follow sector
        rjmp l18540
                 
l18570: cpi r30,low((nanlsw<<1)+$0b)
        brne l18560    ;b.i.not end of filenames
           
        ldi r25,$33    ;33--
        call l23560

        ld r16,y       ;read file attributes (r28=060b...07eb)   =NLQ-SWAP.SYS found in dir
        andi r16,$18   ;masks volume-id & directory bits
        breq l18590    ;b.i.no volume-id  and no directory
        
        ldi r25,$34    ;34--
        call l23560

l18580: ldi r17,$0d    ;13--  WRONG NLQ-SWAP.SYS             
        rjmp l18630    ;system error + LED-blink + main waiting loop 0d-- 13--
                       ;(and make swapfile illegal)

l18590: ldi r16,$0f
        add r28,r16    ;060b->061a 07eb->07fa
        ld r12,y+      ;startcluster low of swapfile     061a
        ld r13,y+      ;startcluster high                061b
        andi r28,$f7   ;061c->0614 07fc->09f4
        ld r14,y+      ;startcluster hiher               0614
        ld r15,y+      ;startcluster highest             0615
        
        ldi r25,$35    ;35----
        call l13090

        ldi r16,$06
        add r28,r16    ;0616->061c  07f6->07fc
        
        ldi r25,$36    ;36--
        ld r16,y+      ;lowbyte filelength
        cpi r16,$00
        brne l18580    ;b.i.length not 65536 bytes
        ld r16,y+
        cpi r16,$00
        brne l18580
        ld r16,y+ 
        cpi r16,$01
        brne l18580
        ld r16,y+      ;highest byte filelength
        cpi r16,$00  
        brne l18580    ;b.i.length not 65536 bytes

        ldi r25,$37    ;37---- xx-- xx-- xx-- xx-- xx--
        call l13060    ;start-cluster swapfile

                       ;test whether legal address (perhaps load this cluster?)         
        
        mov r20,r12    ;startcluster of NLQ-SWAP.SYS
        mov r21,r13    ;backup to r20-23 because needed at l18610?
        mov r22,r14
        mov r23,r15

        call l14520   ;clusteraddress (in r12-15) -> sectoraddress of first sector of cluster
                      ;                                     (in r12-15) 
        sts seswfi,r12 ;sector swap-file ($0120-0123)
        sts seswfi+1,r13
        sts seswfi+2,r14
        sts seswfi+3,r15
      
        ldi r25,$38    ;38-- xx-- xx-- xx-- xx-- xx--
        call l13060    ; start-sector swapfile

        lds r16,sepecl;            sepecl: 1    2    4    8   16    32    64 sectors per cluster
        ldi r26,$00    ;bytes per cluster: 512 1024 2048 4096 8192 16384 32768 bytes per cluster
        sec            ;65536 bytes file = 128 64   32   16    8    4     2   clusters f.swapfile
                       ;at first time: carry=set     next times: carry=cleared
l18600: ror r26        ;check whether r26 is unchanged (changed 9.2.08 from r24 to r26
        lsr r16        ;  test whether this works at IDE-HD!!!!!!!)
        brcc l18600    ;r17=amount of clusters for 64kB swapfile (which must be in one row)

        mov r25,r24    ;----
        call l23560

        ldi r25,$39    ;39--
        call l23560

        dec r26
        
        ;brne l18610         ;b.i.all 128 sectors aren't in one cluster  
        ;rjmp l25990         ;all 128 sectors are in one cluster (=defrag-test not necessary) 

l18610:                ;r12-r15: follow-cluster from FAT (not sectors)
                       ;r20-r23: follow-cluster computed by adding one (not sectors)

        mov r12,r20    ;actual cluster
        mov r13,r21
        mov r14,r22
        mov r15,r23

        ldi r25,$3a    ;3a--
        call l23560

        clt            ;=flag for don't compare FAT1 and FAT2
        call l14390    ;compute follow cluster (->r12-15) of cluster in r12-r15
                       ;=reads content of FAT-entry of cluster in r12-r15 
        ldi r16,$01
;        lds r20,acclsg
        add r20,r16    ;increments old actual cluster by 1
;        lds r21,acclsg+1
        adc r21,r06    ;#$00 adds carry
;        lds r22,acclsg+2
        adc r22,r06 
;        lds r23,acclsg+3
        adc r23,r06
        
;        sts acclsg,r20 ;=old actual cluster incremented by 1    
;        sts acclsg+1,r21
;        sts acclsg+2,r22
;        sts acclsg+3,r23
       
        ldi r25,$3b    ;3b--
        call l23560

        ldi r25,$12    ;12-- xx-- xx-- xx-- xx-- xx--
        call l13060    ;(follow-cluster read from FAT)
     
        ldi r25,$20    ;20--
        call l23560
     
        mov r25,r20    ;----  (follow-cluster computed by adding 1)
        call l23560
        mov r25,r21    ;----
        call l23560
        mov r25,r22    ;----
        call l23560
        mov r25,r23    ;----
        call l23560
        
        ldi r25,$26    ;26--  (counter for still to test clusters)
        call l23560

        mov r25,r26    ;----
        call l23560
 
        cp r20,r12     ;compares old incremented cluster and follow cluster
        brne l18620    ;b.i not all sectors are in one row 
        cp r21,r13     ;  (=b.i.NLQ-SWAP.SYS is fragmented) 
        brne l18620 
        cp r22,r14
        brne l18620    
        cp r23,r15
        breq l18640    

l18620: ldi r25,$3f    ;3f--
        call l23560

        ldi r17,$0e    ;NLQ-SWAP.SYS fragmented     system error 0e-- 14--            

l18630: sts seswfi+3,r07 ;#$ff  makes sector swap file illegal

       #if partname == 7
        #message 644-NLQ-HD/full
                       ;NLQ-HD/full: there must be a swapfile

                       ;!!!!!! disable write to devices !!!!! 

        rjmp l18430    ;system error + LED-blink + main waiting loop 0d-- 13--

       #else
                       ;sd2iec & NLQ-HD/lite: it's possible that there is no swapfile
        rjmp l18650

       #endif 

l18640: ldi r25,$3c    ;3c--
        call l23560

        dec r26        ;decrements clusters per NLQ-SWAP.SYS-file 
        breq l18650    ;b.i.complete chain checked whether unfragmented
        rjmp l18610    ;not yet complete chain checked whether unfragmented
                       ;end NLQ-SWAP.SYS---------------------------------------------------------
       #endif          ;end of l18440-l18540  
                 
                       ;-------------------------------------------------------------------------
                       ;problem: the sector with the FSInfo-block must be written at every
                       ; scatch and save to disk
                       ; => this sector is extremly often written
                       ; this is no problem at a HD
                       ;   => use information from FSInfo-block at a HD (because the FAT can be 
                       ;      very big (128GB) and there is no dammage at the sector)
                       ; this is a problem at a SD-acrd, because a sector is destroyed when it
                       ; is too often written
                       ;   => don't use the FSInfoblock at a SD-card
                       ;      never write the FSInfo-block
                       ;      compute the free clusters and the first free cluster at every
                       ;      initialize-command
                       ;at scandisk of a SD-card:        
                       ;      WME: computes and writes FSInfoblock
                       ;      WXP: doesn't write FSInfoblock

l18650:                ;read free clusters and first free cluster from HD------------------------
        call l22150    ;reads FSInfo-block into HD-buffer
                       ;X shows to begin of free-clusters drive0
                       ;Y shows to $01e8 = free clusters of HD-buffer
                           
        ldi r25,$53    ;53----
        call l13090
              
l18660: ld r16,y+      ;reads free clusters  and  first free cluster from FSInfo sector           
        st x+,r16      ;stores to free clusters  and  first free cluster of actual emulation
                       ;amfrcl and fifrcl must be directly together in memory
        cpi r28,low(hdbube+$01f0)
        brne l18660    ;-------------------------------------------------------------------------

       #if partname == 1    
        #message 162-IEC-ATA-V2
        ;sts hdfldc,r06 ;clears HD flag disk change  (not used)         (=$1c at 1541)
       #endif
     
       #if (partname == 3) | (partname == 6) 
        #message 644-NLQ-HD/SD-routines 
        ;sts sdcafl     ;SD-capabilities flags 
                        ;bit7: 0=not accessable 1=accessable
                        ;bit1: LBA-mode 0=HD doesn't support (=CHS) 1=HD supports (=LBA)
                        ;make here more bits e.g. IDE-bus locked (HD no power supply)
                        ;                         FAT32 partition found/not found
                        ;                         NLQ-SWAP.SYS legalillegal
        lds r16,sdfldc
        andi r16,$02
        breq l18670     ;b.i.don't clear actual dir of SD

        ;ldi r16,$02    ;r16 is accidentially #$02
        sts cbadd2,r16  ;clusterbegin actual directory drive2 SD  
        sts cbadd2+1,r06
        sts cbadd2+2,r06 ;clear actual dir of SD
        sts cbadd2+3,r06
     
l18670: sts sdfldc,r06 ;#$00 clears SD flag disk change  (bit0-3=$1c at 1541)                d071
                       ;                                 (bit4-7=$1e at 1541)
        ;sts sddrac    ;SD drive accessable      =$ff at 1541
       #endif

       #if partname == 4
         #message 644-NLQ-HD/lite

       #endif
 
       #if partname == 7    
        #message 644-NLQ-HD/full
        lds r16,acemen ;actual emulated entry 0,1,2
        cpi r16,$02
        brne l18690    ;b.i.not initialize of SD

       ;sts sdcafl     ;SD-capabilities flags 
                        ;bit7: 0=not accessable 1=accessable
                        ;bit1: LBA-mode 0=HD doesn't support (=CHS) 1=HD supports (=LBA)
                        ;make here more bits e.g. IDE-bus locked (HD no power supply)
                        ;                         FAT32 partition found/not found
                        ;                         NLQ-SWAP.SYS legalillegal
        lds r16,sdfldc
        andi r16,$02
        breq l18680     ;b.i.don't clear actual dir of SD

        ;ldi r16,$02    ;r16 is accidentially #$02
        sts cbadd2,r16  ;clusterbegin actual directory drive2 SD  
        sts cbadd2+1,r06
        sts cbadd2+2,r06 ;clear actual dir of SD
        sts cbadd2+3,r06
  
l18680: sts sdfldc,r06 ;#$00 clears SD flag disk change  (bit0-3=$1c at 1541)                d071
                       ;                                 (bit4-7=$1e at 1541)
        ;sts sddrac    ;SD drive accessable      =$ff at 1541

l18690:  
       #endif

        ldi r25,$54    ;54----
        call l13090

        ret            ;                                                                     d09a
;------------------------------------------------------------------------------------------------
l18700: ldi r16,$40    ;                        checks whether actual SA is opened for read  d0eb
        rjmp l18720    ;bitmask for opened for read
;------------------------------------------------------------------------------------------------
l18710: ldi r16,$80    ;bitmask for write      checks whether actual SA is opened for write  d107
                       ;.........................................................................
l18720: push r16       ;backups mask to stack 
        
        lds r16,icsawo ;SA-only without bits whether open/close/SA = $83 at 1541        d0eb/d107
        ldi r17,$c0    ;%11000000 pseudo-byte for command/errorchannel
        cpi r16,$0f
        breq l18730    ;b.i.command/errorchannel  (always opened)
        
        call l14190   ;backup actual swap-buffer and read wanted SA into swapbuffer

        lds r17,asfla1 ;actual SA flags1 (0-17)

l18730: pop r16        ;restores mask from stack
        clc            ;default-flag that actual SA is opened for wanted mode (read/write)
        and r16,r17
        brne l18740    ;b.i.actual SA is opened for wanted mode (read/write)
        
        sec            ;=flag that actual SA isn't opened for wanted mode (read/write)
         
l18740: ret
;------------------------------------------------------------------------------------------------
                       ;from l21890
l18750: ldi r16,$80    ;sets flag that actual SA is opened for write                         d1df
        rjmp l18770    ;                        sets bit that SA is used/opened (e.g.for LED)         
                       ;.........................................................................
                       ;from l21840
l18760: ldi r16,$40    ;sets flag that actual SA is opened for read                          d1e2 
                       ;                        sets bit that SA is used/opened (e.g.for LED)
l18770:                ;still test, whether SA was opened before?????????????????
        sts asfla1,r16 ;actual SA flags1 (0-17)
                       ;what about the other bits of asfla1???
                       ;what about asfla0???
        ldi r16,$00    ;byte for opened
        rjmp l18800    ;                                                                     d226 
;------------------------------------------------------------------------------------------------
                       ;from l19020, l19100, l19100, l21660, 
                       ;                                            free things of actual SA d227
l18780: lds r16,icsawo ;SA-only without bits whether open/close/SA    =$83 at 1541
                       ; =SA which is freed
        lds r17,acsacb ;actual SA in CBM-buffer (00-$11 0-17)
        cp r16,r17     ;compares to-close-SA and actual-in SA-buffer-SA
        brne l18790    ;b.i.the SA which is closed isn't actually in the SA-buffer

        ;lds r16,icsawo ;SA-only without bits whether open/close/SA
        ;call l14180    ;backups old CBM-swapbuffer and read actual one from swapfile
                       ;the bit in saopbi is already cleared
                       ;=> rcall l14180 doesn't load from HD but clears all with #$00
                       ;?? is this necessary??

        sts acsacb,r07 ;#$ff makes flag that nothing in actual SA in CBM-buffer (00-$11 0-17)

l18790: ldi r16,$ff    ;byte for not opened
                       ;the CBM buffer still contains bytes of the old buffer
                       ; it isn't cleared........................................................    
l18800: lds r18,icsawo ;IECSecundaryAddress without bits whether open,close,SA ($83)  0-0f 
        cpi r18,$0f
        breq l18810    ;b.i.command/errorchannel (important that this bit isn't set
                       ; because else the LED would go on if commandchannel would be open)
        push r26
        push r27
        ldi r26,low(tasach) ;table secundaryaddress -> channel
        ldi r27,high(tasach)
        add r26,r18    ; adds SA = vector to entry in table of SA
        st x,r16       ;#$00 sets bit that actual SA is opened
        pop r27        ;ff=SA not opened 0-fe=SA opened
        pop r26        ; still make flag for read/write / channel  here in tasach 

l18810: ret            ;                                                                d226/d259
                       ;!!!!!
                       ;e.g.at scratch:
                       ;icsawo = #$0f
                       ;but the actual cbm-buffer contains buffer of SA$11


;------------------------------------------------------------------------------------------------
                       ;from l13580, l13580
l18820:                ;read FATx-entry of file-cluster, test whether endclusterentry
                       ; write follow-cluster to FAT-entry, (write FAT-sector to HD)    
                       ;uses actual cluster
                       ; doesn't use cluster opfde.
                       ;carry says whether FAT1 / FAT2  
        lds r12,ashbcl ;open free dir entry cluster = $0291 at 1541
        lds r13,ashbcl+1
        lds r14,ashbcl+2 ;so far last dircluster
        lds r15,ashbcl+3
        rjmp l18840    ;-------------------------------------------------------------------------
                       ;from l19050, l19050
l18830:                ;read FATx-entry of dir-cluster, test whether endclusterentry
                       ; write follow-cluster to FAT-entry, (write FAT-sector to HD)    
                       ;doesn't use actual cluster
                       ; uses cluster opfde.
                       ;carry says whether FAT1 / FAT2  
        lds r12,ofdecl ;open free dir entry cluster = $0291 at 1541
        lds r13,ofdecl+1
        lds r14,ofdecl+2 ;so far last dircluster
        lds r15,ofdecl+3
      
l18840: ldi r16,$0f
        and r15,r16    ;clears bit 31-28 of clusteraddress of so far last dircluster

        set            ;=flag for compare FAT1 and FAT2
        call l14390    ;read FAT1-entry of cluster in r12-r15 = so far last direntry
                       ;Y shows to first byte of wanted FAT-entry
                       ;still test wether ashbcl isn't changed
                       ;carry says whether FAT1 / FAT2  

                       ;FAT1 must be compared with FAT2???

        lds r12,geaccl ;general actual cluster
        lds r13,geaccl+1 ;new values to write into FAT-entry
        lds r14,geaccl+2 ;isn't it changed at rcall l14390???????????? 
        lds r15,geaccl+3 ;new found  new made dircluster
                       ; this is mode to the follow-cluster
        ldi r17,$04

l18850: ld r16,y+      ;reads old FAT-entry
        dec r17
        breq l18870

        cpi r16,$ff    ;isn't this made at l14390 to the carry flag?
        breq l18850    ;b.i.old cluster is / was an endcluster
        
l18860: ldi r17,$29    ;29--   41--  old dircluster was no endcluster  = error
        jmp syserr     ;Fatentry wasn't xfffffff 

l18870: andi r16,$0f   ;masks off bit31-28
        cpi r16,$0f
        brne l18860    ;b.i.old cluster isn't / wasn't an endcluster
                       ;r16=#$0f  (old FAT-entry was an end-cluster entry
        
        and r15,r16    ;#$0f  masks of bit31-28 doesn't change bit27-24         
        
        ld r16,-y      ;FAT-entry highest
        andi r16,$f0   ;doesn't change bit 7-4   clears bit27-24
        or r16,r15      
        st y,r16
        st -y,r14
        st -y,r13
        st -y,r12

        lds r25,flfbch ;flags FAT-buffer changed
                       ; (if few RAM then perhaps together with acenfb??)      
                       ;bit7: FAT-buffer changed (doesn't matter whether allocate or free)
                       ;bit6: FAT-buffer changed by allocate cluster
                       ;bit5: FAT-buffer changed by free cluster
        ori r25,$c0    ;sets bits for changed general and changed by allocating
        sts flfbch,r25 ;=> FAT-buffer is rewritten to HD

        ;call l14630   ;write sectors with retry  actual sector FAT-buffer = FAT-sector  
                       ;send block-write-command to HD (write 1 sector only)
                       ;write FAT-sector with allocted enty to HD
                       ; write sector-address
                       
                       ;!! doesn't write !!
                       ; must be made at close or when different FAT-sector is read
        ret
;================================================================================================
                       ;from l18240
l18880:                ;free all SAs, channels, buffers of actual drive                      d313
                       ; without closing them (e.g. at initialize-command)
       #if partname == 1    
        #message 162-IEC-ATA-V2
        sts acsehb+3,r07 ;#$ff makes actual sector in HD-buffer illegal
        sts acsefb+3,r07 ;#$ff makes actual sector in FAT-buffer illegal
       #endif
     
       #if (partname == 3) | (partname == 6) 
        #message 644-NLQ-HD/SD-only-routines 
        sts seswfi+3,r07 ;#$ff makes swapfile illegal
                       ;at NLQ-HD/SD2IEC the swapfile is on the SD-card
        sts acsehb+3,r07 ;#$ff makes actual sector in HD-buffer illegal
        sts acsefb+3,r07 ;#$ff makes actual sector in FAT-buffer illegal
     
       #endif

       #if partname == 4
         #message 644-NLQ-HD/lite
        sts seswfi+3,r07 ;#$ff makes swapfile illegal
                         ;at NLQ-HD/lite the swapfile is on the HD
                         ;!! change if CD is supported !!
        sts acsehb+3,r07 ;#$ff makes actual sector in HD-buffer illegal
        sts acsefb+3,r07 ;#$ff makes actual sector in FAT-buffer illegal
       #endif
 
       #if partname == 7    
        #message 644-NLQ-HD/full
        lds r17,acemen ;actual emulated entry 0,1,2 

                       ;don't make swapfile ilegal because it is on HD 
                       ;even when the HD is initialized:
                       ; CBM-sectors of the SD / device-emulation-buffer of the SD
                       ; is in the swapfile of the HD

        lds r16,acenhb ;actual emulation(entry)number (of sector) in HD buffer
        cp r16,r17
        brne l18890    ;b.i. e.g. the HD is initialized, but a SD-sector is in the buffer
        
        sts acsehb+3,r07 ;#$ff makes actual sector in HD-buffer illegal
        
l18890: lds r16,acenfb ;actual emulation(entry)number (of sector) in FAT buffer
        cp r16,r17
        brne l18900    ;b.i. e.g. the HD is initialized, but a SD-sector is in the buffer

        sts acsefb+3,r07 ;#$ff makes actual sector in FAT-buffer illegal
       #endif

l18900: rjmp l19000
;------------------------------------------------------------------------------------------------
       #if partname >= 2
        #message not-IEC-ATA
                       ;from l17180 (begin of a command), l19560 (begin of open)
l18910:                ;                                     test whether the SD has been changed
                       ;                                          and if so then free all buffers
        lds r16,acemen ;actual emulated entry 0,1,2
        cpi r16,$02
        brne l19040    ;b.i.not SD

       #if (partname == 3) | (partname == 6) | (partname == 7)
        #message nlq-hd/SD-routines
l18920: lds r16,sdfldc ;SD flag disk change       
        andi r16,$01   ;                            
        brne l18940    ;b.i.SD has been changed

                       ;test whether there is a SD card in the drive and read header-ID 
       #if partname == 3
        #message 644-NLQ-HD/SD2IEC
        in r20,pisdcd  ;AVR-pin SD-CardDetect
        andi r20,1<<bisdcd ;bit AVR-SD-CardDetect
       #endif

       #if partname == 6
        #message 644-NLQ-HD/SD
        in r20,pisdcd  ;AVR-pin SD-CardDetect
        andi r20,1<<bisdcd ;bit AVR-SD-CardDetect
        #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
        call l23810    ;reads I2C-parallel-port to r20
        andi r20,1<<bisdcd ;bit AVR-SD-CardDetect
       #endif
        brne l18930    ;b.i.no SD inserted           

        set            ;flag for deactivate SPI-CS at end
        call l26530    ;send read-status-command via SPI to SD-card and read response
        brcc l19040    ;b.i.an already initialized SD is inserted

l18930: lds r16,sdfldc ;SD-flag diskchanged
        ori r16,$03    ;set bit that disk is changed (important that it is initialized
        sts sdfldc,r16 ; later automatically) 
l18940:
       #endif
;................................................................................................
                       ;from l11030 (Listen&Talk), l25520 (mainwaitingloop)
l18950:                ;                                               e.g.when a disk is changed
                       ;                                  !!!!changes r26,r27 X !!!!      (d313?)
       #if (partname == 3) | (partname == 6) 
        #message 644-NLQ-HD/SD-only-routines 
        sts seswfi+3,r07 ;#$ff makes swapfile illegal
                       ;at NLQ-HD/SD2IEC the swapfile is on the SD-card
        sts acsehb+3,r07 ;#$ff makes actual sector in HD-buffer illegal
        sts acsefb+3,r07 ;#$ff makes actual sector in FAT-buffer illegal

        lds r16,sdfldc
        andi r16,$02
        breq l18960    ;b.i.don't clear actual dir of SD

        ;ldi r16,$02   ;r16 is accidentially #$02
        sts cbadd2,r16 ;clusterbegin actual directory drive0  
        sts cbadd2+1,r06 
        sts cbadd2+2,r06 ;makes actual dir to rootdir 
        sts cbadd2+3,r06 
     
l18960:  
                       ;clear last loaded file-clusteraddress???   
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
                       ;the only media that can be changed is the SD card
                       ;=> so far it must be the SD
                       ; if CD is supported then test whether SD or CD was changed         

                       ;don't make swapfile ilegal because it is on HD (not SD)
        lds r16,sdfldc
        andi r16,$02
        breq l18970    ;b.i.don't clear actual dir of SD

        ;ldi r16,$02   ;r16 is accidentially #$02
        sts cbadd2,r16 ;clusterbegin actual directory drive0  
        sts cbadd2+1,r06 
        sts cbadd2+2,r06 ;makes actual dir to rootdir 
        sts cbadd2+3,r06 
     
l18970:
                       ;clear last loaded file-clusteraddress???   

        lds r16,acenhb ;actual emulation(entry)number (of sector) in HD buffer
        cpi r16,$02
        brne l18980    ;b.i.no SD-sector is in HD-buffer (HD-sector / CD-sector)

        sts acsehb+3,r07 ;#$ff makes actual sector in HD-buffer illegal

l18980: lds r16,acenfb ;actual emulation(entry)number (of sector) in FAT buffer
        cpi r16,$02
        brne l18990    ;b.i.no SD-sector is in HD-buffer (HD-sector / CD-sector)

        sts acsefb+3,r07 ;#$ff makes actual sector in FAT-buffer illegal
l18990:
       #endif          ;.........................................................................
       #endif          ;of l18910
                       ;.........................................................................
                       ;from l18900
l19000:                ;free all buffers of actual drive                                     d313
                       ; but not the internal addresses (e.g.when a disk is changed)

        lds r16,icsawo
        push r16       ;backup icsawo (important at open)

        ldi r19,$0e    ;secundary address 14-0                                               d313 

l19010: sts icsawo,r19 ;SA-only without bits whether open/close/SA = $83 at 1541             d315  

        ;lds r17/r19,icsawo ;SA-only without bits whether open/close/SA                      d317
   
        ldi r26,low(tasach) ;table secundaryaddress -> channel
        ldi r27,high(tasach)
        add r26,r19    ; adds SA = vector to entry in table of SA
        ld r16,x       ;                                                                     d319
        cpi r16,$ff    ;                                                                     d31c
        breq l19030    ;b.i.wanted SA isn't opened                                           d31e    

l19020: rcall l18780   ;free things of actual SA ($83 at 1541)                               d331

l19030: lds r19,icsawo ;SA-only without bits whether open/close/SA           
        dec r19        ;                                                                     d334
        brpl l19010    ;                                                                     d336

        pop r16
        sts icsawo,r16 ;restore icsawo

l19040: ret            ;                                                                     d338
                       ;at the end: the SA which was received with the command from
                       ;the c64 isn't in the cbm-buffer!!!!!!!!!
                       ;1541:icsawo = #$ff 
                       ;NLQ-HD: icsawo stays how before                       
;------------------------------------------------------------------------------------------------
                       ;from l19200
l19050:                ;take track&sector?                           make new dircluster     d48d
                       ;ofdesc & ofdecl must show to end of actual dir!!!!

                       ;=even at the last sector of this dircluster there aren't
                       ;  3 direntries free
        call l22050    ;search next free cluster -> geaccl(0-3) & allocates it in FATs       d49b
                       ;  as an endcluster
                       ; geaccl contain clusteraddress of new found free cluster

                       ;make follow link of actual-old dir cluster (former endcluster)  d4a1-d4b3
                       ; to link-cluster-address of now-found cluster
                       ;1541: the link is in the file-sector (not in the BAM)
                       ;FAT32: the link is in the FAT (not in the file-sector/file-cluster)   
                       ;read FAT1-entry of cluster in r12-r15 = so far last direntry
        rcall l18830   ;test whether actual FAT-entry is an endcluster, write new values for
                       ;follow-cluster to FAT-entry           

                       ;ashbcl - ashbcl+3 contain clusteraddress of new dircluster
                       ; or  ofdecl - ofdecl+3 ????
 
        ldi r26,low(hdbube) ;hd-buffer-begin $0600                                      d4b6-d4c5
        ldi r27,high(hdbube)

l19060: st x+,r06      ;#$00 clears new generated empty dirsectors of new dircluster
        cpi r27,high(hdbuen) ;HD-buffer-end+1   
        brne l19060
 
        lds r16,geaccl ;new followcluster of directory
        sts ashbcl,r16
        lds r16,geaccl+1 ;this is different as the 1541
        sts ashbcl+1,r16 ;1541 uses general actual cluster (not actual SA HD-buffer cluster)
        lds r16,geaccl+2
        sts ashbcl+2,r16
        lds r16,geaccl+3
        sts ashbcl+3,r16
  
                       ;ashbcl - ashbcl+3 contain clusteraddress of new dircluster
        sts ashbsc,r06 ;#$00 sets actual SA HD-buffer sector in this cluster to first sector 
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector

l19070: ldi r16,$c4    ;makes override-bit for write from AVR-HD-buffer to HD
        sts ovhbtw,r16 ; and use actual hardware

        call l14720   ;write hd-buffer to disk at acscas & ashbcl         
                       ; write cluster-address
                       ;writes new, empty, filled with #$00 dirsector to HD

        lds r16,ashbsc ;actual SA HD-buffer sector in this cluster
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        subi r16,$fe   ;-$fe -254 same as +2   adds 2   makes next sector in this cluster       
        sts ashbsc,r16 ;sets actual SA HD-buffer sector in this cluster 
        lds r17,sepecl ;sectors per cluster 1,2,4,8,$10,$20
        lsr r16
        cp r16,r17
        brcs l19070    ;writes all sectors of cluster to HD                             d4b6-d4c5        
                       ;one must fill all sectors of a cluster with #$00
                       ; tested at 3.5" HD disk (2 sectors per cluster)

                       ;opfde. still shows to end-#$00-direntry
                       ;                   (or #$f0 if endcluster without end-#$00-direntry)
                       ;ac..as shows to new made dircluster
        sts ashbsc,r06 ;#$00 necessary???
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector

        lds r26,ofdeve ;open free direntry position
        cpi r26,$f0
        brcs l19090    ;b.i.there is a end-#$00-direntry (20,40,...c0,e0)

                       ;=there is no end-#$00-direntry (f0)
                       ; = dir ends exactly at end of a cluster
        sts ofdeve,r06 ;#$00 makes dir-vector to #$00
        
        sts ofdesc,r06 ;#$00 makes dir-sector in this cluster to first sector and first half  

        ldi r30,low(ofdecl) ;open free dir cluster
        ldi r31,high(ofdecl)
  
l19080: ldd r16,z+ashbcl-ofdecl ;reads from actual SA HD-buffer cluster  
        st z+,r16      ;stores to open free dir entry cluster
        cpi r30,low(ofdecl+4) 
        brne l19080    ;copies position, sector-in this-cluster and cluster (1+4bytes)

l19090: ret            ;                                                                     d4c5
;------------------------------------------------------------------------------------------------
l19100: ldi r16,$11    ;internal read-address                       close internal addresses d4da
        sts icsawo,r16 ;SA-only without bits whether open/close/SA    =$83 at 1541           d4dc
        rcall l18780   ;free things of actual SA 
        ldi r16,$12    ;internal write-address
        sts icsawo,r16 ;SA-only without bits whether open/close/SA    =$83 at 1541
        rjmp l18780    ;free things of actual SA                                             d4e5 
;------------------------------------------------------------------------------------------------
l19110: ldi r25,$50    ;50--'w'
        call l13080

        ldi r30,low(geaccl+4) ;general actual cluster     copy values from geaccl to ashbcl  d6d0    
        ldi r31,high(geaccl+4) ;                                       !! changes Z!!

l19120: ld r16,-z      ;copies from general actual cluster ($80/81)
        std z+ashbcl-geaccl,r16 ;stores to actual SA HD-buffer cluster (=$06/07 - $0e/0f)
        cpi r30,low(geaccl)
        brne l19120
                       ;what about copying bufferpointer and sector in this cluster????
        ret  
;------------------------------------------------------------------------------------------------
                       ;from l19240
l19130:                ;                    swap actalcluster- and dircluster-values (not buffer)
        ldi r30,low(ofdeve+6) ;open free dir entry vector                    and read dircluster
        ldi r31,high(ofdeve+6)
        
l19140: ld r16,-z      ;swaps open free dir entry sector in this cluster       $0291/0292 at 1541
        ldd r17,z+ashbve-ofdeve ; and actual SA HD-buffer sector in this cluster   $06/07 at 1541
        std z+ashbve-ofdeve,r16 ;                                                  $06/07 at 1541
        st z,r17       ;                                                       $0291/0292 at 1541
                       
                       ;                                                                d79a/d7a2
        std z+asdeve-ofdeve,r16 ;copies open free dir entry.. ($0291/92)                d79f/d7a7
                       ; to actual direntry-... of actual SA  (0206,x/0266,x)               
        
        cpi r30,low(ofdeve) ;copies pointer, sector-in-this-cluster and cluster 
        brne l19140    ;swaps position, sector-in-this-cluster and cluster (1+1+4bytes)
                       ;actual cluster is now end of dir
         
                       ;ashbve, ashbsc & ashbcl show now to first of 3 free direntries
        
                       ;makes actual dircluster -> actual cluster
                       ;(backups actual cluster (unused???)->memory of dircluster)
                       ;(startcluster of new file = acclgl)

                       ;ofdeve   <-> ashbve   actual SA HD-buffer vector  
                       ;ofdesc   <-> ashbsc   actual SA HD-buffer sector in this cluster
                       ;ofdecl   <-> ashbcl   actual SA HD-buffer cluster 
                       ;ofdecl+1 <-> ashbcl+1
                       ;ofdecl+2 <-> ashbcl+2
                       ;ofdecl+3 <-> ashbcl+3

                       ;the direntry-values which are stored for the actual SA
                       ; (asdeve-asdecl 0260,x/0266,x) must show to the first dir-partentry
                       ; because this is important for the DOS to determine whether a
                       ; file is actually opened (e.g. at scratch l21940) 
                       ;!! when the file is closed later then the vector must be changed
                       ;   from the first to the last dir-partentry
                       ;the amount of dirpartentries of complete direntry is made at l19340

        call l14790    ;read actual sector of actual SA (!!swapped!!) 
                       ;read dirsector where first of 3(/1) free direntries is
                       ;load dirsectot dirctly without swapping isn't possible, 
                       ; because the followcluster must be computed

        lds r26,ashbve ;HD-pointer to first of 3(/1) free dirpartentries (!!swapped!!)
        
        lds r27,ashbsc ;%.......0/%.......1 actual SA HD-buffer sector in this cluster
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        andi r27,$01   ;             00 / 01  masks bit for first/second half of HD-buffer 
        subi r27,$100-high(hdbube) ;-fa  -fa  X-high shows to correct half of HD-buffer (#$06/07)
                                   ;  6    7
        ret
;------------------------------------------------------------------------------------------------
                       ;from l18040 (rename)
l19150:                ;                  add #$0020  00  20  40  60  80  a0  c0  e0
                       ;            =subtract #$ffe0
        subi r26,low($10000-$0020)  ;subtract #$e0
                                    ;add #$20         20s 40s 60s 80s a0s c0s e0s 00c
        
        sbci r27,high($10000-$0020) ;subtract #$ff    06  06  06  06  06  06  06  06
                                    ;add#$01          06  06  06  06  06  06  06  07  
                       ;.........................................................................
                       ;from l19280 (create direntry part2), l19320
l19160:                ;                  test whether hdbuffer is at end: 
                       ;                  if so then write it back to HD and read follwsector and 
                       ;                  make X-vector to begin of HD-buffer
        cpi r27,high(hdbuen) ;HD buffer end
        brne l19170    ;b.i.in actual dir entry there is still space for next direntry
                       
                       ;=write this direntry to HD and read follow dirsector
        call l14590    ;writes last read sector back to HD using acsehb
                       ; actual sector in HD-buffer (in lba)        

        call l14760    ;read follow-512-HD-sector of actual cluster

        ldi r26,low(hdbube) ;HD-buffer begin
        ldi r27,high(hdbube)
l19170: ret
;------------------------------------------------------------------------------------------------
                       ;from l18040 (rename), l20680 (save)
l19180:                ;        create dir-entry (part1 search or make 3 free direntries)    d6e4
                       ;it's important that l20680 rcall l19980 (create and compare shortnames)
                       ;is made before this routine, because only then the complete dir is
                       ;searched for 3 free direntries in a chain

                       ;opfd.. open free dir... contain:
                       ;  -if 3 free direntries in a chain: address of first of 3 free direntries
                       ;  -if no 3 free direntries in a chain: address of end of dir:
                       ;         -if #$00-endflag direntry: address of this #$00-endflag direntry
                       ;         -if no #$00-endflag direntry (= dir ends exactly at end of a 
                       ;             cluster): address of last direntry of dir (no #$00-endflag
                       ;                                                              direntry) 
                   
                       ;tested at a FAT12 disk:
                       ;if a dirsector is filled with 16 direntries:
                       ; there is no follow dirsector with no single entry #$00
                       ;=> DOS recognized end of dir when endcluster found, 
                       ;even if no direntry with #$00 exists   

                       ;tested at FAT12 disk, 1.44" (= 2 sectors per cluster)
                       ;if a dir (at FAT12 a subdir not the rootdir) is increased so that
                       ; a new dircluster must be made, then all sectors of the new dircluster
                       ; are filled with #$00 (no only the first of up to 64)
                        
                       ;backup SA, channel, sector, track
                       ;set SA=17 ($11) = internal read channel
                       ;backup filetype
                       ;set and compare drivenumber

        ldi r25,$20    ;20--'w'  20-- 57--   20--'r'  20-- 52--
        call l13080         

        lds r16,ofdecl+3 ;open free dir entry cluster highest = $0291 at 1541                d715
        andi r16,$ff
        brpl l19230    ;b.i.there are 3(/1) free direntries in a chain in actual dir    d718/d71a
                       ;   and opfde. show to it

                       ;there are no 3(/1) free direntries in a chain                            d726  
                       ;=>add 3(/1) direntries at the end of the dir

l19190: andi r16,$f0   ;masks bit 7-4
        cpi r16,$b0    ;flag whether opfd..-values contain value of end of dir
        breq l19200    ;b.i.opfd..-values contain value of end of dir

        ldi r17,$28    ;28--  40--   =opfd..-values don't contain value of end of dir 
        jmp syserr     ;system error

l19200: lds r16,ofdesc ;open free dir entry sector in this cluster
        lsr r16        ;flag whether first/second half of sector -> carry
        brcc l19220    ;b.i.first half of 512-bytes HD-buffer (=at least 8 direntries in 
                       ; second half free)

        lds r17,sepecl ;sectors per cluster
        inc r16        ;increments sector in this cluster
        cp r16,r17     ;compares incremented sector in this cluster and sectors per cluster
                       ; (doesn't change carry)
        brcs l19220    ;b.i.there is at least 1 sector behind the actual dirsector
                       ;    (= there are at least 16 free direntries at end of dir)  

                       ;=end of dir is in second half of 512-bytes HD-buffer
                       ; =>could be that in this dir-sector there isn't space for
                       ;    3 free direntries at the end

        lds r16,natac0 ;name-tail-counter0
        bst r16,5      ;copies flag for real-short-name / part of long-name to t-flag
        
        ldi r16,$b0    ;default for CBM
        brts l19210    ;b.i.part of a longname = CBM (3 free partdirentries needed)

        ldi r16,$f0    ;= real short-name = FOReign (1 free partdirentries needed)

l19210: lds r26,ofdeve ;open free dir entry vector /vector = $0292 at 1541
        cp r26,r16     ;$b0/$f0
        brcs l19220    ;b.i.                                                                d72e?
                       ;  -CBM: vector=$00,20,40,60,80,a0 (=> a0,c0,e0 are free for new entry)
                       ;  -FOR: vector=$00-$e0 (=> e0 is free for new entry)
                       ;=vector is c0,e0,f0 => new direntry doesn't fit in this dirsector
                       ;c0 = 2 free direntries at end of dir
                       ;e0 = 1 free direntry at end of dir
                       ;f0 = no free direntry at end of dir (=dir ends exactly at clusterend)
                       ; => must make new dirsector
                       
        rcall l19050   ;make new dircluster                                                  d730

l19220: lds r16,ofdecl+3 ;open free dir entry cluster highest
        andi r16,$0f   ;masks off bit 31-28
        sts ofdecl+3,r16 
        
l19230: ldi r25,$2f    ;2f--'w'   2f--'r' 
        call l13080 
        ret            ;ofdeve, ofdesc & ofdecl show now to first of 3/1 free direntries     d73a
;------------------------------------------------------------------------------------------------
                       ; between l19230 and l19240 is:
                       ;  rcall l21890 ;allocates startcluster, set flag f. listener,
                       ;                reset vectors, allocates startcluster   d9e9

                       ;save:
                       ;l20690:     
                       ;rcall l19980  
                       ;   search and compare input-shortname with dirnames
                       ;   it's impossible to make this at the first direntry search
                       ;    because there the filetype is unknown
                       ;    => dir search must be made (at least) twice (slower)
                       ;   and search 3 free direntries in a chain
  
                       ;rcall l19180   
                       ;   create direntry  part1                                       d9ec       
                       ;   allocates dir-cluster (if this new direntry doesn't fit into directory)
                       ;   ofdeve, ofdesc & ofdecl show now to first of 3 free direntries
      
                       ;rcall l21890
                       ;   allocates startcluster, set flag f. listener, reset vectors   d9e9
                       ;   allocates startcluster 

                       ;ldi r16,$00    ;flag for open
                       ;rcall l19240   ;create direntry part2                            d9ec       

                       ;dangerous   danger to loose datas:
                       ;open a file (file1) for write/save
                       ;  -> create dir-entry (part1)
                       ;  -> search and allocate the startcluster of the new file
                       ;  -> create dir-entry (part2)
                       ;     => ! the startcluster is allocated in the FAT in the AVR-RAM only
                       ;        ! the startcluster isn't allocated in the FAT on the HD 
                       ;-bad, dangerous version: 
                       ;  startcluster is written into direntry
                       ;  => direntry of file1 shows to startcluster, but this cluster isn't
                       ;     allocated in the FAT on the HD (only allocated in the FAT in RAM)
                       ;     (when the files is closed the the FAT is written from RAM to HD
                       ;      and everything is ok)
                       ;     the file isn't closed, e.g. caused by a reset of the AVR
                       ;     => the startcluster of file1 isn't allocated in the FAT on HD,
                       ;        but the direntry of file1 shows to it
                       ;  the next file is opened (file2)                       
                       ;  -> create dir-entry (part1)
                       ;  -> search and allocate the startcluster of the new file
                       ;  -> create dir-entry (part2)
                       ;     => the same startcluster as at file1 is allocated again for file2
                       ;  close file2 
                       ;     => the startcluster of file2 is correctly written to the FAT of HD
                       ;  => file1 has the '*'-mark in the C64-dir that it isn't closed
                       ;     file2 is correct in dir
                       ;     direntry of file1 and of file2 show to the same startcluster
                       ;     (scratch file1 at C64: No data-loss, because the NLQHD-scratch-
                       ;      routine doesn't free clusters of files having the filelength 0)
                       ;  delete fil1 at an Windows-PC:
                       ;     startcluster of file1 is freed in the FAT, but because this is the
                       ;     same startcluster for file2 the startcluster of file2 is also freed
                       ;     in the FAT
                       ;  the next file is opened (file3)     
                       ;  -> create dir-entry (part1)
                       ;  -> search and allocate the startcluster of the new file
                       ;  -> create dir-entry (part2)
                       ;     => the same startcluster as at file1 and of file2 is allocated 
                       ;        again for file3
                       ;  => datas of file2 are overwritten with datas of file3
                       ;  => datas of file2 are lost!!!!
                       ; advantage of this version would be:
                       ;   the direntry of a not-closed file shows to its startcluster
                       ;    so the modify-command could work
                       ;-good, undangerous version:
                       ;   the startcluster is stored intp the AVR-memory
                       ;   the direntry shows to startcluster 00000000
                       ;   => when this file isn't close and deleted under Windows then no 
                       ;       cluster (startcluster of a different file) isn't freed
                       ;   = no data-loss
                       ;   when the file is closed, then the startcluster is written from 
                       ;    AVR-memory to the direntry
                       ; disadvantage: the startcluster of a not-closed file shows always              
                       ;  to 00000000 => modify-command cannot work. 
;------------------------------------------------------------------------------------------------
                       ;from l20680
l19240:                ;                                          create dir-entry (part2)   d73d
                       ;in opfde. are values of 3 free direntries (first dir-partentry)
                       ;  at rename: if FOR then perhaps 1 free partentry only
                       ;in ac..ge are values of startcluster of file
 
                       ;?? reads dirsector, writes direntry into it (1-3 partdirentries),
                       ; writes dirsector if partialdirentries are full, 
                       ; copies values (startcluster filelength...) into it
                       ; writes it to HD  
                     
        sts cm0071,r16 ;stores flag for save (00) / rename (80)
                       ;00 = save
                       ;80 = rename and same direntry
                       ;c0 = rename and different direntry
                       ;CBM-memory 0071
                       ;at test whether file is opened: counter for SA  
                       ;at create direntry part2: flag for save / rename             

        ldi r25,$40    ;40--'w'
        call l13080

        rcall l19130   ;swap actualcluster and dircluster and reads sector

        lds r16,natac0 ;name-tail-counter0 (set at rcall l?????)
        bst r16,5      ;copy flag for real-short-name / part of long-name to t-flag
        
        ldi r16,$00    ;default for FOReign: amount of dirpartentries of complete direntry

        brts l19250    ;b.i.CBM-file (or DIR) = b.i.direntry with three (2+1) partentries
        rjmp l19340    ;=real short-name = FOReign (write 1 direntry only)

l19250:                ;=CBM-file = write 3 direntries (always)
        ldi r28,low(innash) ;inputname short ($0140)
        ldi r29,high(innash) ;must be at $..00, ..20, ..40, ..60, .. 80, ..a0, ..c0, ..e0
        ldi r24,$00    ;clear checksum
        
l19260: ld r16,y+      ;read filename char 0-10 /1-11  8+3chars
        lsr r24        ;shift checksum right
        brcc l19270    ;b.i.(old bit0) now carry is low (=don't add #$80)
        
        subi r24,$80   ;add #$80
        
l19270: add r24,r16    ;add actual char to checksum
        
        mov r16,r28
        andi r16,$1f
        cpi r16,$0b
        brne l19260    ;b.i.end of filename not yet reached

        sts ldchsu,r24 ;lde-checksum

        ldi r29,high(buwlfn) ;buffer Windows95 long filenames 
                       ;UNICODE length: 2*(16+1+3)=40  
        ldi r17,$2d    ;2d-- 45--
        ld r16,x       ;read first byte of (free) direntry
        cpi r16,$00
        breq l19280    ;b.i.end of dir
 
        cpi r16,$e5
        breq l19280    ;b.i.free direntry        

        lds r18,cm0071
        tst r18
        brpl l19300    ;b.i.save, not rename           

        cpi r16,$42    
        brne l19310    ;b.i.not correct flag-char for first partentry
.db 0
l19280: ldi r16,$42
        ldi r28,low(buwlfn)+$0d*2 ;shows to 14th char of UNICODE-doublechar   char13
        rcall l19500   ;write first shortentry----------------
        rcall l19160   ;test whether hdbuffer is at end: 
                       ;if so then write it back to HD and read follwsector and 
                       ;make X-vector to begin of HD-buffer
        lds r24,ldchsu ;lde-checksum
        rcall l19930   ;compute length of inputfilename (long) changes Y  
                       ;r19 = length  
        ldi r29,high(buwlfn) ;buffer Windows95 long filenames 
                       ;UNICODE length: 2*(16+1+3)=40  
                        
l19290: ldi r17,$2e    ;2e-- 46--
        ld r16,x       ;reads first byte of (free) direntry
        cpi r16,$00
        breq l19320    ;b.i.end of dir
 
        cpi r16,$e5
        breq l19320    ;b.i.free direntry        

        lds r18,cm0071
        tst r18
l19300: brpl l19360    ;b.i.save, not rename           

        cpi r16,$01    
l19310: brne l19360    ;b.i.not correct flag-char for first partentry

l19320: ldi r16,$01    ;first byte of long direntry
        ldi r28,low(buwlfn) ;shows to 1th char of UNICODE-doublechar   char0
        rcall l19500   ;write second shortentry----------------
        rcall l19160   ;test whether hdbuffer is at end: 
                       ;if so then write it back to HD and read follwsector and 
                       ;make X-vector to begin of HD-buffer

l19330:                ;is this necessary???????????????????????????????
        lds r16,ashbsc ;actual sector in this cluster of AS
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        andi r16,$fe   ;masks off bit for first/second half

        mov r17,r27    ;highbyte HD-buffer-vector (06/07 of 0600-07e0)
        andi r17,$01   ;masks bit for first/second half
        add r16,r17
        sts ashbsc,r16 ;this is necessary because it is changed if the 3 direntries are
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
                       ; 06c0,06e0,0700   or 06e0,0700,0720 
                       ;is this necessary????????????????????????????????
        
        ldi r16,$02    ;amount of dirpartentries of complete direntry (CBM-file)
                        
l19340:                ;is this necessary???????????????????????????????
        sts ashbve,r26 ;HD-pointer to last of 3 free direntries (!!swapped!!)
                       ;stores pos of last of 3 direntries -> when the file will be closed
                       ;then here (=shortentry) the filelength must be written 
                       ;is this necessary???????????????????????????????
   
        sts asdeam,r16 ;actual SA dir-entry amount of dirpartentries (0,1,2)         
   
        ldi r28,low(innash) ;inputname short
        ldi r29,high(innash)
 
        lds r18,cm0071      
        ldi r17,$2f    ;2f-- 47--
        ld r16,x       ;reads first byte of (free) direntry
        cpi r16,$00
        breq l19380    ;b.i.end of dir
 
        cpi r16,$e5
        breq l19380    ;b.i.free direntry        

        tst r18
l19350: brpl l19360    ;b.i.save, not rename           

        ori r26,$1a    ;0600->061a  07e0->07fa

        lds r16,cfstcl+1 ;command/filename startcluster low of second file in inputbuffer     
        ld r19,x+      ;061a startcluster of direntry
        cp r16,r19
        brne l19360          
             
        lds r16,cfstcl+$5+1 ;command/filename startcluster high of second file in inputbuffer     
        ld r19,x+      ;061b startcluster of direntry
        cp r16,r19
        brne l19360          
        
        subi r26,$08   ;061c->0614 
        lds r16,cfstcl+$a+1 ;command/filename startcluster higher of second file in inputbuffer     
        ld r19,x+      ;0614 startcluster of direntry
        cp r16,r19
        brne l19360          
         
        lds r16,cfstcl+$f+1 ;command/filename startcluster highest of second file in inputbuffer     
        ld r19,x+      ;0615 startcluster of direntry
        cp r16,r19
        breq l19370          

l19360: jmp syserr     ;system error  2d-- 2e-- 2f--   45-- 46-- 47--
                       ;                  wanted direntry not free
l19370: andi r26,$e0   ;0616->0600

l19380: ld r16,y+
        st x+,r16      ;copies shortname into direntry 0600-060a  07e0-07ea
        cpi r28,low(innash+$0b)
        brne l19380

        tst r18        
        brpl l19400    ;b.i.save, not rename
       
                       ;=rename
        andi r18,$40   ;masks bit whether new direntry is at a different position as old direntry 
        breq l19460    ;b.i.at same direntry

                       ;=new direntry is at a different position as old direntry 
        ldi r28,low(tmvade) ;temporary memory values of direntry
        ldi r29,high(tmvade) ;contains unchanged values of a direntry at rename

l19390: ld r16,y+      ;copies temporary memory values of direntry to
        st x+,r16      ; unchanged parts of old direntry
        cpi r28,low(tmvade+$15)
        brne l19390    ;copies 060b-061f

        rjmp l19460    ;----

l19400: lds r23,cm024a ;open actual filetype
        ldi r16,$28    ;2*20=40=$28  end of filename of CBM-file 16+1+3
        cpi r23,$06
        ldi r16,$20    ;fileattribute = archive bit is set
    
        brne l19410    ;b.i.CBM

        ldi r16,$30    ;fileattribute = archive bit is set  DIR-bit is set  =DIR
    
l19410: st x+,r16      ;060b 07eb fileattribute
        
        ldi r17,$ec    ;counter
l19420: st x+,r06      ;clears 060c-061f
        inc r17
        brne l19420
     
        rcall l19480   ;copy geaccl -> asstcl  
                       ;genearl actual cluster -> actual SA start-cluster
                       ; (startcluster of file is swaped???)
                       ;chanche r12-r15
/*
                       ;this would be the dangerous version,
                       ; where the startcluster is at once written into the direntry
        ldi r17,$0c    ;counter
l19430: st x+,r06      ;clears 060c-0613
        inc r17
        cpi r17,$14
        brne l19430
        
        lds r16,geaccl+2 ;startcluster of file higher (!!swapped!!)
        st x+,r16      ;0614 
                         
        lds r16,geaccl+3 ;startcluster of file highest (!!swapped!!)
        st x+,r16      ;0615 

        ldi r17,$16
l19440: st x+,r06      ;clears 0616-0619
        inc r17
        cpi r17,$1a
        brne l19440
 
        lds r16,geaccl ;startcluster of file low (!!swapped!!)
        st x+,r16      ;061a 
                         
        lds r16,geaccl+1 ;startcluster of file high (!!swapped!!)
        st x+,r16      ;061b 

        ldi r17,$fc    
l19450: st x+,r06      ;clear 061c-061f (filelength)
        inc r17
        brne l19450
*/
                       ;at end: X shows to next direntry
       #if (partname == 6) | (partname == 7)    
        #message 644-NLQ-HD/full
        call l27540    ;write time and date into direntry
       #endif

l19460: call l14590    ;write sectors with retry  actual sector HD-buffer = dir-sector  
                       ;send block-write-command to HD (write 1 sector only)
                       ;write dir-sector with allocted enty to HD
                       ; write sector-address  

                       ;write back dir-or fat????????????????????????????????????????  

        ldi r30,low(ofdeve+6) ;open free dir entry vector 
        ldi r31,high(ofdeve+6)
        
l19470: ld r16,-z     
        ldd r17,z+ashbve-ofdeve ;reswaps   open free dir entry sector in this cluster
        std z+ashbve-ofdeve,r16 ; and    actual SA HD-buffer sector in this cluster  
        st z,r17
        cpi r30,low(ofdeve) 
        brne l19470    ;reswaps position, sector-in this-cluster and cluster (1+1+4bytes)
                       ;actual cluster is now end of dir
      
                       ;makes actual cluster -> dircluster
                       ;restores actual cluster (startcl.of new file) from memory of dircluster
        
        ldi r25,$4f    ;4f--'w'
        call l13080

        ret            ;                                                                     d7b3
;------------------------------------------------------------------------------------------------
                       ;from l19420, l19780 
l19480: lds r12,geaccl ;startcluster of file low
        lds r13,geaccl+1 ;startcluster of file high
        lds r14,geaccl+2 ;startcluster of file higher
        lds r15,geaccl+3 ;startcluster of file highest
                       ;.........................................................................
                       ;from l19870
l19490: sts asstcl,r12 ;actual SA start-cluster low        
        sts asstcl+1,r13 ;actual SA start-cluster high
        sts asstcl+2,r14 ;actual SA start-cluster higher
        sts asstcl+3,r15 ;actual SA start-cluster highest                   
        ret
;------------------------------------------------------------------------------------------------  
                       ;from l19280, l19320
l19500: st x+,r16      ;$42/$01                                      copy first/second shortentry 
                       ;                  r16=first byte 
                       ;                  r17= (free?)  
                       ;                  r18=counter
                       ;                  r19=inputnamelength
                       ;                  r20
                       ;                  r21
                       ;                  r22
                       ;                  r23=open actual filetype
                       ;                  r24=checksum
                       ;            X=r26,r27=writevector into HD-buffer
                       ;            Y=r28,r29=readvector=buwlfn buffer Windows95 long filenames
                       ;            Z=r30,r31=
l19510: ld r20,y+      ;UNICODE low from LFN-buffer
        ld r21,y+      ;UNICODE high from LFN-buffer

        lds r23,cm024a ;open actual filetype
        ldi r16,low(buwlfn)+$2a    ;2*20=40=$28 ->$2a end of filename of CBM-file 16+1+3
        cpi r23,$06
        brne l19520    ;b.i.CBM

        ldi r16,low(buwlfn)+$22    ;2*16=32=$20 -> $22  end of filename of DIR-file 16
                  
l19520: cp r28,r16     ;compares readvectorlow from LFN with end of filename
        brcs l19530    ;b.i.filename not yet at end

        ldi r20,$00    ;default for first byte behind filename #0000
        ldi r21,$00   

        breq l19530    ;b.i.exactly at pos behind filename

        ldi r20,$ff
        ldi r21,$ff    ;#ffff fillebytes behind end-#0000-flag

l19530: st x+,r20      ;unicode low  01..09  0e..18  1c..1e  
        st x+,r21      ;unicode high 02..0a  0f..19  1d..1f
                       ;          -> 03..0b  10..1a  1e..00
        mov r20,r26    ;Xlow
        andi r20,$1f   ;0600-061f -> 00-1f    07e0-07ff -> 00-1f
        cpi r20,$0b
        brne l19540  

        ldi r16,$0f    ;attribute-byte  0f=lonf filenameentry
        st x+,r16      ;060b 062b  07eb

        st x+,r06      ;#$00  060c 062c  07ec

        st x+,r24      ;checksum  060d 062d  07ed
                       ;      ->  060e 062e  07ee
l19540: cpi r20,$1a
        brne l19550
         
        st x+,r06      ;#$00      061a 063a  07fa
        st x+,r06      ;#$00      061b 063b  07fb  
                       ;      ->  061c 063c  07fc

l19550: cpi r20,$00
        brne l19510    ;b.i.end of direntry not reached -> copy next char

        ret
;------------------------------------------------------------------------------------------------
                       ;from l17160
l19560:                ;                                                               open  d7b4
        ldi r25,$11    ;11----
        call l13090

       #if partname >= 2    
        #message 644-non-IEC-ATA
        rcall l18910   ;test whether the SD has been changed and if so then free all buffers
       #endif

        lds r16,icsawo ;IEC secundary address without bits for SA,open,close  ($83) 
        
        mov r25,r16    ;xx--
        call l13130
       
        ;sts temesa,r16 ;temporary memory secundary address = 024c at 1541  necessary???
                       ;backup actual SA
                       ;so far it's faster and easier to use the normal SA and not
                       ; SA17 for internal read-SA        !!!!!!!!!!!!!!!!!
        rcall l17440   ;xx-- xx--  initialize command/filename-tables/values                 d7b9 
                       ;Y-reg r28/29 shows to begin inputbuffer
                       ;Z-reg r30/31 shows to end of startclustertable of open-tables

        sts cocono,r06 ;#$00 clears command commandnumber                                    d7bc

        lds r17,inbube ;loads first character of inputbuffer
       
        mov r25,r17    ;xx--
        call l13130
       
        cpi r16,$00
        brne l19570    ;b.i.not Load (not SA=0)                                              d7c5
        
        cpi r17,$2a    ;'*'
        brne l19570    ;b.i.not load last file again                                         d7c9
        
        lds r15,laprcb+3 ;last program clusterbegin                                          d7cb
        and r15,r07    ;#$ff   
        brmi l19600    ;b.i.laprcb+3>$0f = illegal because cluster is 28bits =               d7cd
                       ;    b.i.last program not yet set

        lds r12,laprcb ;  007e at 1541 026f at 1541
        lds r13,laprcb+1               
        lds r14,laprcb+2            
        
        lds r20,laprfl ;last program filelength
        lds r21,laprfl+1 ;necessary at FAT32 for calculating necessary bytes of end-cluster
        lds r22,laprfl+2
        lds r23,laprfl+3
                
        ldi r16,$05    ;%....1101 makes flags for copy into 256bytes CBM-buffer
        sts ashbtr,r16 ;actual SA HD-buffer-transfer read (0-17)
                       ;don't know where to make this command?????????????????????????    

        sts ashbve,r06 ;#$00 clears actual SA HD-buffer vector               d7cf/d7df
        sts ashbsc,r06 ;#$00 clears actual SA HD-buffer sector in this cluster 
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        
        sts ashbcl,r12 ;actual SA HD-buffer cluster low                                 
        sts ashbcl+1,r13 ;actual SA HD-buffer cluster high
        sts ashbcl+2,r14 ;actual SA HD-buffer cluster higher
        sts ashbcl+3,r15 ;actual SA HD-buffer cluster highest                           d7cf/d7df

        sts asflre,r20 ;actual SA filelength (remaining) (for EOI-calculating)
        sts asflre+1,r21
        sts asflre+2,r22
        sts asflre+3,r23 ;actual SA filelength (remaining) (for EOI-calculating)
                       
                       ;it's not necessary to make the drivenumber, because the drives are
                       ;computed to clusters => the old cluster contains the drivenumber

        ldi r16,$02    ;filetype=PRG                                                         d7d6    
        sts cffljo,r16 ;command/filename flag for joker =                e7 at 1541          d7da   

       #if partname == 1    
        #message 162-IEC-ATA-V2
        call l10750    ;single-LED on                                                        d7e1

       #else
        #message 644-non-IEC-ATA
        call l10780    ;active-LED on                                                        d7e1
       #endif 

        rcall l21840   ;open a channel for read & read start-sector                          d7e4

        ldi r16,$02    ;filetype=PRG  
        sts asfity,r16 ;actual SA file-type                (= ec,x at 1541)         d7ed
       ;sts asdrnu,??? ;actual SA drive-number             (= ec,x at 1541)         d7ed                                          

        rjmp l17250    ;make diskstate+ret                                                   d7f0
        
l19570: cpi r17,$24    ;'$'                                                                  d7f3
        brne l19590    ;b.i.not directory                                                    d7f5
                
        ;tst r16       ;                                                                     d7fa    
        ;brne l19580   ;b.i.not load"$" or not open2,x,0,"$                                  d7fa

        jmp l20790    ;create first directory-block (with header-line) = open "$" for read   d7fc
                       ; + ret -------------
l19580:                ;??????????????????                                                   d7ff

l19590: cpi r17,$23    ;'#'                                                                  d815
        brne l19610    ;b.i.not direct-access                                                d817

        ldi r17,$62    ;62-- 98--   =direct access  
        jmp syserr     ;system error
                
l19600: ldi r16,$02    ;value for PRG  = load"*" but there is no old prg                     d81c
        sts opfity,r16 ;open-file-type  0296 at 1541

l19610: rcall l17320   ;search colon :                                            =   load a file
        brne l19620    ;b.i.colon found
        
        ldi r30,$00    ;clears amount of found commas  = no colon found
        rjmp l19650

l19620: cpi r30,$00    ;amount of so far found commas  = colon found                         d834
        breq l19640    ;b.i.no comma found before colon

l19630: ldi r16,$1e    ;30,syntax error 30--
        jmp l13980    ;-----------------
        
l19640: dec r28        ;r28,r29=Y shows now to colon                                         d83c
        breq l19650    ;b.i.colon is first character of inputbuffer
        
        dec r28        ;Y shows now to (last character of) drivenumber

l19650: sts cfpobc,r28 ;open-position of drivenumber = 027a at 1541 = part of table          d840
        
        ldi r17,$8d    ;shift-return = character that cannot be in a filename
        call l16460    ;analyse inputstring until end                                        d845
                     
        inc r30        ;increments amount of found commas
        sts opamco,r30 ;open amount of commas (=0278 at 1541)

        call l16540    ;backups amount of commas; sets value for 1 comma                     d84c
                       ;extracts drivenumbers for one file from inputbuffer
                       ;set value for 1 comm = 1 filename
                       ;important at open2,08,2,"abcd,p,w"
                       ;that only file "abcd" is searched 
                       ; and that there is no search for the files "p" and "w"   
   
        call l16640    ;test whether drivenumbers are legal                                  d84f
                       ; and initialize SD if it changed
                       ; if illegal drivenumber (1) then drive not ready
      
        call l16770    ;searches 1 input-filename-entry in dir and                           d852
                       ;stores values of them in table (only 1 filenameentry)
                       ;the dirsector containing the wanted filename is in HD-buffer

        sts cm0258,r06 ;#$00 clears CBM-memory record-length?
        sts opfimo,r06 ;#$00 clears filemode (read/write)
        sts cm024a,r06 ;#$00 clears actual filetype

        ldi r30,$01    ;Z shows to second filenamentry-table                 1581/1541: 9713/d860
        lds r17,cm0277 ;old amount of commas/filenames (",p,r" is included)                  d860 
        cp  r30,r17
        brcc l19660    ;b.i.0-1 commas/filenames (xyz,p,r  p and r is count as filename by me)
 
                       ;= 2-ff commas in inputstring
        rcall l20740   ;take filetype (Del Seq Prg Usr Rel (41 71 81 Nat For) -> cm024a

        ldi r30,$02    ;                                                                     d869
        lds r17,cm0277 ;old amount of commas/filenames??                                     d869 
        cp  r30,r17
        brcc l19660    ;b.i.0-1 commas/filenames (xyz,p,r  p and r is count as filename by me)
                       
                       ;= 3-ff commas in inputstring
        cpi r18,$04    ;compares filetype                                                    d86f
        breq l19690    ;b.i.rel file
                      
        rcall l20740   ;take filemode (Read Write Append Modify) -> cm0297                   d873

l19660: ;lds r17,temesa ;temporary memory secundary address = 024c at 1541  necessary???     d876
                       ;temesa isn't backuped at l19560
        ;sts icsawo,r17 ;isn't changed at l19560
        lds r17,icsawo ;IEC secundary address without bits for SA,open,close  ($83)          d876 
                            
        cpi r17,$02
        brcc l19670    ;b.i.SA 2-14 =open 
                       
                       ;SA 0-1 =load save
        sts opfimo,r17 ;open filemode (read/write)   0297 at 1541
                       ;00=read 01=write?  load=#$00  save=#$01

                       ;BAM dirty?????????????????????

        lds r16,cm024a ;actual filetype                                                      d887
        andi r16,$ff
        brne l19680    ;b.i.not doesn't matter (not del)?

        ldi r16,$02
        sts cm024a,r16 ;sets PRG as actual filetype

l19670: lds r16,cm024a ;actual filetype                                                      d891  
        andi r16,$ff
        brne l19680    ;b.i.not doesn't matter

        lds r16,cffljo ;command/filename flag for joker and filetype of first                d896
                       ;input-filename              e7,x at 1541
        andi r16,$0f   ;masks filetype-bits
        sts cm024a,r16 ;sets actual filetype from values from direntry                       d89a

        lds r16,cfstcl+$0f ;command/filename startcluster of file           0280,x/0285,x    d89d
        andi r16,$ff   ;r16=startcluster highest of first input-filename
        brpl l19680    ;b.i.00-0f = b.i.filename found                                       d8a0

        ldi r16,$01    ;=file not found (in dir)                                             d8a2
        sts cm024a,r16 ;sets SEQ as actual filetype                                          d8a4

l19680: lds r16,opfimo ;open filemode (read/write)   0297 at 1541                            d8a7
                            ;00=read 01=write?
        cpi r16,$01    ;compares with write
        breq l19700    ;b.i.write

        rjmp l19800    ;read, load   read, append, modify                                    d8ae
        
l19690: ldi r17,$63    ;63-- 99--   = rel file  
        jmp syserr     ;rel-file  -> system error                                            d8b1

l19700:                ;= save  / write
        lds r17,cffljo ;command/filename flag for joker and filetype of first                d8c6
                       ;input-filename              e7,x at 1541
        andi r17,$a0   ;masks joker-bit and not-closed-bit                                   d8c8
        brmi l19720    ;b.i.joker in input filename                                          d8cb
        
        bst r17,5      ;copies not-closed-bit -> t-flag                                      d8cf
        brtc l19710    ;b.i.direntry-file is closed (correctly)                              d8d1
                    
                       ;=save and old-file-wasn't-closed-(correctly)      
        rcall l17730   ;delete direntry & write sector to HD                                 d8d3   
                       ;clear all sub-direntries of 1 direntry  
                       ;problem: only the direntry is freed
                       ; the allocated clusters in the FAT eren't freed
                       ; (freeing them would be too dangerous to loose perhaps data)
        rjmp l20680    ;save and old-file-wasn't-closed-(correctly)                          d8d6
                       ;flag whether direntry file is correctly closed

l19710: lds r16,cfstcl+$0f ;command/filename startcluster of file     0280,x/0285,x          d8d9
        andi r16,$ff   ;r16=startcluster highest of first input-filename
        brpl l19720    ;b.i.00-0f = b.i.filename found
        rjmp l20680    ;save and file doesn't exist------------------------------------------d8de       

l19720:                ;=save and file already exists 
        lds r16,inbube ;reads first character of inputbuffer                                 d8e1        
        cpi r16,$40    ;@
        breq l19760    ;b.i.save&replace

        andi r17,$80   ;                                                                     d8e8
        brne l19740    ;b.i.joker in inputfilename at save                                   d8e9

l19730: ldi r16,$3f    ;63,file exists  63--                                                 d8eb             
        rjmp l19750    ;                                                                     d8ed

l19740: ldi r16,$21    ;33,syntax error  33--                                                d8f0
l19750: jmp l13980     ;                                                                     d8f2
;------------------------------------------------------------------------------------------------
                       ;from l19720
l19760:                ;save&replace                                                         d8f5
        lds r16,cffljo ;command/filename flag for joker & filetype        = e7,x at 1541     d8f5    
                       ; bit7: 0=no joker          1=joker
                       ;       bit 7 is taken from inputfilename
                       ;       bit6-0 is taken every time from dirfilename    
                       ; bit6: 0=can be scratched  1=scratch-protected
                       ; bit5: 0=not closed        1=closed
                       ; bit4: unused?
                       ;bit3-0: filetype  !!!!!change to bit4-0!!!!!!!!!!!!!!!!!!!!     
        andi r16,$0f   ;mask bits for filetype  (chabe to andi r16,$1f)
        lds r19,cm024a ;open actual filetype (bit7-4 is always %0000)
                       ;                     (change that bit7-5 is always %000)       
        cp r16,r19     ;compare filetype of inputname and of dir                             d8f9
        brne l19770    ;b.i.different filtypes -> 64,file type mismatch 64--                 d8fc

        cpi r16,$04    ;                                                                     d8fe
        brne l19780    ;b.i.not REL-file 

                       ;=REL-file -> 64,file type mismatch 64--                              d900      
l19770: rjmp l19840    ;-> 64,file type mismatch 64--                            

l19780: rcall l21890   ;allocate new cluster (starcluster of new file) and set variables     d902
                       ; found free cluster->geaccl
     
        rcall l19480   ;copy geaccl (= startcluster) -> asstcl  
                       ;genearl actual cluster -> actual SA start-cluster
                       ;change r12-r15

        ldi r30,$00    ;set to first entry of open table
        rcall l19910   ;copy values of direntry from open-dir-tables to actual SA-buffer
     
        sts ashbve,r06 ;#$00 clears actual SA HD-buffer vector                         
        sts ashbsc,r06 ;#$00 clears actual SA HD-buffer sector in this cluster 
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        rcall l19110   ;copy geaccl general actual cluster (=startcluster of file)  
                       ; to  ashbcl actual SA HD-buffer cluster                   
                       ; geaccl ->     ashbcl
                       ; $80/81 -> $06/07 - $0e/0f            

        sts asflre,r06 ;clear actual SA filelength (remaining) (for EOI-calculating)
        sts asflre+1,r06
        sts asflre+2,r06
        sts asflre+3,r06 ;actual SA filelength (remaining) (for EOI-calculating)
        
        lds r16,asfla0 ;actual SA flags0 (0-17)
                       ;bit5: 0=not save&replace 1=save&replace ($d91b)
        ori r16,$20    ;set bit for save&replace                                             d91b
        sts asfla0,r16

l19790: ldi r16,$04    ;....1100 flag for read/write only into/from AVR-HD-buffer
                       ;                  don't change CBM-buffer
                       ; so far the routine 'action after Listen' makes the reading of 
                       ;  a HD-sector and copying from CBM to HD-buffer
                       ; this could perhaps be changed in future to    
                       ;  flag for write CBM-buffer to AVR HD buffer and then to HD
                       ;but before the write sector routine must be changed 
        sts ashbtr,r16 ;HD-buffertransfer-read
        sts ashbtw,r16 ;actual SA HD-buffer-transfer write
                       ;don't know whether correct place here??????????????????????????
       
 
        rjmp l20700    ;end of command (jmp c199)                                            d93d
;------------------------------------------------------------------------------------------------
                       ;.........................................................................
                       ;from l19680        
                       ;                open for read, load, append, modify (not save not write)
l19800: lds r16,asfla0 ;flag0 of actual SA
        andi r16,$fc   ;clears flag for directory
        sts asfla0,r16 ;!!!!!!!!!don't know where to make this command!!!!!!!!!!!!!!!!!!!!!!!!!!!

        lds r16,cfstcl+(3*5) ;command/filename startcluster of file        0280,x/0285,x     d940
        andi r16,$ff   ;r16=startcluster highest of first input-filename
        brpl l19820    ;b.i.00-0f = b.i.filename found

l19810: ldi r16,$3e    ;62,file not found  62--          
        jmp l13980

l19820: lds r16,opfimo ;open filemode (read/write)   0297 at 1541                            d94a
                            ;00=read 01=write?
        cpi r16,$03    ;compares with modify
        breq l19830    ;b.i.modify

                       ;flag whether file is closed correctly??????????

l19830: lds r16,cffljo ;command/filename flag for joker and filetype of first                d95c
                       ;input-filename-table              e7,x at 1541
        andi r16,$0f   ;masks filetype-bits of inputstring
        lds r19,cm024a ;actual filetype of dir
        cp r16,r19
        breq l19850    ;b.i.same filetype in inputstring and direntry

l19840: ldi r16,$40    ;64,file type mismatch 64--                                           d965
        jmp l13980

l19850: sts cm0279,r06 ;#$00 clears amount of commas/filename??                              d96c
                       ;set to first entry of open-table
                        
        lds r17,opfimo ;open filemode (read/write)   0297 at 1541                            d96f
                       ;00=read 01=write 02=appen 03=modify?
        cpi r17,$02    ;                                                                     d972
        breq l19860    ;b.i.Append                                                           d974

        rcall l19920   ;opens file for read                                                  d990
        rjmp l20700    ;=not Append                                                          d998
;------------------------------------------------------------------------------------------------
l19860:                ;                                                         append d976/d99a
        cpi r16,$04    ;                                                                     d976
        breq l19840    ;b.i. rel (=append to rel-file)                                       d978

                       ;ashbve - ashbcl still show to last of 3 dirpartentries of
                       ; wanted file
                       ;in HD-buffer there is still the direntry of wanted file
        lds r26,ashbve ;vector to last dirpartentry of wanted filename
        lds r27,ashbsc ;%.......0/%.......1 actual SA HD-buffer sector in this cluster
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        andi r27,$01   ;             00 / 01  masks bit for first/second half of HD-buffer 
        subi r27,$100-high(hdbube) ;-fa  -fa  X-high shows to correct half of HD-buffer (#$06/07)
                                   ;  6    7
        andi r26,$e0   ;0600-061f -> 0600
        ori r26,$14    ;0614 0634 06f4
        st x+,r06      ;clear startcluster higher                                            d97e
        st x+,r06      ;clear startcluster highest 0615 -> 0616
        subi r26,$100-$04 ;add #$04  0616 -> 061a

l19870: st x+,r06      ;clear startcluster low, high, filelength
        mov r16,r26    ;clear 061a-061f
        andi r16,$1f
        brne l19870
                       ;cleared filelength = flag for not-closed file 
                       ;cleared startcluster = important that delete-command of W95 doesn't 
                       ; free crosslinked clusters
        call l14590    ;write last read sector back to HD using acsehb                       d98a
                       ; actual sector in HD-buffer (in lba)        
                       ;write back changed dir-entry-sector--------    

        rcall l19920   ;open file for read                                                   d990
                       ;copy from open-table to as.... values of:
                       ;  direntry, startcluster. filelength
                       ;change ashbve - ashbcl ...
                       ;load startcluster into CBM-buffer
 
        lds r12,ashbcl ;actual SA HD-buffer cluster low        
        lds r13,ashbcl+1 ;actual SA HD-buffer cluster high
        lds r14,ashbcl+2 ;actual SA HD-buffer cluster higher
        lds r15,ashbcl+3 ;actual SA HD-buffer cluster highest   
 
        rcall l19490   ;write r12-r15 -> asstcl  
              
                       ;ashbve, ashbsc is cleared
                       ;ashbcl is set to startcluster of file

        lds r20,asflre ;actual SA filelength              00000001 000000ff 00000100 00000101 
        lds r21,asflre+1
        lds r22,asflre+2
        lds r23,asflre+3   
        
        subi r20,$01
        sbci r21,$00
        sbci r22,$00
        sbci r23,$00   ;                                  00000000 000000fe 000000ff 00000100 

l19880: subi r21,$01    ;subtract #$01                    00000100 00000100 00000100 00000100                        
        sbci r22,$00    ;= subtract 1*256 
        sbci r23,$00    ;= 256 bytes                      ffffff00 fffffffe ffffffff 00000000
                        ;                       carry:           s        s        s        c
        brcs l19890     ;b.i.last sector found
    
        ;sts teflre,r20 ;temporary filelength remaining
        sts teflre+1,r21 ;  for append
        sts teflre+2,r22
        sts teflre+3,r23 

        call l14770    ;read follow-256-CBM-HD-sector of actual cluster using ashbcl     
                       ;ashbtr HD-buffer-transfer read of actual SA (0-17) = #$05
                       ; => copies also into CBM-buffer

        ;lds r20,teflre ;temporary filelength remaining
        lds r21,teflre+1 ;  for append
        lds r22,teflre+2
        lds r23,teflre+3    
        rjmp l19880

l19890:                ;filelength at last 512bytes-sector 
 
        lds r20,asflre ;actual SA filelength
        sts ascbve,r20 ;actual SA CBM-vector  =  vector to write next IECIN-databyte
      
        ldi r16,$80    ;sets flag that actual SA is opened for write               
        sts asfla1,r16 ;actual SA flags1 (0-17)
                       ;what about the other bits of asfla1???    
                       ;perhaps rcall l18750 would be shorter??? 
          
        rjmp l19790    ;set flags for HD-read/write (#$04) and end of command
        
                       ;$17 23 try to append a file having the length 00000000 
                       ; or startcluster 00000000
                       
                       ;             position  ascbve
                       ;             of last
                       ;             written   write
                       ;-filelength   byte     vector
                       ;  0001        0000     0001
                       ;  0002        0001     0002
                       ;  00ff        00fe     00ff
                       ;  0100        00ff     0100
                       ;  0101        0100     0101
                       ;  01fe        01fd     01fe
                       ;  01ff        01fe     01ff
                       ;  0200        01ff     0000
 
                       ;works with CBM buffer which has 256bytes only ($0100)

;------------------------------------------------------------------------------------------------
                       ; l19920 (open file for read)
l19900: lds r30,cm0279 ;amount of commas/filenames (cleared to #$00 at l19850?)    
                       ;.........................................................................
                       ;from l19760 (save&replace),
l19910:                ;copy values of direntry from open-dir-tables to actual SA-buffer
                       ;r30 must show to correct entry of table !!

        ldi r31,high(cfmebe) ;command/filename memory begin 

        ldd r17,z+low(cfdile)     ;length of direntry of actual file inputbuffer (d8,x/dd,x)
                                  ;=amount of dir-partentries 
        ldd r18,z+low(cfdive)     ;vector of direntry of actual file inputbuffer   dd,x      d9dd
        ldd r19,z+low(cfdisc)     ;sector in this cluster of direntry of...   d8,x/dd,x
        ldd r20,z+low(cfdicl)     ;cluster of direntry of actual file inputbuffer low d8,x   d9db
        ldd r21,z+low(cfdicl)+$05 ;cluster of direntry of actual file inputbuffer high d8,x  d9db
        ldd r22,z+low(cfdicl)+$0a ;cluster of direntry of actual file inputbuffer higher d8,x 9db
        ldd r23,z+low(cfdicl)+$0f ;cluster of direntry of actual file inputbuffer highest d8,x db
                       ;   1541: x=vector to correct inputpart

        sts asdeam,r17 ;actual SA dir-entry amount of dirpartentries (0,1,2)   
        sts asdeve,r18 ;actual SA dir-entry vector                      0266,y at 1541       d9df
        sts asdesc,r19 ;actual SA dir-entry sector in this cluster 
        sts asdecl,r20 ;actual SA dir-entry cluster low                 0260,y at 1541       d9da
        sts asdecl+1,r21 ;actual SA dir-entry cluster high
        sts asdecl+2,r22 ;actual SA dir-entry cluster higher
        sts asdecl+3,r23 ;actual SA dir-entry cluster highest                           d9c9/d9ce
                       ;1541: y=vector of channel
        ret
;------------------------------------------------------------------------------------------------
                       ;from l19850, l19860
l19920:                ;                                                 open file for read  d9a0
                       ;still make a lot for rel-files!!!!!!!!!!!!!!
       
        ldi r16,$05    ;%....1101 makes flags for copy into 256bytes CBM-buffer
        sts ashbtr,r16 ;HD-buffer-transfer read of actual SA (0-17)
                       ;don't know where to make this command?????????????????????????    
                       ;amount of commas/filenames cm0279 is cleared to #$00 at l19850
        rcall l19900   ;                                                                d9dd-d9df
 
        ori r30,$20    ;the maximal displacement for the std-command is $3f
                       ;=> the displacement for the last two tables would be too big
                       ;=> one must add #$20 to the Z-register => the displacement is #$20 bytes
                       ;    smaller => access to this table is possible 

        ldd r12,z+low(cfstcl)-$20 ;command/filename startcluster of file  0280,x/0285,x d9c6/d9cb
        ldd r13,z+low(cfstcl)-$20+$05 ;startcluster high
        ldd r14,z+low(cfstcl)-$20+$0a ;startcluster higher           
        ldd r15,z+low(cfstcl)-$20+$0f ;startcluster highest                             d9c6/d9cb 
        
        sts ashbve,r06 ;#$00 clears actual SA HD-buffer vector                          d9c9/d9ce
        sts ashbsc,r06 ;#$00 clears actual SA HD-buffer sector in this cluster 
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
                       ;this is perhaps also made at l21870 ??    

        sts ashbcl,r12 ;actual SA HD-buffer cluster low                                 d9c9/d9ce
        sts ashbcl+1,r13 ;actual SA HD-buffer cluster high
        sts ashbcl+2,r14 ;actual SA HD-buffer cluster higher
        sts ashbcl+3,r15 ;actual SA HD-buffer cluster highest                           d9c9/d9ce

        ldd r20,z+low(cffile)-$20 ;command/filename filelength      
        ldd r21,z+low(cffile)-$20+$05 
        ldd r22,z+low(cffile)-$20+$0a 
        ldd r23,z+low(cffile)-$20+$0f ;command/filename filelength      
                       ;the filelength must be stored here, because at FAT32 it's impossible to
                       ;calculate the length of the last block from the last block itself
                       ;retore Z isn't necessary because it is changed when the HD-sector is read
        
        sts asflre,r20 ;actual SA filelength (remaining) (for EOI-calculating)
        sts asflre+1,r21
        sts asflre+2,r22
        sts asflre+3,r23 ;actual SA filelength (remaining) (for EOI-calculating)
                       
        rcall l21840   ;open a channel for read & read startblock                            d9d0

                       ;?????????????????????????????????????????????????????????????????

        ret            ;                                                                     d9e2
;------------------------------------------------------------------------------------------------
                       ;from l19270, l19990
l19930:                ;                          compute length of first filename of inputbuffer  
                       ;                             mustn't change r24
        lds r28,cfpobc ;command/filename position of begin/commas =     027a at1541
        ldi r29,high(inbube) ;begin of name of the first inputname

        ldi r19,$00    ;counter for filenamelength   (similar to l17540-l17560)   c6a6-c6cc
        ldi r18,$80    ;clears position of last dot in filename  (=begin-1 of fileextension)

        rjmp l19960    ;this command isn't at 1541
                       ;save":" => 
                       ; cfpobc = #$01
                       ; incoen = #$01
                       ;length of filename should be #$00 => r19=filenamelength should be #$00

l19940: ld r16,y+      ;loads character of first inputfilename
                       ;                                           searches end of inputfilename 
        cpi r16,$2c
        breq l19970    ;b.i.comma (=end of this inputfilename)

        cpi r16,$3d
        breq l19970    ;b.i.'='  (=end of this inputfilename)

        cpi r16,$2e    ;dot .
        brne l19950    ;b.i.no dot
        
        mov r18,r19    ;position of last dot in filename  (=begin-1 of fileextension)      
                       ; (=end of filename without fileextension)
l19950: inc r19        ;increments length of filename (long)

        cpi r19,$10    ;compares length of input-filename (CBM-name)
        brcc l19970    ;b.i.length of input-filenmae >=16 

l19960: lds r16,incoen ;inputcommand end =0274 at 1541
        cp r28,r16     ;compares vector and end of inputstring
        brcs l19940    ;b.i.end of inputstring not yet reached----------------------------------- 

l19970: ret            ;r18 = position of dot between filename and fileextension at FOR-files
                       ;r18 = end+1 of filename (without filextension) (or #$80 if no dot)
                       ;r18 = begin-1 of fileextension

                       ;r19 = end+1 of filename          CBM    CBM    FOR   FOR        FOR
                       ;       (with extension)           0  012345678  0  01234567  0123456789ab
                       ;                                  a  abcde.ghi  a  abcdefgh  abcdefgh.xyz
                       ;                             r18  80     05     80    80         08
                       ;                             r19  01     09     01    08         0c
;------------------------------------------------------------------------------------------------
                       ;there are 3 posibilities:
                    ;1 ;CBM-name is a FAT32-longname '0123456789'   '+'   ' '   '.'
                       ;                              (>8 characters or a not allowed MSDOS char)
                       ;    => create a shortname with a tail
                       ;       if the created shortname exists already in the dir 
                       ;        then increment the number of the tail until there isn't
                       ;          a different direntry with this name)
                       ; I decided to make all CBM-filenames long, because I want that every 
                       ; entry has three shortentries because this is easier for later renameing
                       ; when I use 2 empty direntries ($e5) and 1 shortentry then Windows ME
                       ; deletes the empty entries. That's bad when the entry will be renamed 
                       ; later. => CBM-files are always long-entries 
                    
                    ;2 ;CBM-name is a shortname without accidential tail '01234567'   'a'   'A'
                       ;                                 (1-8 chars and only allowed MSDOS-chars)
                       ;    => use this shortname
                       ;       if the shortname exists already in the dir 
                       ;        then create an error 
                       ;         (this shouldn't be possible, because there should be already
                       ;          a file exist error at the compare of the longnames before)
                       ; this is only possible at FOReign files.                     

                    ;3 ;CBM-name is a shortname with accidential tail 'abcdef~1' = 'abcdef-1'
                       ;                                 (1-8 chars and only allowed MSDOS-chars)
                       ;    => use this shortname (with accidential tail
                       ;       if the shortname exists already in the dir:
                       ;          -if the different shortname is the mainname (no longname)
                       ;            then create an error 
                       ;            (this shouldn't be possible, because there should be already
                       ;             a file exist error at the compare of the longnames before)
                       ;          -if the different shortname is part of a longname
                       ;            then increment the number of the tail of the different name
                       ;            until there isn't a different (third) direntry with this name)
                       ;            (the longname-direntry-parts must be also changed,
                       ;             because the checksum over the shortname changes) 
                       ; this is only possible at FOReign files. If there is any matching dir-
                       ; filename found then make an error (easier / it's too difficult to
                       ; rename a different shortname which is part of a longname)                        

                       ;NLQHD always makes three direntries (even at a short name)
                       ; this is easier if the shortname is later renamed to a longname                      
 
                       ;the longnames are already compared
                       ;now the shortnames must be compared
                       ;if it's a real shortname without tail:
                       ; -if INS=DNS -> 63,exists error (63-error should be already at 
                       ;                                 compare of longnames)
                       ;             -> stop search, because the real shortname without tail
                       ;                cannot be renamed
                       ;if it's a -real shortname with accidential tail         
                       ;     or   -shortname is part of a longname:
                       ; always search dir until end
                       ; -if INS=DNS then store the direntry-values of this entry
                       ;     (at real shortname with accidential tail: 
                       ;           to rename the differnt shortname to a differnt tailnumber
                       ;           if the differnt direntry is also a shortname then error) 
                       ;     (at shortname is part of a longname:
                       ;           to make flag that shortname already exist
                       ;           to rename the shortname of the actual longname-direntry
                       ;               to a different tailnumber)
                       ; search an unused possible free direntry: 
                       ;  -compare all 11 ($0b) caharcters of INS and DNS exept the last digit
                       ;                                                    of the tail
                       ;  if 10 of the 11 characters matter (exept last digit of tail)   
                       ;  compare this character of the direntry:
                       ;  if it's no digit then do nothing
                       ;  if it's a digit then set a bit that this digit (0-9) does already
                       ;    exist in the dir
                       ;  => at 1 dir-entry search-loop the avr can find 10 free direntries
                       ;       where only the last digit of the tail differs
                       ; at the end of 1 dir-serch loop:
                       ;  check if the actual shortname already exist in the dir
                       ;   if it doesn't exist then write the actual direntry
                       ;   if it already exist:
                       ;   -if it's a real shortname with accidential tail:
                       ;     the actual shortname cannot be renamed 
                       ;     you must try to rename the different direntry
                       ;     -if the different direntry is a real shortname =>
                       ;       different shortname cannot be renamed => error
                       ;     -if the different direntry is part of a longname 
                       ;       different shortname can be renamed
                       ;       rename different shortname   
                       ;       check whether there is one free shortname, where only the last
                       ;         digit of the tail differs, free
                       ;       -if yes then rename the different shortname of different direntry
                       ;          (rename also longnameparts because the checksum changes)
                       ;       -if no then create new tail (increment the number of the tail
                       ;          by 10) and search complete dir whether there is any unused
                       ;          shortentry
                       ;          (if the new generated shortname with new tail matches
                       ;           completely to a direntry then don't store the values of the
                       ;           now-found direntry
                       ;           this would later rename this direntry but the direntry which
                       ;           fits to the actual shortname without tail must berenamed)
                       ;          begin a complete new serch of the new-created shortname in dir
                       ;   -if it's shortname is part of a longname:
                       ;     the actual shortname can be renamed 
                       ;     you must try to rename the actual direntry
                       ;       rename actual shortname   
                       ;       check whether there is one free shortname, where only the last
                       ;         digit of the tail differs, free
                       ;       -if yes then use this free shortname to make the new direntry
                       ;       -if no then create new tail (increment the number of the tail
                       ;          by 10) and search complete dir whether there is any unused
                       ;          shortentry
                       ;          begin a complete new serch of the new-created shortname in dir
                       ; 
                       ;a FAT32-directory has maximal 65536 ($10000) direntries
                       ;NLQ-HD uses always 3 direntries for one filename-entry 
                       ;                 (easier later if shortname is renamed to longname)
                       ;there are 21844 direntries possible
                       ;if all files of 1 dir should have the same shortname (a~1 to a~21845):
                       ;NLQ-HD searches for 10 free possibel shortname-tails in 1 complete
                       ;    dir-search-loop
                       ;=> it could be that NLQ-HD must make 2185 complete dir-search-loops
                       ;   until it finds a free shortname (very slow)   


                       ;this shortname-routines are absolutely complicated.
                       ;it would be much easier to make a simple counter, e.g.:
                       ; ÑÐ~1.PRG          ÑÐ~1    PRG
                       ; ÑÐ~65636.PRG      ÑÐ~65636PRG
                       ;the tail could easyly be the counter, which dir entry in this dir
                       ;         the new direntry will be
                       ; one should use characters which are seldomly used in shartnames, e.g.
                       ;Ñ is the first char of NLQ-HD
                       ;Ð is the last char of NLQ-HD  
                       ;you needn't compare the dir whether this direntry exists, just use it.
                       ;if there should be a shortname twice in a dir then this would be no
                       ; prblem for NLQ-HD, and perhaps MS-scandisk would repair it?????????

                       ;CFN = CBM filename
                       ;SFN = short MS-DOS filename
                       ;LFN = long Windows95 filename

                       ;what happend when the first char of the filename is a dot '.'
                       ;-CBM-file (= file with extension SEQ...D64...):
                       ;  always '.xyz' attached at end 
                       ;   => never necessary to generate the extension from the CFN
                       ;-directory: 
                       ;  a dot as first char is changed to a comma 
                       ;   => not SFN-extension 
                       ;-FOR-file: => syntax error

                       ;normal SFN-generation:
                       ;-CBM-file:
                       ; -no 8+3 check 
                       ; -no extension-generation from CFN
                       ;-DIR-file:
                       ; -no 8+3 check
                       ; -generate extension from CFN (if a dot is in CFN)
                       ;-FOR-file:
                       ; -check 8+3 (if wrong -> syntax error)
                       ; -generate extension from CFN (if a dot is in CFN)

                       ;from l18020 (rename), l20680 (save)         create and compare shortnames
l19980: ldi r25,$10    ;10--'w'
        call l13080    
        
        ldi r26,low(innash+$0b) ;inputname short (end+1)                 
        ldi r27,high(innash+$0b)
        ldi r16,$20    ;space

l19990: st -x,r16      ;default: fills inputbuffer short with spaces
        cpi r26,low(innash)
        brne l19990
                       ;at 1541 and AVR: always the first (of possible 5) filename is the
                       ; to saved program (save "abc)
                       ;                  (open2,8,2,"abc,p,w)
                       ;                  (r:abc=xyz)
                       ;                  (c:abc=x,y,z)
                       ; => only for the first inputname the shortname must be compared
     
        rcall l19930   ; compute length of first filename of inputbuffer    
                       ;the file which is saved is always the first one in the inputbuffer
                       ;  save "savefilename"
                       ;  rename:newfilename=oldfilename
                       ;r18 = position of dot between filename and fileextension at FOR-files
                       ;r18 = end+1 of filename (without filextension) (or #$80 if no dot)
                       ;r18 = begin-1 of fileextension
                       ;r19 = end+1 of filename (length of filename)

                       ;DEL,SEQ,PRG,USR,REL,D16,D64,D81    but also DIR
                       ;the CBM-files get a CBM-fileextension, so here the filename needn't be 
                       ; searched for a dot and a fileextension behind
                       ;the subdir doesn't get a fileextension, so the filename must be 
                       ; searched for a dot and a fileextension behind
                       ;it's necessary to make the fileextension at a subdirentry correctly,
                       ; because else Windows scandisk could destroy the long filename
        cpi r19,$00    ;                          
        breq l20020    ;b.i.filename-length=0bytes

        lds r23,cm024a ;open actual filetype (mustn't
                       ;  be changed until l!!)

        cpi r23,$0e    ;bit7-4 is always %000
        brne l20030    ;b.i.not FOR

                       ;=FOReign
        clt            ;flag for FOR-filetype=FOReign
        ldi r22,$0f    ;flag that no tail and no lossy convertion    
                       ;mustn't be changed until l20310 at FOR (-> natac0)
                       ;                                  a  abcde.ghi  a  abcdefgh  abcdefgh.xyz
                       ;                             r18  80     05     80    80         08
                       ;                             r19  01     09     01    08         0c
        cpi r18,$80
        brne l20010    ;b.i.dot found

l20000: mov r18,r19    ;                             r18                01    08         08  

l20010: cpi r18,$00
        breq l20020    ;b.i.there is no FOR-filename 
                       ; e.g. '.txt' (without anything in front of dot) 
        cpi r18,$09    ;                             r18:               01    08         08        
        brcc l20020    ;b.i.FOR-filename >8 characters                  s     s          s

        mov r20,r19    ;end of name with extension   r19                01    08         0c
        sub r20,r18    ;subtracts end of name without extension         00    00         04
        cpi r20,$05                                                                     
        brcs l20040    ;b.i.fileextension 0-3 characters                s     s          s                                  

l20020: rjmp l19630    ;30, syntax error (correct error number???)---------------    

l20030: set            ;flag for CBM-filetype or DIR  
        ldi r18,$10    ;flag for no dot in filename
                       ;important to make r18=#$10 for tail-generation when filename with many
                       ;  spaces  
      
l20040: lds r28,cfpobc ;command/filename position of begin/commas =     027a at1541--------------
                       ;r29,still shows to begin of name of the first inputname

        ldi r26,low(buwlfn) ;buffer Windows95 long filenames          
        ldi r27,high(buwlfn)

        clr r24        ;counter for CFN-length 

l20050: ldi r30,low(taclnc<<1) ;table CFN->LFN / CFN-part               (-------loopbegin-------)
        ldi r31,high(taclnc<<1); table CFN->LFN / CFN-part
                       ;at byte0 (and byte15): set to begin of table (changes also space to =) 
                       ;(next bytes: set to byte1 of table)

                       ;T-flag: low=FOR  set= CBM (DEL,SEQ...D81) and DIR
                       ;r16 actual char from inpubuffer
                       ;r17
                       ;r18 position of dot
                       ;r19 end of inputname
                       ;r20 UNICODE low-char into LFN-buffer
                       ;r21 UNICODE-high
                       ;r22 position of digit of tail at CBM and DIR #$27 (FOR: #$0f) (-> natac0)
                       ;r23 filetype
                       ;r24 counter for CFN-length
                       ;r25 (debug)
                       ;r26,r27 writevector into LFN-buffer
                       ;r28,r29 readvector from CFN-inputbuffer
                       ;r30,r31 FLASH-tablevector   

l20060: ld r16,y+      ;read char from inputbuffer $0200-02f?   --------loopbegin-CFN->LFN-------

/*
        mov r25,r30
        call l13090
*/

        ldi r20,$10    ;default for CFN-char $00-1f
        add r20,r16    ; CFN  ->  LFN   
        ldi r21,$04    ;00-1f -> 0410-042f
        cpi r16,$20
        brcs l20090    ;b.i.$00-1f

                       ;=$20-$ff
        mov r20,r16
        ldi r21,$00    ;default for unicode page 0
        cp r24,r18     ;compares actual positon and position of dot
        breq l20100    ;print dot into long filename buffer
                       ;important at FOR because else a dot would be an illegal char
   
l20070: lpm r25,z+     ;reads character from table
        cp r16,r25
        brne l20080    ;b.i.actual CBM-inputname-char isn't in table

        subi r30,low((taclnc<<1)-(taclnl<<1)+1) ;change vector from taclnc to taclnl
                       ; ($0e (14) chars in front)
        sbci r31,$00   ;tacelf   table character export LFN

        lpm r20,z      ;read CBM-char from taclnl table CFN->LFN / LFN-part
        tst r20
        breq l20020    ;b.i.illegal CFN-char (it's too dangerous to change it into a legal one
                       ;because it could then be possible that a LFN-file with an already in
                       ; the dir existing filename could be made)
        rjmp l20090

l20080: cpi r30,low((taclnc<<1)+$0d) ;last char of table is unused (taclnc-length: $0d)
        brne l20070

        mov r20,r16
        cpi r16,$60
        brcs l20100    ;b.i.$20-5f =legal chars even at FOR

        ldi r20,$f0    ;=$60-ff
        add r20,r16    ;$60-9f -> 50-8f 
        ldi r21,$02    ;       -> $0250-028f
        cpi r16,$a0
        brcs l20090    ;b.i.60-9f

        mov r20,r16
        ldi r21,$00
        cpi r16,$e0
        brcs l20090    ;b.i.a0-df
                       ;changes of the CBM-graphical char'-' to an IBM-'~'
                       ;is already made at l????? 

        ldi r20,$d0    ;=$e0-ff
        add r20,r16    ;$e0-ff -> b0-cf
        ldi r21,$02    ;       ->$02b0-02cf

l20090: brtc l20020    ;b.i.illegal char at FOR

l20100: st x+,r20      ;unicode low  01..09  0e..18  1c..1e  
        st x+,r21      ;unicode high 02..0a  0f..19  1d..1f
        inc r24        ;increments counter for read from CBM-inputname
                       ;00->01 ... 0f->$10  

/*
        ldi r25,$53
        call l13090
        mov r25,r16
        call l13090
        mov r25,r20
        call l13090
        mov r25,r24
        call l13090
*/

        cp r24,r19
        brcc l20120    ;b.i.end reached

        ldi r30,low((taclnc<<1)+2) ;table CFN->LFN / CFN-part
        ldi r31,high((taclnc<<1)+2) ;table CFN->LFN / CFN-part
                       ;next CBM-bytes: set to byte1 of table (-don't change space to '='
                       ;                                       -don't change '.' to ',' 
        cpi r23,$06    ;                                       -change all other taclnc-chars)
l20110: brne l20060    ;b.i.CBM-file        

                       ;=DIR 
        ldi r30,low((taclnc<<1)+1) ;table CFN->LFN / CFN-part
        ldi r31,high((taclnc<<1)+1) ;table CFN->LFN / CFN-part
                       ;next bytes: set to byte1 of table (-don't change space to '='
                       ;                                   -change '.' to ',' 
        cpi r24,$0f    ;                                   -change all other taclnc-chars)
        brne l20110    ;b.i.next char is not char$0f (the 16th char) 
                       ; space isn't replaced with '='

                       ;=the filename is 16 chars long and the last char is the next one
                       ;at CBM-files (not directory): behind the 16-char-long-filename
                       ;   the fileextension (.seq) is written 
                       ;   => it's impossible that a space or dot is the last char
                       ;at directory: nothing written behind 16-char-long-filename
                       ;   =>it's possible that the last char is a space or dot (=period) '.'
                       ;   trailing spaces and dots aren't allowed
                       ;   => trailing space or dot must be changed to = or comma '.' -> ','
                       ;dots are always replaced with commas, because it's easier
                       ; when there is no unwanted fileextension in the LFN, e.g.at DIR

                       ;perhaps make:
                       ; if CBM: change only dot at first pos to comma, next dots stay dots
                       ; if DIR: change all dots to commas (because else there would be a 
                       ;          fileextension; e.g.: LFN: 'files 1.4.09' would be files1~1.09   
                       ;           => shortname  generation would be too difficult
        
                       ;=directory and char$0f (the 16th char) change space to '='
                       ;            set to byte0 of table (-change space to '='
                       ;                                   -change '.' to ',' 
                       ;                                   -change all other taclnc-chars)
/*
        ldi r25,$54
        call l13090
*/

        rjmp l20050    ;set table to byte0                       --------loopend CFN->LFN--------

l20120: brtc l20170    ;b.i.FOR
      
        ldi r20,$a0   ;shift-space    

l20130: cpi r24,$10
        breq l20150   ;b.i.CFN is 16 chars long

l20140: st x+,r20     ;fill end of filename with shift-space
        st x+,r06     ;#$00 codepage0
        inc r24
        rjmp l20130

l20150: ;ldi r18,$10    ;flag for no dot in filename (made at l20030?)
                       ;important to make r18=#$10 for tail-generation when filename with many
                       ;  spaces  
        ldi r19,$11    ;default: filenamelength for directory
                       ;important to make r19=#$11 for tail-generation when filename with many
                       ;  spaces  
        
        cpi r23,$06
        breq l20170    ;b.i.directory (no fileextension)

        ldi r16,$2e    ;'.'                    copy LFN-fileextension----------------------------
        st x+,r16
        st x+,r06
        inc r24        ;#$10->$11

        ldi r30,low(optatf<<1) ;open table type FAT
        ldi r31,high(optatf<<1) ;open table type FAT
        
        add r30,r23    ;open actual filetype
        adc r31,r06    ;#$00 adds carry
        lsl r23        ;*2   adds offset to correct CBM-filetype of table
        add r30,r23
        adc r31,r06

l20160: lpm r16,z+     ;reads CBM-FAT-filetype from table
        st x+,r16
        st x+,r06
        inc r24        ;#$10->$11
        cpi r24,$14
        brne l20160

        ;ldi r18,$10    ;position of dot at CBM (made at l20030?)        
        ldi r19,$14    ;filenamelength for CBM-files
l20170:                ;                                        --------end LFN-generation-------

                       ;                                                          CBM DIR FOR
                       ;r15=temp
                       ;r16=UNICODE low
                       ;r17=UNICODE high
                       ;r18=pos of last dot in inputname                          $10 $10 1-8/80
                       ;    (not position of inputbuffer)                              
                       ; r18=#$80 if there is no dot
                       ;      (only possible at FOR)
                       ;       mustn't be #$ff because else overflow from 
                       ;       ff->00 and loop would begin again
                       ;r19=length of LFN                                         $14 $11
                       ;r20=unused?
                       ;r21=counter for LFN-length 
                       ;r22=position of digit behind '~' or $0f at FOR (-> natac0)        $0f
                       ;r23=(filetype?)
                       ;r24=unused?
                       ;r25=debug
                       ;r26/r27=X=write into SFN inputname short
                       ;r28/r29=Y=read from LFN
                       ;r30/r31=Z=table

        ldi r26,low(innash) ;inputname short
        ldi r27,high(innash) ;inputname short
       
        ldi r28,low(buwlfn) ;buffer Windows95 long filenames          
        ldi r29,high(buwlfn)
                
        ldi r30,low(talsnl<<1) ;table LFN->SFN / LFN-part
        ldi r31,high(talsnl<<1); table LFN->SFN / LFN-part
                       ;at byte0: set to begin of table (next bytes: set to byte1 of table)
        ldi r21,$00    ;counter for LFN-length 

l20180: ld r16,y+      ;LFN-UNICODE low                        --------loopbegin LFN->SFN--------
        ld r17,y+      ;LFN-UNICODE high 

        cp r21,r18     ;test whether position of dot between name and fileextension
        breq l20250    ;b.i.at position of dot between name and fileextension
                       ;only possible at CBM and FOR (not DIR)
       
        brtc l20190    ;b.i.FOR (no tail)

        cpi r26,low(innash+$06)
        breq l20260    ;b.i.at SFN-position where ~1-tail must begin at CBM
    
l20190: cpi r17,$00
        brne l20220    ;b.i.not UNICODE-page0

l20200: lpm r17,z+     ;!postincremented!
        cp r16,r17
        brne l20210    ;b.i.not a char of the table which must be changed to a different char
    
        brtc l20230    ;illegal char at FOR
    
        subi r30,low((talsnl<<1)-(talsns<<1)+1) ;computes vector to talsns
        sbci r31,$00   ;subtracts carry

        lpm r16,z      ;tacec  table char export shortfilenames save                                

        cpi r16,$01
        breq l20220    ;b.i.#$01 print underscore _ $5f

        brcc l20240    ;b.i. $02-$ff (legal DOS character)

        rjmp l20290    ;#$00 = flag for skip character (at space and dot)

l20210: cpi r30,low((talsnl<<1)+$0b) ; last char of table is unused (talsnl-length: $0b)
        brne l20200

        cpi r16,$80
        brcs l20240    ;b.i.CBM-$20-5f
       
                       ;=CBM-$a0-df       
        brtc l20230    ;illegal char at FOR
    
        ldi r30,low((tashna<<1)-$a0) ;    =$a0-df (graphical & upper case letters)
        ldi r31,high((tashna<<1)-$a0) ;table shortname UNICODE-$a0-df -> DOS

        add r30,r16    ;adds offset of actual CBM-character
        adc r31,r06    ;#$00 adds carry

        lpm r16,z      ;changes UNICODE->DOS-ASCII
        rjmp l20240

l20220:                ;=illegal shortname-character 
        ldi r16,$5f    ;'_' underscore    = DOS-character doesn't exist or isn't allowed
        brts l20240    ;b.i.CBM and DIR (=change to underscore)
        
l20230: rjmp l20020    ;=illegal char at FOR

l20240: st x+,r16
        rjmp l20280   
       
l20250: brtc l20270    ;b.i.FOR (no tail)

                       ;=CBM and DIR: there are spaces and dots in the LFN so that to SFN is
                       ; shorter than 8 chars => tail must be made in front of pos 6

l20260:                ;=position where ~1-tail must begin at CBM and DIR
        ldi r16,$7e    ;'~' =CBM and DIR = tail-generation
        st x+,r16

        mov r22,r26    ;r22=position of digit behind '~' 0922 0927 
                       ;                                   22   27
       ;subi r22,low(innash)-$20 ;sets flag for tail       22   27
                       ;fits accidentially

        ldi r16,$31    ;'1'
        st x+,r16

l20270: mov r15,r18    ;position of dot between filename and extension
        lsl r15        ;*2 because LFN-buffer is unicode is two bytes for one byte    
        ldi r28,low(buwlfn+2) ;buffer Windows95 long filenames         
        add r28,r15    ;readvevtor shows to begin of fileextension

        ldi r26,low(innash+$08) ; writevector shows to begin of fileextension
        mov r21,r18    ;counter for LFN-length = position of dot between filename and extension 
                      
l20280: cpi r26,low(innash+$0b) ;
        breq l20300    ;b.i.end of SFN reached = end of SFN
        
l20290: ldi r30,low((talsnl<<1)+1) ;table LFN->SFN / LFN-part
        ldi r31,high((talsnl<<1)+1); table LFN->SFN / LFN-part
                       ;at next bytes: set to byte1 of table ($E5 isn't replaced with $05)
/*
        ldi r25,$55
        call l13090
        mov r25,r16
        call l13090
        mov r25,r21
        call l13090
*/
        inc r21        ;increments counter of length of filename (long)
        cp r21,r19     ;compares length of LFN
        brcs l20180    ;b.i.counter <= length of input-filename----------loopend LFN->SFN--------
                       
                       ;      CBM                      DIR                    FOR
                       ;CFN:  '0123456789abcdef'       '0123456789abcdef'     '01234567.txt'  
                       ;LFN:  '0123456789ABCDEF.PRG'   '0123456789ABCDEF'      
                       ;SFN:  '012345~1PRG'            '012345~1   '          '01234567TXT' 

                       ;      CBM                      DIR                    FOR
                       ;CFN:  '                '       '                '     '0.txt'  
                       ;LFN:  '=               .PRG'   '=              ='      
                       ;SFN:  '_~1     PRG'            '__~1       '          '0       TXT' 

                       ;      CBM                      DIR                    FOR
                       ;CFN:  '................'       '................'     '01234567'  
                       ;LFN:  ',................PRG'   ',,,,,,,,,,,,,,,,'      
                       ;SFN:  '_~1     PRG'            '______~1   '          '01234567   ' 

                       ;r18   #$10                     #$10                   #$01-08
                       ;r19   #$14                     #$11                   ?
                       ;r22   #$22-27                  #$23-27                #$0f
                       
                       ;r18=pos of last dot in inputname
                       ;    (not position of inputbuffer)
                       ; r18=#$80 if there is no dot (only possible at DIR and FOR)
                       ;r19=length of LFN                              
                       ;r22=position of digit behind '~'  or $0f at FOR

l20300:                ;length of filename:
                       ;FOR: innash  8+3
                       ;DIR: buwlfn 16
                       ;CBM: buwlfn 16+1+3 = 20
                       ;-------------------------------------------------------------------------
                       ;r22=position if digit behind ~ at CBM and DIR
                       ;    at CBM and DIR: there is always a W95-longname
                       ;                    the MS-DOS-shortname has always a tail
                       ;                    the MS-DOS-shortname can always be changed
                       ;                    if it already exist in the dir
                       ;   = #$0f at FOR
                       ;    at FOR: never a tail (only perhaps accidentially)
                       ;                
                       ;                    the MS-DOS-shortname cannot be changed
                       ;                    if it already exist in the dir
                       ;                    If it exists already then file exists error


      sts sdstcl+3,r07 ;#$ff short-directory-start-cluster highest of direntry in dir-sector              
                       ; makes flag that shortentry not (yet) found
                       ; it's important to find at shortname with accidential tail the different
                       ;   direntry with the same name as the actual shortname
                       ;   => make this flag only before the first loop of a complete dirsearch
                       ;      if you need several loops until you find an unused tail
                       ;        then don't overwrite the first-found dirvalues with
                       ;        values of the next loops
                       ;       => make this flao only before the first complete-dir-search-loop
                       ;          don't reset it at the next complete-dir-search-loops
                       
        sts ofdecl+3,r07 ;#$ff open free dir entry cluster highest           = $0291 at 1541
                       ;#$ff = flag that first 3 free direntries not yet found and
                       ;and search starts from begin

        ldi r23,$80    ;at first loop: set flag that last-digit=0 already exists in dir
                       ; (=> filename a~0 or abcdef~0 will not be used)                       

                        
                        ;these flags are perhaps still set from first dir routine (l16880)
        ;lds r16,asfla0 ;flag0 of actual SA                      
        ;ori r16,$03    ;makes flag for directory and display also empty entries
        ;sts asfla0,r16 ;changed!!!! still necessary???????????????
 
        ;ldi r16,$04    ;%....1100 makes flag for read into AVR-HD-buffer but not into CBM-buffer
        ;sts ashbtr,r16 ;actual SA HD-buffer-transfer read (0-17) 

l20310: andi r22,$3f   ;clears bits for existing shortnames with last taildigit '8' and '9'
        sts natac0,r22 ;name-tail-counter0----------------dir-search-loop------------------------ 
                       ;bit 7-6: bitwise flags which last number of shortnametail
                       ;          is found in dir numbers 8-9
                       ;           bit7 = '8'
                       ;           bit6 = '9'
                       ;bit 5  : flag for real-short-name / part of long-name
                       ;          0 = real short-name (FOReign)
                       ;          1 = part of a longname (CBM & DIR)
                       ;bit 4  : 
                       ;bit 3-0: position where last digit of tail is (2-7)
                       ;                        ($.f = no tail (FOR)) 
                       ;                         CBM: 7
                       ;                         DIR: 7  dots are changed to commas 
                       ;                                 => never fileextension  
                       ;                         FOR  f (no tail)
        sts natac1,r23 ;#$80/00 nametailcounter1 bitwise flags which last number o.shortnametail
                       ;  is found in dir numbers 0-7    (first loop:$80   next loops:$00)
                       ;   bit7 = '0'
                       ;   bit0 = '7'
        call l15640   ;read first direntry   without using SA$11
                       ;-> dirname is in dibube directory buffer begin
        rjmp l20330

l20320: call l15660   ;read next direntry  -------------------------------loop-----
                       ;Y = r28/r29 shows to dir-shortname

l20330: ldi r26,low(innash) ; X = inputname short                 
        ldi r27,high(innash)

        lds r17,ofdecl+3 ;open free dir entry cluster highest = $0291 at 1541
        bst r17,7      ;bit wheather first 3(/1) free direntries already found  

        breq l20340    ;b.i.end of dir not yet reached

        rjmp l20510    ;end of dir reached--------
        
l20340: andi r16,$ff   ;directory file type
        brne l20390    ;b.i.not empty direntry
        
                       ;= free unused direntry
                       ;the 1541-routines at l17020 already search a free direntry (but 1 only)
                       ;here 3 free durentries are earched
                       ;=> routines at l17020 could be unnecessary???
                     
                       ;ofdecl+3:
                       ;bit7: 0=3 free direntries found   1=notyet found
                       ;bit6: 0=second or third possible free direntry
                       ;      1=first free direntry
                       ;bit5-4: counter for free direntries in a chain  
                       ;bit3-0: LBA-address of cluster 31-28

        brtc l20320    ;b.i.first 3(/1) free direntries already found

        tst r10        ;flag whether orphan-direntry between former-old an actual-new direntry
        brmi l20350    ;b.i.orphan-direntry between former-old an actual-new direntry
                       ;    = there is an orphan-direntry between empty direntries
                       ;      => must begin search for 3 free direntries again from beginning
                         
        bst r17,6      ;bit whether        
        brtc l20370    ;b.i.former direntry was a free direntry 
                       ;b.i.this direntry = second or third of a possible chain
                        
l20350:                ;= first free direntry behind used direntry
        sts ofdeve,r28 ;open free dir entry vector /vector = $0292 at 1541

        ldi r30,low(ofdesc) ;open free dir entry sector in this cluster
        ldi r31,high(ofdesc)

l20360: ldd r17,z+ashbsc-ofdesc ;reads from actual SA HD-buffer sector in this cluster  
        st z+,r17      ;stores to open free dir entry sector in this cluster
        cpi r30,low(ofdecl+4) ;open free dir entry cluster = $0291 at 1541
                       ;bit 7-4 of ofdecl+4 =%0000
        brne l20360    ;copies sector-in this-cluster and cluster (1+4bytes)
                       ;at end: r17 contains ofdecl+3 open free dir entry cluster highest
                       ;bit7-4 = clear
        lds r16,natac0 ;name-tail-counter0
        andi r16,$20   ;masks bit whether real-short-name / part of long-name
        breq l20320    ;b.i.real shortname = FOReign = search 1 (not 3) free direntries

        ori r17,$b0    ;$00-0f -> $b0-bf  makes bits that:
                       ;bit7: 3 free direntries in a chain not yet found
                       ;bit6: actual direntry (-> former entry of next loop) = unused direntry  
                       ;($b0-bf is at once changed to $a0-af => ofdecl+3 can here not be $b0-bf
                       ; => ofdecl+3 = $b0-bf is flag for 3 free direntries not found
                       ;                                  and values of end of dir -> l20530)
                       
                       ;1.free direntry   2.free direntry   3.free direntry
l20370: subi r17,$10   ; $b0-bf->a0-af     $a0-af->90-9f     $90-9f->80-8f

        cpi r17,$90
        brcc l20380    ;b.i.90-ff = b.i.not third free direntry

                       ;=third free direntry in a row
        andi r17,$0f   ;(doesn't change bit3-0 = LBA31-28)
                       ;masks off bits 7-4 =
                       ;bit7=0 = flag that 3 free direntries in a chain are found
        
l20380: sts ofdecl+3,r17 ;open free dir entry cluster highest = $0291 at 1541       
        rjmp l20320    ;read next direntry-----

l20390:                ;=used (not free) direntry 
        brtc l20400    ;b.i.first 3 free direntries already found

        sts ofdecl+3,r07 ;#$ff = flag that first 3 free direntries not yet found
                       ;and search starts from begin

l20400: andi r16,$0f   ;masks filetypebits
        cpi r16,$0e    
        breq l20410    ;b.i.FOR-file ($0e)
        
        cpi r16,$0c   
        brcc l20320    ;b.i.dot, dotdot, volume-ID ($0c, $0d, $0f)
                       ;!!!! 0c isn't dot    0c is perhaps for 1581-CPM !!!!        

l20410: ldi r18,$00    ;initialize input-char of last digit of tail
        ldi r19,$01    ;initialize directory-char of last digit of tail

        ldi r20,$00    ;counter for char in filename

        lds r22,natac0 ;name-tail-counter1 
                       ;bit 7-6: bitwise flags which last number of shortnametail
                       ;          is found in dir numbers 8-9
                       ;           bit7 = '8'
                       ;           bit6 = '9'
                       ;bit 5  : flag for real-short-name / part of long-name
                       ;          0 = real short-name
                       ;          1 = part of a longname
                       ;bit 4  :
                       ;bit 3-0: position where last digit of tail is (2-7)
                       ;                        ($.f = no tail) 
        andi r22,$0f   ;masks pos of last digit of tail (or $0f if no tail)

l20420: ld r16,x+      ;inputname short
        ld r17,y+      ;dirname short

        cp r20,r22     ;compares whether at position of last digit of tail
                       ; (pos of dot is always at pos7)
        brne l20430    ;b.i.not pos of last digit of tail
         
        mov r18,r16    ;input-char of last digit of tail
        mov r19,r17    ;directory-char of last digit of tail  
        rjmp l20440
                
l20430: cp r16,r17
        brne l20320    ;b.i.difference in input- and dir-filename -> read next direntry
        
l20440: inc r20
        cpi r20,$0b
        brne l20420
        
        cpi r20,$0f
        brne l20450    ;b.i.shortname has no tail

        rjmp l19730    ;63,file exist   INS=DNS at shortname without tail
                       ;  (this error should be already found at compare of longnames?)

l20450: lds r16,sdstcl+3 ;short-directory-start-cluster highest of direntry in dir-sector
        andi r16,$ff
        brpl l20470    ;b.i.fitting direntry already found
                       ;this means: the actual shortname was already found at first 
                       ;dir-search-loop (and this is the 2., 3.,4.,...2185. loop)
                       ;there was no free different posibility out of 10 to rename the shortname
                       ;the tail was increnmented by 10
                       ;the next complete-dir-search was started
                       ;=> don't continue to search => after first loop (a~1 was found), the
                       ; last digit of the tailnumber isn't compared with inputfilename
                       ; =>it's not necessary to make the last digit 0 (it can stay 1) 
                       ;it even must stay 1 because this is later used as end-flag for the number
                          
                       ;= this must be the first loop
        cp r18,r19     ;compares the last digit of tail input- and dir-name
        brne l20470    ;b.i.INS<>DNS
        
        ldi r30,low(ldstle+$07) ;long-directory-start-length of direntries 
        ldi r31,high(ldstle+$07) ;    for this complete direntry 

l20460: ld r16,-z       ;(PREdecremented) copies values of found direntry to 
        std z+sdstle-ldstle,r16 ; values of shortname, which fits to the one searched for 
        
        cpi r30,low(ldstle)
        brne l20460
                        ;copies ldstle, ldstve, ldstsc, ldstcl  $0391 - 0397
                        ;  to   sdstle, sdstve, sdstsc, sdstcl  $0399 - 039f

l20470: cpi r19,$30
        brcs l20500     ;b.i.last char of tail isn't a digit -> read next direntry

        cpi r19,$3a       
        brcc l20500     ;b.i.last char of tail isn't a digit -> read next direntry
        
        ldi r16,$00     ;      =last char of tail is a digit
        ldi r17,$80     ;bit-counter for last digit of tail

        andi r19,$0f    ;$30-$39 -> 00-09 
        breq l20490     ;b.i.'0'

l20480: lsr r17         ;moves bit-mask for occupied last-tail-digit 1 right (increments digit)
        ror r16

        dec r19         ;1->0 ... 9->8
        brne l20480 

l20490: lds r18,natac0 ;name-tail-counter1 
                       ;bit 7-6: bitwise flags which last number of shortnametail
                       ;          is found in dir numbers 8-9
                       ;           bit7 = '8'
                       ;           bit6 = '9'
        or r18,r16     ;sets bit that actual last-tail-digit exists in dir
        sts natac0,r18
                     
        lds r18,natac1 ;name-tail-counter0 bitwise flags which last number of shortnametail
                       ;  is found in dir numbers 0-7
                       ;   bit7 = '0'
                       ;   bit0 = '7'
        or r18,r17
        sts natac1,r18 ;#$00 name-tail-counter0 bitwise flags which last number of shortnametail
                       ;  is found in dir numbers 0-7
                       ;   bit7 = '0'
                       ;   bit0 = '7'
l20500: rjmp l20320    ;check next direntry until end of dir-------------------------------------

                       ;                                    =end of one complete dir-search-loop
                       ;(if shortname without accidential tail already exists in dir
                       ;         then the program doesn't come to this place)
l20510: brtc l20540    ;b.i.first 3 free direntries already found
                        
                       ;= there are no 3 free direntries in the dir at all
                       ;=>the values show to the end of the dir
        
                       ;carry = clear: found a direntry with #$00-endflag
                       ;                =>Y r28,r29 shows to #$00-endflag direntry
                       ;carry = set: dir ended with an endcluster without #$00-endflag direntry
                       ;                =>Y r28,r29 doesn't show to #$00-endflag direntry
                       ;                  Y shows to last legal direntry
                       ;                  last direntry mustn't be overwritten with 
                       ;                  future to generate direntry
                       ;r28 = 00, 20, 40, 60, 80, a0, c0, e0 =begin of direntry
        brcc l20520    ;b.i.there is a #$00-endflag-direntry =>ofdesc - ofdecl contain values 
                       ;                                       of #$00-endflag-direntry

                       ;=there is no #$00-endflag-direntry
                       ;=>ofdesc - ofdecl contain values of last not-#$00-direntry
        ldi r28,$f0    ;=flag for there is no #$00-endflag-direntry

l20520: sts ofdeve,r28 ;open free dir entry vector /vector = $0292 at 1541
                       ;Y=vector low to shortname (here: end-#$00 direntry)

        ldi r30,low(ofdesc) ;open free dir entry sector in this cluster
        ldi r31,high(ofdesc)

l20530: ldd r17,z+ashbsc-ofdesc ;reads from actual SA HD-buffer sector in this cluster  
        st z+,r17      ;stores to open free dir entry sector in this cluster
        cpi r30,low(ofdecl+4) ;open free dir entry cluster = $0291 at 1541
        
        brne l20530    ;copies sector-in this-cluster and cluster (1+4bytes)
                       ;at end: r17 contains ofdecl+3 open free dir entry cluster highest
                       ;bit7-4 = clear
        ori r17,$b0    ;$00-0f -> $b0-bf  makes bits that:
                       ;bit7: 3 free direntries in a chain not found at all
                       ;bit6: flag that opfd..-values contain values of end of dir 

        sts ofdecl+3,r17 ;open free dir entry cluster highest = $0291 at 1541       

                       ;??? if there are 1 or 2 empty direnties before zhe end of the dir
                       ;    => the two direntries arent used???

l20540: lds r16,sdstcl+3 ;short-directory-start-cluster highest of direntry in dir-sector              
        andi r16,$ff   ;  (X shows to begin of shortname)
        brpl l20550    ;b.i.wanted-to-saved-input-shortname already exists in dir

        rjmp l20670    ;=no single dir-shortname fits to to-saved-input-shortname
                       ; (at once, after first loop)
                          
l20550:                ;=to-saved-input-shortname already exists in dir
                       ;  =>any shortname must be changed
                       ; (shortrname of different direntry is too complicated to rename) 
                       ;part of longname (=>to-saved-input-shortname must be renamed)
                
        lds r16,natac0 ;name-tail-counter1 
                       ;bit 7-6: bitwise flags which last number of shortnametail
                       ;          is found in dir numbers 8-9
                       ;           bit7 = '8'
                       ;           bit6 = '9'
                       ;bit 5  : flag for real-short-name / part of long-name
                       ;          0 = real short-name
                       ;          1 = part of a longname
                       ;bit 4  : flag whether shortname contains tail  no-tail
                       ;          (only if it's a real shortname and not a part of a longname)  
                       ;          0 = real-short-name has no tail
                       ;          1 = real short-name has accidentially tail
                       ;bit 3-0: position where last digit of tail is (2-7)
                       ;                        ($.f = no tail) 
        lds r17,natac1 ;name-tail-counter0 bitwise flags which last number of shortnametail
                       ;  is found in dir numbers 0-7
                       ;   bit7 = '0'
                       ;   bit0 = '7'

        mov r22,r16    ;natac0
        andi r22,$0f   ;masks position where last digit of tail is (2-7)
                       ;pay attention that program doesn't come here if there is no tail
        add r26,r22    ;r26,r27 must contain vector to inputname short                      
   
        ldi r18,$30    ;'0'

l20560: lsl r16        ;'8'-bit -> carry   '9'-bit -> '8'-bit    
        rol r17        ;'0'-bit -> carry   '1'-bit -> '0'-bit    carry -> '7'-bit    

        brcc l20660    ;b.i.shortname with this last digit ('0' - '9') wasn't found in dir
                       
                       ;=shortname with this last digit ('0' - '9') already exists in dir
l20570: inc r18         ;'0'->'1'  '1'->'2'     '8'->'9'   '9' -> $3a
        cpi r18,$3a
        brne l20560    ;test whether one of the 10 tested shortnames is free 
                       ;at first loop: a~0 is always set as present => tests a~1 to a~9 
                       ; later loops: a~10 to a~19    abcde~10 to abcde~19    a~2130 to a~2139
                       ;-------------------------------------------------------------------------
                       ;=all 10 tested shortnames with tail already exist in dir a~1 ~1 aaaaaa~1
                       ;incremets tailnumber by 10
l20580: ld r16,-x      ;digit of tailnumber that must be incremented (starts at secondlast digit)
        cpi r16,$7e    ;~
        breq l20620    ;b.i. overflow at increment e.g. increment 91->101 or 991->1001
        
        inc r16        ;'0'->'1'    '8'->'9'    '9'->$3a

        cpi r16,$3a
        brne l20590    ;b.i.no overflow at this digit e.g. a~10->a~20  a~80->a~90  a~8990->a~9990

                       ;=a~191->a~201  a~11191->a~11201   a~19001->a~20001 abcd~191->abcd~201
        ldi r16,$30    ;'0'
        st x,r16       ;

        rjmp l20580    ;increments digit in front

l20590: st x,r16

l20600: lds r22,natac0 ;name-tail-counter0

l20610: ldi r23,$00
        rjmp l20310    ;check whether next 10 shortnames already exist in dir--------------------  

l20620:                ;make tailnumber 1 digit longer
                       ;= a~1->a~11   a~91->a~101  a~9991->a~10001  abcdef~1->abcde~11
                       ;abcdef~1->abcde~11  abcde~1->abcdef~11

                       ;the filenames can alos be that the digit of the tail is not at pos 7
                       ; e.g. a 'space' is skipped and not chnaged to underscore
        cpi r22,$07    ;r22 still contains position of last digit of tailnumber
        breq l20640    ;b.i.shortname already 8 chars long (=>increment tailnumber at begin)

                       ;=shortname less than 8 chars long (=>increment tailnumber at end)
                       ;012        0123456                                    012     0123456 
                       ;a~1->a~11  abcde~1->abcde~11           old shortname: a~1     ab~9991
        inc r26        ;X shows to first digit after ~     so far changed to: a~1     ab~0001
        
        
        ldi r16,$31    ;'1'

l20630: ld r17,x       ;                                                      a~1     ab~0001
        st x+,r16      ;1 or 0 (important to overwrite old last digit (1)     a~1     ab~1001 
        
        ldi r16,$30    ;'0'
        cpi r17,$31    ;'1' is always last digit of tailnumber
                       ;              (=endflag of tailnumber)
        brne l20630    ;write middle of tailnumber with '0'
                       ;                                                      a~1     ab~1000      
        st x,r17       ;write '1' as last digit of tailnumber                 a~11    ab~10001

        lds r22,natac0 ;name-tail-counter1--
        inc r22        ;make pos of last cahr of tailname one more to end  
        rjmp l20610    ;check whether next 10 shortnames already exist in dir--------------------  

l20640:                ;=shortname already 8 chars long (=>increment tailnumber at begin)      
                       ;                                   old shortname: abcdef~1   ab~99991
                       ;                               so far changed to: abcdef~1   ab~00001
        cpi r26,low(innash+2) ;inputname short (X shows to ~)              6          2                                     
        brcc l20650    ;b.i.new shortname will be legal (a~100001)
                   
        ldi r17,$1e    ;1e-- 30--               
        jmp syserr     ;system error  
  
l20650: dec r26        ;X shows to 1 in front of ~
        st x+,r16      ;~                                                 abcde~~1   a~~00001            

        ldi r16,$31
        st x,r16       ;                                                  abcde~11   a~100001
        
        rjmp l20600    ;check whether next 10 shortnames already exist in dir--------------------  

l20660:                ; =shortname with this last digit ('0' - '9') (r18) wasn't found in dir
                       ; (X shows to last digit of tailnumber)  
        st x,r18       ;write not-found last digit as last digit of tailnumber of shortname    

                       ;the shortname could be changed
                       ;=> must perhaps be generated again out of longname????????????????????
                       ;(if different shortname was renamed)  
                       ; no, it's always the shortname of the actual CBM-name changed  
l20670: ldi r25,$1f    ;1f--'w'
        call l13080

        ret            ;innash contains now shortname which can be used (doesn't exist in dir) 
;------------------------------------------------------------------------------------------------     
                       ;from l19700, l19710
l20680:                ;                                                        save a file  d9e3
        ldi r16,$57    ;'w' for write/save as debugbyte high
        sts debyhi,r16 ;debug-byte-high               

        lds r16,cm024a ;actual filetype
        cpi r16,$06
        brne l20690    ;b.i.not DIRectory
        
        ldi r16,$30    ;48,illegal job,00,00
        jmp l17600
            
l20690:      
/*  
        lds r25,ofdeve ;temporary
        sts $0d1a,r25
        lds r25,ofdesc
        sts $0d1b,r25
        lds r25,ofdecl
        sts $0d1c,r25
        lds r25,ofdecl+1
        sts $0d1d,r25
        lds r25,ofdecl+2
        sts $0d1e,r25
        lds r25,ofdecl+3
        sts $0d1f,r25  ;temporary
*/
  
        rcall l19980   ;search and compare input-shortname with dirnames
                       ;it's impossible to make this at the first direntry search
                       ; because there the filetype is unknown
                       ; => dir search must be made (at least) twice (slower)
                       ;and search 3 free direntries in a chain

/*        
        lds r25,ofdeve ;temporary
        sts $0d22,r25
        lds r25,ofdesc
        sts $0d23,r25
        lds r25,ofdecl
        sts $0d24,r25
        lds r25,ofdecl+1
        sts $0d25,r25
        lds r25,ofdecl+2
        sts $0d26,r25
        lds r25,ofdecl+3
        sts $0d27,r25  ;temporary
*/

        rcall l19180   ;create direntry  part1                                               d9ec       
                       ;allocates dir-cluster (if this new direntry doesn't fit into directory)
                       ;ofdeve, ofdesc & ofdecl show now to first of 3 free direntries

 
/*  
        lds r25,ofdeve ;temporary
        sts $0d2a,r25
        lds r25,ofdesc
        sts $0d2b,r25
        lds r25,ofdecl
        sts $0d2c,r25
        lds r25,ofdecl+1
        sts $0d2d,r25
        lds r25,ofdecl+2
        sts $0d2e,r25
        lds r25,ofdecl+3
        sts $0d2f,r25  ;temporary
*/
      
        rcall l21890   ;allocates startcluster, set flag f. listener, reset vectors          d9e9
                       ;allocates startcluster 

/*
        lds r25,ofdeve ;temporary
        sts $0d32,r25
        lds r25,ofdesc
        sts $0d33,r25
        lds r25,ofdecl
        sts $0d34,r25
        lds r25,ofdecl+1
        sts $0d35,r25
        lds r25,ofdecl+2
        sts $0d36,r25
        lds r25,ofdecl+3
        sts $0d37,r25  ;temporary
*/
        ldi r16,$00    ;flag for open
        rcall l19240   ;create direntry part2                                                d9ec       
 
/*
        lds r25,ofdeve ;temporary
        sts $0d3a,r25
        lds r25,ofdesc
        sts $0d3b,r25
        lds r25,ofdecl
        sts $0d3c,r25
        lds r25,ofdecl+1
        sts $0d3d,r25
        lds r25,ofdecl+2
        sts $0d3e,r25
        lds r25,ofdecl+3
        sts $0d3f,r25  ;temporary
*/

        rcall l19110   ;copy geaccl general actual cluster (=startcluster of file)  
                       ; to  ashbcl actual SA HD-buffer cluster                   
                       ; geaccl ->     ashbcl
                       ; $80/81 -> $06/07 - $0e/0f            

                       ;create dir entry is splitted into two parts because:
                       ; first the new dircluster is allocated (in the FAT)
                       ; then the first filecluster is allocated (in the FAT)
                       ; => the new file isn't fragmented after the first file-cluster

                       ;so far it has been important, that the AVR-HD-buffer is used only
                       ; (without using the CBM-buffer)
                       ;at the real save/write it's important that the CBM-buffer is used

         ldi r16,$04   ;....1100 flag for read/write only into/from AVR-HD-buffer
                       ;                  don't change CBM-buffer
                       ; so far the routine 'action after Listen' makes the reading of 
                       ;  a HD-sector and copying from CBM to HD-buffer
                       ; this could perhaps be changed in future to    
                       ;  flag for write CBM-buffer to AVR HD buffer and then to HD
                       ;but before the write sector routine must be changed 
        sts ashbtr,r16 ;HD-buffertransfer-read
        sts ashbtw,r16 ;actual SA HD-buffer-transfer write
                       ;don't know whether correct place here??????????????????????????
                       ;this is 'save a file'
                       
                       
                       ;.........................................................................
                       ;from l19790, l19850 (load, read) 
l20700: lds r16,icsawo ;IECSecundaryAddress without bits whether open,close,SA ($83)         d9ef  
        cpi r16,$00
        brne l20710    ;b.i.not load

                       ;=load
        rcall l20720   ;store filedatas of last file at load (/save) 
                       ;for next acces with e.g.: load"*"
                       
                       ;at load:
                       ; -at open:  
                       ;  the startcluster is known
                       ;  the filelength is known
                       ; -at close:
                       ;  the (remainig) filelength is wrong
                       ; => at load: store the values at opening the file
                       
                       ;save: at save:
                       ; -at open:
                       ;  the startcluster is known, but not yet written into the direntry
                       ;  the filelength is unknown
                       ; -at close:
                       ;  the startcluster is known
                       ;  the filelength is known
                       ; => at save: store the values at closing the file
                       
l20710: jmp l17260     ;end of command (jmp c199)                                            da06
;................................................................................................
                       ;from l20690, 
l20720:                ;                                store filedatas of last file at load/save 
                       ;                                 for next acces with e.g.: load"*"
                       ;at load:
                       ; -at open:  
                       ;  the startcluster is known
                       ;  the filelength is known
                       ; -at close:
                       ;  the (remainig) filelength is wrong
                       ; => at load: store the values at opening the file
                       
                       ;save: at save:
                       ; -at open:
                       ;  the startcluster is known, but not yet written into the direntry
                       ;  the filelength is unknown
                       ; -at close:
                       ;  the startcluster is known
                       ;  the filelength is known
                       ; => at save: store the values at closing the file
        lds r12,ashbcl                                                                 ;d9f8/da01  
        lds r13,ashbcl+1;loads actual cluster secundary address
        lds r14,ashbcl+2
        lds r15,ashbcl+3 ;startcluster highest 00-0f 
                       ;.........................................................................
                       ;from l21810
l20730: sts laprcb,r12 ;  007e 026e 026f at 1541                                        d9fa/da03
        sts laprcb+1,r13
        sts laprcb+2,r14            
        sts laprcb+3,r15
       
        lds r20,asflre ;actual SA filelength (remaining) (for EOI-calculating)
        lds r21,asflre+1
        lds r22,asflre+2
        lds r23,asflre+3
   
        sts laprfl,r20 ;last program filelength 
        sts laprfl+1,r21
        sts laprfl+2,r22
        sts laprfl+3,r23

        ;lds r16,acdrnu ;actual drive number  =$007f at 1541                                 d9fc
        ;sts laprdr,r16 ;last program drivenumber (for load"*")                              d9fe
        ret
;------------------------------------------------------------------------------------------------
                       ;                             take filetype and filmode out of inputstring
l20740: ldd r28,z+low(cfpobc) ;command/filename position of begin/commas = 027a,x at1541     da09 
        ld r16,y       ;reads first char behind first or second comma
        
;        mov r18,r30    ;backups vector to open-table necessary??

        ldi r30,low(optamo<<1) ;open table mode: Read Write Append Modify
        ldi r31,high(optamo<<1)       

        ldi r18,$ff    ;default for neither type nor mode found

l20750: cpi r30,low((optamo<<1)+4)
        breq l20760    ;b.i.end of mode-table reached                                        da12

        lpm r19,z+
        cp r16,r19     ;compares input-character and table-character                         da14
        brne l20750

        subi r30,(low(optamo<<1)+1)
        sts opfimo,r30 ;open filemode (read/write)   0297 at 1541

l20760: ldi r30,low(optats<<1) ;open table type: Del Seq Prg Usr reL (Cbm=dir Image=diskimage)
        ldi r31,high(optats<<1)       

l20770: cpi r30,low((optats<<1)+$10)
        breq l20780    ;b.i.end of type-table reached                                        da1f

        lpm r19,z+
        cpi r19,$20    ;space = flag for empty table entry
        breq l20770 

        cp r16,r19     ;compares input-character and table-character                         da21
        brne l20770

        subi r30,(low(optats<<1)+1)
        sts cm024a,r30 ;actual filetype?

        mov r18,r30    ;r18 = filetype 0-4 (=Y at 1541) 

l20780: ldi r31,high(cfmebe) ;restores command/filename memory begin
 
        ret            ;                                                                     da29
;------------------------------------------------------------------------------------------------
                       ;directory of 1541:
                       ; C64 makes open 2,8,0,"$
                       ;ea2e-ea53 write $.... into inputbuffer
                       ;ebe7 mainwaitingloop
                       ;ebfc jsr c146 analyse command
                       ;    c146
                       ;    c15d
                       ;    d7b4 open (no command)
                       ;    d7f3
                       ;    d7fc
                       ;    da55 =open of DIR
                       ;         analyse input-string
                       ;         initialize drives
                       ;    daa1 jsr c7b7
                       ;         c7b7 =create dirheaderline
                       ;              read BAM from disk (if neccessary)
                       ;              clear dirbuffer (02b1-02d4) (with spaces)
                       ;              write <RVS ON> " <diskname> " <space> to 02b1-02c4
                       ;    daa4 jsr c49d search first fitting dirnameentry
                       ;         c49d
                       ;         c4a2 jsr c5ac
                       ;              c5ac
                       ;              c5c1 jsr d475 set filetype = seq
                       ;                            set SA = $11 = internal read-address
                       ;                   d475 open channel of SA$11
                       ;                   d47e jsr dc46
                       ;                        dc46 open channel of SA$11 
                       ;                             make 1 buffer of channel of SA$11
                       ;                              make #$0x02-99,x/9a,x
                       ;                                 (dc48->d1e2->d20a->d28e->d2b1)
                       ;                              make #$0x02-99,x/9a,x
                       ;                                 (dc4b->dcb6->dcbc/dcc9)
                       ;                             read block 18,01 ($12,$01) (=first dirblock)
                       ;                              store followblock to $80,81
                       ;                              bufferpointer shows to pos2 = 1. databyte
                       ;                              read 1. databyte and store it as outputbyte
                       ;                              make ready to talk
                       ;                   d483 make bufferpointer to pos2 = 1. databyte
                       ;                         #$0x02->$94/95  #$0x02->99,x/9a,x
                       ;                            (d483->d4c8->d4cf-d4d7)
                       ;              c5ca-c63c search as long direntries until the first
                       ;                         not-deleted direntry is found
                       ;                         ++++++++ (read also follow-blocks) ++++++++
                       ;                         set vectors to actual direntry at
                       ;                          c621 lda#$20 jsr d1c6
                       ;                          d1ce #$0xy2->$94 #$0xy2->$99,x
                       ;                         at end when not-deleted direntry is found:
                       ;                          store dirvector -> $0294
                       ;                          store dirsector -> $0290
                       ;                          (dirtrack is always #$12 => not stored)
                       ;         c4a5 if no more not-deleted direntries at this drive, 
                       ;               then change drive (if the inputfilenames want this)---.
                       ;         --------------------------                                  |
                       ;-->  .-->c4b5 jsr c617 search next fitting dirnameentry              |
                       ;     |   ..........................                                  |
                       ;     |   c4ba jsr c4d8 <---------------------------------------------'
                       ;     |        c4d8 compare the dir-name with 1 - 4 inputnames
                       ;     |              at end: x=#$ff = names don't match
                       ;     |        c5ab          x=00-04 = dirname fits to inputname 0-4
                       ;     +---c4bd if no match then search next not-deleted direntry
                       ;     |   c4c9 compare filetype; if inputname-filetype doesn't match to 
                       ;     '---------dirname-filetype then search next not-deleted direntry
                       ;         c4d7 at end: plus (c4d7) = matching direntry found
                       ;                            x = number of fitting inputfilename (0-4)
                       ;                            0294 0290 shows to direntry of fitting entry
                       ;                      minus (c4b4) = no matching direntry found
                       ;    daa7 jsr ec9e open 1 buffer of channel of SA$00
                       ;                   (1541: diretory is only at SA$00 possible
                       ;                          open 2,8,1,"$" doesn't open dir
                       ;                          open 2,8,0,"$" opens dir)
                       ;                   (NLQ-HD: opens directory at any SA)
                       ;                  clear end-flag #$00->$0244,x
                       ;                  create first dirline (with dirname) in SA$00-buffer
                       ;                   by copying from dirbuffer 02b1 to SA$00-buffer
                       ;             ece7 write correct values in this first dirline
                       ;
                       ;-->      .-->ecea ----loop----
                       ;         |   ecf2 jsr c6ce 
                       ;         |        c6ce backup actual SA (#$00) and channel to stack
                       ;         |        c6d4 jsr c6de 
                       ;         |             c6de activate SA$11
                       ;         |             c6e8 if no fitting direntry at this drive
                       ;         |                   then change drive
                       ;         |                  if no fitting direntry at next drive 
                       ;         |                   then write 'blocks free' into dirbuffer
                       ;         |                   (c6f2 jsr c806)
                       ;         |             c71b copy dirname from SA$11-buffer into dirbuffer
                       ;         |             c7a7 jsr c4b5 search next fitting dirnameentry
                       ;         |                            (see above)
                       ;         |               ++++++++ (read also follow-blocks) ++++++++
                       ;         |             c7ab-end: sec=there is an actual fitting direntry
                       ;         |             c6f6-end: clc=there is no fitting direntry
                       ;         |             c71a-end: sec=there is the next drive to display
                       ;         |                            (no more direntry on former actual
                       ;         |                              drive)
                       ;         |                  end of c6de-routine:
                       ;         |                   -carry says whether there is an actual 
                       ;         |                     direntry:
                       ;         |                      -clc: there is no actual fitting direntry
                       ;         |                      -sec: there is an acatual fitting dirent.
                       ;         |                       '-if sec:
                       ;         |                          $0293 says whether there is a 
                       ;         |                           follow-dirblock of actual direntry
                       ;         |                           -#$00: there is no follow-dirblock
                       ;         |                                    of actual direntry
                       ;         |        c6dd restore SA$00 and channel from stack
                       ;         |   ecf5 - if there is no actual fitting direntry found:
                       ;         |           write 'blocks free' in SA$00-buffer
                       ;         |           set ready to talk
                       ;         |        - if there is an actual fitting direntry found:     
                       ;         |           copy entry from dirbuffer 02b1 to SA$00-buffer
                       ;         |           -make as long next direntries until
                       ;         '-----------  1 SA$00-buffer (256bytes = 8direntries) is full
                       ;                     -if 1 SA$00-buffer is full then
                       ;                       set ready to talk
                       ;    daaa take 1 byte from buffer
                       ;         set values
                       ;         clear inputvector (not inputbuffer)
                       ;         ( rts to ebfc at open / rts to ed7f at TALK) 
                       ;ebff main-waitingloop----------------------------------------------------                          
                       ;
                       ;---- C64 sends TALK & SA after TALK ----
                       ;---- 1541 reacts to ATN-active edge and goes to 
                       ;            fffe -> fe67 ->fe73 -> e853:  #$01->$7c ----
                       ;ec04 jmp e85b 
                       ;     e85b action after receive of ATN
                       ;          receive TALK and SA
                       ;     e8f7 jsr e909 job of TALK 
                       ;          e909 
                       ;     .--->e90f send databyte to C64
                       ;     |    e992 jsr d3aa take byte from buffer
                       ;     |         d3aa
                       ;     |         d40e jsr ed67 take OPEN-byte from buffer
                       ;     |              ed67 take OPEN-byte from buffer
                       ;     |                   -if still bytes in SA$00-buffer then  
                       ;     |                     rts to e995
                       ;     |                   -if SA$00-buffer is read to end then
                       ;     |                     -if this was the last direntry then
                       ;     |                       set flag for EOI 
                       ;     |                       rts to e995
                       ;     |                     -if there are still direntries then
                       ;     |              ed7f jsr ecea already explained at OPEN above
                       ;     |                   ++++++++ (read also follow-blocks) ++++++++
                       ;     |                   ecea read fitting direntry from SA$11-buffer
                       ;     |                         to dirbuffer
                       ;     |                        copy direntry from dirbuffer to 
                       ;     |                         SA$00-buffer  
                       ;     |                   ed22 copy as long direntries until 1 buffer 
                       ;     |                         (= 256bytes = 8direntries) is full
                       ;     |              ed83 rts to e995      
                       ;     '----e996 jmp e90f (send next databyte to C64)                  
                       ;1541 doesn't leave this routine even if the end of the dir is reached
                       ;it just sends an EOI at sending of the last byte
                       ;it waits until the C64 sends an UNTALK (with ATN=active)
                       ;-1541 wants to send a not-existing byte after EOI
                       ;-e916 jsr ea59
                       ;      ea59 ATN-line is made active by C64 
                       ;            as sign that C64 wants to send UNTALK   
                       ;      ea60  branch     
                       ;      ea6b jmp e8d7 routine after ATN-active (=receive UNTALK)

                       ;1541 makes everything difficult:
                       ;it uses two buffers, an active and an inactive one
                       ;reason: this was perhaps faster at old drives with two microprocessors
                       ; while the mainprocessor sends the active buffer to the C64
                       ;  the second processor reads a block from disk  = faster
                       ; the 1541 has one processor only => second processor is replaced by
                       ;  the IRQ-routine
                       ; => this isn't faster at the 1541 (but more complicated)
                       ;NLQ-HD uses one buffer only
                       ;
                       ;at directory-routines:
                       ;routine c6de-c7ab take dirnameentry from disk
                       ;-(the vector 99,x/9a,x must be set before (#$0xy2, e.g.#$0x02)
                       ;  to the actual dirnameentry)
                       ;-copy dirnameentry from SA$11-buffer to dirbuffe 02b1 (c71b-c7a5)
                       ;-search the next direntry
                       ;  at end:-94/95 and 99,x/9a,x show to the followdirnameentry
                       ;                                    (not to the actually copied)
                       ;         -$0253 contains the flag for the followdirnameentry
                       ;                                    (not to the actually copied)
                       ;this makes the routine very complicated
                       ;easier would be:
                       ;-first check whether there is a not-deleted dirnameentry
                       ;-then copy this to the dirbuffer       
                       ;from l19570
l20790:                ;                                                     load directory  da55
                       ;Y-reg r28/29 shows to begin inputbuffer
                       ;Z-reg r30/31 shows to end of startclustertable of open-tables

                       ;COMMANDER64 uses $=t:*=l for dir (=timestamp)-------------------begin----
                       ; => NLQHD must sent at this command a cerrect dir
                       ; => time-parts of inputname must be deleted
                       ;command from C64      changed to
                       ; $=t                  $
                       ; $=t2                 $2
                       ; $=t2:*=p             $2:*=p
                       ; $=t2:*=p,l           $2:*=p
                       ; $=t2:*=r,l           $2:*=l   ??? not shure ??? reL-files only?
                       ; $=t2:*=p,l,>...      $2:*=p
                       ; $=t:*=l,<...         $ or $*
                       ; $=t4:*=s,n,>...,<... $4:*=s
                       ; $=t:*=l              $ or $*
                       ; $=t/path             $/path
                       ; $=t2/path            $2/path
                       ; $=t2/path:*=l        $2/path or $2/path:*
                       ; $=t2/path:*=u,l      $2/path:*=u
                       ; $=t:a*=l             $a*
                       ; $=t:a*=p,l           $:a*=p

                       ; $=t:*=<... is probably not possible? (there must be *=l or *=n) ???

                       ; when rel-files are wanted: use 'r' (not'l' how usually)!!!!!!

        lds r16,inbube+1
        cpi r16,$3d    ;'='
        brne l20890    ;b.i.not '$='

        lds r16,inbube+2
        cpi r16,$54    ;'t'
        brne l20890    ;b.i.not '$=t'

        ldi r26,low(inbube+1) ;writevector to char 1 of inputbuffer (#$01)
        ldi r27,high(inbube+1)

        ldi r28,low(inbube+3) ;readvector to char 3 of inputbuffer  (#$03)
                       ;r29 skows already to inputbufferbegin
 
        lds r17,incoen ;input command end

l20800: cp r28,r17
        brcc l20810    ;b.i.end of inputstring reached

        ld r16,y+      ;copy inputstring to remove '=t' behind $
        st x+,r16
        rjmp l20800

l20810: sts incoen,r26 ;new inputcommandend is 2 chars shorter

        mov r17,r26    ;(new) inputcommandend 
        ldi r28,low(inbube)

l20820: cp r28,r17
        brcc l20880    ;b.i.end of inputstring reached       

        ld r16,y+
        cpi r16,$3a    ;':'  search ':'
        brne l20820
                       ;= ':' found
l20830: cp r28,r17
        brcc l20880    ;b.i.end of inputstring reached       

        ld r16,y+
        cpi r16,$3d    ;'='  search '='
        brne l20830

        ld r16,y       ;read char behind '$ (t=) :[a]*='
        cpi r16,$52    ;'r'
        brne l20840
                       ;=$ (t=) : [a]*=r
        ldi r16,$4c    ;'l'
        st y,r16       ; $ (t=) . [a]*=l
        rjmp l20860  

l20840: cpi r16,$4c    ;'l'
        breq l20850

        cpi r16,$4e    ;'n'
        brne l20860    ;b.i. *=s, *=p, *=u, *=b ... (not *=r, not *=l, not *=n)
                       ;b.i. *=s,l, *=p,n, *=u,< *=b,> (cut off end)

l20850: subi r28,$02   ;cuts off end of command: [a]*=l -> [a]*
                       ;(is incremented at l20860) 
l20860: inc r28

l20870: sts incoen,r28

l20880: ldi r28,low(inbube);--------------------------------------------------------------end----

l20890: ldi r16,$12    ;1541 uses #$0c                                 
        sts cocono,r16 ;command commandnumber  =022a at 1541                                 da57 
        ldi r16,$00    ;default for drivenumber 0                                            da5a                                           
        lds r17,incoen ;input command end (+1) =length of command  = $0274 at 1541           da5c
        dec r17        ;                                                                     da5f
        breq l20900    ;b.i.command is 1 char long                                           da60

        dec r17        ;                                                                     da62
        brne l20910    ;b.i.comand is 3-255 chars long                                       da63

                       ;=command is 2 chars long
        lds r16,inbube+1 ;second char of inputbuffer = drivenumber                           da65
        call l17520    ;test whether a contains a legal drivenumber
        brmi l20910    ;b.i.illegal drivenumber                                              da6b

l20900: sts cfdrno,r16 ;command/filename drive number                        = e2,x at 1541  da6d
                       ;if length = 1, 3-255: #$00
                       ;if length = 2:        second char of inputbuffer and#$81?
        ldi r18,$01
        sts cm0277,r18 ;CBM-memory $0277 length of filename0????????????????????????????     da6f
                       ;cleared at d7b9 jsr c2b3 => here #$00->#$01
        sts opamco,r18 ;open amount of commas  =                              $0278 at 1541  da72
                       ;cleared at d7b9 jsr c2b3 => here #$00->#$01
        sts cfpobc,r18 ;command/filename position of begin/commas            = 027a,x at1541 da75
                       ;begin of filename 0 in inputbuffer
        ldi r16,$80    ;                                                                     da78
        sts cffljo,r16 ;command/filename flag for joker & filetype            = e7,x at 1541 da7a
                       ; bit7: 0=no joker          1=joker
                       ;       bit 7 is taken from inputfilename
                       ;       bit6-0 is taken every time from dirfilename    
                       ; bit6: 0=can be scratched  1=scratch-protected
                       ; bit5: 0=not closed        1=closed
                       ; bit4: unused?
                       ;bit3-0: filetype
                       ;!!!! bit7 has here probably a different meaning !!!!
        ldi r16,$2a    ;*-joker                                                              da7c
        sts inbube,r16 ;store * as first char of inputstring                                 da7e
        sts inbube+1,r16 ;store * as first char of inputstring                               da81
        rjmp l20940    ;                                                                     da84
        ;--------
l20910: call l17320    ;search colon (':')                                                   da86
                       ;initializes Y-reg r28/29 to begin of inputbuffer
                       ;initialized Y-reg r30/31 to begin of open-tables
                       ;r28 = 1541-Y position+1 of searched character (#$00 if not found)

        brne l20920    ;b.i.colon found                                                      da89

                       ;=colon not found 
        call l17460    ;clear most values for open                                           da8b                                                                     da8b
                       ;at return: 1541-X = r30 must be #$00 ??
        ldi r28,$03    ;                                                                     da8e

l20920: dec r28        ;                                                                     da90
        dec r28        ;                                                                     da91
        sts cfpobc,r28 ;command/filename position of begin/commas           = 027a,x at1541  da92  
                       ;-if no colon:        012345
                       ;  r28=#$01           $*=p   r28=#$01 
                       ;-if colon:
                       ;  r28 show to pos    $:*=p  r28=#$02
                       ;  in front of ':'    $0:*=p r28=#$03
                       ;                     012345
                       ;Y-reg r28/r29 must show to correct pos of inputbuffer
                       ;Z-reg r30/r31 must show to open-tables
        call l17370    ;analyse inputstring                                                  da95
 
/*
ldi r25,$44   ;44--

brne l20930

ldi r25,$45   ;45--

l20930:
jmp freeze
*/




 
 
 
 
        call l17490    ;take filetype from inputbuffer                                       da98
        call l16550    ;take drivenumbers from inputbuffer                                   da9b

l20940: call l16640    ;initialize drive & switch on LED                                     da9e
                       ;---------end analyse inpustring and initialize at open dir-----------
                       ;---------begin create first dirline (with diskname)------------------ 
l20950:                ;                                                     
                       ;                                       daa1 jsr c7b7 create first dirline  
                       ;1541 writes first from SA$11-nuffer to dirbuffer
                       ;            then from dirbuffer to SA$00-buffer
                       ;NLQ-HD writes directly from 512bytes-HD-buffer to CBM-buffer

        ldi r25,$f0    ;f0----
        call l13090

                       ;1541 uses SA=$11 for reading dir
                       ;nlq-hd uses actual SA 
                       ;because this SA is used by the C64

        lds r16,asfla0 ;flag0 of actual SA    = load "$" 
        andi r16,$fc   ;clears dir-bits  
        ori r16,$02    ;sets flag for directory                           = $0254 at 1541??  ed1a
        sts asfla0,r16  
                       ;still make: load short dir only = ori r16,$01!!!!!!!!!!!!!!!!!!!!!!!!!!!!  

        ldi r16,$04    ;....1100 makes flag for don't copy 512-HD-buffer to 256-CBM-buffer
        sts ashbtr,r16 ;actual SA HD-buffer-transfer read 

                       ;what about hbtwr????????????????

        call l18760    ;sets flag that actual SA is opened for read daa4-c5ac-d475-dc46-d1e2-d1f5
                       ;sets tasach table SA->channel for SA 00-0e that actual SA is opened

        ldi r30,low(fidili<<1) ;first dir line
        ldi r31,high(fidili<<1) ;initialize Z pointer

        ldi r28,low(cbbube) ;0b00
        ldi r29,high(cbbube)

        sts ashbve,r28 ;actual SA HD-buffer vector to 00 (0900)
      
        ldi r25,$f4    ;f4----
        call l13090

l20960: lpm r16,z+      ;copies no dirname error  default                          daa1-c7b7-c7ed
        st y+,r16       ;
        cpi r28,$20     ;copies to 0b00-0b1f
        brne l20960        
                        ;1541 writes first in dirbuffer 02b1
                        ;and later from dirbuffer into SA$00-buffer
                        ;NH writes directly into SA$xx-buffer

       #if (partname == 3) | (partname == 6)
        #message nlq-hd/SD-routines
        ldi r16,$53     ;'s'
        sts cbbube+$1d,r16  ;'nlqsd'
       #endif

       #if (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/multiple emulations
        lds r17,acemen  ;actual emulation entry
        cpi r17,$02
        brne l20970     ;b.i.not SD
               
        ldi r16,$53     ;'s'
        sts cbbube+$1d,r16 ;'nlqsd'

l20970:
       #endif

       #if partname == 1    
        #message 162-IEC-ATA-V2
        lds r12,cbadd0 ;clusterbegin actual directory drive0 
        lds r13,cbadd0+1 ;                                                   
        lds r14,cbadd0+2 
        lds r15,cbadd0+3

       #else
        #message 644-non-IEC-ATA
        push r26
        push r27

        ldi r26,low(cbadd0)
        ldi r27,high(cbadd0) ;              $10c8                
        lds r25,acemen ;actual emulated entry $00,  $01,  $02
        swap r25       ;                      $00,  $10,  $20    
        or r26,r25     ;                    $10c8,$10d8,$10e8

        ld r12,x+      ;clusterbegin actual directory of actual deviceemulation
        ld r13,x+
        ld r14,x+
        ld r15,x

        pop r27
        pop r26
       #endif 

        ldi r25,$f5    ;f5--
        call l13130

        mov r16,r12
        cpi r16,$02
        brne l21020    ;b.i.not root-directory = b.i.search dirname in not-rootdirectory
                       ;                               = search it in parentdirectory
        mov r16,r13
        or r16,r14
        or r16,r15
        brne l21020    ;b.i.not root-directory (00000002)

                       ;= search dirname in rootdirectory 
        call l15640   ;read first dir entry (=root-dir) without using SA$11

        ldi r25,$f6    ;f6--
        call l13130

        rjmp l20990    ;---------------------------------------------

l20980: call l15660   ;read next direntry (changes everything Y Z...)
                       ;Y shows to begin of HD-short-direntry
                        
l20990: brne l21010    ;b.i.end of dir reached without finding volume-ID-entry
        
                       ;at volume-ID-entry bit 6-4 is always cleared (read-only = scratch-proof ..)
        cpi r16,$8f    ;compares with directory filetype for Volume-ID
        brne l20980    ;b.i.not volume-ID -> read next dir-entry

        ldi r25,$f8    ;f8--
        call l13130

        ldi r30,$08    ;Z = writevector into CBM-dirline
        ldi r31,high(cbbube)
        
l21000: ld r16,y+      ;copies dirname from HD-dir into CBM first dir line
        st z+,r16      ;11 characters (0a00-0a0a / 0be0-0bea)
        cpi r30,$13    ;writes 11 characters =name   to 0808-0812
        brne l21000    ;                                0d08-0d12

        ldi r25,$fb    ;fb--
        call l13130

l21010: rjmp l21080    ;end of dirname of rootdir from volume-ID--------------

l21020:                ;read dirname of non-rootdirs
                       ;the dir of non-rootdirs contains not the name of the dir.
                       ; the dirname is in the parent-directory only
       #if partname == 1    
        #message 162-IEC-ATA-V2
        lds r12,cbadd0 ;clusterbegin actual directory drive0 
        lds r13,cbadd0+1 ;                                                   
        lds r14,cbadd0+2 
        lds r15,cbadd0+3

       #else
        #message 644-non-IEC-ATA
        push r26
        push r27

        ldi r26,low(cbadd0)
        ldi r27,high(cbadd0) ;              $10c8                
        lds r25,acemen ;actual emulated entry $00,  $01,  $02
        swap r25       ;                      $00,  $10,  $20    
        or r26,r25     ;                    $10c8,$10d8,$10e8

        ld r12,x+      ;clusterbegin actual directory of actual deviceemulation
        ld r13,x+
        ld r14,x+
        ld r15,x

        pop r27
        pop r26
       #endif 

        sts ofdecl,r12 ;open free dir entry cluster                       = $0291 at 1541
        sts ofdecl+1,r13 ;backups clusterbegin actual directory drive0 
        sts ofdecl+2,r14 ; to open free dir entry cluster !!!!!!!
        sts ofdecl+3,r15 ;used here as temporary memory

        call l17900   ;searches dotdot-entry of actual dir and stores clusteraddress of
                       ;parent-dir to clusterbegin actual directory drive0

        brne l21070    ;b.i.dotdot-entry not found (=error)

        call l15640   ;read first direntry of actual directory (=parent dir of actual dir)
        rjmp l21040    ;    without using SA$11

l21030: call l15660   ;reads next direntry of actual directory (=parent dir of actual dir)
                       ;r12-r15 contain startcluster of actual dir-entry 

l21040: brne l21070    ;b.i.end of dir reached without finding 
                       ; entry of actual dir in parent entry 

        ;andi r16,$0f   ;masks filetype bits
        ;cpi r16,$06    ;06= filetype for directory
        ;brne l21030    ;b.i.not directory

        lds r16,ofdecl ;open free dir entry cluster                       = $0291 at 1541
        lds r17,ofdecl+1 ;contains clusteraddress of actual dir
        lds r18,ofdecl+2 ;not the parent dir which is actually loaded
        lds r19,ofdecl+3 ;here used as temporary memory

        cp r12,r16
        brne l21030    ;b.i.clusteraddres of fileentry is different to actual directory

        cp r13,r17
        brne l21030

        cp r14,r18
        brne l21030

        cp r15,r19
        brne l21030
                       ;=direntry of actual dir in parent dir found
        ldi r28,low(dibube) ;directory buffer begin 
        ldi r29,high(dibube)
          
        ldi r30,$08    ;Z = writevector into CBM-dirline
        ldi r31,high(cbbube)
        
l21050: ld r16,y+      ;copies dirname from HD-dir into CBM first dir line
        cpi r16,$a0
        brne l21060    ;b.i.not shift-space
        
        ldi r16,$20    ;at dirname there are no shift-spaces => change them to space 
     
l21060: st z+,r16      ;16 characters (05e8-05f7a)
        cpi r30,$18    ;writes 16 characters =name   to 0508-0517
        brne l21050

l21070: lds r12,ofdecl ;open free dir entry cluster                       = $0291 at 1541
        lds r13,ofdecl+1
        lds r14,ofdecl+2
        lds r15,ofdecl+3

       #if partname == 1    
        #message 162-IEC-ATA-V2
        sts cbadd0,r12 ;clusterbegin actual directory drive0 low              
        sts cbadd0+1,r13 ;restores clusterbegin actual directory drive0 
        sts cbadd0+2,r14 ; from open free dir entry cluster !!!!!!!
        sts cbadd0+3,r15 

       #else
        #message 644-non-IEC-ATA
        push r26
        push r27

        ldi r26,low(cbadd0)
        ldi r27,high(cbadd0) ;              $10c8                
        lds r25,acemen ;actual emulated entry $00,  $01,  $02
        swap r25       ;                      $00,  $10,  $20    
        or r26,r25     ;                    $10c8,$10d8,$10e8

        st x+,r12      ;clusterbegin actual directory of actual deviceemulation
        st x+,r13
        st x+,r14
        st x,r15

        pop r27
        pop r26
       #endif 

        sts ofdecl+3,r07 ;#$ff  clears open free dir entry cluster----------

l21080: ldi r28,$20    ;Y = 0920 =next to-write entry in CBM-buffer
        sts ascbve,r28 ;actual SA CBM-buffer vector ($20, $40...$00)
                         
;        sts c6cor3,r06 ;clears (temporary)------------------------------------------------------

l21090: call l16770    ;search first to inputname fitting dirnameentry                                  c49d
        rjmp l21170    ;write dirline into cbm-buffer at vector ashbve         
                       ;-----------end create first dirline (with diskname)------------------ 
;------------------------------------------------------------------------------------------------
                       ; from l13440 (Talk to C64)
l21100: ldi r28,$00    ;write to begin of CBM-buffer              write dir-lines into CBM-buffer
        rjmp l21150         
l21110:
                       ;.........................................................................
                       ; from l  begin of loop
l21120: ori r28,$1f    ;0900-091f->091f  0920-093f->093f  (09e0-09ff->09ff)
        ld r16,y+      ;           0920             0940             (0a00)
                       ;increments CBM-dir-write-vector to begin of next entry

                       ;Y=write into CBM-buffer

l21130:
                       ;.........................................................................
                       ; from l21080
l21140: andi r28,$e0   ;
l21150: sts ascbve,r28 ;actual SA CBM-buffer vector ($20, $40...$00)
                       ;not incremented by $20 if unused-, volume-id(dirname)-entry

l21160: call l16790    ;search next to inputname fitting dirnameentry                        ecf2 
                       ; without loading dirblock

l21170:                ;found direntryname is in dibube directory-buffer
        lds r28,ascbve ;actual SA CBM-buffer vector ($20, $40...$00)
        ldi r29,high(cbbube) ; CBM-buffer begin 0800

        brpl l21180    ;b.i.end of dir not yet reached = b.i.fitting filename found         ?ecf5

                       ;= no (further) fitting dirname found 
        rjmp l21400    ;create last dirline

l21180: ldi r16,$01
        st y+,r16      ;#$01 to 0500 linkaddress low                                         ecec
        st y+,r16      ;#$01 to 0501 linkaddress high                                        ecef

                       ;compute blocklength of file---------------------------------------------- 
                       ;r20-23 contains filelength
  
        clr r12        ;default for filelength 0 bytes (= 0 blocks)
        clr r13

        subi r20,$01   ;subtracts 1 from filelength (without carry)
        sbci r21,$00   ;#$00 subtracts carry   
        sbci r22,$00   
        sbci r23,$00   
        brcc l21190    ;b.i.filelength >0 bytes
        
        clr r16
        clr r17
        rjmp l21270    ;filelength 0 bytes = 0 blocks

l21190:                ;begin divission by 254---------------------------------------------
                       ;http://www.avr-asm-tutorial.net/avr_de/rechnen/division.html#rolror
                       ;r20-r23 = divident = filelength
                       ;r24 = divisor (=$fe=254)  
                       ;r16-r19 = result = blocks ( 1 block = 254 bytes)
                       ;r13 = temporary register
        
        ldi r16,$01    ;result =$00000001
        ldi r17,$00    ;result register is also counter-register
        ldi r18,$00
        ldi r19,$00 
                       
        clr r13        ;temporary register
        ldi r24,$fe    ;254 divisor

l21200: lsl r20
        rol r21
        rol r22
        rol r23
        
        rol r13
        brcs l21210
        
        cp r13,r24     ;compares temporary-register and divisor
        brcs l21220
        
l21210: sub r13,r24    ;temporary-register minus divisor (without carry)
        sec
        rjmp l21230

l21220: clc

l21230: rol r16
        rol r17
        rol r18
        rol r19
        brcc l21200    ;end divission by 254---------------------------------------------
                  
        ldi r24,$01
        add r16,r24    ;#$01 adds 1 (to length in blocks)
        adc r17,r06    ;#$00 adds carry
        adc r18,r06
        adc r19,r06
/*        
        mov r20,r16    ;lowbyte filelength in blocks
        mov r21,r17    ;highbyte filelength in blocks

        subi r16,$ff   ;subtracts  f9ff 63999    0000f9fe  0000f9ff 0000fa00
        sbci r17,$f9   ;                         ffffffff  00000000 00000001
        sbci r18,$00   ;               carry =     set      clear    clear
        sbci r19,$00
        brcs l21240    ;b.i.block-filelength < f9ff 63999

        ldi r20,$ff    ;=block-filelength >= f9ff 63999
        ldi r21,$f9    ;=> set block-filelength = f9ff 63999

l21240: st y+,r20      ;low block-filelength to 0602                                         ecfa
        st y+,r21      ;high block-filelength to 0603                                        ed00

        ldi r22,$20    ;space
        cpi r21,$00
        brne l21260    ;b.i.block-filelength >=256 blocks (-> 1 space)
                
        cpi r20,$64
        brcc l21260    ;b.i.block-filelength 100-255 blocks (-> 1 space)
        
        cpi r20,$0a  
        brcc l21250    ;b.i.block-filelength 10-99 blocks (-> 2 spaces)    
                         
        st y+,r22      ;block-filelength 0-9 blocks (-> 3 spaces) 0504
l21250: st y+,r22      ;                                          0505 0504      
l21260: st y+,r22      ;                                          0506 0505 0504
*/
  
        or r18,r19
        breq l21270    ;b.i.filelength 1-65535 1-$ffff blocks
        
        ldi r16,$ff    ;=filelength >65535 >$ffff blocks
        ldi r17,$ff  
  
l21270: st y+,r16      ;low block-filelength to 0602                                         ecfa
        st y+,r17      ;high block-filelength to 0603                                        ed00  
  
        ldi r22,$20    ;space
        cpi r17,$00
        brne l21290    ;b.i.block-filelength >=256 blocks (-> 1 space)
                
        cpi r16,$64
        brcc l21290    ;b.i.block-filelength 100-255 blocks (-> 1 space)
        
        cpi r16,$0a  
        brcc l21280    ;b.i.block-filelength 10-99 blocks (-> 2 spaces)    
                         
        st y+,r22      ;block-filelength 0-9 blocks (-> 3 spaces) 0504
l21280: st y+,r22      ;                                          0505 0504      
l21290: st y+,r22      ;                                          0506 0505 0504

                       ;Y=HD-read= 061f  063f  0bff----------------------------------------------
        ldi r16,$22    ;start-"
        st y+,r16      ;                                          0507 0506 0505

        ldi r30,low(dibube) ;directory buffer begin
        ldi r31,high(dibube)
        
        clt            ;clears flag for " or shift-space already found

l21300: ld r16,z+       
        
        brts l21320    ;b.i." or shift-space already found before
        
        cpi r16,$22    ;"                                                                    c78b 
        breq l21310    ;b.i. "

        cpi r16,$a0    ;                                                                     c78f
        brne l21330    ;b.i.not shift-space

l21310: ldi r16,$22    ;end-"
        set            ;sets flag that " or shift-space already found

l21320: andi r16,$7f   ;clears bit 7                                                         c79f

l21330: st y+,r16 

        cpi r30,low(dibube)+$11
        brne l21300    ;copies $11 17 characters 
                       ;!!! 17th character must be a #$a0 shift-space

        ldi r17,$20    ;space
        lds r16,difity ;directory file type
        tst r16
        brmi l21340    ;b.i.file is closed

        ldi r17,$2a    ;'*'  file isn't closed
                
l21340: st y+,r17     
        
        ldi r30,low(optatl<<1)  ;open table type long
        ldi r31,high(optatl<<1)
      
 
        mov r17,r16    ;directory file type
        lsl r17        ;*2
        add r17,r16    ;*3 = offset to text in table of filenameextensions
        andi r17,$3f   ;masks filetype bits
        
        add r30,r17    ;adds offset to correct text of filenameextension
        adc r31,r06    ;#$00 adds carry
        
        ldi r17,$03

l21350: lpm r18,z+
        st y+,r18
        dec r17
        brne l21350

        andi r16,$40   ;masks scratch-protected-bit read-only-bit of directory file type
        breq l21360    ;b.i.not write-protected

        ldi r16,$3c    ;<
        st y+,r16

l21360: ldi r16,$20    ;space 
l21370: mov r17,r28
        andi r17,$1f
        cpi r17,$1f
        breq l21380
        st y+,r16
        rjmp l21370

l21380: st y,r06       ;#$00 flag for end of basic-line 081f  083f  08ff
                       ;                                0d1f  0d3f  0dff
                       ;Y shows to end of actual written entry

        cpi r28,$ff    ;checks whether the last CBM-buffer-entry (05e0-05ff) was written
        breq l21390    ;b.i.CBM-buffer full                                                  ed0b

        rjmp l21120    ;next direntry until CBM-buffer is full                               ed0b
 
l21390:                ;Y=CBM-dir-buffer-vector needn't be stored
                       ;(allways set to $0600 at begin of l21100 write dir-lines into CBM-buffer)
                       
                       ;ascbve is used double here:       !!!!!!!!!!!!!!
                       ;here for writing into CBM-buffer
                       ;at Talk from AVR to C64 as vector for sending bytes   !!!!!!!!!!! 

        sts ascbve,r06 ;#$00  sets IEC-OUT buffer vector to begin of CBM-buffer
        sts asflre+1,r07 ;#$ff sets filelength to $ffxx => never EOI        
        clc            ;ok-flag
        sez            ;=equal = flag for end of dir not yet reached 
                       ;Y shows to last byte of actual read HD-dir-entry
                       ;Z shows to last byte of actual written CBM-dir-entry
        ret            ;-------------------------------------------------------------------------
                       ;from l21170
l21400: ldi r16,$01    ;                                               create last dir line  ed23 
        st y+,r16
        st y+,r16
       
;        sts ascbve,r28 ;actual SA CBM-buffer vector ($22, $42...$02)

;        lds r16,$0480  ;sectors per cluster    
;        lds r20,$0481  ;free clusters 
;        lds r21,$0482
;        lds r22,$0483
;        lds r23,$0484
            
;        mov r25,r16    ;----
;        rcall l13130
;        mov r25,r17    ;----
;        rcall l13130
;        mov r25,r20    ;----
;        rcall l13130
;        mov r25,r21    ;----
;        rcall l13130
;        mov r25,r22    ;----
;        rcall l13130
;        mov r25,r23    ;----
;        rcall l13130

;        cpi r16,$00
;        brne l21410


        lds r20,amfrcl ;amount of free clusters of actual drive
        lds r21,amfrcl+1
        lds r22,amfrcl+2
        lds r23,amfrcl+3

        lds r16,sepecl ;(512-bytes-)sectors per cluster for every deviceemulation
                       ;         (1sector=2blocks)
                    
l21410: ldi r25,$f0    ;f0----
        call l13090
;        mov r25,r16    ;----
;        rcall l13130  
;        mov r25,r20    ;----
;        rcall l13130  
;        mov r25,r21    ;----
;        rcall l13130  
;        mov r25,r22    ;----
;        rcall l13130  
;        mov r25,r23    ;----
;        rcall l13130  
   
                       ;               minimum    minimum    maximum    maximum
                       ;                FAT32      FAT32      AVR        FAT32
                       ;HD-size         31.99      32MB      128GB       (8TB)
                       ;HD-size         33.55      33.55     137.4        8.8
                       ;sepecl           1          1         64  
                       ;sectors         65525      65536   268435456
                       ;sectors         $fff5     $10000   $10000000
                       ;blocks         $1ffea     $20000   $20000000
                       ;clusters        65525      65536     4194304
                       ;clusters        $fff5     $10000     $400000




l21420: lsl r20        ;*2  loop is 1 time oftener made than sepecl
        rol r21        ;  => doubles one time more = computes from 512-HD to 256 CBM-sectors
        rol r22
        rol r23        ;maximmal blocks (at AVR (128GB)) is $20.00.00.00 => 4 bytes is enough
                
        lsr r16        ;counter for multiplication
        brne l21420        
                       ;r20-23 contain now number of free blocks
           
;        ldi r25,$f1    ;f1--
;        rcall l13130
;        mov r25,r20    ;----
;        rcall l13130  
;        mov r25,r21    ;----
;        rcall l13130  
;        mov r25,r22    ;----
;        rcall l13130  
;        mov r25,r23    ;----
;        rcall l13130  

/*   
        mov r16,r20     ;free 256bytes blocks
        mov r17,r21
        mov r18,r22
        mov r19,r23
        
        mov r12,r20
        mov r13,r21

        subi r16,$ff   ;subtracts  f9ff 63999    0000f9fe  0000f9ff 0000fa00
        sbci r17,$f9   ;                         ffffffff  00000000 00000001
        sbci r18,$00   ;               carry =     set      clear    clear
        sbci r19,$00
        brcs l21430    ;b.i.block-filelength < f9ff 63999
 
        mov r12,r07    ;#$ff =block-filelength >= f9ff 63999
        ldi r16,$f9    ;=> set block-filelength = f9ff 63999
        mov r13,r16
           
;        ldi r25,$f2    ;f2--
;        rcall l13130
;        mov r25,r12    ;----
;        rcall l13130  
;        mov r25,r13    ;----
;        rcall l13130  
     
l21430: 
;        ldi r25,$f3    ;f3--
;        rcall l13130
;        mov r25,r12    ;----
;        rcall l13130  
;        mov r25,r13    ;----
;        rcall l13130  
     
;        lds r28,ascbve ;actual SA CBM-buffer vector ($22, $42...$02)
;        ldi r29,high(cbbube) ;Y (not Z )

        st y+,r12      ;low block-filelength to 0502
        st y+,r13      ;high block-filelength to 0503
*/
        mov r16,r20     ;free 256bytes blocks
        mov r17,r21
        mov r18,r22
        or r18,r23

        breq l21440    ;b.i.filelength 1-65535 1-$ffff blocks
        
        ldi r16,$ff    ;=filelength >65535 >$ffff blocks
        ldi r17,$ff  
  
l21440: 
;        lds r28,ascbve ;actual SA CBM-buffer vector ($22, $42...$02)
;        ldi r29,high(cbbube) ;Y (not Z )

        st y+,r16      ;low block-filelength to 0502
        st y+,r17      ;high block-filelength to 0503  
  
        ldi r30,low(txblfr<<1) ;text free blocks
        ldi r31,high(txblfr<<1) ;initialize Z pointer

l21450: lpm r14,z+      ;copies blocks free.
        st y+,r14
        mov r24,r28
        andi r24,$1f
        cpi r24,$11     ;copies to 0504-0510
        brne l21450
        
        mov r16,r20    ;free 256bytes blocks
        mov r17,r21
        mov r18,r22    ;0-$027fffff   $02800000-$20000000 blocks
        mov r19,r23    ;0MB-9999MB         10GB-128GB
        
        subi r16,$00   ;subtracts      027fffff  02800000 02800001
        sbci r17,$00   ;               ffffffff  00000000 00000001
        sbci r18,$80   ;        carry =     set      clear    clear
        sbci r19,$02
        brcs l21470    ;b.i.block-filelength < $02800000 = print MB

                       ;block-filelength >= $02800000 = print GB
;        ldi r25,$f4    ;f4--
;        rcall l13130     

        ldi r16,$06    ;2^22 * 256 = 1GB (= 2^(6+8+8) * 256)
l21460: lsr r23        ;divides by 2   6 times
        ror r22
        dec r16
        brne l21460    ;r22 contain free GB 
        mov r16,r22
        ldi r17,$00    ;r16+17 contain free GB 
        ldi r23,$47    ;G
        rjmp l21490


l21470: 
;        ldi r25,$f5    ;f5--
;        rcall l13130
        
        ldi r16,$04    ;2^12 * 256 = 1MB (= 2^(4+8) * 256)
l21480: lsr r23        ;divides by 2   4 times
        ror r22
        ror r21  
        dec r16
        brne l21480    ;r22+21 contain free MB 
        mov r16,r21
        mov r17,r22    ;r16+17 contain free MB 
        ldi r23,$4d    ;M
          
l21490: 
;        ldi r25,$f6    ;f6--
;        rcall l13130
;        mov r25,r16    ;----
;        rcall l13130  
;        mov r25,r17    ;----
;        rcall l13130  
;        mov r25,r23    ;----
;        rcall l13130  
     
        clt            ;flag that first digit not yet printed        
        ldi r18,$10    ;low(10000)
        ldi r19,$27    ;high(10000)
        call l14020   ;divides by 10000: result in r20  remainder in r16,r17
        breq l21500    ;b.i.'0'
        st y+,r20      ;tenthousands
        set            ;flag that first digit already printed              

l21500: 
;        ldi r25,$f7    ;f7--
;        rcall l13130
       
        ldi r18,$e8    ;low(1000)
        ldi r19,$03    ;high(1000)
        call l14020   ;divides by 1000: result in r20  remainder in r16,r17
        brts l21510    ;b.i.first digit already printed
        breq l21520    ;b.i.'0'
l21510: st y+,r20      ;thousands
        set            ;flag that first digit already printed         

l21520: 
;        ldi r25,$f8    ;f8--
;        rcall l13130
        
        ldi r18,$64    ;low(100)
        call l14010   ;divides by 100: result in r20  remainder in r16,r17
        brts l21530    ;b.i.first digit already printed
        breq l21540    ;b.i.'0'
l21530: st y+,r20      ;hundreds
        set            ;flag that first digit already printed             
          
l21540: 
;        ldi r25,$f9    ;f9--
;        rcall l13130
       
        ldi r18,$0a    ;low(10)
        call l14010   ;divides by 10: result in r20  remainder in r16,r17
        brts l21550    ;b.i.first digit already printed      
        breq l21560    ;b.i.'0'
l21550: st y+,r20      ;tenths
                    
l21560: ori r16,$30    ;hexdec-0 - 9 -> ASCII-0 - 9 
        st y+,r16      ;ones
        
        st y+,r23      ;'M' or 'G'
        
        ldi r16,$42    ;'B'
        st y+,r16 
       
;        ldi r25,$fa    ;fa--
;        rcall l13130

        ldi r16,$20    ;space
l21570: st y+,r16
        mov r17,r28    ;Ylow
        andi r17,$1f 
        cpi r17,$1d    ;fills 0514/0517-051c with space 
        brne l21570
        
        st y+,r06      ;081d 08fd   0d1d 0dfd                   
        st y+,r06      ;#$00 end of basic file  0800 0820 08fe         0d00 0d20 0dfe 
        st y+,r06      ;                        0801 0821 08ff         0d01 0d21 0dff
                       ; Y=                     0802 0822 0900         0d02 0d22 0e00
        sts asflre,r28 ;actual filelength          2   22 $100            2   22 $100                 
        subi r29,high(cbbube) ;                 0802 0822 0900         0d02 0d22 0e00 
        sts asflre+1,r29 ;                      00   00   01           00   00   01       
        sts asflre+2,r06 ;#$00
        sts asflre+3,r06 ;correct filelength 
        
        sts ascbve,r06 ;#$00  sets IEC-OUT buffer vector to begin of CBM-buffer
        
        clc            ;ok-flag
        clz            ;=notequal = flag for end of dir reached 

        ret

                       ;what happens if 1 cluster is completely full?
                       ;is there a follow-cluster with first filenamecharacter =#$00
                       ;or is there no followcluster and if you want to read further
                       ; then you see that the follow-cluster is 0ffffff8????????????????????????































;------------------------------------------------------------------------------------------------
                       ; from 
                       ;swap-buffer (CBM-buffer) contains correct values of actual SA       close
                       ;but not if SA=command-/error-channel
                       ;tasach = table SA->channel for SA 00-0e contain correct values  ????
l21580: lds r16,icsawo ;SA-only without bits whether open/close/SA = $83 at 1541      close  dac0
        andi r16,$ff
        brne l21590    ;b.i.not load                                                         dac7
       
        nop            ;=load

l21590: cpi r16,$0f    ;                                                                     dad4
        breq l21600    ;b.i.close command/errorchannel                                       dad6

        rcall l21640   ;close actual SA and free things of it                                dad8

                       ;close internal channels??? if load or save

        rjmp l21620    ;                                                                dae1-dae9 
;------------------------------------------------------------------------------------------------
l21600: ldi r16,$0e    ;SA=14                                    close command/errorchannel  daec
                       ;                                  =close all datachannels 0-14 0-0e
l21610: sts icsawo,r16 ;SA-only without bits whether open/close/SA = $83 at 1541             daee
        rcall l21640   ;close this SA                                                        daf0
        lds r16,icsawo ;SA-only without bits whether open/close/SA = $83 at 1541             daf3
        dec r16        ;                                                                     daf3
        brpl l21610    ;b.i.not SA0 made
        
l21620: lds r16,floker ;flag ok/error                                                   dae1/daf7
        andi r16,$ff
        brne l21630    ;b.i.there was an error at closing                               dae4/dafa
        
        jmp l17250    ;=no error  -> diskstate??                                       dae6/dafc
 
l21630: jmp l17300    ;=error                                                          dae9/daff
;------------------------------------------------------------------------------------------------
                       ;from l21610,
l21640: lds r18,icsawo ;SA-only without bits whether open/close/SA = $83 at 1541   close SA  db02
        push r26
        push r27
        ldi r26,low(tasach) ;table secundaryaddrsee -> channel
        ldi r27,high(tasach)
        add r26,r18    ; adds SA = vector to entry in table of SA
        ld r17,x
        pop r27
        pop r26
        cpi r17,$ff
        brne l21650    ;b.i.wanted SA is opened                                              db09

        ret            ;!!if the tested SA isn't opened then                                 db0b
                       ;the old SA-values stay in the SA-CBM-buffer!!        

l21650: lds r16,icsawo ;wanted new CBM-buffer ($00-$0e 0-14)
        call l14190    ;save old-actual cbm-buffer to swapfile and 
                       ;load new-actual CBM-buffer from swapfile 
                       ;at close all channels (at close commandchannel):
                       ; it's necessary to read the correct actual swap- (and CBM-) buffer
                       ;this is made here and not at l21640 because
                       ;else at close ecery SA from 14 to 0 would be the swapbuffer written to
                       ;swapfile
        
        rcall l18710   ;tests whether actual SA is opened for write                          db1b
        brcs l21660    ;b.i.not opened for write
        
        rcall l21670   ;write last sector of file                                            db20
        call l14610    ;writes back actual FAT-buffer if it's changed                        db26
                       ;1541 writes first direntry then BAM
                       ; this is dangerous when there is an error at writing the BAM
                       ; when the direntry is written (=file closed) but the new BAM
                       ; with allocated blcks/clusters isn't written ->
                       ; then a scratch command would free blocks of a different file
                       ;writing first BAM/FAT, then direntry should be more secure?
  
        rcall l21750   ;write directory-entry                                                db23      
                       ;at save&replace: free clusters of old file 
      
        call l14610    ;writes back actual FAT-buffer if it's changed                        db26
                       ;important at save&replace that FAT of freed clusters are
                       ; written to HD
        rcall l22120   ;writes first free cluster and free clusters driveX to FSInfo-block

l21660: rjmp l18780    ;free things of actual SA                                             db29
;------------------------------------------------------------------------------------------------
l21670: lds r16,asflre ;                                    write last sector of file to HD  db62
        lds r17,asflre+1 ;actual filelength of actual SA
        or r16,r17
        lds r17,asflre+2
        or r16,r17
        lds r17,asflre+3
        or r16,r17
        brne l21680    ;b.i.filelength not 0                                                 db6f
        
        ldi r16,$0d    ; =filelength = 0   = no single byte written into file                db71   
        sts cbbube,r16

        ldi r16,$01
        sts asflre,r16 ;makes filelength = 1
        sts ascbve,r16 ;actual SA CBM-buffer vector

l21680: lds r17,ascbve ;actual SA CBM-buffer vector
                       ;shows to position of next to-write databyte 
        andi r17,$ff
        breq l21740    ;b.i.all databytes fitted into former sector
                       ; actual sector is empty / no single byte written into it

        lds r16,ashbsc ;actual sector of this cluster of actual SA
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        lsr r16
        brcs l21700    ;b.i.CBM-buffer must be copied to second half of HD-buffer
           
                       ;=CBM-buffer must be copied to first half of HD-buffer
        ldi r28,low(cbbube)
        ldi r29,high(cbbube)
        
        ldi r26,low(hdbube)
        ldi r27,high(hdbube)
         
l21690: ld r16,y+      ;copies from CBM-buffer ($0500-05..)
        st x+,r16      ; to first half of HD-buffer ($0600-06..) 
        cp r28,r17     ;compares whether end of databytes in CBM-buffer reached
        brne l21690                 

        rjmp l21720    ;----
l21700:                ;=CBM-buffer must be copied to second half of HD-buffer
        call l14790   ;read actual sector of actual cluster (again) (changes X, Y)
                       ;because first half of it contains a CBM-buffer 
                        
        ldi r28,low(cbbube)
        ldi r29,high(cbbube)
        
        ldi r26,low(hdbube+$100) ;vector to second half of HD-buffer
        ldi r27,high(hdbube+$100)

        lds r17,ascbve ;actual SA CBM-buffer vector
                       ;shows to position ofnext to-write databyte 

l21710: ld r16,y+      ;copies from CBM-buffer ($0500-05..)
        st x+,r16      ; to second half of HD-buffer ($0700-07..) 
        cp r28,r17     ;compares whether end of databytes in CBM-buffer reached
        brne l21710              

l21720: st x+,r06      ;#$00 clears rest of AVR-HD-buffer ($06../07..-07ff)
        cpi r27,high(hdbuen)
        brne l21720  

l21730: call l14720   ;writes actual sector of actual SA HD-buffer cluster to HD             db9c

l21740: ret          ;                                                                       dba2
;------------------------------------------------------------------------------------------------
                     ;from l21650
l21750: ldi r30,low(ashbve) ;                                              finish dir-entry  dba5
        ldi r31,high(ashbve) ;acd.as actual direntry ... of AS shows to first dirpartentry 

l21760: ldd r17,z+asdeve-ashbve ;04ea-04ef swaps   open free dir entry sector in this cluster
                       ;copies actual direntry ... of AS  0260,x/0266,x at 1541
        st z+,r17      ;04e2-04e7
                       ; to actual ... of actual SA    = $06/07 - $0e/0f at 1541
        cpi r30,low(ashbve+6) 
        brne l21760    ;swaps position, sector-in this-cluster and cluster (1+1+4bytes)
                       ;actual cluster is now end of dir
                       ;ashbve, ashbsc & ashbcl show now to first of 3 actual direntries
                       ;makes actual dircluster of actual SA-> actual SA HD-buffer cluster

                       ;at save: there are 2 possibilities only:
                       ;  -FOR:      1 dirpartentry
                       ;  -CBM, DIR: 3 dirpartentries
                       ;  -there are never 2 direntries

                       ;at ave&replace: there are 3 possibilities:
                       ; 1,2 or 3 dipartrentries
        lds r16,asdeam ;actual SA dir-entry amount of dirpartentries (0,1,2)   
        tst r16
        breq l21800    ;b.i.complete direntry consists of 1 dirpartentry only
                       ;b.i. there is 1 dirpartentry only => 
                       ;firts dirpartentry = dirpartentry where MS-DOS fileinfos are
                       
                       ;= 2 or 3 dirparentries
        ldi r17,$e0    ;default for 2 dirpartentries
        cpi r16,$01
        breq l21770    ;b.i.2 dirpartentries
        
        ldi r17,$c0    ;= 3 dirpartentries                            
        
l21770: lds r26,ashbve ;HD-pointer to first of 3 actual dirpartentries (!!swapped!!)
        lds r16,ashbsc ;actual SA HD-buffer sector in this cluster (!!swapped)
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        bst r16,0      ;copies bit for CBM-buffer first/second half of HD-buffer to T-flag
        brts l21780    ;b.i.second half

                       ;=dir-CBM-buffer is first half of HD-buffer (=last dirpartentry must
                       ;  be in same HD-buffer as first dirpartentry)
                       ;$00  $20  $40  $60  $80  $a0  $c0  $e0
        sub r26,r17    ; 40s  60s  80s  a0s  c0s  e0s  00c  20c   adds #$20 / #$40
                       ;                            changes vector from first to last dirpartentry
        brcs l21790    ;b.i.last dirpartentry is also in first half of HD-buffer

        ori r16,$01    ;set bit that CBM-buffer is second half of HD-buffer 
        rjmp l21790

l21780:                ;=dir-CBM-buffer is second half of HD-buffer (=last dirpartentry can 
                       ;  perhaps be in follow HD-buffer as first dirpartentry)
                       ;$00  $20  $40  $60  $80  $a0  $c0  $e0
        sub r26,r17    ; 40s  60s  80s  a0s  c0s  e0s  00c  20c   adds #$20/#$40
                       ;                            changes vector from first to last dirpartentry
        brcs l21790    ;b.i.last dirpartentry is also in actual HD-buffer (not follow-sector)

                       ;=last dirpartentry is in follow-sector of actual sector
        sts ashbve,r26 ; 
                       ;bit 0 of ashbsc is cleared at call l14760     
    
        call l14760    ;read follow-512-HD-sector of actual cluster of AS
        
        rjmp l21810

l21790: sts ashbsc,r16 ; 
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        sts ashbve,r26 ;

                       ;are the bits for read-sector set at ashbtr HD-buffertransfer-read
l21800: call l14790    ;reads actual sector of actual SA (!!swapped!!)                       dbc9
                       ;reads dirsector where last of 3 free direntries is
      
l21810: lds r26,ashbve ;HD-pointer to last of 3 actual direntries (!!swapped!!)
        
        lds r27,ashbsc ;%.......0/%.......1 actual SA HD-buffer sector in this cluster
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector
        andi r27,$01   ;             00 / 01  masks bit for first/second half of HD-buffer 
        subi r27,$100-high(hdbube) ;-fa  -fa  X-high shows to correct half of HD-buffer (#$06/07)
        
        ori r26,$14    ;0600->0614  0620->0634   07e0-07f4  position of startcluster

        ld r16,x       ;startcluster of old direntry at save&replace
        sts geaccl+2,r16 ;general actual cluster
        lds r14,asstcl+2 ;actual SA startcluster higher
        st x+,r14      ;0614 
      
        ld r16,x       ;startcluster of old direntry at save&replace
        sts geaccl+3,r16 ;general actual cluster
        lds r15,asstcl+3 ;actual SA startcluster highest
        st x+,r15      ;0615 (-> 0616) 

        subi r26,$100-$04 ;add #$04  16->$1a 
 
        ld r16,x       ;startcluster of old direntry at save&replace
        sts geaccl,r16 ;general actual cluster
        lds r12,asstcl ;actual SA startcluster low
        st x+,r12      ;061a 
      
        ld r16,x       ;startcluster of old direntry at save&replace
        sts geaccl+1,r16 ;general actual cluster
        lds r13,asstcl+1 ;actual SA startcluster high
        st x+,r13      ;061b 

        lds r16,asflre   ;actual filelength of actual SA
        st x+,r16        ;061c
        lds r16,asflre+1 ;copies filelength into direntry
        st x+,r16        ;061d
        lds r16,asflre+2
        st x+,r16        ;061e
        lds r16,asflre+3
        st x+,r16        ;061f -> vector shows to next direntry!!!

        lds r16,icsawo ;IECSecundaryAddress without bits whether open,close,SA ($83)         d9ef  
        cpi r16,$01
        brne l21820    ;b.i.not save

                       ;=save
                       ;r12-r15 contain startcluster of actually saved file
        rcall l20730   ;store filedatas of last file at load (/save) 
                       ;for next acces with e.g.: load"*"
                       
                       ;at load:
                       ; -at open:  
                       ;  the startcluster is known
                       ;  the filelength is known
                       ; -at close:
                       ;  the (remainig) filelength is wrong
                       ; => at load: store the values at opening the file
                       
                       ;save: at save:
                       ; -at open:
                       ;  the startcluster is known, but not yet written into the direntry
                       ;  the filelength is unknown
                       ; -at close:
                       ;  the startcluster is known
                       ;  the filelength is known
                       ; => at save: store the values at closing the file
l21820:                    
                       ;at end: X shows to next direntry
       #if (partname == 6) | (partname == 7)    
        #message 644-NLQ-HD/full
        call l27540    ;write time and date into direntry
                       ;important at save&replace that date of new file is in dir
       #endif

        call l14590    ;writes last read sector back to HD using acsehb                      dc3d
                       ; actual sector in HD-buffer (in lba)        
                       ;write back changed dir-entry-sector    

        lds r16,asfla0 ;actual SA flags0 (0-17)
                       ;bit5: 0=not save&replace 1=save&replace ($d91b)

        andi r16,$20
        breq l21830    ;b.i.no save&replace
      
                       ;delete old file at save&replace 
        call l17700    ;clear all FAT-entries of file (in accl-general ($80/81))             dc1b 
    
l21830: ret            ;                                                                     dc43
;------------------------------------------------------------------------------------------------
                       ;from l19560 (load"*"), l19920, l21850
l21840:                ;                  open a channel for read & read startblock          dc46
                       ;there are no channels at the AVR. There is one buffer for every
                       ;secundary address => channels aren't necessary = easier and shorter
                       ;the correct CBM-buffer must be copied from swapfile (NLQ-SWAP.SYS)
                       ;to the AVR RAM. This is made at the end of rceiving a commandbyte from 
                       ;the C64
                       ;the 1541 uses two buffers for one SA (an active and an inactive one,
                       ;  and swaps them). The AVR uses one buffer only for every SA (easier)
        call l18760   ;open channel for actual SA                                           dc48

        rcall l21870   ;clears buffer-vector                                                 dc4b 
                       ;doesn't clear filelength (at read) because it is needed for EOI-
                       ;calculating
        lds r16,cm024a ;open actual filetype                                                 dc4e
        sts asfity,r16 ;actual SA file-type (= ec,x at 1541)                        dc55
        
        lds r16,acdrnu ;actual drive number  =$007f at 1541                                  dc53
        sts asdrnu,r16 ;actual SA drive-number (= ec,x at 1541)                     dc55                                           

        call l14810   ;reads startsector of actual SA HD-buffer cluster                     dc57
                       ;1541 sets buffervector to first databyte of buffer
                       ; (without sectorlink) = 0302 0402 ... 0702 
                       ;AVR copies first CBM-buffer = first half of a HD-buffer and then 
                       ; clears ascbve actual SA CBM-buffer vector 
     
        lds r16,asfity ;actual SA file-type (= ec,x at 1541)                        dc65
        cpi r16,$04
        brne l21850    ;b.i.not rel file                                                     dc68
        
        ldi r17,$1a    ;1a-- 26--
        jmp syserr     ;read from rel-file                                              dc6a-dca6  

l21850:                ;actual databyte -> 023e,x?????????????                                                  dca9
                       
                       ;#$88 -> f2,x ???????????
                       ;don't understand what this is

        ret            ;                                                                     dcb5



;------------------------------------------------------------------------------------------------        
                       ;from l21890 (save/write) (not l21840)
l21860:                ;                               set parameters for opening a channel? dcb6
        
        sts asflre,r06 ;#$00 clears actual SA filelength (remaining)               dcd0
        sts asflre+1,r06
        sts asflre+2,r06
        sts asflre+3,r06 ;#$00 clears actual SA filelength (remaining)             dcd2
                       ;the filelength must be cleared at opening a file for write
                       ;because the filelength must be written into the FAT32 direntry
                       ;it mustn't be cleared a opening a file for read, because 
                       ;the filelength copied from the direntry is important for calculating
                       ;the EOI

                       ;there is no end-vector (0244,x at the 1541). the end must be
                       ;calculated of the filelength at FAT32
        sts ascbve,r06 ;#$00 clears actual SA CBM-buffer vector   ?????     
                       ;.........................................................................
                       ;from l21840 (load/read)
l21870: lds r16,asfla1 ;actual SA flags1 (0-17)                                              dcb8
        andi r16,$20   ;masks bit 5: buffer-dirty-bit = bit6 of a7,x / ae,x at 1541 ?????????
                       ;  0: buffer not dirty  1: buffer dirty
        brne l21880    ;b.i.buffer is dirty
        
        sts ashbve,r06 ;#$00 clears actual SA HD-buffer vector                               dcbe
        sts ashbsc,r06 ;#$00 clears actual SA HD-buffer sector in this cluster 
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector

l21880: ret            ;??????????????????????????????????                                   dcd9
;------------------------------------------------------------------------------------------------
                       ;from l19760 (save&replace), l20680 
l21890: ldi r25,$30    ;30--'w'
        call l13080

        rcall l22050   ;search startcluster of file at save                                  dcda
                       ;    and allocate it   found free cluster->geaccl
       
        ldi r25,$31    ;31--'w'
        call l13080
       
        call l18750    ;sets flag that actual SA is opened for write  (asfla1)               dcdf 
                       ;sets bit that SA is used/opened (e.g.for LED)
      
        ldi r25,$32    ;32--'w'
        call l13080
      
        rcall l21860   ;clears filelength, resets vectors                                    dce5             

        ldi r25,$33    ;33--'w'
        call l13080

        lds r16,cm024a ;open actual filetype                                                 dcea
        sts asfity,r16 ;actual SA file-type (= ec,x at 1541)                                 dcf1
        
        lds r17,acdrnu ;actual drive number  =$007f at 1541                                  dcef
        sts asdrnu,r17 ;actual SA drive-number (= ec,x at 1541)                              dcf1                                           
     
        cpi r16,$04    ;actual SA file-type (= ec,x at 1541)                                 dcf4
        breq l21900    ;b.i.rel file                                                         dcf6
                       
                       ;#$01 -> f2,x ???????????
                       ;don't understand what this is
        
        ldi r25,$3f    ;3f--'w'
        call l13080

        ret            ;                                                                     dcfc

l21900: ldi r17,$1b    ;1b-- 27--
        jmp syserr     ; write to rel-file                                                   dcfd
                       ;                                                                     dd8a
;------------------------------------------------------------------------------------------------
                       ;from l17610
                       ;                 checks whether actual found file is also actually opened
l21910: lds r16,acsacb ;actual SA in CBM-buffer (00-$11 0-17)  
        push r16       ;backups actual SA in CBM-buffer to stack  (->l21930, l21940)
 
        ldi r17,$00    ;............            ldi r17,$0e                                  ddb7
l21920: sts cm0071,r17 ; clears/updates counter for SA                                       ddb9
          
        push r26
        push r27
        ldi r26,low(tasach) ;table secundaryaddrsee -> channel      022b,x
        ldi r27,high(tasach)
        add r26,r17    ; adds SA = vector to entry in table of SA
        ld r17,x
        pop r27
        pop r26
        cpi r17,$ff
        brne l21940    ;b.i.wanted SA is opened                                              ddc0

l21930: lds r17,cm0071 ;counter for SA                                                       ddc2 
        inc r17        ;                        dec r17                                      ddc4
        cpi r17,$0f    ;                      (save this command)                            ddc5
        brcs l21920    ;b.i.SA = (0-14)1-$0e    brpl l21920                                  ddc7
                       ;1541 tests 0-15 !even command-channel is checked          
                       ;=> at 1541 bit for command-channel must be always cleared

        pop r16        ;restores actual SA in CBM-buffer from stack  (->l21910)
        call l14190    ;save old CBM-buffer to swapfile and load new CBM-buffer from swapfile
        
        sec
        ret            ;filename not opened = sec --------                                   ddc9

l21940:                ;this SA (cm0071) is actually opened/used                             ddca
        lds r16,cm0071 ;=in table found used, opened SA 
        call l14190    ;save old CBM-buffer to swapfile and load new CBM-buffer from swapfile

        lds r19,asdrnu ;actual SA drive-number (= ec,x at 1541)                     ddcf
        ;sts cm0070,r19 ;necessary?? or just temporary
        lds r30,opfifo ;flag for open filename found  = $0253 at 1541                        ddd6
                       ;0-5 = found and number of filename in inputbuffer
                       ;$ff = so far not found  
        ldi r31,high(cfmebe) ;command/filename memory begin
                       ;vector Z shows to values of actually found filename
        ldd r16,z+low(cfdrno) ;command/filename drive number                                 ddd9
                       ;loads drivenumber of actually found filename from inputtable   
        cp r16,r19     ;compare drivenumber from found inputcommand and dirname              dddd
        brne l21930    ;b.i.different drivenumbers 
                       ;drivenumbers are so far complicated!!!!!!!!!!!!!!!!

        lds r16,asdesc ;actual SA dir-entry sector in this cluster  0260,x at 1541  dde1
        ldd r19,z+low(cfdisc)     ;sector in this cluster of direntry of...   d8,x
        cp r16,r19     ;compares sector-in-this-cluster of tested SA and input-string        dde4        
        brne l21930    ;b.i.different sector-in-this-cluster                                 dde6
        
        lds r16,asdecl ;actual SA dir-entry cluster                 0260,x at 1541  dde1
        ldd r19,z+low(cfdicl)     ;cluster of direntry of actual file inputbuffer low d8,x   
        cp r16,r19     ;compares cluster of tested SA and matching inputname                 dde4
        brne l21930    ;b.i.different cluster low
                  
        lds r16,asdecl+1 ;actual SA dir-entry cluster               0260,x at 1541  dde1
        ldd r19,z+low(cfdicl)+$05 ;cluster of direntry of actual file inputbuffer low d8,x   
        cp r16,r19     ;compares cluster of tested SA and matching inputname                 dde4
        brne l21930    ;b.i.different cluster high
              
        lds r16,asdecl+2 ;actual SA dir-entry cluster               0260,x at 1541  dde1
        ldd r19,z+low(cfdicl)+$0a ;cluster of direntry of actual file inputbuffer low d8,x   
        cp r16,r19     ;compares cluster of tested SA and matching inputname                 dde4
        brne l21930    ;b.i.different cluster higher
      
        
        lds r16,asdecl+3 ;actual SA dir-entry cluster               0260,x at 1541  dde1
        ldd r19,z+low(cfdicl)+$0f ;cluster of direntry of actual file inputbuffer low d8,x   
        cp r16,r19     ;compares cluster of tested SA and matching inputname                 dde4
        brne l21930    ;b.i.different cluster highest
        
        lds r16,asdeve ;actual SA dir-entry vector                0266,x at 1541  dde81
        ldd r19,z+low(cfdive)     ;vector of direntry of actual file inputbuffer   dd,x  
        cp r16,r19     ;compares cluster of tested SA and matching inputname                 ddeb
        brne l21930    ;b.i.different vectors/pointers                                       dded 
        
        pop r16        ;restores actual SA in CBM-buffer from stack  (->l21910)
        call l14190    ;save old CBM-buffer to swapfile and load new CBM-buffer from swapfile
    
        clc            ;                                                                     ddef                 
        ret            ;matching inputname is also opened carry=clear                        ddf0
;------------------------------------------------------------------------------------------------
                       ;                                                                     ef5c
                       ;.........................................................................
                       ;from l17710 (scratch),
l21950:                ;                       free general actual cluster ($80,81) in FATs  ef5f
        call l14600    ;writes back actual FAT-buffer if a cluster is changed by allocating

        lds r12,geaccl ;general actual cluster ($80,81 at 1541)  
        lds r13,geaccl+1
        lds r14,geaccl+2
        lds r15,geaccl+3 

        lds r16,fifrcl ;first free cluster of actual device
        sub r16,r12
        lds r16,fifrcl+1
        sbc r16,r13
        lds r16,fifrcl+2
        sbc r16,r14
        lds r16,fifrcl+3
        andi r16,$0f   ;masks off bits for changed...
        sbc r16,r15
        brcs l21960    ;b.i.actually freed cluster behind ( greater than) first free cluster   

        sts fifrcl,r12 ;= actually freed cluster in front of ( smaller than) first free cluster   
        sts fifrcl+1,r13
        sts fifrcl+2,r14 ; store it to first free cluster   
        mov r16,r15    ;first free cluster drive0 highestbyte:
        ori r16,$20      ; bit5  0 = not yet changed = still correct value
        sts fifrcl+3,r16 ;       1 = changed = must be rewritten to HD
                       ;        (change of free clusters and of first free cluster)       
                       ;=> free clusters and first free cluster must be rewritten
                       ;    to FSInfo-block at close
 
l21960: set            ;=flag for compare FAT1 and FAT2
        call l14370    ;read FAT1-entry of general actual cluster ($80/81 at 1541)
                       ;     (=follow-cluster of former actual cluster) 
        brne l21990    ;b.i.error at compare of FAT1 and FAT2               
      
        mov r16,r12
        or r16,r13
        or r16,r14   
        or r16,r15
        brne l21980    ;b.i.actual cluster is allocated

        ldi r17,$42    ;42--  66-- actual cluster is free = error
l21970: jmp syserr     ;43--  67-- actual cluster isn't allocated = error?????

l21980: st y+,r06      ;#$00
        st y+,r06
        st y+,r06      ;sets actual cluster = free
        ld r16,y
        andi r16,$f0   ;clears bit 27-24   doesn't change bits 31-28
        st y,r16

        ;push r12       ;backup (former) follow-cluster of geaccl to stack
        ;push r13       
        ;push r14
        ;push r15

        ;call l14630    ;write sectors with retry  actual sector FAT-buffer = FAT-sector  
                       ;send block-write-command to HD (write 1 sector only)
                       ;write FAT-sector with allocted enty to HD
                       ; write sector-address
                       ;write FAT-sector with allocted enty to HD
                            
        ;pop r15        ;restore (former) follow-cluster of geaccl from stack   
        ;pop r14
        ;pop r13
        ;pop r12
                       ;!! the changed FAT isn't written to HD !!
                       ; this must be made at close 
    
        lds r25,flfbch ;flags FAT-buffer changed
                       ; (if few RAM then perhaps together with acenfb??)      
                       ;bit7: FAT-buffer changed (doesn't matter whether allocate or free)
                       ;bit6: FAT-buffer changed by allocate cluster
                       ;bit5: FAT-buffer changed by free cluster
        ori r25,$a0    ;sets bits for changed general and changed by freeing

        lds r16,amfrcl ;amount of free clusters of actual drive
        lds r17,amfrcl+1 
        lds r18,amfrcl+2 
        lds r19,amfrcl+3
 
        sec            ;sec carry => adds one more additionally
        adc r16,r06    ;                  00000000  0ffffffe  0fffffff                   
        adc r17,r06    ;#$00 adds carry   00000001  0fffffff  10000000
        adc r18,r06    ;                   legal     legal    illegal
        adc r19,r06
      
        rjmp l22030    ;HD-buffer contains FAT1-sector of freed cluster                      ef87
                       ;r12-15 = (former) follow-cluster of geaccl
;------------------------------------------------------------------------------------------------
l21990: ldi r16,$47    ;71,dir error  71--
        jmp l13980     ;print error+blink+waitingloop
;------------------------------------------------------------------------------------------------
                       ;from l22110
l22000:                ;                             alocate general actual cluster in FATs  ef90
        set            ;=flag for compare FAT1 and FAT2
        call l14370    ;read FAT1-entry 
                       ;of general actual cluster     (=write endclusterflag into it)
                       ;($80/81 at 1541)
        brne l21990    ;b.i.error at compare of FAT1 and FAT2               
        
                       ;r12-15 contains value of FAT for the cluster (e.g.follow-/endcluster) 
                       ;Y shows to begin of FAT-entry of the cluster  
                       ;it's necessary to write anything into this FATentry because else a 
                       ;second opened file could allocate this cluster a second time
                       ;NLQ-HD uses the the endclusterflag (perhaps a different flag would 
                       ; be better??, but which one???)  
        mov r16,r12
        or r16,r13
        or r16,r14   
        or r16,r15
        breq l22020    ;b.i.actual cluster is free

        ldi r17,$32    ;32--  50--
l22010: jmp syserr     ;actual cluster isn't free = error

l22020: st y+,r07      ;#$ff
        st y+,r07
        st y+,r07      ;sets actual cluster = end of file-flag
        ld r16,y
        ori r16,$0f    ;sets bit 27-24   doesn't change bits 31-28
        st y,r16

        ;call l14630    ;write sectors with retry  actual sector FAT-buffer = FAT-sector  
                       ;send block-write-command to HD (write 1 sector only)
                       ;write FAT-sector with allocted entry to HD
                       ; write sector-address 
                       ;write FAT-sector with allocted entry to HD

                       ;!! the changed FAT isn't written to HD !!
                       ; this must be made at close 

        lds r25,flfbch ;flags FAT-buffer changed
                       ; (if few RAM then perhaps together with acenfb??)      
                       ;bit7: FAT-buffer changed (doesn't matter whether allocate or free)
                       ;bit6: FAT-buffer changed by allocate cluster
                       ;bit5: FAT-buffer changed by free cluster
        ori r25,$c0    ;sets bits for changed general and changed by allocating

        lds r16,amfrcl ;amount of free clusters of actual drive
        lds r17,amfrcl+1 
        lds r18,amfrcl+2 
        lds r19,amfrcl+3

        subi r16,$01   ;                            0fffffff  00000001  00000000
        sbci r17,$00   ; decrements free clusters   0ffffffe  00000000  ffffffff
        sbci r18,$00   ;                             legal     leagl    illegal 
        sbci r19,$00   

l22030: sts flfbch,r25

        cpi r19,$10
        brcc l22040    ;b.i.illegal (10-ff) (10000000 or ffffffff)

        sts amfrcl,r16   ;amount of free clusters of actual drive   
        sts amfrcl+1,r17    
        sts amfrcl+2,r18    
        sts amfrcl+3,r19  

        lds r16,fifrcl+3 ;first free cluster of actual drive highestbyte:
        ori r16,$20      ; bit5  0 = not yet changed = still correct value
        sts fifrcl+3,r16 ;       1 = changed = must be rewritten to HD
                         ;        (change of free clusters and of first free cluster)       
                         ;=> free clusters and first free cluster must be rewritten
                         ;    to FSInfo-block at close

l22040: ret            ;FAT-buffer contains FAT-sector of new allocted cluster               efce
;------------------------------------------------------------------------------------------------
                       ;from l21890
                       ;                              search startcluster of file at save    f1a9
                       ;from l19050, (l21890)
l22050:                ;                                         search next free cluster    f11e
                       ;                           starts with first free cluster on HD
        lds r12,fifrcl ;first free cluster
        lds r13,fifrcl+1 
        lds r14,fifrcl+2
        lds r15,fifrcl+3 ;first free cluster highest
        tst r15
        brpl l22070    ;b.i.first free cluster of HD is already set
        
l22060: ldi r16,$02    ;=not yet set => start with cluster 00000002 
        mov r12,r16     
        clr r13
        clr r14
        clr r15
        
        ldi r16,$c0    ;%11000000
        sts fifrcl+3,r16 ;bit7=1: flag that first free cluster isn't set
                         ;bit6=1: flag that this search started at cluster 00000002 (from begin)
                         ;bit5 is cleared accidentially, but is set at l22110 again

l22070: ldi r16,$0f
        and r15,r16    ;masks off bit 31-28 
        sts geaccl,r12 ;stores to general actual cluster                      = $80/81 at 1541
        sts geaccl+1,r13
        sts geaccl+2,r14
        sts geaccl+3,r15
        ldi r16,$00    ;don't increment cluster before search 
                       ;.........................................................................
l22080: lds r12,geaccl ;actual SA HD-buffer cluster    loop
        lds r13,geaccl+1
        lds r14,geaccl+2
        lds r15,geaccl+3 ;.......................................................................

l22090: add r12,r16    ;adds #$00/#$01
        adc r13,r06    ;#$00 adds carry
        adc r14,r06
        adc r15,r06         

l22100: sts geaccl,r12
        sts geaccl+1,r13
        sts geaccl+2,r14
        sts geaccl+3,r15

        call l14510    ;computes actual cluster in r12-r15-> last sector of actual cluster

        lds r16,sbpaen ;sectorbegin partition end of partition (+1) 
        lds r17,sbpaen+1
        lds r18,sbpaen+2
        lds r19,sbpaen+3

        sec            ;!sec => subtracts 1 additionally 
        sbc r16,r12
        sbc r17,r13
        sbc r18,r14
        sbc r19,r15

        brcc l22110    ;b.i.legal sector (=legal cluster)

                       ;=end of dataarea reached
        lds r16,fifrcl+3 ;first free cluster highest
        andi r16,$40   ;masks bit whether this search began at cluster 00000002
        breq l22060    ;b.i.this search didn't start at cluster 00000002

        sts geaccl+3,r07 ;#$ff  makes actual general cluster = illegal

        ldi r16,$48    ;72,disk full 72--
        jmp l13980     ;error + main-waiting-loop
        
l22110: set            ;=flag for compare FAT1 and FAT2
        call l14370    ;read FAT-entry of general actual cluster into FAT-buffer
                       ;writes actual FATbuffer to HD if it's changed and if it's a different
                       ;  FATsector 
                       ;r12-r15 contain FAT-entry of new found cluster 
        ldi r16,$01    ;increment cluster before search 
        brne l22080    ;b.i.error at compare of FAT1 and FAT2 
                       ;=> don't use any cluster of this FAT-sector
                       ; because there is 1 FAT-buffer only but 2 different FATs
                       ; => check next clusters whether they are free until you read 
                       ;    a FATsector with no compare error 

        or r12,r13
        or r12,r14   
        or r12,r15
        brne l22080    ;b.i.actual cluster isn't free -> check next one

        ;sts ashbsc,r06 ;#$00 clears actual SA HD-buffer sector in this cluster
                        ;??clear actual bufferpointer (don't know whether CBM- or HD-one
                       ;bit7-1=512-bytes-hd-sectors
                       ;bit0: 0=byte0-255  1=byte256-511 of actual hd-sector is actual cbm sector

        lds r12,geaccl ;general actual cluster            =actual new (computed) cluster is free
        lds r13,geaccl+1
        lds r14,geaccl+2
        lds r15,geaccl+3

        ldi r16,$20    ;bit5
        or r15,r16     ;sets bit that first free cluster is changed and must be rewritten to HD

        sts fifrcl,r12 ;first free cluster
        sts fifrcl+1,r13 
        sts fifrcl+2,r14
        sts fifrcl+3,r15 ;first free cluster highest
        rjmp l22000    ;allocate general actual cluster in FATs (not r12-15)                 f19a
                       ; (= write endclusterflag into it)                                    f1a6
                       ; at end: geaccl contains values of new found free cluster
                       ;         ashbcl is unchanged 
;------------------------------------------------------------------------------------------------
                       ;search startcluster of file at save                                  f1a9
                       ;-> l22050
                       ;at AVR: routines f11e and f1a9 are the same???????????????           f1f7
;------------------------------------------------------------------------------------------------
l22120:                ;       writes first free cluster and free clusters driveX to FSInfo-block
        lds r16,fifrcl+3 ;first free cluster drive0 highest
                       ; bit7: 0 = not yet set   1 = already set 
                       ;         (notread/read from one of the first sectors from HD)
                       ; bit6: 0 = search didn't start at cluster 00000000
                       ;       1 = search started at cluster 00000000
                       ; bit5  0 = not yet changed in RAM = still correct value in RAM
                       ;       1 = changed in RAM = must be rewritten to HD FSInfo-block
                       ;        (change of free clusters and of first free cluster)       
      
        tst r16
        brmi l22140    ;b.i.not yet set (shouldn't be possible)     
            
        bst r16,5      ;copies in-RAM-changed-bit to T-flag   
        brtc l22140    ;b.i.first-free-cluster and free-clusters
                       ; of actual deviceemulation not changed in RAM        

        andi r16,$0f   ;clears bit31-28, clears flags
        sts fifrcl+3,r16
        rcall l22150   ;reads FSInfo-block into HD-buffer
                       ;X shows to begin of amount of free clusters of actual drive
                       ;Y shows to $01e8 = free clusters of HD-buffer
l22130: ld r16,x+      ;reads amount of free clusters of actual drive
                       ; and  first free cluster of actual drive from RAM
        st y+,r16      ;stores free clusters  and  first free cluster to FSInfo sector           
                      ;amfrcl and fifrcl must be directly together in memory
        cpi r28,low(hdbube+$01f0)
        brne l22130    ;-------------------------------------------------------------------------

        call  l14590   ;writes last-read/actual HD-buffer back to HD

l22140: ret
;------------------------------------------------------------------------------------------------
                       ;from l22120, l18650, 
l22150:                ;                                        reads FSInfo-block into HD-buffer
        lds r12,sbpabo ;sectorbegin partition bootsector
        lds r13,sbpabo+1 
        lds r14,sbpabo+2 ; =bootsector 
        lds r15,sbpabo+3

        ldi r25,$50    ;50----
        call l13090
        
        ldi r16,$01
        add r12,r16    ; = FSInfo-sector FileSystem-info-sector
        adc r13,r06    ;#$00  directly behind bootsector
        adc r14,r06
        adc r15,r06

        call l14890    ;reads FSinfosector of P (r12-r15 contain address) ------
        
        ldi r25,$51    ;51----
        call l13090

        ldi r28,low(hdbube+$01fc)
        ldi r29,high(hdbube+$01fc)  ;begin of SignatureBytes of FsInfo sector ($00,$00,$55,$aa) 

        ldi r30,low(txsbss<<1) ;SignatureBytes SystemSector (boot- and FSInfo-sector)  
        ldi r31,high(txsbss<<1)       
     
l22160: ld r16,y+      ;SignatureBytes ($00,$00,$55,$aa) from HD 
        lpm r17,z+     ;SignatureBytes ($00,$00,$55,$aa) from table    
        cp r16,r17
        brne l22180    ;b.i.wrong signature bytes 
      
        cpi r28,low(hdbube+$01fc+4)
        brne l22160    ;-------------
     
        ldi r25,$52    ;52----
        call l13090

        ldi r26,low(hdbube+0) ;begin of SignatureBytes of FsInfo sector ($52,$52,$61,$41) 
        ldi r27,high(hdbube+0)

        ldi r28,low(hdbube+$01e4)  ;begin of SignatureBytes of FsInfo sector ($72,$72,$41,$61) 
        ldi r29,high(hdbube+$01e4)
    
        ldi r30,low(txsbfi<<1) ;SignatureBytes of FsInfo sector           
        ldi r31,high(txsbfi<<1)       

        ldi r18,$20    ;

l22170: ld r16,x+      ;SignatureBytes of FsInfo sector ($52,$52,$61,$41) from HD 
        lpm r17,z+     ;SignatureBytes of FsInfo sector ($52,$52,$61,$41) from table    
        cp r16,r17
        breq l22190    ;b.i.correct signature bytes 

l22180: ldi r17,$0f    ;error at FSInfo sector     system error 0f-- 15--            
        jmp l18430     ;system error + LED-blink + main waiting loop 0f-- 15--

l22190: ld r16,y+      ;SignatureBytes of FsInfo sector ($72,$72,$41,$61) from HD
        eor r17,r18    ;$52->$72  $61<->$41
        cp r16,r17
        brne l22180    ;b.i.wrong signature bytes 
      
        cpi r26,low(hdbube+0+4)
        brne l22170    ;--------------
                      
        ldi r26,low(amfrcl) ;amount of free clusters of actual device
        ldi r27,high(amfrcl) ;              $10c0   
                       ;X shows to begin of free-clusters of actual deviceemulation
                       ;Y shows to $01e8 = free clusters of HD-buffer
        ret
;================================================================================================
                       ;from l17240
l22200:                ;                                                                t-command
      #if (partname == 6) | (partname == 7)    
        #message 644-NLQ-HD/

                       ;t-ra 
                       ;0              01       1
                       ;0123456789abcdef012345678
                       ;mon. 12/31/99 12:59:59 pm

                       ;t-rb t-rd                (ho: 1-12 & am/pm)
                       ;00 01 02 03 04 05 06 07
                       ;wd ye mo da ho mi se am  

                       ;wd ye mo da ho mi se ce  (ho=0-23 ce=century 0-99 (=>year=0000-9999))
                       ;00 01 02 03 04 05 06 07
                       ;atr atw

      #if partname == 6    
        #message 644-NLQ-HD/SD
   
        mov r18,r12

        ldi r25,$8e    ;8e----
        call l13090

        cpi r16,$2d    ;'-'
        brne l22210

        cpi r17,$52    ;'r'
        brne l22210

        ldi r24,$40    ;flag for t-rd
        cpi r18,$44    ;'d'
        breq l22220

        ldi r24,$20    ;flag for t-rb
        cpi r18,$42    ;'b'
        breq l22220

        cpi r18,$41    ;'a'
        brne l22210

        rjmp l22290    ;t-ra

l22210: jmp l19630     ;30,syntax error 

                       ;from l23430 (atr-command)
l22220:                ;r24: $80= atr                                               =atr -command
                       ;     $40= t-rd                                              =t-rd-command
                       ;     $20= t-rb                                              =t-rb-command

        cli            ;disable IRQs

        lds r22,tcnt2  ;TCNT2 Timer/Counter2        
                       ;(8 Bit)  seconds  and 1/100
        
        lds r16,tifr2  ;Timer/Counter2 Interrupt Flag Register
        tst r16
        breq l22230    ;b.i.there was an overflow from $bf to $00 which could not be executed
                       ; because the IRQ was disabled
        
        ldi r22,$bf
        
l22230:                ;bit7-5of r22: seconds
                       ;bit4-0of r22: 1/32 seconds (0-31)
        lds r16,airtwd ;AVR-internal-RTC-weekday 0-7
        rcall l22370 
        sts erbube,r16 ;weekday+++

        lds r16,airtyl ;AVR-internal-RTC-year-low   -----
        lds r17,airtyh ;AVR-internal-RTC-year-high   -----
   
        ldi r21,$00    ;counter fo centuries 0-99

l22240: cpi r17,$00
        brne l22250

        cpi r16,$64
        brcs l22260    ;b.i.0-99

l22250: subi r16,$64
        sbci r17,$00
        inc r21
        brne l22240

        ldi r16,$63    ;year=9999
        ldi r21,$63
  
l22260: rcall l22370 
        sts erbube+1,r16 ;yl+++

        lds r16,airtmo ;AVR-internal-RTC-month
        rcall l22370 
        sts erbube+2,r16 ;mo+++

        lds r16,airtda ;AVR-internal-RTC-day ----
        rcall l22370 
        sts erbube+3,r16 ;day+++

        lds r16,airtho ;AVR-internal-RTC-hours   ----
        tst r24 
        brmi l22280    ;b.i. atr (not t-rd) (r21=centuries high / r16=hour0-23)
    
        ldi r21,$00    ;default for am
        cpi r16,$0c
        brcs l22270    ;b.i.0-11

                       ;=12-23
        ldi r21,$01    ;flag for pm
        subi r16,$0c

l22270: cpi r16,$00
        brne l22280    ;b.i.1-11

        ldi r16,$0c    ;0->12
    
l22280: rcall l22370 
        sts erbube+4,r16 ;hour+++

        lds r16,airtmi ;AVR-internal-RTC-minutes   -----
        rcall l22370 
        sts erbube+5,r16 ;minutes+++

        lds r16,airtse ;AVR-internal-RTC-second (in 6s steps)-----
        sei            ;enable IRQs       
        andi r22,$e0   ;second 0-5
        swap r22
        lsr r22
        add r16,r22
        rcall l22370 
        sts erbube+6,r16 ;second+++

        mov r16,r21
        rcall l22370 
        sts erbube+7,r16 ;t-rd: am/pm-flag+++
                         ;atr : century   +++
     
                         ;end carriage -return is added automatically at 
                         ; action after talk
        ldi r17,$08       ;length of errormessage
        rjmp l23190      ;to end of afr arr aer--------------------------------------------------

l22290: ldi r25,$8f    ;8f----                                                               t-ra
        call l13090

        cli            ;disable IRQs

        lds r22,tcnt2  ;TCNT2 Timer/Counter2        
                       ;(8 Bit)  seconds  and 1/100
        
        lds r16,tifr2  ;Timer/Counter2 Interrupt Flag Register
        tst r16
        breq l22300    ;b.i.there was an overflow from $bf to $00 which could not be executed
                       ; because the IRQ was disabled
        
        ldi r22,$bf
        
l22300:                ;bit7-5of r22: seconds
                       ;bit4-0of r22: 1/32 seconds (0-31)

        lds r16,airtwd ;AVR-internal-RTC-weekday 0-7
        lsl r16        ;                bit4-2 (= *2) 
        lsl r16        ;                bit4-2 (= *4) 
        ldi r30,low(txweda<<1) ;text weekdays
        ldi r31,high(txweda<<1)  
        add r30,r16
        adc r31,r06    ;#$00
        ldi r26,low(erbube)
        ldi r27,high(erbube)

l22310: lpm r16,z+     ;weekdays
        st x+,r16
        cpi r26,low(erbube+4)
        brne l22310

        lds r16,airtmo ;AVR-internal-RTC-month
        rcall l22410
        sts erbube+$05,r20 ;month first
        sts erbube+$06,r16 ;month second

        lds r16,airtda ;AVR-internal-RTC-day
        rcall l22410
        sts erbube+$08,r20 ;day first
        sts erbube+$09,r16 ;day second

        lds r16,airtyl ;AVR-internal-RTC-year-low
        lds r20,airtyh ;AVR-internal-RTC-year-high
        ldi r21,$00    ;counter for centuries 0-99

l22320: cpi r20,$00    ;highbyte year hexdec
        brne l22330

        cpi r16,$64    ;lowbyte year hexdec
        brcs l22340    ;b.i.0-99

l22330: subi r16,$64
        sbci r20,$00
        inc r21
        brne l22320

        ldi r16,$63    ;year=9999
  
l22340: rcall l22410
        sts erbube+$0b,r20 ;year first
        sts erbube+$0c,r16 ;year second

        lds r16,airtho ;AVR-internal-RTC-hour
        ldi r23,$41    ;default for am 'a'
        cpi r16,$0c
        brcs l22350    ;b.i.0-11

                       ;=12-23
        ldi r23,$50    ;flag for pm 'p'
        subi r16,$0c

l22350: cpi r16,$00
        brne l22360    ;b.i.1-11

        ldi r16,$0c    ;0->12
    
l22360: sts erbube+$17,r23 ;AM/PM-flag

        rcall l22410       
        sts erbube+$0e,r20 ;hour first
        sts erbube+$0f,r16 ;hour second

        lds r16,airtmi ;AVR-internal-RTC-minutes
        rcall l22410
        sts erbube+$11,r20
        sts erbube+$12,r16

        lds r16,airtse ;AVR-internal-RTC-seconds
        andi r22,$e0   ;second 0-5
        swap r22
        lsr r22
        add r16,r22
        rcall l22410
        sts erbube+$14,r20
        sts erbube+$15,r16

        ldi r16,$20    ;space
        sts erbube+$04,r16
        sts erbube+$0d,r16
        sts erbube+$16,r16

        ldi r16,$2f    ;'/'
        sts erbube+$07,r16
        sts erbube+$0a,r16
    
        ldi r16,$3a    ;':'
        sts erbube+$10,r16
        sts erbube+$13,r16
    
        ldi r16,$4d    ;'m'
        sts erbube+$18,r16
        
        ldi r17,$19      ;length of errormessage
        rjmp l23190      ;to end of afr arr aer--------------------------------------------------

l22370: bst r24,5        ;copies BCD-bit from r24 to T-flag                           hexdec->BCD
        brtc l22400      ;b.i.not BCD

        ldi r20,$00      ;counter first
      
l22380: cpi r16,$0a
        brcs l22390      ;b.i.0-9 

        subi r20,$100-$10 ;add #$10  00->$10 
        subi r16,$0a
        rjmp l22380
       
l22390: or r16,r20
       
l22400: ret              ;----------------------------------------------------------------------

l22410:                  ;                                             hexdec->ascii-first&second
        ldi r20,$30      ;counter first
      
l22420: cpi r16,$0a
        brcs l22430      ;b.i.0-9 

        inc r20        ;increment first 
        subi r16,$0a
        rjmp l22420
       
l22430: ori r16,$30    ;counter second
       
        ret            ;-------------------------------------------------------------------------  

l22440:                ;                                                              atw-command
                       ;wd ye mo da ho mi se ce  (ho=0-23 ce=century 0-99 (=>year=0000-9999))
                       ;00 01 02 03 04 05 06 07
                       ;atr atw
        cli            ;disable IRQ
        lds r16,inbube ;wd---
        sts airtwd,r16 ;wd+++

        lds r16,inbube+1 ;ye--- 0-$63 hexdec
        ldi r17,$00      ;yh hexdec 0-ff
        lds r18,inbube+7 ;ce--- century 0-$63 hexdec

                         ;                                    00    9b    9c    9d    ff 
l22450: subi r16,$100-$64 ;subi #$9c  add #$64   add 100      64 s  ff s  00 c  01 c  63 c
        
                       ;                                      00    00    00    00    00    
        sbci r17,$ff   ;subtract carry              -ff:      ff    ff    ff    ff    ff 
                       ;                            -carry:   00    00    01    01    01
        dec r18
        brne l22450

        sts airtyl,r16 ;yl+++ 0000-ffff
        sts airtyh,r17 ;yh+++

        lds r16,inbube+2 ;mo---
        sts airtmo,r16 ;mo+++

        lds r16,inbube+3 ;da---
        sts airtda,r16 ;da+++

        lds r16,inbube+4 ;ho--- 0-23
        sts airtho,r16 ;ho+++

        lds r16,inbube+5 ;mi---
        sts airtmi,r16 ;mi+++

        lds r16,inbube+6 ;se---
        ldi r17,$00

l22460: cpi r16,$06
        brcs l22470    ;b.i.0-5

        subi r16,$06
        subi r17,$100-$06 ;add #$06    00 06 0c 12 18 1e 24 2a 30   
        rjmp l22460    ;               06 0c 12 18 1e 24 2a 30 36 

l22470:                ;r16= seconds 0-5   r17=seconds in 6-seconds-steps
                       ;00 01  04 05
        swap r16       ;00 10  40 50
        lsl r16        ;00 20  80 a0
        sts airtse,r17 ;se+++
        sts tcnt2,r16  ;TCNT2 Timer/Counter2        
                       ;(8 Bit)  seconds  and 1/100
        ldi r16,$07
        sts tifr2,r16  ;clear RTC-timer2 IRQ-flags 
 
        reti           ;sei + ret
       #endif            ;-----------------------------------------------------------------------

       #if partname == 7    
        #message 644-NLQ-HD/full
   
        mov r18,r12

        ldi r25,$8e    ;8e----
        call l13090

        mov r25,r16    ;----
        call l13090

        mov r25,r17    ;----
        call l13090

        mov r25,r18    ;----
        call l13090

        cpi r16,$2d    ;'-'
        brne l22480

        cpi r17,$52    ;'r'
        brne l22480

        ldi r24,$40    ;flag for t-rd
        cpi r18,$44    ;'d'
        breq l22490

        ldi r24,$20    ;flag for t-rb
        cpi r18,$42    ;'b'
        breq l22490

        cpi r18,$41    ;'a'
        brne l22480

        rjmp l22670    ;t-ra

l22480: jmp l19630     ;30,syntax error----------------------------------------------------------

                       ;from l23450
l22490:                ;r24: $80= atr                                               =atr -command
                       ;     $40= t-rd                                              =t-rd-command
                       ;     $20= t-rb                                              =t-rb-command

        ldi r25,$8f    ;8f----
        call l13090

/*
        ldi r25,$8b    ;8b----
        call l13090
      
        rcall l23630   ;I2C-start-condition  !!changes r20!!

        ldi r20,$a0
        rcall l23660   ;send slave address of pcf8583RTC write

        ldi r20,$00
        rcall l23660   ;send wordaddress#$00=control-register

        ldi r20,$40
        rcall l23660   ;send set hold last count flag in control-register
                       ;wordaddress is incremented #$00->#$01
        rcall l23650   ;I2C-stop-condition 
*/

        ldi r25,$8c    ;8c----
        call l13090
        
        rcall l23630   ;I2C-start-condition  !!changes r20!!

        ldi r20,$a0
        rcall l23660   ;send slave address of pcf8583RTC write

        ldi r20,$00
        rcall l23660   ;send wordaddress#$00=status

        rcall l23650   ;I2C-stop-condition  (necessary??)
        
        ldi r25,$8d    ;8d----
        call l13090
    
        rcall l23630   ;I2C-start-condition  !!changes r20!!

        ldi r20,$a1
        rcall l23660   ;send slave address of pcf8583RTC read
        
        rcall l23700   ;read r00 status----
        ;sts $09f0,r20
        andi r20,$fc
        brne l22520    ;b.i.any bit set wrongly

        rcall l23700   ;read r01  1/10  1/100 ----

        rcall l23700   ;read r02 seconds ----   
        ;sts $09f2,r20
        mov r16,r20
        bst r24,5      ;copies BCD-bit from r24 to T-flag
        brts l22500    ;b.i. t-tb       
        
        call l27510   ;BCD->hexdec
     
l22500: sts erbube+6,r16

        rcall l23700   ;read r03 minutes   -----
        ;sts $09f3,r20
        mov r16,r20
        bst r24,5      ;copies BCD-bit from r24 to T-flag
        brts l22510    ;b.i. t-tb       

        call l27510   ;BCD->hexdec

l22510: sts erbube+5,r16

        rcall l23700   ;read r04 hours     -> r20----
        ;sts $09f4,r20
        tst r20
        brpl l22530    ;b.i.AM/PM-flag is cleared

l22520: rcall l23710   ;read + send that this is the last I2C-byte
        rcall l23650   ;I2C-stop-condition
        ldi r17,$fa    ;(fa-- 250--)   
        jmp syserr     ;system error PCF8583-RTS set wrongly 
        .db 0

l22530: call l27510   ;BCD->hexdec
        tst r24
        brmi l22580    ;b.i. atr =0-23 (not t-rd)
    
                       ;=t-rd t-rb 1-12
        ldi r22,$00    ;default for am
        cpi r16,$0c
        brcs l22540    ;b.i.0-11

                       ;=12-23
        ldi r22,$01    ;flag for pm
        subi r16,$0c

l22540: cpi r16,$00
        brne l22550    ;b.i.1-11

        ldi r16,$0c    ;0->12
   
l22550: bst r24,5      ;copies BCD-bit from r24 to T-flag
        brtc l22580    ;b.i. t-td       
 
        ldi r17,$00    ;BCD-highnibble hour

l22560: cpi r16,$0a
        brcs l22570    ;b.i.0-9

        subi r16,$0a
        subi r17,$100-$10 ;add #$10  00->$10 
        rjmp l22560
    
l22570: or r16,r17

l22580: sts erbube+4,r16 ;hour

        rcall l23700   ;read r05 year/day -> r20
        ;sts $09f5,r20
        mov r18,r20    ;backups year (0-3)
        mov r16,r20
        andi r16,$3f
        bst r24,5      ;copies BCD-bit from r24 to T-flag
        brts l22590    ;b.i. t-tb       

        call l27500   ;BCD(and#$3f)->hexdec        

l22590: sts erbube+3,r16

        rcall l23700   ;read r06 weekday/month
        ;sts $09f6,r20
        mov r16,r20
        andi r16,$e0   ;masks weekdays
        swap r16
        lsr r16
        sts erbube,r16
       
        mov r16,r20
        andi r16,$1f
        bst r24,5      ;copies BCD-bit from r24 to T-flag
        brts l22600    ;b.i. t-tb       
           
        call l27490   ;BCD(and#$1f)->hexdec 
        
l22600: sts erbube+2,r16 ;month       

        rcall l23700   ;read r07 (overread)                       
        ;sts $09f7,r20  ;                    
        
        rcall l23700   ;read r08 year low from RAM wordaddress#$08 (alarm must be disabled)
        ;sts $09f8,r20
        mov r19,r20    ;year low (hexdec  not BCD) bit1-0=%00 

        rcall l23710   ;read r09 year high from RAM wordaddress#$09 (alarm must be disabled)
                       ; + send that this is the last I2C-byte
        ;sts $09f9,r20  
        andi r18,$c0   ;mask year
        swap r18
        lsr r18
        lsr r18
        add r19,r18    ;add y0-3 + yl
   
        ldi r21,$00    ;counter for centuries 0-99

l22610: cpi r20,$00
        brne l22620

        cpi r19,$64
        brcs l22630    ;b.i.0-99

l22620: subi r19,$64
        sbci r20,$00
        inc r21
        brne l22610

        ldi r19,$63    ;year=9999
        ldi r21,$63
  
l22630: sts erbube+1,r19 ;yl

        tst r24
        brmi l22660    ;b.i. atr (not t-rd)

        mov r21,r20    ;=year 0-99 0-$63 hexdec
     
        bst r24,5      ;copies BCD-bit from r24 to T-flag
        brtc l22660    ;b.i. t-td       
 
        ldi r17,$00    ;BCD-highnibble hour

l22640: cpi r21,$0a
        brcs l22650    ;b.i.0-9

        subi r21,$0a
        subi r17,$100-$10 ;add #$10  00->$10 
        rjmp l22640
    
l22650: or r21,r17

l22660: sts erbube+7,r21 ;t-rd: am/pm-flag
                         ;atr : century
 
        rcall l23650   ;I2C-stop-condition
        

        ldi r25,$8e    ;8e----
        call l13090

/*      
        rcall l23630   ;I2C-start-condition  !!changes r20!!

        ldi r20,$a0
        rcall l23660   ;send slave address of pcf8583RTC write

        ldi r20,$00
        rcall l23660   ;send wordaddress#$00=control-register

        ldi r20,$00
        rcall l23660   ;send clear hold last count flag in control-register

        rcall l23650   ;I2C-stop-condition 
        
        ldi r25,$8f    ;8f----
        call l13090
*/      

        ldi r17,$08    ;length of errormessage
        rjmp l23190    ;to end of afr arr aer------------------------------

l22670: ldi r25,$8f    ;8f----                                                               t-ra
        call l13090

/*
        ldi r25,$8b    ;8b----
        call l13090
      
        rcall l23630   ;I2C-start-condition  !!changes r20!!

        ldi r20,$a0
        rcall l23660   ;send slave address of pcf8583RTC write

        ldi r20,$00
        rcall l23660   ;send wordaddress#$00=control-register

        ldi r20,$40
        rcall l23660   ;send set hold last count flag in control-register
                       ;wordaddress is incremented #$00->#$01
        rcall l23650   ;I2C-stop-condition 
*/

        ldi r25,$8c    ;8c----
        call l13090
        
        rcall l23630   ;I2C-start-condition  !!changes r20!!

        ldi r20,$a0
        rcall l23660   ;send slave address of pcf8583RTC write

        ldi r20,$00
        rcall l23660   ;send wordaddress#$00=status

        rcall l23650   ;I2C-stop-condition  (necessary??)
        
        ldi r25,$8d    ;8d----
        call l13090
    
        rcall l23630   ;I2C-start-condition  !!changes r20!!

        ldi r20,$a1
        rcall l23660   ;send slave address of pcf8583RTC read
        
        rcall l23700   ;read r00 status----
        ;sts $09f0,r20
        andi r20,$fc
        brne l22680    ;b.i.any bit set wrongly

        rcall l23700   ;read r01  1/10  1/100 ----

        rcall l23700   ;read r02 seconds ----   
        ;sts $09f2,r20
        mov r16,r20
        swap r16
        andi r16,$0f
        ori r16,$30
        sts erbube+$14,r16
        andi r20,$0f
        ori r20,$30
        sts erbube+$15,r20

        rcall l23700   ;read r03 minutes   -----
        ;sts $09f3,r20
        mov r16,r20
        swap r16
        andi r16,$0f
        ori r16,$30
        sts erbube+$11,r16
        andi r20,$0f
        ori r20,$30
        sts erbube+$12,r20

        rcall l23700   ;read r04 hours     -> r20----
        ;sts $09f4,r20
        tst r20
        brpl l22690    ;b.i.AM/PM-flag is cleared

l22680: rcall l23710   ;read + send that this is the last I2C-byte
        rcall l23650   ;I2C-stop-condition
        ldi r17,$fa    ;(fa-- 250--)   
        jmp syserr     ;system error PCF8583-RTS set wrongly 
        .db 0

l22690: call l27510    ;BCD->hexdec r20->r16
        ldi r22,$41    ;default for am 'a'
        cpi r16,$0c
        brcs l22700    ;b.i.0-11

                       ;=12-23
        ldi r22,$50    ;flag for pm 'p'
        subi r16,$0c

l22700: cpi r16,$00
        brne l22710    ;b.i.1-11

        ldi r16,$0c    ;0->12
    
l22710: sts erbube+$17,r22 ;AM/PM-flag
       
        ldi r17,$30    ;hour-first  begin hexdec->ascii
    
l22720: cpi r16,$0a
        brcs l22730    ;b.i.0-9

        subi r16,$0a
        inc r17
        rjmp l22720

l22730: sts erbube+$0e,r17 ;hour first
        ori r16,$30
        sts erbube+$0f,r16 ;hour second

        rcall l23700   ;read r05 year/day -> r20
        ;sts $09f5,r20
        mov r18,r20    ;backups year (0-3)

        mov r16,r20
        swap r16
        andi r16,$03
        ori r16,$30
        sts erbube+$08,r16 ;day first
        andi r20,$0f
        ori r20,$30
        sts erbube+$09,r20 ;day second

        rcall l23700   ;read r06 weekday/month
        ;sts $09f6,r20
        mov r16,r20    ;      weekdays  bit7-5
        andi r16,$e0   ;masks weekdays  
        swap r16       ;      weekdays  bit3-1 
        lsl r16        ;                bit4-2 (= *4) 
        ldi r30,low(txweda<<1) ;text weekdays
        ldi r31,high(txweda<<1)  
        add r30,r16
        adc r31,r06    ;#$00
        ldi r26,low(erbube)
        ldi r27,high(erbube)

l22740: lpm r16,z+     ;weekdays
        st x+,r16
        cpi r26,low(erbube+4)
        brne l22740

        mov r16,r20
        swap r16
        andi r16,$01
        ori r16,$30
        sts erbube+$05,r16 ;month first
        andi r20,$0f
        ori r20,$30
        sts erbube+$06,r20 ;month second

        rcall l23700   ;read r07 (overread)                       
        ;sts $09f7,r20  ;                    
        
        rcall l23700   ;read r08 year low from RAM wordaddress#$08 (alarm must be disabled)
        ;sts $09f8,r20
        mov r19,r20    ;year low (hexdec  not BCD) bit1-0=%00 

        rcall l23710   ;read r09 year high from RAM wordaddress#$09 (alarm must be disabled)
                       ; + send that this is the last I2C-byte
        ;sts $09f9,r20  
        andi r18,$c0   ;mask year
        swap r18
        lsr r18
        lsr r18
        add r19,r18    ;add y0-3 + yl
   
        ldi r21,$00    ;counter for centuries 0-99

l22750: cpi r20,$00    ;highbyte year hexdec
        brne l22760

        cpi r19,$64    ;lowbyte year hexdec
        brcs l22770    ;b.i.0-99

l22760: subi r19,$64
        sbci r20,$00
        inc r21
        brne l22750

        ldi r19,$63    ;year=9999
        ldi r21,$63
  
l22770: ldi r17,$30    ;year-high  begin hexdec->ascii
    
l22780: cpi r19,$0a
        brcs l22790    ;b.i.0-9

        subi r19,$0a
        inc r17
        rjmp l22780

l22790: sts erbube+$0b,r17 ;year first
        ori r19,$30
        sts erbube+$0c,r19 ;year second

        ldi r16,$20    ;space
        sts erbube+$04,r16
        sts erbube+$0d,r16
        sts erbube+$16,r16

        ldi r16,$2f    ;'/'
        sts erbube+$07,r16
        sts erbube+$0a,r16
    
        ldi r16,$3a    ;':'
        sts erbube+$10,r16
        sts erbube+$13,r16
    
        ldi r16,$4d    ;'m'
        sts erbube+$18,r16


        rcall l23650   ;I2C-stop-condition
        

        ldi r25,$8e    ;8e----
        call l13090

/*      
        rcall l23630   ;I2C-start-condition  !!changes r20!!

        ldi r20,$a0
        rcall l23660   ;send slave address of pcf8583RTC write

        ldi r20,$00
        rcall l23660   ;send wordaddress#$00=control-register

        ldi r20,$00
        rcall l23660   ;send clear hold last count flag in control-register

        rcall l23650   ;I2C-stop-condition 
        
        ldi r25,$8f    ;8f----
        call l13090
*/      

        ldi r17,$19      ;length of errormessage
        rjmp l23190      ;to end of afr arr aer
       #endif

       #else
        jmp l13970
       #endif
;=================================================================================================
                       ;from l17240
                       ;a additional
                       ;auj additional UJ-command   reset (and actual dir is resetted)
                       ;a+
                       ;a-
                       ;a2r I2C-bus read
                       ;a2w I2C-bus write 
                       ;aca calibrate
                       ;arc RTC calibrate (NLQHD-SD only) 32768kHz
                       ;ahi HD-identify device
                       ;ahr HD-read
                       ;ahv HD-verify
                       ;ahw HD write
                       ;ahc HD clear sectors
                       ;air IDE-register read
                       ;aiw IDE-register write
                       ;aer EEPROM read
                       ;aew EEPROM write
                       ;arr RAM, register & I/O read
                       ;arr RAM write
                       ;afr FLASHRAM read
                       ;aof off
                       ;al  lock ??
                       ;au  unlock ??
                       ;apr partition read ??
                       ;apw partition write ??
                       ;acr CDROM (&DVD) read 
                       ;aso SD/MMC-order (command)
                       ;asr SD/MMC-read
                       ;asw SD/MMC-write
                       ;asc SD/MMC-clear sectors
                       ;a4u 1541U-debug
                         
                       ;from l17240
l22800:                ;        $0200 a a aa a a a a a a a a a a aa a a                additional
                       ;r16     $0201 u c hh h h h i i e e r r f +- 2 2
                       ;r17     $0202 j a ii r w c r w r w r w r    r w
                       ;r12=r28 $0203     01 lba-0 reg              sla LBA0 (sector?)      
                       ;r13=r29 $0204        lba-1  vl                  LBA1 (!hexdez  not ASCII)  
                       ;r14     $0205        lba-2  vh                  LBA2  lowbyte first   
                       ;r15     $0206        lba-3                      LBA3  highbyte-last
                       ;        $0207        amount                   

                       ;!!!  at ARR/ARW the swapbuffer isn't yet made to SA15
                       ;     in the swapbuffer RAM is still the values of the old SA!!!!!
                       ;  (this is made because a user wants perhaps to read values of the old
                       ;    SA using the ARR command)
                       ;don't change values of the old SA swapbuffer area RAM ($08e0-09ff)

                       ;at the different E-commands the swapbuffer is made to SA15
                       ; (it's cleared?)

        ldi r25,$3f    ;3f----    
        call l13090

        cpi r16,$55    ;'u'
        brne l22830

        ldi r16,$02    ;flag for AUI-softwarereset 
        cpi r17,$49    ;'i'
        brne l22820

l22810: rjmp l23530    ;auj = software-reset with reset of actual directory----------------------

l22820: 
       #if partname >= 2    
        #message 644-non-IEC-ATA

        ldi r16,$03    ;flag for AUJ-command
        cpi r17,$4a    ;'j'
        breq l22810    ;b.i.not 'AUJ'
       #endif

        rjmp l23540    ;31,syntax error 

l22830: 
       #if (partname == 1) | (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/HD-routines
        cpi r16,$48    ;'h' HD
        breq l22840 
       
        rjmp l22930 

                       ;ah-commands                                                   ah-commands
                       ;  

l22840: cpi r17,$52    ;'r'
        brne l22850

        ldi r16,$c4    ;makes (override-) flag for read into AVR-HD-buffer          ahr = HD-Read
        sts ovhbtr,r16 ;overwrite HD-buffer-transfer read but use actual hardware     

        call l14920    ;read 1 sector from hd (read allways)  
        rjmp l23550    ;return to main waiting loop

l22850: cpi r17,$57    ;'w'
        brne l22860

        ldi r16,$c4    ;makes (override-) flag for write from AVR-HD-buffer to HD  ahw = HD-Write
        sts ovhbtw,r16 ;actual SA HD-buffer-transfer write-overwrite  but use actual hardware
        
        ldi r17,$30    ;write sectors with retry
        call l14930    ;write 1 sector to HD 
        rjmp l23550    ;return to main waiting loop

l22860: cpi r17,$56    ;'v'
        brne l22870

        ldi r17,$40    ;verify sectors with retry
        call l14930    ;write 1 sector at HD  
        rjmp l23550    ;return to main waiting loop

l22870: cpi r17,$49    ;'i'  identify device
        brne l22890    
        
l22880: ldi r25,$40    ;40----                                             ahi HD-identify device
        call l13090

        call l14570    ;send identify-device-command and copy to AVR-HD-buffer 
        rjmp l23550    ;return to main waiting loop---------------------------------------

l22890: cpi r17,$43    ;'c'  identify device
l22900: brne l22950    ;syntax error 
 
        ldi r28,low(inbube) ;input buffer begin                              ahc HD-clear sectors
        ldi r29,high(inbube) ;command must be send double e.g. ehc012309ehc012309
        
l22910: ldd r17,y+8    ;security backup of command (second half of command)        
        ld r16,y+      ;command (first half of command)
        cp r16,r17
        brne l22950    ;b.i.difference in first and second half of command
        
        cpi r28,low(inbube+8)
        brne l22910

        ldi r26,low(hdbube)
        ldi r27,high(hdbube)

l22920: st x+,r06      ;clears HD-buffer
        cpi r27,high(hdbuen)
        brne l22920

                       ;still make master/slave
        
        ldi r16,$04    ;makes flag for write from AVR-HD-buffer to HD 

                       ;use perhaps a differnt values as 01 as flag for clear (=write #$00)
                       ;??????????????????????????????????????????????????????????? 
                       ;the basic-format-program relies on that the HD-buffer is filled with
                       ; #$00 after a ahc command
        sts ashbtw,r16 ;actual SA HD-buffer-transfer write
        
        ldi r17,$30    ;write sectors with retry
        lds r16,inbube+7 ;$0207 amount of sectors to clear
        call l14940    ;clear 1-$0100 sectors on HD 

        rjmp l23550    ;return to main waiting loop---------------------------------------------

l22930: cpi r16,$49    ;'i'                                air/aiw IDE-register
        brne l22960    ;           

        mov r16,r12    ;register 0-7
        cpi r16,$08
        brcc l22980    ;b.i.register = 08-ff =illegal       00 01 02 03 04 05 06 07    
    
        lsl r16        ;                                    00 02 04 06 08 0a 0c 0e
        lsl r16        ;                                    00 04 08 0c 10 14 18 1c
        lsl r16        ;                                    00 08 10 18 20 28 30 38

       #if partname == 1     
        #message 162-IEC-ATA-V2
        ori r16,$c6    ;makes register to                   c6 ce d6 de e6 ee f6 fe 
                       ;correct possition for PrtD
       #endif ;162-IEC-ATA-V2

       #if partname == 4    
        #message 644-NLQ-HD/lite-lite
        ori r16,$07    ;makes register to                   07 f0 17 1f 27 2f 37 3f
                       ;correct possition for PrtD
       #endif ;644-NLQ-HD/lite         
      
      #if partname == 7    
        #message 644-NLQ-HD/full
        ori r16,$06    ;makes register to                   06 0e 16 1e 26 2e 36 3e
                       ;correct possition for PrtD
       #endif ;644-NLQ-HD/lite-lite & full

        cpi r17,$52    ;'r'                            
        brne l22940    ; 
      
        ldi r25,$43    ;43--
        call l13130

        mov r25,r16    ;-- register 0-7
        call l13130    

        call l14060   ;read register (r16)                                 air IDE-register-read 
                       ;r18=value low  r19=value high   air <register (0-7)> 

        mov r25,r18    ;-- value low
        call l13130    

        mov r25,r19    ;-- value high
        call l13130    

        sts erbube,r18 ;writes to error-buffer  value low  
        sts erbube+1,r19 ;writes to error-buffer value high  
        ldi r17,$02    ;length of errromessage = 2

        rjmp l23190

l22940: cpi r17,$57    ;'w'                            
l22950: brne l22980    ;syntax error 
        
        mov r18,r13    ;value low                                          aiw IDE-register-write
        mov r19,r14    ;value high            aiw <register (0-7)> <value> 

        ldi r25,$44    ;44--
        call l13130

        mov r25,r16    ;-- register
        call l13130    

        mov r25,r18    ;-- value low
        call l13130    

        mov r25,r19    ;-- value high
        call l13130    

        call  l14130   ;write ATA-register (r16)     

        ret            ;or jmp instead of call+ret???-----------------------
       #endif          ;of l22830

l22960: cpi r16,$43    ;'c'
        brne l23060

l22970: cpi r17,$41    ;'a'  =ca                                                   aca  calibrate
        breq l22990

l22980: rjmp l23540    ;syntax error

l22990: sts fljdal,r06 ;flag JiffyDOS allowed  switch Jiffydos IEC-routines off
                       ; important because timing is wrong
        cpi r28,$00    ;00 and ff isn't possible (00=use old value ff=empty or corrupted EEPROM)
        breq l23000    ;b.i. 'cal chr$(0)' = don't change value

        sts osccal,r28 ;calibrationbyte for internal 8MHz-oscilator   r28=hexdec
                       ;in-out-command doesn't work at 644 

l23000: ldi r25,$f0    ;f0----
        call l13090
         
        ldi r19,$05    ;%.....101  (wgm make normal mode)
        out tccr0_,r19 ;starts timer0 (8bit) with 8MHz/1024 = 1count per 128µs (at 8MHz)
                       ;                      (1024/8 =128)     er 138.888µs at 7.3728MHz  
                       ;different address and bits at 162 and 644    
        ldi r19,$ff        
        out Tcnt0,r19  ;$ff to timer0

l23010: in r19,Tcnt0   ;reads timer
        cpi r19,$01    ;                                               128*256=
        brne l23010    ;b.i.counter<>$01 = waits until counter=01  waits 32768µs=32.7685ms
                       ;                                                     for 1 halfcycle
l23020: in r19,Tcnt0   ;reads timer
        cpi r19,$00
        brne l23020    ;b.i.counter<>$00 = waits until counter0000
        
                       ;DataOut should be active?
                       ;program should be in data- not in Command-mode              
        
l23030: inc r18
        andi r18,$01   ;0->1->0->1...
        breq l23040    ;                = 65.536ms for 1 (complete) cycle of AVR-ClockOut-period

        call l12880    ;ClockOut=active                     (=6.553s for 100cycles at8MHz)
        rjmp l23050   

l23040: call l12910    ;ClockOut=inactive  

l23050: call l11260    ;waits until C64 makes Atn=active
        rjmp l23010    ;------------------------------------------------------------------------

l23060: cpi r16,$52    ;'r'
        brne l23150

       #if partname == 6    
        #message 644-NLQ-HD/SD
        cpi r17,$43    ;'c'  =rc                                               arc  RTC-calibrate
        brne l23120

        ldi r25,$f1    ;f1----
        call l13090

l23070: lds r19,Tcnt2  ;reads RTC timer2                               32768Hz/1024=32Hz
        cpi r19,$00    ;                                               32Hz/192=6sec
        brne l23070    ;b.i.counter<>$00 = waits until counter=00  waits 6s
                       ;                                                     for 1 halfcycle
l23080: lds r19,Tcnt2  ;reads timer
        cpi r19,$01
        brne l23080    ;b.i.counter<>$01 = waits until counter01
        
                       ;DataOut should be active?
                       ;program should be in data- not in Command-mode              
        
l23090: inc r18
        andi r18,$01   ;0->1->0->1...
        breq l23100    ;                = 12sec for 1 (complete) cycle of AVR-ClockOut-period

        call l12880    ;ClockOut=active        
        rjmp l23110   

l23100: call l12910    ;ClockOut=inactive  

l23110: call l11260    ;waits until C64 makes Atn=active
        rjmp l23070    ;------------------------------------------------------------------------

l23120:   
       #endif

                       ;!!!swapbuffer area still contains values of old SA
                       ; don't change any value of the swapareaRAM
                       ;if the C64 wanted more bytes as which fit in the errorbuffer
                       ;then the swapfile would have to be changed
                       ;it would be easier to make a syntax error if the C64 wanted to
                       ; request too many byte with the ERR-command  
                               
        lds r16,inbube+6 ;$0106 value to write                                      =arr arw
                                 
        cpi r17,$57    ;'w'   err arw RAM
        breq l23130

        ld r20,y       ;arr RAM
        rjmp l23180    ;------

l23130: cpi r29,$00    ;arw RAM
        breq l23140    ;b.i.0000-00ff doesn't write to registers and I/O  
       
        st y,r16       ;=0100-ffff

l23140: ret            ;-----------------------------------

l23150: cpi r16,$45    ;'e'
        brne l23170

        mov r20,r15    ;value                                                       =aer aew
               
        cpi r17,$57    ;'w'  =aer  aew  EEPROM
        breq l23160
                       ;=aer (reads allways one byte only)

        call l13770   ;EEPROM-read -> r20
        rjmp l23180    ;------

l23160:                ;=aew (writes allways one byte only)
       
        call l13750   ;EEPROM-write
        ret            ;--------------- 

l23170: cpi r16,$46    ;'f'
        brne l23200
     
        mov r30,r12    ;lowbyte RAM to read/write                              =afr  (afw)
        mov r31,r13    ;highbyte                         
                       ;it's impossible to store the vector at once to r30,31, because 
                       ; r30,r31 is needed for indirect jump at l17240 
        
        lpm r20,z      ;efr flashROM (never write)
     
l23180: sts erbube,r20 ;writes to error-buffer   
        ldi r17,$01    ;length of errromessage = 1

                       ;from
l23190: sts erbufi,r17 ;error-buffer filelength (remaining) (for EOI-calculating)
        sts erbufi+1,r06 ;#$00 

        ;ldi r16,low(erbube) ;   
        ;sts erbuve,r16 ;sets error-buffer vector to first byte   
        sts erbuve,r06 ;#$00 sets error-buffer vector to first byte
        
        ret            ;------------------------------------------------------------------------

l23200: lds r18,fljdal ;flag JiffyDOS allowed
        ori r18,$80    ;sets bit7

        cpi r16,$2b    ;'+'
        breq l23210    ;b.i.a+
        
        cpi r17,$2d    ;'-'
        brne l23220    ;b.i.not a- 
        
        andi r18,$7f   ;clears bit7
l23210: sts fljdal,r18
        rjmp l23550    ;-------------------         
 
l23220: cpi r16,$4f    ;'o'  off=switch AVR off (from IEC-bus)
        brne l23260

        cpi r17,$46    ;'f'
l23230: brne l23260
        
        ldi r25,$03    ;03----
        call l13090

        cli            ;disable IRQs  switch AtnAck-emulation off
        call l12840    ;ClockOut=inactive
                       ;(DtaOut, SrqOut, AtnOut should be already inactive ???)
l23240:                ;does this work???   or must there be a rjmp l23240
                       ;because at l25300 the IRQ is enables again by sei??????????? 

l23250: ret            ;return to main waiting loop  (-> l25290)
                        
l23260:
      #if partname == 3
        #message 644-NLQ-HD/sd2iec
        cpi r16,$34    ;'4'
        brne l23270

        cpi r17,$55    ;'u'
        breq l23280

l23270: rjmp l23410
                       ;=a4u = 1541U-debug
        
l23280: 
       #if partname == 6    
        #message 644-NLQ-HD/SD
        ldi r16,$03
        sts iratin,r16 ;disbale AtnIn-IRQs (int2) 
                       ;don't use cli, because this would disable 100Hz timer IRQs
                       ;100Hz IRQs are important for debugswitch at sd2iec        ?????   
                       ;don't disable RTC-IRQ, RstIn-IRQ (int0), Sleep-IRQ (int1)          

       #else
        sts iratin,r06 ;#$00 makes no more IRQ = also flag for ATN-IRQ 
                       ;IRQ-register AtnIn-pin   162: PD2   644: PB2  
                       ;   external interrupt 0/2 control mask register
                       ; different at 162 (PD2 IRQ0 bit6 of gicr) 
                       ;          and 644 (PB2 IRQ2 bit2 of eimsk)
                       ;=> NLQ-HD doesn't make an IRQ when NLQ-HD sets AtnOut=active
                       ;    and doesn't make AtnAck-emulation and doesn't make DtaOut=active
                       ;it's impossible to use the cli command, because there is a sei
                       ; at the end of the IECOUT routine 
       #endif

        ldi r25,$d0    ;d0--
        call l13130

        call l12990   ;makes all lines of IEC-bus inactive
                       ;problem: at S-jiffydos the C64 reads the status after having
                       ; sent a command
                       ;C64 sends probably:
                       ;Listen to device-swap device 
                       ;SA
                       ;C64 switches to next device
                       ;Listen to next device 
                       ;SA
                       ;Unlisten
                       ;Talk to next device
                       ;SA
                       ;IECIN, IECIN, .... IECIN   (reads errormessage from next device)
                       ;Untalk
l23290: ldi r24,$2d    ;=45

l23300: in r16,piiema  ;     1 reads IECIN-port
      
       #if partname == 3
        #message 644-NLQ-HD/sd2iec
        andi r16,0b00000111 ;1 masks input-bits (!SrqIn isn't connected)
        cpi r16,0b00000111 ; 1 
       #endif

       #if ((partname >= 4) & (partname <= 7))
        #message 644-NLQ-HD/all
        andi r16,0b10100110 ;1 masks input-bits
        cpi r16,0b10100110 ; 1 
       #endif

        brne l23290    ;     1 b.i.any IEC-line is active         
        
        dec r23        ;     1
        brne l23300    ;     2   7*256 = 1792 = 224µs

        dec r24        ;     1   224*44 = 10080µs = 10ms = 1/100s
        brne l23300    ;     2   waits until bus is 10000µs inactive
        
        ldi r25,$d1    ;d1--
        call l13130

        call l12940   ;AtnOut=active                                                     64:ed33
        call l12880   ;ClkOut=active                                                     64:ed37
        call l12840   ;DtaOut=inactive

        ldi r25,$64    ;100
        call l10840   ;r25*10µs waiting loop  = 1000µs = 1ms                             64:ed3d

        ldi r16,$80    ;sets bit for Atn-mode (bit7)   clears bit for EOI (4)
        sts flicbb,r16 ;flag IECbus bits
                       ;important that IECOUT routine isn't left
        lds r16,$0203  ;Listen to device   character behind 'a4u'
        ori r16,$20    ;sets bit for listen
        call l11720   ;CBM-IECOUT                                                   64:ed40-edac
                       ;must jump to this place, because before the Atn-line is checked
        ldi r16,$6f    ;SA= commandchannel 15                                             64:edb9
        call l11720   ;CBM-IECOUT                                                        64:edbb

        call l13020   ;AtnOut = inactive                                                 64:edc3
        
        sts flicbb,r06 ;#$00 clears bit for Atn-mode (bit7)   clears bit for EOI (4)
                       ;important that IECOUT routine isn't left
        
        ldi r30,low(tx41ud<<1)  ;text 1541U-debug   m-e $06 $02 $00 ...
        ldi r31,high(tx41ud<<1) 

l23310: lpm r16,z+     ;reads command from flashrom
       
        mov r25,r16    ;..-- (IECOUT-byte at device swap)
        call l13130
       
        call l11720   ;IECOUT
        cpi r30,low((tx41ud<<1)+$28)
        brne l23310    ;b.i.command not yet read to end

        ldi r16,$10    ;clears bit for Atn-mode (bit7)   sets bit for EOI (4)
        sts flicbb,r16 ;flag IECbus bits

        ldi r16,$0d    ;
        call l11720   ;IECOUT
      
        call l12940   ;AtnOut=active                                                     
        call l12880   ;ClkOut=active                                                     
                       ;DtaOut is already inactive
        ldi r25,$64    ;100
        call l10840   ;r25*10µs waiting loop  = 1000µs = 1ms                             

        ldi r16,$80    ;sets bit for Atn-mode (bit7)   clears bit for EOI (4)
        sts flicbb,r16 ;flag IECbus bits
                       ;important that IECOUT routine isn't left
        ldi r16,$3f    ;Unlisten
        call l11720   ;IECOUT                                                            64:ee00
        call l13020   ;AtnOut = inactive                                                 64:ee03

        ldi r25,$06    ;
        call l10840   ;r25*10µs waiting loop  = 60µs                                     64:ee06

        call l12990    ;makes all lines of IEC-bus inactive                          64:ee0d-ee10        
    
        ldi r25,$30    ;30-- 
        call l13130
         
        ldi r26,$00
        ldi r27,$0c
        
        ldi r28,$00
        ldi r29,$0e

l23320: sbis piiema,bidain ;s.i.1541 makes data=inactive
        rjmp l23320    ; waits until 1541 makes data=inactive         

        call l10780    ;active-LED on
    
        ldi r25,$31    ;31-- 
        call l13130
                
        ldi r25,$64
        call l10840    ;1000µs waiting loop

        sts timsk1,r06 ;#$00 Timer/Counter1 Interrupt Mask Register
                       ;disables timer1-IRQs
                       ;there is no RTC-timer2 at SD2IEC
        lds r25,timsk1 ;..--
        call l13130   

        ldi r16,$01
        sts pcicr,r16  ;Pin Change Interrupt Control Register   enables IRQs of portA
        
        ldi r16,$02    ;DtaIn = pa1 = pcint1
        sts pcmsk0,r16 ;Pin Change Mask Register 0  enables DtaIn-IRQs
                       ;                            (disables AtnIn-IRQs)
l23330: clr r07        ;r07=#$00 = flag for IRQ-routine that 1541U-debug        

        ldi r25,$64
        call l10840    ;1000µs waiting loop
    
        ldi r25,$32    ;32-- 
        call l13130
     
        mov r25,r06    ;..-- 
        call l13130
         
        mov r25,r07    ;..-- 
        call l13130

        sei

        mov r16,r28    ;try of different delay for every byte   
 
l23340: dec r16        
        brne l23340 
     
        in r16,poiema
        ldi r17,1<<biclou
        eor r16,r17
        out poiema,r16 ;invert ClkOut

        ldi r16,$01 
        ldi r17,$10

l23350: dec r17        ;1  16*3=48=6µs  
        brne l23350    ;2

        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
        inc r16
l23360: rjmp l23360; rem no IRQ generated early enough

                       ;from l10400 DtaIn-IRQ
l23370: ldi r25,$33    ;33-- 
        call l13130
     
        mov r25,r06    ;..-- 
        call l13130
         
        mov r25,r07    ;..-- 
        call l13130
       
        dec r07        ;#$00->#$ff
        out spl,r07    ;#$ff
        in r17,poiema
        andi r17,1<<biclou
        brne l23390
    
        st x+,r16
        cpi r27,$0e
        breq l23400

l23380: ldi r25,$34    ;34-- 
        call l13130

        rjmp l23330
    
l23390: st y+,r16
        cpi r29,$10
        brne l23380
        
l23400: ldi r25,$3f    ;3f-- 
        call l13130

        rjmp l25290    ;to mainwaitingloop  (makes AtnIn-IRQ again)------------------------------

l23410: cpi r16,$53    ;'s'
        brne l23500    ;b.i.not 'as'

        jmp l27420     ;as.-commands SD/MMC-card
       #endif

       #if partname == 6    
        #message 644-NLQ-HD/SD
        cpi r16,$54    ;'t'
        brne l23430

        cpi r17,$52    ;'r'
        brne l23420

        ldi r24,$80    ;flag for atr                                             command: atr
        rjmp l22220

l23420: cpi r17,$57    ;'w'
        brne l23500

        rjmp l22440    ;                                                         command: atw

l23430: cpi r16,$53    ;'s'
        brne l23500    ;b.i.not 'as'

        jmp l27420    ;as.-commands SD/MMC-vard

   
       #endif

       #if partname == 7
        #message 644-NLQ-HD/full
        cpi r16,$54    ;'t'
        brne l23450

        cpi r17,$52    ;'r'
        brne l23440

        ldi r24,$80    ;flag for atr                                             command: atr
        rjmp l22490

l23440: cpi r17,$57    ;'w'
        brne l23500

        rjmp l23490    ;                                                         command: atw


l23450: cpi r16,$32    ;'2'
        brne l23480    ;b.i.not 'a2'

                       ;it's difficult to make a concrete routine,
                       ;because every I2C-chip can have a different command-structure

                       ;    ----READ----      PCF8574      PCF8583         PCF8583
                       ;byte0 (slaveaddress)    $41          $a0            $a1
                       ;                       stop                        stop
                       ;                       start                       start  
                       ;                       read                        read
                       ;byte1                              address (0-$ff)
                       ;byte2 (slaveaddress)                 $a1 
                       ;                                    stop
                       ;                                    start
                       ;                                    read

                       ;    ----WRITE----     PCF8574      PCF8583 
                       ;byte0 (slaveaddress)    $40          $a0
                       ;byte1                 databyte     address (0-$ff)
                       ;byte2                (databyte)    data of register <address>
                       ;byte3                (databyte)    (data of register <address+1>) 

                       ;at read pcf8574 wrong: $41 is sent, then stop, then start, then $41 again
                       ; then databyte read from I2C-chip
                       
                       ;one can read 1 byte only 
                       ;C64 canot read pcf8583-register directly
                       ;must first set address wirth write-command   

        ldi r26,low(inbube+3)
        ldi r27,high(inbube+3)
       
        lds r21,incoen ;lowbyte input command end (+1)  = $0274 at 1541  
                       ; (end-carriagereturn is already cut off)
        mov r25,r21    ;xx----
        call l13090

        rcall l23630   ;I2C-start-condition  !!changes r20!!

l23460: ld r20,x+      ;loads bytes behind a2r / a2w

        ldi r25,$4c    ;4c----
        call l13090

        mov r25,r20    ;xx----
        call l13090

        rcall l23660   ;send I2C-byte

        ldi r25,$4c    ;4c----
        call l13090

        cp r26,r21   
        brcs l23460    ;b.i.still bytes from inputbuffer to send

        cpi r17,$57    ;'w'   
        breq l23470    ;b.i.a2w 
                       
        ldi r25,$4d    ;4d----
        call l13090

        rcall l23710   ;read byte from I2C-bus -> r20
       
        rcall l23650   ;I2C-stop-condition
       
        mov r25,r20    ;xx----
        call l13090

        rjmp l23180    ;prints byte into errorbuffer

l23470:                ; =i2w
        ldi r25,$4e    ;4e----
        call l13090

        rjmp l23650    ;I2C-stop-condition 

        ldi r25,$4f    ;4f----
        call l13090

        ldi r17,$a0    ;=I2C-bus error               
        jmp syserr     ;system error  a0--  160--

l23480: cpi r16,$53    ;'s'
        brne l23500    ;b.i.not 'as'

        jmp l27420    ;as.-commands SD/MMC-vard

l23490:


       #endif ;644-NLQ-HD/full

l23500: rjmp l23540    ;syntax error
                       ;                                                   end additional command
;------------------------------------------------------------------------------------------------
                       ;from l17240
l23510:                ;                                                                     user
                       ;a C64-program could send the initialize-command while it is
                       ; executed in a subdirectory
                       ;=>the UI-/UJ-command mustn't reset 
                       ;  cbaddX clusterbegin actual directory driveX

        cpi r16,$49    ;'i'
        breq l23520    ;b.i. ui
    
        cpi r16,$4a    ;'j'
        brne l23540    ;b.i.not uj
         
l23520: ldi r16,$01    ;flag for UI- / UJ-software-reset

l23530: clt            ;flag for no software-reset 
        rjmp l23970    ;=ui uj = software-reset and actual directory stays-----------------------

l23540: ldi r16,$1f    ;31,syntax error 31--
        jmp l13980     ;syntax error into errorbuffer & main waiting loop

l23550: ret            ;return to main waiting loop
;------------------------------------------------------------------------------------------------
l23560: jmp l13130     ;write debug-value   
;================================================================================================
       #if partname == 7
        #message 644-NLQ-HD/full
                       ;-------------------------------------------------------begin I2C-routines
                       ;danger: the slave can hold I2C-clock to low (? at an end of a byte)
                       ; to signal that it cannot receive a byte
                       ; this is very bad, because the AVR-I2C-clock isn't open collector!!!!
                       ;it would be perhaps better to use a LED-port?????
                       ;LED-port is bad because AVR cannot see whether low level is
                       ; user presses switch or I2C-slave pulls to low

                       ;pcf8583.pdf 9.1 page 16:
                       ;The clock/calendar acts as a slave receiver or slave transmitter.
                       ;Therefore the clock signal SCL is only an input signal,
                       ;but the data signal SDA is a bidirectional line.
                       ;=> I2C-clock is not used by the 8583 to pull to low to signal that it
                       ; cannot receive a byte ????????????
                       ;=> the AVR-pin can perhaps stay not-open-collector?????????
                      
                       ;I2C_specs.pdf:
                       ;THE I2C-BUS SPECIFICATION   VERSION 2.1   JANUARY 2000
                       ;If a slave cant
                       ;receive or transmit another complete byte of data until it
                       ;has performed some other function, for example servicing
                       ;an internal interrupt, it can hold the clock line SCL LOW to
                       ;force the master into a wait state. Data transfer then
                       ;continues when the slave is ready for another byte of data
                       ;and releases clock line SCL.
                      
                       ;When a slave doesnt acknowledge the slave address (for
                       ;example, its unable to receive or transmit because its
                       ;performing some real-time function), the data line must be
                       ;left HIGH by the slave.

                       ; 'bus free' =  both I2C-lines are high
                       ; start I2C-transaction only if bus is free

                       ;I2C-chips are connected to +3.3V (not +5V)
                       ; => never activate AVR-pullup-resistors
                       ;    never pull acrtive to +5V
                       ;must be open collector and external pullup-resistors pull to +3.3V

                       ;    ----READ----      PCF8574      PCF8583 
                       ;byte0 (slaveaddress)    $41          $a0
                       ;byte1                 databyte     address (0-$ff)
                       ;byte2                (databyte)      $a1 
                       ;byte3                (databyte)    data of register <address>
                       ;byte4                (databyte)   (data of register <address+1>) 

                       ;    ----WRITE----     PCF8574      PCF8583 
                       ;byte0 (slaveaddress)    $40          $a0
                       ;byte1                 databyte     address (0-$ff)
                       ;byte2                (databyte)    data of register <address>
                       ;byte3                (databyte)    (data of register <address+1>) 

;------------------------------------------------------------------------------------------------
l23570: sbi ddi2da,bii2da ;I2C-data = output-0V                                     I2C-data->low
        rjmp l23610    ; (I2C-data = open-collector)                    mustn't change carry
;------------------------------------------------------------------------------------------------
l23580: cbi ddi2da,bii2da ;I2C-data = input                                        I2C-data->high
        rjmp l23610    ; (I2C-data = open-collector)                    mustn't change carry
;------------------------------------------------------------------------------------------------
l23590: sbi ddi2cl,bii2cl ;I2C-clock = output-0V                                   I2C-clock->low
        rjmp l23610    ; (I2C-clock = open-collector)                   mustn't change carry
;------------------------------------------------------------------------------------------------
l23600: cbi ddi2cl,bii2cl ;I2C-clock = input                                      I2C-clock->high
                        ; (I2C-clock = open-collector)                  mustn't change carry
                        ;........................................................................
l23610: ldi r25,$08     ;8                                                              3µs-delay
l23620: dec r25         ;1                                               mustn't change carry
        brne l23620     ;2 3*8=24 = 3µs
        ret
;------------------------------------------------------------------------------------------------


;------------------------------------------------------------------------------------------------
l23630:                 ;                                                     I2C-start-condition
        cbi poi2da,bii2da ;I2C-data = pullupoff / 0V          
        cbi poi2cl,bii2cl ;I2C-clock = pullupoff / 0V

        ;ldi r25,$af    ;af--                                     !!changes r20!!
        ;call l13130    
      
        ;lds r25,fli2ir
        ;call l13130    ;---- fli2ir     
/*
        sts fli2ir,r07  ;#$ff flag for IRQ-routine that i2c-bus is used by mainprogram
                       ;........................................................................
        ldi r20,$14    ;20* (1startbit + 9bits per byte at 2 bytes

        rcall l23580   ;I2C-data -> high  = master doesn't send ack
                       ;                  => slave knows that master doesn't request next byte
l23640: rcall l23610   ;3µs delay
        rcall l23600   ;I2C-clock -> high

        rcall l23610   ;3µs delay

        rcall l23590   ;I2C-clock -> low
        dec r20
        brne l23640

        ;ldi r25,$b0    ;b0--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rcall l23570   ;I2C-data -> low 

        ;ldi r25,$b0    ;b0--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rcall l23600   ;I2C-clock -> high

        ;ldi r25,$b0    ;b0--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rcall l23580    ;I2C-data -> high 
                        ;i2c-Dta low->high change while clock is high = stop-condition
*/
                       ;........................................................................
                       ;wait here until I2C-bus is free??????????????????????

        ;ldi r25,$90    ;90--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rcall l23590   ;I2C-clock -> low

        ;ldi r25,$92    ;92--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rcall l23580   ;I2C-data -> high

        ;ldi r25,$93    ;93--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rcall l23600   ;I2C-clock -> high

        ;ldi r25,$94    ;94--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rjmp l23570    ;I2C-data -> low 
                       ;high to low transition of data while clock is high = start-condition
                       ;after start-condition: I2C-data=low  I2C-clock=high
;------------------------------------------------------------------------------------------------
l23650:                ;                                                       I2C-stop-condition
        ;ldi r25,$b0    ;b0--                                       mustn't change carry-flag
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rcall l23590   ;I2C-clock -> low                                 

        ;ldi r25,$b0    ;b0--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rcall l23570   ;I2C-data -> low

        ;ldi r25,$b0    ;b0--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rcall l23600   ;I2C-clock -> high

        ;ldi r25,$b0    ;b0--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rcall l23580    ;I2C-data -> high 
/*
        sts fli2ir,r06  ;#$00 flag for IRQ-routine that i2c-bus is unused
*/
        ret   
                       ;low to high transition of data while clock is high = stop-condition
                       ;after stop-condition: both lines are high = good (=bus free)
;------------------------------------------------------------------------------------------------
                       ;from l23260, l23260, l23260
l23660: sec            ;counter for 8 bits per byte                           send r20 to I2C-bus
                       ;                                                     changes r20, r25
        ;ldi r25,$91    ;95--
        ;call l13130    

        ;mov r25,r20    ;--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

l23670: rcall l23590   ;I2C-clock -> low  (mustn't change carry)

        ;ldi r25,$96    ;96--
        ;call l13130    

        ;mov r25,r20    ;--
        ;call l13130    

        ;mov r25,r24    ;--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rol r20        ;sends bit7 first, bit0 last
        brcs l23680    ;b.i.high-bit to send

        ;ldi r25,$97    ;97--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rcall l23570   ;I2C-data -> low 
        rjmp l23690

l23680: 

        ;ldi r25,$98    ;98--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rcall l23580   ;I2C-data -> high

l23690: 
    
        ;ldi r25,$99    ;99--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130        
        
        rcall l23600   ;I2C-clock -> high
        rcall l23610   ;3µs delay

        ;ldi r25,$9a    ;9a--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        cpi r20,$80
        clc
        brne l23670    ;sends 8 bits of a byte

        ;ldi r25,$9b    ;9b--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    


        rcall l23590   ;I2C-clock -> low

        ;ldi r25,$9c    ;9c--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    


        rcall l23580   ;I2C-data -> high (open-collector)


        ;ldi r25,$9d    ;9d--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    




        rcall l23600   ;I2C-clock -> high


        ;ldi r25,$9e    ;9e--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    



        clc            ;flag for ok
        sbic pii2da,bii2da  ;skips if slave makes I2C-data low as acknowledge

        sec            ;flag for error
        
        rcall l23610   ;3µs delay    mustn't change carry


        ;ldi r25,$9f    ;9f--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rjmp l23590    ;I2C-clock -> low    mustn't change carry
                       ;at ennd: I2C-data=high  I2C-clock=low
;------------------------------------------------------------------------------------------------
                       ;from l27540-24560
l23700: clt            ;flag for not last byte
        rjmp l23720    ;.........................................................................
                       ;from l23460, l23820, l27540 - l27620
l23710: set            ;flag for last byte

l23720: ldi r20,$01    ;counter for 8 bits per byte                         read r20 from I2C-bus
                       ;                                            changes r20, r25, T-flag
        ;ldi r25,$a0    ;a0--                                         can read one byte only
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rcall l23590   ;I2C-clock -> low

        ;ldi r25,$a1    ;a1--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rcall l23580   ;I2C-data -> high

        ;ldi r25,$a2    ;a2--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    
        
l23730: rcall l23590   ;I2C-clock -> low

        ;ldi r25,$a3    ;a3--
        ;call l13130    

        ;mov r25,r20    ;--
        ;call l13130    

        ;mov r25,r24    ;--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rcall l23610   ;3µs delay   

        rcall l23600   ;I2C-clock -> high

        ;ldi r25,$a4    ;a4--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130   
        
        clc
        sbic pii2da,bii2da  ;skips if slave makes I2C-data low as transfer of 0-bit

        sec            ;= slave makes I2C-data high as transfer of 1-bit

        rol r20
        
        rcall l23610   ;3µs delay  mustn't change carry

        ;ldi r25,$a5    ;a5--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    
        
        brcc l23730    ;reads 8 bits of a byte

        ;ldi r25,$a6    ;a6--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rcall l23590   ;I2C-clock -> low

        ;ldi r25,$a7    ;a7--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        brtc l23740    ;b.i.not last requested byte

        ;ldi r25,$a8    ;a8--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rcall l23610   ;3µs delay (doesn't send acknowledge as flag to slave 
        rjmp l23750    ;           that this is the last byte)

l23740: rcall l23570   ;I2C-data -> low (sends acknowledge as flag to slave 
                       ;           that this isn't the last byte)
        ;ldi r25,$a9    ;a9--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

l23750: rcall l23600   ;I2C-clock -> high

        ;ldi r25,$aa    ;aa--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    
        
        rcall l23610   ;3µs delay

        rcall l23590   ;I2C-clock -> low    mustn't change carry

        ;ldi r25,$ab    ;ab--
        ;call l13130    

        ;mov r25,r20    ;--
        ;call l13130    

        ;in r25,pinb    ;--
        ;call l13130    

        ;in r25,pind    ;--
        ;call l13130    

        rjmp l23580    ;I2C-data -> high                      
                       ;at ennd: I2C-data=high  I2C-clock=low
;------------------------------------------------------------------------------------------------
                       ;from l10790, l12940, l26280
l23760: lds r20,i2pova ;I2C-port-value                    clears bits of r25 to I2C-parallel-port
        and r20,r25
        rjmp l23780    ;-------------------------------------------------------------------------
                       ;from l10810, l13020, l25980, l26310
l23770: lds r20,i2pova ;I2C-port-value                      sets bits of r25 to I2C-parallel-port
        or r20,r25     ;.........................................................................
                       ;from l23760, l23970, l25490, l25980
l23780: ldi r25,$ae    ;ae--                                      writes r20 to I2C-parallel-port
        call l13130    ;                                                   changes r20, r25

        mov r25,r20    ;--  (i2c-byte)
        call l13130   
        
l23790: sts i2pova,r20 ;I2C-port-value                            writes r20 to I2C-parallel-port
                       ;  (of 8bit port expander chip)                       changes r20, r25
        rcall l23630   ;I2C-start-condition !!changes r20!!                mustn't change t-flag               
                       ;                                                   (SPI-active l26270)
        ldi r20,$40    ;slaveaddress of pcf8574
        rcall l23660   ;send I2C-byte
        brcs l23800    ;b.i. I2C-bus error      

        lds r20,i2pova ;parallelport-byte
        rcall l23660   ;send I2C-byte
        
l23800: rjmp l23650    ;I2C-stop-condition   (mustn't change carry-flag)
;------------------------------------------------------------------------------------------------
                       ;from l17090, l17970, l18920, l26570
l23810: ldi r25,$af    ;af--                                      reads I2C-parallel-port to r20           
        call l13130    ;                                              changes r20, r25, T-flag

                       ;from l25290, l25980, l27000
l23820: rcall l23630   ;I2C-start-condition  !!changes r20!!       reads I2C-parallel-port to r20           
                       ;                                              changes r20, r25, T-flag
        ldi r20,$41    ;slaveaddress of pcf8574 for read
        rcall l23660   ;send I2C-byte
        brcs l23830    ;b.i. I2C-bus error      

        rcall l23710   ;read I2C-port
        
l23830: rjmp l23650    ;I2C-stop-condition   (mustn't change carry-flag)
       #endif ;644-NLQ-HD/full --------------------------------------------------end I2C-routines
;================================================================================================
                       ;from l25230 (reset), 
l23840:                ;                                                   enable AtnIn-IRQ & SEI
       #if partname == 1     
        #message 162-IEC-ATA-V2
        ldi r16,$82    ;bit7   = %1 enable external RAM    
                       ;bit1-0 = %10 =falling edge
        out mcucr,r16  ;MCU control register int0-IRQs at falling edge 
                      
        ldi r16,1<<ibatin ;IRQ-bit AtnIn-pin interrupt0 (bit6->$40)
        sts iratin,r16 ;IRQ-register AtnIn-pin    
                       ;gicr   General Interrupt Control Register
                       ;allows int0 irq
                       ; IECATA  PD2   int0   bit6 of gicr   falling edge 
        reti
       #endif ;162-IEC-ATA-V2
   
       #if partname == 3
        #message 644-NLQ-HD/sd2iec
        ldi r16,1<<biatin ; enables bit0 of PrtA as pinchange-pin
        sts pcmsk0,r16 ;Pin Change Mask Register 0    
        
        ldi r16,1<<ibatin  ;IRQ-bit AtnIn-pin interrupt 0 (bit0->$01)
        sts iratin,r16 ;IRQ-register AtnIn-pin
                       ;pcicr  Pin Change Interrupt Control Register
                       ;   644: PA0  
                       ; SD2IEC  PA0  pcint0  bit0 of pcicr  pin change
        reti
       #endif
       
       #if ((partname >= 3) & (partname <= 7))
        #message 644-NLQ-HD/all
     
       #if partname == 6    
        #message 644-NLQ-HD/SD
        ldi r16,$0a
        sts eicra,r16  ;$49+$20=$69  in and out command doesn't work => must use sts lds
                       ;external interrupt control register a   int2-IRQs at falling edge 
                       ;bit5-4: %00 = low level    = int2 = PB2 = sleep/awake
                       ;bit3-2: %10 = fallin edge  = int1 = PD3 = IEC-AtnIn 
                       ;bit1-0: %10 = falling edge = int0 = PD2 = reset
                       ;problem at AT90S8515:
                       ;%x0000010 falling edge = IRQ-trigger doesn't work because:
                       ; IEC-ATN falls so slow that it doesn't trigger reliably an IRQ 
                       ;ATMEGAs seem to generate always a falling edge INT even when
                       ; the level changes very slow
        ldi r16,$07
        sts iratin,r16 ;enabale AtnIn-IRQs (int2) 
                       ;bit2 = int2
                       ;bit1 = int1
                       ;bit0 = int0   
                       ;enable RstIn-IRQ (int0)
                       ;enable Sleep-IRQ (int1)          
                       ;doesn't change RTC-IRQ
                       ;doesn't change 100Hz timer IRQs
        reti

       #else
        ldi r16,$20    
        sts eicra,r16  ;$49+$20=$69  in and out command doesn't work => must use sts lds
                       ;external interrupt control register a   int2-IRQs at falling edge 
                       ;problem at AT90S8515:
                       ;%x0000010 falling edge = IRQ-trigger doesn't work because:
                       ; IEC-ATN falls so slow that it doesn't trigger reliably an IRQ 
                       ;ATMEGAs seem to generate always a falling edge INT even when
                       ; the level changes very slow

        ldi r16,1<<ibatin  ;IRQ-bit AtnIn-pin interrupt 2 (2->$04)
        sts iratin,r16 ;   external interrupt 2 control mask register
                       ;external interrupt 2 control mask register    allows int2 irq
                       ;IRQ-register AtnIn-pin   644: PB2  
                       ;   external interrupt 2 control mask register
                       ; NLQ-HD  PB2   int2   bit2 of eimsk  falling edge
        reti 
       #endif         
       #endif
;------------------------------------------------------------------------------------------------
                       ;                                     initialize timer1 to 100IRQs/s & SEI
        #if ((partname >= 3) & (partname <= 7))
         #message 644-NLQ-HD/all
                       ;from l24860 (reset). l25290 (mainwaitingloop)
l23850:                ;wanted timer functions:
                       ;CTC clear timer on compare match
                       ;   when the counter is equal to a programmed value then the counter is 
                       ;    reset to 0000  
                       ;   counter counts up (not down)
                       ;   => wgm13-wgm10 must be %0100 = compares with output compare register A
                       ;           (not input compare register   never output compare register B)

        ldi r25,$0a    ;%000 01 010 Clear Timer1 on Compare match 8388608Hz/8=1048576Hz  
        sts tccr1b,r25 ;Timer/Counter1ControlRegisterB          1048576Hz/10486=100Hz
                       ;sts instead of out                     10486=$28f6
                       ;M162&M644
                       ;7 icnc1   0
                       ;6 ices1   0
                       ;5         0
                       ;4 wgm13   0   
                       ;3 wgm12   1
                       ;2 cs12    0
                       ;1 cs11    1
                       ;0 cs10    0
                       ;Bit4-3=WGM13-WGM12=%01 (=part of wgm13-10)
                       
                       ;bit2-0 = %010 = CS12-CS10 = timer-prescaler clock/8
      
        sts tccr1a,r06 ;#$00 Timer/Counter1ControlRegisterA     necessary????                                 
                       ;  M162    M644     
                       ;7 com1a1  com1a1  0
                       ;6 com1a0  com1a0  0
                       ;5 com1b1  com1b1  0
                       ;4 com1b0  com1b0  0
                       ;3 foc1a           0
                       ;2 foc1b           0
                       ;1 wgm11   wgm11   0
                       ;0 wgm10   wgm10   0

                       ;Bit5,4= com1b1-com1b0 =function of oc1b-pin = pin29 = PrtE2-pin at M162
                       ;                                            = pin18 = PrtD4-pin at M644
                       ;        %00         = no action at oc1b-pin on compare match        
                       ;Bit1-0=WGM11-WGM10=%00
                       ; =>WGM13-WGM10=%0100=4=Clear Timer on Compare Mode and use output compare
                       ;                         registers
                       ;   =clears timer to $0000 when it reaches value ocr1a (28f6)         
 
        ;sts tcnt1h,r06 ;Timer/Counter1 high
        ;sts tcnt1l,r06 ;Timer/Counter1 low    make Timer1 = $0000
                       ;at write: The highbyte must be written before the lowbyte
                       ;at read: The lowbyte must be read before the highbyte 
                        
                       ;ocr1a determines the TOP-value of the counter 
        ldi r25,$28
        sts ocr1ah,r25 ;T/C1 Output Compare Register A high
        ldi r25,$f6    ;about 100Hz  
        sts ocr1al,r25 ;T/C1 Output Compare Register A low
                       ;at write: The highbyte must be written before the lowbyte
                       ;at read: OCR1a has no special 'Accessing 16-bit Registers'
                       ;IEC-ATA: timer1 (16bit) counts single/error-LED only ->l10740
                       ;         timer1 counts 0.25s (4Hz)
                       ;         timer1 influences single/error-LED directly
                       ;M644:    timer1 (16bit) countse 100Hz-IQ
                       ;         100Hz-IRQ influences single/error-LED 
        ldi r25,$02
        sts timsk1,r25 ;Timer/Counter1 Interrupt Mask Register
                       ;bit1 = Timer/Counter1 Output Compare Match A Interrupt Enable
        reti           ; = ret + sei  enable IRQs
        
                       ;general registers of timers 0-2 
                       ;a '9' is a replacement for 0-2 (use 0 instead of 9 for timer 0...)

                       ;foc9 force output compare
                       ;     foc0, foc1a, foc1b, foc2

                       ;wgm93-wgm90: waveform genaration mode
                       ;      determines 

                       ;com91-90: compare match output mode
                       ;      com1a1-com1a0, com1b1-com1b0 
                       ;      determines what happens with the portpins when the timer
                       ;       has the same value as the programmed value

                       ;csel92-csel90: clock select
                       ;      determines timer-prescaler (not system-clock-prescaler)   
                       ;      %000 = no timer-prescaler
                       ;      %101 = 1/1024 timer-prescaler

                       ;tcnt9 timer counter register tcnt0 
                       ;      actual value of timer/counter  
       #endif
;================================================================================================
       #if partname == 6
l23860:                ;                                  initialize timer2 for 32kHz-crystal-RTC
                       ;wanted timer functions:              mustn't change T-flag  
                       ;normal mode                           
                       ;   counter counts up (not down)
                       ;   => wgm22-wgm20 must be %000
        ldi r25,$20
        sts assr,r25   ;asynchronous status register
                       ;bit5: AS2: Asynchronous Timer/Counter2
                       ;enables external 32kHz-crystal-oscylator

        ldi r25,$07    ;%000 00 111 normal mode                        32768Hz/1024=32Hz  
        sts tccr2b,r25 ;Timer/Counter2ControlRegisterB          
                       ;sts instead of out                     
                       ;M162&M644
                       ;7 foc2a   0
                       ;6 foc2b   0
                       ;5         0
                       ;4         0   
                       ;3 wgm22   0
                       ;2 cs22    1
                       ;1 cs21    1
                       ;0 cs20    1
                       ;Bit4-3=WGM22=%0 (=part of wgm22-20)
                       
                       ;bit2-0 = %111 = CS12-CS10 = timer-prescaler clock/1024
      
        ldi r25,$02
        sts tccr2a,r25 ;Timer/Counter2ControlRegisterA 
                       ;  M162    M644     
                       ;7 com2a1  com2a1  0
                       ;6 com2a0  com2a0  0
                       ;5 com2b1  com2b1  0
                       ;4 com2b0  com2b0  0
                       ;3 foc2a           0
                       ;2 foc2b           0
                       ;1 wgm21   wgm21   1
                       ;0 wgm20   wgm20   0

                       ;Bit5,4= com1b1-com1b0 =function of oc2b-pin 
                       ;        %00         = no action at oc2b-pin        
                       ;Bit1-0=WGM21-WGM20=%10
                       ; =>WGM22-WGM20=%010=2=CTC=clear timer on compare match mode         
 
        ldi r25,$bf    ;=191 counts from 0-191   6sec=1IRQ
        sts ocr2a,r25  ;Timer/Counter2 Output Compare Register A
        sts ocr2b,r25  ;Timer/Counter2 Output Compare Register B

        ldi r25,$04
        sts timsk2,r25 ;Timer/Counter2 Interrupt Mask Register
                       ;bit0 = Timer/Counter2 Overflow Interrupt Enable
                       ;bit1 = Timer/Counter2 Output Compare Match A Interrupt Enable (sleep)
                       ;bit2 = Timer/Counter2 Output Compare Match B Interrupt Enable (awake)
        reti           ;= ret + sei  enable IRQs

                       ;-644 is awake: make Timer/Counter2 Compare Match A IRQs
                       ;-644 sleeps: make Timer/Counter2 Overflow IRQs
                       ;overflow-IRQ is when tnct2 = #$00
                       ;=> make ocr2a also =#$00 => both IRQs are generated at the same timer-
                       ; value     

.db 0
                       ;If Timer/Counter2 is used to wake the device up from Power-save or
                       ;ADC Noise Reduction mode, precautions must be taken if the user wants to
                       ;re-enter one of these modes: The interrupt logic needs one TOSC1 cycle 
                       ;to be reset. If the time between wake-up and reentering sleep mode is 
                       ;less than one TOSC1 cycle, the interrupt will not occur, and the device
                       ;will fail to wake up. If the user is in doubt whether the time before 
                       ;re-entering Power-save or ADC Noise Reduction mode is sufficient, the 
                       ;following algorithm can be used to ensure that one TOSC1 cycle has 
                       ;elapsed:
                       ;a. Write a value to TCCR2x, TCNT2, or OCR2x.
                       ;b. Wait until the corresponding Update Busy Flag in ASSR returns to zero.
                       ;c. Enter Power-save or ADC Noise Reduction mode.
                       ; tosc1 = pin C6 = input-pin of 32kHz crystal
       #endif  
;================================================================================================
l23870: cpi r23,$00    ;                                            r23*0.1s delay-loop (0-25.5s)
        breq l23900    ;b.i.no delay-loop                           changes r23,r24,r25

l23880: ldi r24,$64    ;100                                       
l23890: ldi r25,$64    ;100
        call l10840    ;r25*10µs delay  100*10µs=1000µs=1ms 
        dec r24     
        brne l23890    ;100*1ms=100ms=0.1s tenth second 
        dec r23        
        brne l23880

l23900: ret
;------------------------------------------------------------------------------------------------
l23910: jmp l10820     ;long-jump to delayloop
;================================================================================================
                       ;from Reset-vector
l23920: set            ;flag for hardware-reset                                    hardware reset
                       ;                                                           from reset-pin
       #if partname ==6
        #message 644-NLQ-HD/SD
        sts $018c,r06
        sts $018d,r07
        sts $0189,r25  ;end of stack: for debug-printing
        in r25,Spl     ;stackpointer low
        sts $018e,r25

        clr r06  
        sts pcicr,r06  ;#$00 Pin Change Interrupt Control Register   disable further IRQs           
        clr r07        ;important if watchdog-timeout at special RTC-IEC-routines
        dec r07

        ldi r25,$bf    ;stackpointerlow = bf  important for debugging 
                       ;  that debugroutine doesn't overwrite stack
        out Spl,r25    ;is made correctly to #$ff at l25290
        ldi r25,high(stpobe)
        out Sph,r25    ;stackpointer high to 01 => stackpointer to 01ff  stack=0180-01ff=$80bytes
       
        ldi r25,0b00111000
        sts wdtcsr,r25 ;Watchdog Timer Control Register
                       ;7:   wdif Watchdog Interrupt Flag
                       ;6:   WDIE Watchdog Interrupt Enable
                       ;5:   wdp3 Watchdog Timer Prescaler 3
                       ;4    WDCE Watchdog Change Enable
                       ;3:   WDE  Watchdog System Reset Enable
                       ;2-0: WDP2-0: Watchdog Timer Prescaler 2, 1 and 0
                       ;             pdp3-0=%0101 = 0.5s 
                       ;wdce=1 and wdw=1 => allows changig of the watchdog
        
        ldi r25,0b00100000
        sts wdtcsr,r25 ;disables watchdog-IRQs (this sts must be within 4cycles)

        ldi r25,$03  
        sts sdfldc,r25 ;SD flag disk change                             (bit0-3=$1c at 1541)
                       ;                                                (bit4-7=$1e at 1541)
                       ;bit4: pin of SS-card-detect
                            
                       ;bit1; 0=preserve actual dircluster 1=reset actual dircluster 
                       ;bit0: 0=not changed  1=changed
                       ;important because at flashing the RAM is cleared

        rcall l23860   ;initialize RTC-timer2 + SEI   mustn't change T-flag   
        
        rjmp l23990
;------------------------------------------------------------------------------------------------
                       ;from PD2 INT0 reset-pin
l23930: set            ;flag for hardware-reset                                    hardware reset
        cli            ;                                                           from PD2-INT
     
        sts $018c,r06
        sts $018d,r07
        clr r06    
        sts pcicr,r06  ;#$00 Pin Change Interrupt Control Register   disable further IRQs 
        
        sts $0189,r25  ;end of stack: for debug-printing
        in r25,Spl     ;stackpointer low
        sts $018e,r25
        
        lds r25,airtrs ;AVR-internal-RTS resetswitch swing counter     
        inc r25
        sts airtrs,r25

        clr r07
        dec r07

        out DdrA,r06
        out PrtA,r06
        out DdrB,r06
        out PrtB,r06

        ldi r25,$04
        out DdrD,r06
        out PrtD,r25   ;RstIn = pullupOn

        in r25,DdrC
        bst r25,bilert ;copies LED-RTC-bit to T-flag
        out DdrC,r06   ;PortC=input
        ldi r25,0b00000100 ;pullupon at LED-RTC (PC2)  (IRQ is disabled)
        out PrtD,r25   
        brtc l23940 

        cbi polert,bilert
        sbi ddlert,bilert

l23940: ldi r25,$bf    ;stackpointerlow = bf  important that debugroutine doesn't overwrite stack
        out Spl,r25    ;is made correctly to #$ff at l25290
        ldi r25,high(stpobe)
        out Sph,r25    ;stackpointer high to 01 => stackpointer to 01ff  stack=0180-01ff=$80bytes
        
        ldi r25,$01
        sts eimsk,r25  ;External Interrupt Mask Register
                       ;disable RstIn-IRQ, disable AtnIn-IRQ
                       ;sleep-IRQ stays enabled
        ldi r25,0b00111000
        sts wdtcsr,r25 ;Watchdog Timer Control Register
                       ;7:   wdif Watchdog Interrupt Flag
                       ;6:   WDIE Watchdog Interrupt Enable
                       ;5:   wdp3 Watchdog Timer Prescaler 3
                       ;4    WDCE Watchdog Change Enable
                       ;3:   WDE  Watchdog System Reset Enable
                       ;2-0: WDP2-0: Watchdog Timer Prescaler 2, 1 and 0
                       ;             pdp3-0=%0101 = 0.5s 
                       ;wdce=1 and wdw=1 => allows changig of the watchdog
        
        ldi r25,0b00100000
        sts wdtcsr,r25  ;disables watchdog-IRQs (this sts must be within 4cycles)
 
        sei 

l23950: ldi r25,$00
        
l23960: sbis PinD,birsin ;s.i.(IEC-)RstIn = inactive  PD2

        rjmp l23950
       
        dec r25
        brne l23960
       
        rjmp l23990 
       #endif
                       ;.........................................................................
                       ;from l23510
                       ;at software-reset: T-flag is cleared
                       ;at software-reset: r16 mustn't be changed until l24250
l23970: cli            ;disables IRQs (= SEI at C64)                                        Reset
                       ;T-flag must stay until l24250 (if no debug-sending)         
l23980:
       #if partname == 7
         #message 644-NLQ-HD/full
        sts $0184,r20  ;necessary because before the debugprinting the I2C-port-chip must
        sts $0185,r21  ; be initialized (because of AtnOut)
        sts $0186,r22  ;end of stack for debug-printing
        lds r20,i2pova ;I2C-port-value (of 8bit port expander chip)
        sts $0180,r20
       #endif
        
        sts $018c,r06
        sts $018d,r07
        sts $0189,r25  ;end of stack: for debug-printing
        in r25,Spl     ;stackpointer low
        sts $018e,r25

        clr r06        ;#$00
        clr r07     
        dec r07        ;#$ff  must be #$ff allways because there can allways be an IRQ  

l23990:                ;not-NLQHD-SD: IRQ disabled
                       ;NLQHD-SD: IRQ enabled!!
        sts $0187,r23
        sts $0188,r24
        sts $018a,r26
        sts $018b,r27
       
        ldi r24,$bf    ;stackpointerlow = bf  important that debugroutine doesn't overwrite stack
        out Spl,r24    ;is made correctly to #$ff at l25290
        ldi r24,high(stpobe)
        out Sph,r24    ;stackpointer high to 01 => stackpointer to 01ff  stack=0180-01ff=$80bytes

                       ;serial IEC-port----------------------------------------Ports-------------   
                       ;                  DDR Port
                       ;input:             0  1   = Input + 40kOhm-Pullup (0.12mA)
                       ;output-activ (0V): 1  0   = Output + push 0V
                       ;output-inactiv     0  0   = Input (=inactiv output)
                       ;IEC-pins are In- or Output (but an Input is allways an Input
                       ;                                an Output is allways an Output)
                       ;using two pins for one line is made to allow additional input- and/or
                       ;output-driver-chips (what wouldn't be possible if one line would be 
                       ;one pin) 
                       ;IEC-pins are open-collector
                       ;ATA-pins aren't open-collector (pull active to +5V)
       
                       ;o=output  i=input
                       ;a=active  p=passive=inactive   

                       ;see also l25500 (74LS244)
                       ;the AVR output pulls an 7407/74LS07 input active to 0V, but doesn't
                       ;pull it active to +5V. It only switches the port to input (before
                       ;november 2007) without activating the pullup-resistors. The input of
                       ;the 7407/74LS07 pulls up to high. I made this to have the possibility
                       ;of making a hardware-version of NLQ-HD without any driver-chips, where
                       ;the outputs to the IEC-bus must be open-collector. Remark: The 8515, 162,
                       ;32 can sink (=pull to 0V) 20mA, the 644 can sink 10mA only. This is very 
                       ;bad, because the C64 and every serial device have 1kOhm-pullup-resistors.
                       ;=> they pullup the IEC-line with 5mA. => You can connect 1 C64, 
                       ;1 serial device (not more) and a NLQ-HD-without-driver-chips only.
                       ;It would perhaps be possible to use an input as second output.
                       ;=> The NLQ-HD-lite could sink 20mA (=1 C64 + 3 serial devices)
                       ;Danger: If this is made at the NLQ-HD-version with driver-chips
                       ;then there is a short-circuit from 74LS244-output to AVR-second-pin.
                       ;I messured the timing. Strange was:
                       ;switchung the AVR-pin from 0V-output to input-without-pullups =>   
                       ; when reading the AVR input-value, the pin was even after 4µs not
                       ; read as high (it probably stayed low forever)
                       ;switching the AVR-pin from input-with-pullups to input-without-pullups 
                       ; when reading the AVR input-value, the pin was even after 4µs not
                       ; read as lowh (it probably stayed high forever)
                       ;=> the AVR inputs seem to have an hyseresis?????
                       ;the AVR-input=74(LS)07-input was still low, while the 74(LS)07-output
                       ;already made the IEC-line inactive

                       ;Chip                      Change of IEC-bus-line    Change of AVR-pin
                       ;                              (=74(LS)07 output)    (=74(LS)07 input)
                       ;                                from low to high    from low to high             
                       ;7407 without pullupresistor       0.250-0.375µs     >4µs (probably never)  
                       ;74LS07 without pullupresistor     1.125-1.250µs     >4µs (probably never)  
                       ;7407 with pullupresistor          0.125-0.250µs     0.125-0.250µs
                       ;74LS07 with pullupresistor        0.250-0.500µs     0.250-0.500µs
                       
                       ;Problem: So far I used a 7407. The 7407 isn't produced. It must be
                       ;replaced by a 74LS07. AT changing the IEC-bus from active (0V) to
                       ;inactive (+5V) (without using the internal pullup-resistors the 74LS07
                       ;is 1µs slower than the 7407. This could make timing problems at Jiffydos?
                       ;Solution: One must switch from 0V-output (=active) to 
                       ;input-plus-activated-pullup-resistors (=inactive). => The timing of the
                       ;74LS07 is the same as the 7407 was before without pullup-resistors.
                       ;=> before November 2007: The pullup-resistors weren't activated
                       ;   after November 2007: The pullup-resistors must be activated. 
                         
;------------------------------------------------------------------------------------------------
       #if partname == 1     
        #message 162-IEC-ATA-V2
                       ; a=active  p=passive

        ldi r24,0b01010111 ;dataDirection--------------------------------PrtB-162-IEC-ATA-V2----
        ldi r25,0b11101111 ;Port
                       ;                      DdrB  PrtB 
                       ;7 IEC-ATN Out       o  0     1  p5V  SCK  (Clock In at flashing) 
                       ;6 IEC-SRQ Out       o  1     1  a5V  MISO (same at flashing)
                       ;5 IEC-data In       i  0     1       MOSI (same at flashing)  
                       ;4 IEC-data Out      o  1     0  a0V
                       ;3 IEC-Clock In      i  0     1
                       ;2 IEC-Clock Out     o  1     1  a5V 
                       ;1 ATA-DOIR          o  1     1       (!not open collector!)
                       ;0 ATA-DOIW          o  1     1       (!not open collector!)
                       ;makes DtaOut active to 0V = IEC-active
                       ;makes ClkOut, SrqOut active to +5V = IEC-inactive
                       ;makes AtnOut passive to +5V because this could be an input
                       ; when jumper C is changed 
        out PrtB,r06  ;PrtB = all 0 to prevent that AVR pulls 20mA to 5V 
        out DdrB,r24   ;DDRB = serial IEC-port settings  
        out PrtB,r25  ;PrtB-----------------------------------------------PrtB-162-IEC-ATA-V2----

        ldi r24,0b11111011 ;---------------------------------------------PrtD-162-IEC-ATA-V2----
        ;ldi r25,0b11111111
                       ;                      DdrD PrtD
                       ;7 /RD           o      1     1   
                       ;6 /WD           o      1     1
                       ;5 ATA-DA2       o      1     1        
                       ;4 ATA-DA1       o      1     1
                       ;3 ATA-DA0       o      1     1 
                       ;2 /IEC-ATN      i      0     1   input&pullup
                       ;1 /ATA-CS1      o      1     1
                       ;0 /ATA-CS0      o      1     1
        ;out PrtD,r06
        out DdrD,r24   ;DdrD = input
        out PrtD,r07
        ;out PrtD,r25   ;PrtD -------------------------------------------------PrtD-------------       

        out DdrA,r06   ;DdrA to input (#00)------------------------------------PrtA------------- 
        out PrtA,r07   ;PrtA = PullUpOn (to prevent swinging???)  Port=inactiv
                       ;=dataport d0-d7----------------------------------------PrtA-------------
        out DdrC,r06   ;DdrC---------------------------------------------------PrtC-------------
        out PrtC,r07   ;PrtC
                       ;=Ddataport  d8-15---------------------------------------PrtC-------------

        out DdrE,r06    ;DdrE   (#$00) ----------------------------------------PrtE-------------
        ldi r24,0b00000011
        out PrtE,r24   ;PrtE 
                       ;                      DdrE PrtE             
                       ;2 Single-LED           0     0     inactive => Single-LED=off            
                       ;1 ALE                  0     1
                       ;0 IEC-SRQ In           0     1-------------------------PrtE-------------
                       ;single-LED must be off to allow reading of the debug-switch
       #endif          ;end mega162-162-IEC-ATA-V2

                       ;ATA-ports aren't open collector
                       ; (exeption: NLQHD-lite: ATA-reset is open collector)

      #if partname == 3     
        #message 644-NLQ-HD/sd2iec
       
        ldi r24,0b11110000 ;------------------------------------------PrtA-644-NLQ-HD/sd2iec----
        ldi r25,0b00101111
                       ;                      DdrD PrtD
                       ;7 -IEC-SrqOut   o      1     0    inverted
                       ;6 -IEC-ClkOut   o      1     0
                       ;5 -IEC-DtaOut   o      1     1         
                       ;4 -IEC-AtnOut   o      1     0    inverted
                       ;3 IEC-SrqIn     i      0     0    notinverted
                       ;2 IEC-ClkIn     i      0     0 
                       ;1 IEC-DtaIn     i      0     0
                       ;0 IEC-AtnIn     i      0     0    notinverted
        out DdrA,r24   ;DdrA   don't activated pullups at inputs because there is a 
                       ;  voltage divider with two resistors
        out PrtA,r25   ;PrtA -------------------------------------------------PrtA-------------

        ldi r24,0b10110000 ;dataDirection------------------------------------PrtB-644-sd2iec----
        ldi r25,0b01011111 ;Port
                       ;                      DdrB  PrtB 
                       ;7 AVR-SPI-ClkOut    o  1     0     SCK   
                       ;6 AVR-SPI-DtaIn     i  0     1     MISO 
                       ;5 AVR-SPI-DtaOut    o  1     0     MOSI   
                       ;4 AVR-SPI-CS-Out    o  1     1   
                       ;3 -                 i  0     1
                       ;2 (IEC-AtnIn)       i  0     1    
                       ;1 -                 i  0     1   
                       ;0 -                 i  0     1   
        out PrtB,r06  ;PrtB = all 0 to prevent that AVR pulls 20mA to 5V 
        out DdrB,r24   ;DDRB = serial IEC-port settings  
        out PrtB,r25  ;PrtB---------------------------------------------------PrtB-644-sd2iec----
    
        ldi r24,0b00000011 ;DdrC--------------------------------------PrtC-644-NLQ-HD/sd2iec----
        ldi r25,0b11111111 ;PrtC
                       ;                      DdrC PrtC
                       ;7 X6-1          i      0     1   
                       ;6 X6-2          i      0     1
                       ;5 X6-3          i      0     1        
                       ;4 X6-4          i      0     1
                       ;3 diskswitch    i      0     1 
                       ;2 X3-3          i      0     1 
                       ;1 LED1          o      1     1   !ON when pin = +5V (not 0V)!
                       ;0 LED2          o      1     1   !ON when pin = +5V (not 0V)!
        out DdrC,r24   ;DdrC
        out PrtC,r25  ;PrtC -------------------------------------------------PrtC-------------

        ldi r24,0b00000000 ;DdrD--------------------------------------PrtD-644-NLQ-HD/sd2iec----
        ldi r25,0b11111111 ;PrtD
                       ;                      DdrD PrtD
                       ;7 device 8/9    i      0     1   
                       ;6 SMC-wrtprtct  i      0     1
                       ;5 device 10/11  i      0     1        
                       ;4 -             i      0     1   (bug at V1.1: debugswitch?)
                       ;3 TXD1          i      0     1   debugswitch?
                       ;2 SMC-crd-dtct  i      0     1 
                       ;1 TXD0          i      0     1
                       ;0 RXD0          i      0     1
        out PrtD,r06
        out DdrD,r24   ;DdrD = input
        out PrtD,r25   ;PrtD -------------------------------------------------PrtD-------------
       #endif   

       #if partname == 4
        #message 644-NLQ-HD/lite

        ldi r24,0b00110000 ;dataDirection---------------------------------PrtB-644-NLQ-HD/lite----
        ldi r25,0b11001111 ;Port 
                       ;                      DdrB  PrtB 
                       ;7 IEC-Clk In       i/o 0     1     SCK  
                       ;6 IEC-Srq Out       o  0     1  p  MISO (AVR is slave while flashing)
                       ;5 IEC-Dta In       i/o 1     0     MOSI   
                       ;4 IEC-Dta Out       o  1     0  a  
                       ;3 IEC-Clk Out       o  0     1  p
                       ;2 IEC-Atn In       i/o 0     1     pinB2 makes Int2
                       ;1 IEC-Srq In       i/o 0     1     and debug switch
                       ;0 IEC-Atn Out       o  0     1  p 
                       ;the 644 can sink with 10mA only
                       ;=> one must use both lines as output to douple to 20mA 
        out PrtB,r06  ;PrtB = all 0 to prevent that AVR pulls 20mA to 5V 
        out DdrB,r24   ;DDRB = serial IEC-port settings  
        out PrtB,r25  ;PrtB
  
        ldi r24,0b11111110 ;DdrD------------------------------------------PrtD-644-NLQ-HD/lite----
        ldi r25,0b00111111 ;PrtD
                       ;                      DdrD PrtD
                       ;7 LED&switch   i/o     1     0   (=LED=on)   
                       ;6 LED&switch   i/o     1     0   (=LED=on)
                       ;5 ATA-DA2       o      1     1        
                       ;4 ATA-DA1       o      1     1
                       ;3 ATA-DA0       o      1     1 
                       ;2 ATA-DIOW      o      1     1
                       ;1 ATA-DIOR      o      1     1
                       ;0 ATA-RST&CS0  i/o     0     1  (+ debugswitch)
       
                       ;activity of LEDs is made by Ddr, not by Port.
                       ;LED-port must be allways %0
                       ;LED and LED-resistor pulls to high (with 2mA/10mA)
                       ; => internal pullup-resistor not necessary?
                       ;all ATA.lines pull active to +5V
                       ;exeption: ATA-reset&CS0 are pulled passively to +5V by the 
                       ; HD-pullup-resistors and the AVR-pullup-resistor
                       ; reason: here is the debugswitch
        out PrtD,r06
        out DdrD,r24   ;DdrD = input
        out PrtD,r25   ;PrtD -------------------------------------------------PrtD-------------
      
        out DdrA,r06   ;DdrA to input (#00)------------------------------------PrtA------------- 
        out PrtA,r07   ;PrtA = PullUpOn (to prevent swinging???)  Port=inactiv
                       ;=dataport d0-d7----------------------------------------PrtA-------------
      
        out DdrC,r06   ;DdrC---------------------------------------------------PrtC-------------
        out PrtC,r07   ;PrtC
                       ;=Ddataport  d8-15---------------------------------------PrtC-------------
      
        #endif

       #if partname == 6
        #message 644-NLQ-HD/SD

        ldi r24,0b00000000 ;DdrB-----------------------------------------PrtB-644-NLQ-HD/SD------
        ldi r25,0b11111010 ;PrtB
                       ;                      DdrB  PrtB 
                       ;7 IEC-Clk In        i  0     1     SCK  
                       ;6 IEC-Srq Out       o  0     1  p  MISO (AVR is slave while flashing)
                       ;5 IEC-Dta In        i  0     1     MOSI   
                       ;4 IEC-Srq Out       o  0     1  p  
                       ;3 IEC-Atn In        i  0     1     
                       ;2 VPS sleep/awake   i  0     0     pinB2 makes Int2
                       ;1 IEC-Srq In&Out    i  0     1     
                       ;0 SPI-Clk           o  0     0     via resistors 3.3V
     
                       ;SPI-pins have +3.3V only
 
        out PrtB,r06  ;PrtB = all 0 to prevent that AVR pulls 20mA to 5V 
        out DdrB,r24  ;DdrB = serial IEC-port settings  
        out PrtB,r25  ;PrtB-----------------------------------------------------PortB------------
      
        ldi r24,$38    ;DdrA----------------------------------------------------PortA------------ 
        ldi r25,$47    ;PrtA
        out PrtA,r06
        out DdrA,r24   ;DdrA  DtaOut = active    ClkOut=inactive
        out PrtA,r25   
                       ;                      DdrA  PrtA 
                       ;7 VCC               i  0     0    
                       ;6 (voltage divider) i  0     1  so far unused  
                       ;5 IEC-Dta Out      i/o 1     0     
                       ;4 IEC-Dta Out      i/o 1     0     
                       ;3 IEC-Dta Out      i/o 1     0     
                       ;2 IEC-Clk Out      i/o 0     1     
                       ;1 IEC-Clk Out      i/o 0     1     
                       ;0 IEC-Clk Out      i/o 0     1     
                       ;PrtA----------------------------------------------------PortA------------
 
        ldi r24,0b00000011 ;DdrC---------------------------------------------------PrtC----------
        ldi r25,0b11110100 ;PrtC
                       ;                      DdrC  PrtC 
                       ;7 RTC               i  0     1      
                       ;6 RTC               i  0     1    
                       ;5 SD-carddetect     i  0     1       
                       ;4 SD-writeprotect   i  0     1    
                       ;3 SPI-chipselect    i  0     0      via diode and resistor to SD-card
                       ;2 free              i  0     1
                       ;1 LED&switch       i/o 1     0   LED on
                       ;0 LED&switch       i/o 1     0   LED on
        out DdrC,r24   ;DdrC
        out PrtC,r25   ;PrtC----------------------------------------------------PrtC-------------

                       ;-------------------------------------------------PrtD-644-NLQ-HD/SD------
        cli            ;important that RTC-IRQ doesn't change RTC-LED
        ldi r24,0b10000000 ;DdrD
        ldi r25,0b01111100 ;PrtD
                       ;                        DdrD PrtD
                       ;7 Jumper-Debug     i      x    -x   (and RTC-test-LED?)        
                       ;6 IEC-Srq Pullup   o      0     1
                       ;5 IEC-Atn Out     i/o     0     1     
                       ;4 IEC-Atn Out     i/o     0     1     
                       ;3 IEC-Atn Out&Int i/o     0     1      Int1           
                       ;2 IEC-RstIn        i      0     1      Int0
                       ;1 AVR-SPI-DtaOut   o      0     0      via resistors to SD-card-DtaIn
                       ;0 AVR-SPI-DtaIn    i      0     0      via resistors from SD-card-DtaOut
     
                       ;look when SD-card goes to sleep-mode: SD-DtaIn = 0V or 3.3V?????????
                       ;SPI- and I2C-pins have +3.3V only
        lds r23,airtse ;seconds
        bst r16,1      ;copies bit of seconds that changes every time to T-flag
        brtc l24000    ;b.i.                                 LED-RTC-on=

        ldi r24,0b00000000 ;DdrD =                           LED-RTC-off=
        ldi r25,0b11111100 ;PrtD

l24000: out DdrD,r06
        out PrtD,r25   ;PrtD
        out DdrD,r24   ;DdrD 
        sei            ;-------------------------------------------------PortD-------------        

                       ;  NH-SDonly:    inactive      active       0V         3.3V
                       ;               Ddr Prt     Ddr Prt     Ddr Prt     Ddr Prt
                       ;AVR-DtaOut d1   0   0  0V               1   0  0V   1   1  0V 
                       ;AVR-ClkOut b0   0   0  0V               1   0  3V   1   1  3V
                       ;AVR-CS-Out d4   0   0  3V   1   0  0V  

/*                     :-------------------------------------------------------------------------
                       ;test whetherbthe hardware-outputs to SD-card is correctly soldered   
        call l12990    ;make all lines of IEC-bus inactive

l24010: in r16,pinb    ;iec-bus
        bst r16,3      ;copies AtnIn-bit to T-flag               
        brts l24020    ;b.i.AtnIn=inactive

                       ;= AtnIn=active (0V)
        sbi ddspcs,bispcs
        cbi pospcs,bispcs
        rjmp l24030
            
l24020:                ;= AtnIn=inactive (5V)  
        cbi ddspcs,bispcs
        cbi pospcs,bispcs

l24030: bst r16,7      ;copies ClkIn-bit to T-flag               
        brts l24040    ;b.i.ClkIn=inactive

                       ;= ClkIn=active (0V)
        sbi ddspcl,bispcl
        cbi pospcl,bispcl
        rjmp l24050
            
l24040:                ;= ClkIn=inactive (5V)  
        sbi ddspcl,bispcl
        sbi pospcl,bispcl

l24050: bst r16,5      ;copies DtaIn-bit to T-flag               
        brts l24060    ;b.i.DtaIn=inactive

                       ;= DtaIn=active (0V)
        sbi DdrD,bispdo
        cbi pospdo,bispdo
        rjmp l24070
            
l24060:                ;= DtaIn=inactive (5V)  
        sbi DdrD,bispdo
        sbi pospdo,bispdo

l24070: rjmp l24010
*/                     ;-------------------------------------------------------------------------
       #endif ;644-NLQ-HD/SD

       #if partname == 7
        #message 644-NLQ-HD/full
        ldi r24,0b01011001 ;DdrB-----------------------------------------PrtB-644-NLQ-HD/full----
        ldi r25,0b11101111 ;PrtB
                       ;                      DdrB  PrtB 
                       ;7 IEC-Clk In        i  0     1     SCK  
                       ;6 IEC-Srq Out       o  1     1  p  MISO (AVR is slave while flashing)
                       ;5 IEC-Dta In        i  0     1     MOSI   
                       ;4 IEC-Dta Out       o  1     0  a  
                       ;3 IEC-Clk Out       o  1     1  p
                       ;2 IEC-Atn In        i  0     1     pinB2 makes Int2
                       ;1 IEC-Srq In        i  0     1     and debug switch
                       ;0 ATA-DIOR          o  1     1 
                       ;0 SPI-Clk           o              via 74LS07 to change to 3.3V
 
      
                       ;SPI-pins have +3.3V only
                       ;NEVER pull active to +5V
                       ;NEVER activate internal pullup-resistor
                       ;SPI-pins have external 3.3V-pullup-restors
                       
                       ;still change: make output to active +5V (instead of pullups-on only)
                       ;74LS07 would make sharper edges
        out PrtB,r06  ;PrtB = all 0 to prevent that AVR pulls 20mA to 5V 
        out DdrB,r24   ;DDRB = serial IEC-port settings  
        out PrtB,r25  ;PrtB
 
        ldi r24,0b00111110 ;DdrD----------------------------------------PrtD-644-NLQ-HD/full----
        ldi r25,0b00111110 ;PrtD
                       ;                       DdrD PrtD
                       ;7 I2C-Dta        i/o     0     0   p (3.3V-pullupresistor (not 5V))
                       ;6 I2C-Clk        i/o     0     0   p (3.3V-pullupresistor (not 5V))
                       ;5 ATA-DA2         o      1     1        
                       ;4 ATA-DA1         o      1     1
                       ;3 ATA-DA0         o      1     1 
                       ;2 ATA-DioW        o      1     1                       
                       ;1 AVR-SPI-DtaOut  o      1     1   a  via 74LS07 to SD-card-DtaIn
                       ;0 AVR-SPI-DtaIn   i      0     0      via 74LS244 from SD-card-DtaOut
     
                       ;SPI- and I2C-pins have +3.3V only
                       ;NEVER pull active to +5V
                       ;NEVER activate internal pullup-resistor
                       ;SPI- and I2C-pins have external 3.3V-pullup-resistors
                       ;activity of SPI- and I2C-lines is made by Ddr, not by Port.
                       ;=> SPI- and I2C-ports must be allways %0
        out PrtD,r06
        out DdrD,r24   ;DdrD = input
        out PrtD,r25   ;PrtD -------------------------------------------------PrtD-------------        
  
        out DdrA,r06   ;DdrA to input (#00)------------------------------------PrtA------------- 
        out PrtA,r07   ;PrtA = PullUpOn (to prevent swinging???)  Port=inactiv
                       ;=dataport d0-d7----------------------------------------PrtA-------------
  
        out DdrC,r06   ;DdrC---------------------------------------------------PrtC-------------
        out PrtC,r07   ;PrtC
                       ;=Ddataport  d8-15---------------------------------------PrtC-------------
 
        ldi r20,0b11111100 ;active-LED on  error-LED on  AtnOut=inactive...    
        rcall l23790   ;send r20 to I2C-parallel-port
                       ; (and don't write debugbytes because vector of the debugbuffer isn't set)
       #endif ;644-NLQ-HD/full

                       ;it would be better to make first the IDE-port-pins to inactive and
                       ;pullups on. When there is a HD connected but the power supply is switched
                       ;off then the AVR makes probably more than 20mA per pin to the HD???
                       ;making theis IDE-port to inactive would be also good to connect
                       ;additionally a USB<->IDE adapter to the IDE-cable (while the AVR stays
                       ;also connected) to run Scandisk and Defrag                       
                       ;PrtB = IEC-Port: 
                       ;  Inputs: DDR=0=input Port=1=PullUpOn
                       
                       ;  Outputs:           inactive               active
                       ;  Outputs: Port=0   DDR=0=Input&PullUpOff  DDR=1=Output&pulls to 0V
;------------------------------------------------------------------------------------------------
        
       #if partname == 1
        #message 162-IEC-ATA-V2    
        ldi r24,$82
        out Mcucr,r24  ;exmem on = switch external memory on
       #endif ;162-IEC-ATA-V2

       #if (partname == 1) | (partname == 3) ;---------
        #message 162-IEC-ATA-V2 SD2IEC   
                       ;r23,r24,r25,r26,r27 are changed at debugsending
                       ;problem: there is no debug-switch at the original IEC2ATA-V2-hardware
                       ; but also at the original SD2IEC-hardware
                       ;there is no reset-switch at the original SD2IEC-hardware 
                       ;most users cannot solder it
                       ;there must be a different solution that NLQ-HD sends the
                       ; debugbytes at a reset
                       ;-type poke56576,63, close jumper r, remove jumper r
                       ;open99,8,15:print#15,"ui":poke56576,63 <return> 
                       ; it takes about 10ms = 10000µs = 800000AVR-cycles until the C64 makes
                       ; the serial port to active after end of UI-command
        ldi r23,$01
        rcall l23870  ;0.1s delay (>0.01s would be enough) 

        ldi r25,$00

l24080: sbic piiema,biclin ;2  s.i.C64 makes Clk=active      pin IEC-main in, bit clock in

        rjmp l24140    ;       C64 doesn't make Clk = active  => no debugsending

        sbic piatin,biatin ;2  s.i.C64 makes Atn=active      pin attention in, bit attention in

        rjmp l24140    ;       C64 doesn't make Atn = active  => no debugsending

        dec r23        ;    1
        brne l24080    ;    2  7cycles*256=1792cycles=224µs

        dec r24
        brne l24080    ;       224µs*256=57344µs = 57.344ms

        dec r25
        brne l24080    ;       57.344ms * 256 = 14680ms = 14.7s      

                       ;=C64 makes Atn and Clk 14.7s active
                       ;  = software-flag to NLQ-HD to send debugbytes
        call l12840    ;          DataOut = inactive (=> C64 can load from 1541
                       ;                                 e.g.'debugtransfer')

    
l24090: call l10750    ;error-LED on
        call l10720    ;delay                            (error) LED blink
        call l10720    ;delay       
        call l10770    ;error-LED off
        call l10720    ;delay        

        ldi r23,$80    ;C64 must send flag that AVR can start sending the debugbytes
                       ; = 128 * toggle of Dta-line while Clk-line is inactive
l24100: ldi r24,$17

l24110: dec r24        ;    1    
        breq l24090    ;    1

        sbis piiema,biclin ;2 b.i. ClkIn=inactive

        rjmp l24090    ;      =C64 or floppy makes  Clk active

        sbic piiema,bidain ;1  pin DtaIn, bit DtaIn
      
        rjmp l24110    ;    2  = DtaIn=inactive        

        ldi r24,$17    ;       = DtaIn=active

l24120: dec r24        ;    1    
        breq l24090    ;    1

        sbis piiema,biclin ;2 b.i. ClkIn=inactive

        rjmp l24090    ;      =C64 or floppy makes  Clk active

        sbis piiema,bidain ;1  pin DtaIn, bit DtaIn
      
        rjmp l24120    ;    2  23 * 7cycles = 160cycles = 20µs         
       
        dec r23
        brne l24100
  
                       ;= C64 changed 128 times Dta-line within of 10µs
l24130: call l12880    ;make ClkOut=active 
        ldi r25,$0a
        call l10840    ;r25*10µs waiting loop
        call l12910    ;make ClkOut=inactive 

        call l10720    ;0.65s delayloop for errorblinking
        rjmp l24200    ;starts sending of debugbytes
    
       #endif ;162-IEC-ATA-V2  SD2IEC---------

l24140: 
       #if partname == 7    
        #message 644-NLQ-HD/full
        in r21,Sreg    ;backup status register (important for T-flag)        
        rcall l23820   ;read I2C-parallel-port to r20  (changes r20, r25, T-flag)
        out Sreg,r21   ;restore status register (important for T-flag) 
        andi r20,$04   ;masks debug-switch 
        brne l24250    ;b.i.debug-jumper=off  = no debug-buffer-sending
        
        call l12840    ;          DataOut = inactive (=> C64 can load from 1541
                       ;                                 e.g.'debugtransfer')
l24150: ldi r24,$00                

l24160: rcall l23820   ;read I2C-parallel-port to r20  (changes r20, r25, T-flag)
        andi r20,$04   ;masks debug-switch 
        breq l24150    ;b.i.debug-jumper=on (when switch swings)                             

        dec r24
        brne l24160    ;waits until debug jumper doesn't swing     not necessary???  
       #endif 

       #if partname == 6
        #message 644-NLQ-HD/SD
        cli
        in r25,ddlert ;backups
        in r24,polert ;backups
        cbi ddlert,bilert ;input
        sbi polert,bilert ; pullupon
        rcall l23910   ;10µs waiting loop    
        in r23,pidesw
        out polert,r24 ;restores
        out ddlert,r25 ;restores
        sei
        andi r23,1<<bidesw
        brne l24250   ;b.i.debugswitch is open
       
        call l12840    ;          DataOut = inactive (=> C64 can load from 1541
                       ;                                 e.g.'debugtransfer')
        cli
        cbi ddlert,bilert ;input          the LED-RTC is at the debugswitch-pin
        sbi polert,bilert ; pullupon      => LED-RTC cannot blink while debugswitch is closed 
        
        sei
        rcall l23910   ;10µs waiting loop    

l24170: in r23,pidesw
        andi r23,1<<bidesw
        breq l24170   ;b.i.debugswitch is closed
                      ;=waits until debugswitch switches open
       #endif

       #if (partname == 1) | (partname == 3) | (partname == 4) | (partname == 5)
        sbic pidesw,bidesw ;b.i.debugswitch is on
                           ;IEC-ATA: PE2
                           ;sd2iec:  PC2
                           ;NH-lite: PD0  
                           ;NH-full: PCF8574

        rjmp l24250    ;=debug-jumper=off  = no debug-buffer-sending
                
        call l12840    ;          DataOut = inactive (=> C64 can load from 1541
                       ;                                 e.g.'debugtransfer')
l24180: ldi r24,$00    ;                 changes r23-r27

       #if partname == 3
        #message 644-NLQ-HD/SD2IEC
        call l10780   
        call l10720    ;active LED blink
        call l10800
        call l10720  
       #endif

l24190: sbis pidesw,bidesw ;b.i.debugswitch gets off-switched
                           ;162: PinE,Bit0
                           ;644: PinB,Bit1
        rjmp l24180    ;debug-jumper is close (when switch swings) 
        dec r24
        brne l24190    ;waits until debug jumper doesn't swing    not necessary??? 
       #endif         

l24200: ldi r26,$00
        ldi r27,$00    ;Xhigh=0  X=0000 
        
l24210: ld r23,x+        

        ldi r24,$04    ;counter for doublebits per byte

l24220: call l12840    ;DataOut=inactive (5V)
        lsl r23
        brcs l24230    ;b.i.high-bit
        call l12870    ;DataOut=active (0V)
 
l24230: rcall l23910    ;10us waitingloop
        
        call l12880    ;clockOut=active (at NLQ-HD/lite: changes r25)
         
        rcall l23910
        rcall l23910

        call l12840    ;DataOut=inactive (5V)
        lsl r23
        brcs l24240    ;b.i.high-bit
        call l12870    ;DataOut=active (0V)
 
l24240: rcall l23910    ;10us waitingloop
        
        call l12910    ;clockOut=inactive
         
        rcall l23910
        rcall l23910
        rcall l23910
        rcall l23910
        rcall l23910
        rcall l23910
        rcall l23910
        
        dec r24
        brne l24220
     
        cpi r27,$11
        brne l24210    ;copies to 10ff (at end: T-flag shouldn't be changed?)

                       ;--------------------------------------------------------end debug sending   

l24250: 
      #if partname == 1     
        #message 162-IEC-ATA-V2
        ldi r25,0b00000100
        out DdrE,r25   ;DdrE PinE2=output  =  OC1B  (LED on)           
                       ;                      DdrE PrtE             
                       ;2 Single-LED           1     0     active => single-LED=on            
                       ;1 ALE                  0     1
                       ;0 IEC-SRQ In           0     1
       #endif          ;end mega162-162-IEC-ATA-V2

                       ;hardware-reset:
                       ; at IEC-ATA: HD-reset is connected to IEC-reset
                       ;             => HD makes also reset
                       ;             => AVR must wait until HD is accessable after reset
                       ; at SD2IEC: there is no hardware-reset via IEC-reset-line
                       ; at NLQ-HD: don't make HD-reset, don't wait for HD (=faster)
                       
                       ;software-reset and dsdati RAM and FLASH matches (UI- / UJ-command)
                       ;            don't make HD-reset, don't wait for HD (=faster)

                       ;software-reset and dsdati RAM and FLASH doesn't match (AUJ-command)
                       ;             make HD-reset, wait for HD

       #if partname == 1    
        #message 162-IEC-ATA-V2
                       ;hardware-reset from IEC-bus: AVR and HD make reset
                       ;hardware-reset from reset-switch: AVR makes reset and HD makes probably 
                       ;                                   also reset
                       ;:AVR must wait until HD is accessable

        brts l24260    ;b.i.hardware-reset
        
                       ;=software-reset
                       ;r16=#$01 UI UJ  = actual dir stays
                       ;r16=#$02 AUI    = actual dir = rootdir
                       ;r16=#$03 AUJ not at IEC-ATA
        cpi r16,$02
        brcs l24320    ;b.i.#$01 = UI / UJ 

        breq l24300    ;b.i.#$02 = AUI

                       ;=hardware-reset
l24260: ldi r28,low(dsdati) ;dataspace date time  $10c0         test if first reset 
        ldi r29,high(dsdati) 

        ldi r30,low(txdati<<1) ;text date time               
        ldi r31,high(txdati<<1)       

                       ;T=set = default for RAM fits to FLASH

l24270: lpm r16,z+     ;read from flashram
        ld r17,y       ;read from RAM
        st y+,r16      ;write to RAM
        cp r16,r17
        breq l24280    ;b.i.correct text in memory = AVR isn't switched on 

        clt            ;flag that difference from RAM to FLASH (=first reset)

l24280: cpi r28,low(dsdati+$10)     
        brne l24270

        brts l24310    ;b.i.not first reset

l24290: st y+,r06      ;clears at-reset-not-cleared-RAM
        cpi r28,low(dsdati+$50)     
        brne l24290

l24300: ldi r16,$02
        sts cbadd0,r16 ;clusterbegin actual directory drive0  
        sts cbadd0+1,r06 
        sts cbadd0+2,r06 ;makes actual dir to rootdir 
        sts cbadd0+3,r06 

l24310: ldi r28,$04
        ldi r29,$00
        call l13770    ;EEPROM reads 0004 of table0 0001-0015
                       ;delay in tenth seconds    0.0-25 seconds possible 
        mov r23,r20
        cpi r23,$ff
        breq l24320    ;b.i.empty EEPROM

        rcall l23870   ;r23*0.1s delay = delay until HD finished its reset

l24320:
       #endif

       #if partname == 3    
        #message 644-NLQ-HD/SD2IEC
                       ;hardware-reset: AVR makes reset

        lds r18,sdfldc 
        ori r18,$01    ;default for initialize SD and preserve actual-dir-cluster              
        brts l24330    ;b.i.hardware-reset
        
                       ;=software-reset
                       ;r16=#$01 UI UJ  = actual dir stays
                       ;r16=#$02 AUI    = actual dir = rootdir
                       ;r16=#$03 AUJ    = actual dir = rootdir
        cpi r16,$02
        brcs l24380    ;b.i.#$01 = UI / UJ 

        breq l24370    ;b.i.#$02 = AUI

                       ;=hardware-reset
l24330: ldi r28,low(dsdati) ;dataspace date time  $10c0         test if first reset 
        ldi r29,high(dsdati) 

        ldi r30,low(txdati<<1) ;text date time               
        ldi r31,high(txdati<<1)       

                       ;T=set = default for RAM fits to FLASH

l24340: lpm r16,z+     ;read from flashram
        ld r17,y       ;read from RAM
        st y+,r16      ;write to RAM
        cp r16,r17
        breq l24350    ;b.i.correct text in memory = AVR isn't switched on 

        clt            ;flag that difference from RAM to FLASH (=first reset)

l24350: cpi r28,low(dsdati+$10)     
        brne l24340

        brts l24380    ;b.i.not first reset

l24360: st y+,r06      ;clears at-reset-not-cleared-RAM
        cpi r28,low(dsdati+$50)     
        brne l24360

l24370: ldi r18,$03    ;initialize SD and reset actual-dir-cluster 

l24380: sts sdfldc,r18 ;SD flag disk change   set flag that SD is changed
                       ; => actual dir is resetted at next initialize
l24390:
       #endif

       #if partname == 4  
         #message 644-NLQ-HD/lite
                       ;hardware-reset from IEC-bus: AVR and HD make reset
                       ;hardware-reset from reset-switch: AVR makes reset and HD makes probably 
                       ;                                   also reset
                       ;:AVR must wait until HD is accessable

        brts l24410    ;b.i.hardware-reset
        
                       ;=software-reset
                       ;r16=#$01 UI UJ  = actual dir stays
                       ;r16=#$02 AUI    = actual dir = rootdir of actual emulation-entry
                       ;r16=#$03 AUJ    = actual dir = rootdir of all emulation entries
                       ;                  & HD-hardware-reset
        cpi r16,$02
        brcs l24470    ;b.i.#$01 = UI / UJ 

        breq l24450    ;b.i.#$02 = AUI

                       ;=AUJ 
        cbi prtD,0     ;PD0=HD-reset 0V
        sbi DdrD,0     ;PD0=output
        ldi r16,$00    ;$0100=256
l24400: dec r16        ;1
        brne l24400    ;2  3*256=768    768/8= 96µs  =96µs-reset=active

        cbi DdrD,0     ;PD0=input (important because debugswitch is here)
        sbi prtD,0     ;PD0=pullupon  

                       ;T-flag=clear = flag that this is the first hardware-reset  
                       ;................................................
                       ;=hardware-reset
l24410: ldi r28,low(dsdati) ;dataspace date time  $10c0         test if first reset 
        ldi r29,high(dsdati) 

        ldi r30,low(txdati<<1) ;text date time               
        ldi r31,high(txdati<<1)       

                       ;hardware-reset: T=set = default for RAM fits to FLASH

l24420: lpm r16,z+     ;read from flashram
        ld r17,y       ;read from RAM
        st y+,r16      ;write to RAM
        cp r16,r17
        breq l24430    ;b.i.correct text in memory = AVR isn't switched on 

        clt            ;flag that difference from RAM to FLASH (=first reset)

l24430: cpi r28,low(dsdati+$10)     
        brne l24420

        brts l24470    ;b.i.not first reset

l24440: st y+,r06      ;clears at-reset-not-cleared-RAM
        cpi r28,low(dsdati+$50)     
        brne l24440

l24450: ldi r16,$02
        sts cbadd0,r16 ;clusterbegin actual directory drive0  
        sts cbadd0+1,r06 
        sts cbadd0+2,r06 ;makes actual dir to rootdir 
        sts cbadd0+3,r06 

l24460: ldi r28,$04
        ldi r29,$00
        call l13770    ;EEPROM reads 0004 of table0 0001-0015
                       ;delay in tenth seconds    0.0-25 seconds possible 
        mov r23,r20
        cpi r23,$ff
        breq l24470    ;b.i.empty EEPROM

        rcall l23870   ;r23*0.1s delay = delay until HD finished its reset

l24470:
                       ;the waitingloop is made at the end, because the IEC-reset-line is 
                       ; coonneted directly to the HD-reset-line
                       ;=> even at not-first hardware resetes the HD makes a reset
                       ;   and the AVR must wait
       #endif
    
      #if partname == 6    
        #message 644-NLQ-HD/SD
                       ;hardware-reset: AVR makes reset

        lds r18,sdfldc 
        ori r18,$01    ;default for initialize SD and preserve actual-dir-cluster              
        brts l24480    ;b.i.hardware-reset
        
                       ;=software-reset
                       ;r16=#$01 UI UJ  = actual dir stays
                       ;r16=#$02 AUI    = actual dir = rootdir
                       ;r16=#$03 AUJ    = actual dir = rootdir
        cpi r16,$02
        brcs l24540    ;b.i.#$01 = UI / UJ 

        breq l24530    ;b.i.#$02 = AUI

                       ;=hardware-reset
l24480: ldi r28,low(dsdati) ;dataspace date time  $10c0         test if first reset 
        ldi r29,high(dsdati) 

        ldi r30,low(txdati<<1) ;text date time               
        ldi r31,high(txdati<<1)       

                       ;T=set = default for RAM fits to FLASH

l24490: lpm r16,z+     ;read from flashram
        ld r17,y       ;read from RAM
        st y+,r16      ;write to RAM
        cp r16,r17
        breq l24500    ;b.i.correct text in memory = AVR isn't switched on 

        clt            ;flag that difference from RAM to FLASH (=first reset)

l24500: cpi r28,low(dsdati+$10)     
        brne l24490

        brts l24540    ;b.i.not first reset

l24510: st y+,r06      ;clears at-reset-not-cleared-RAM
        cpi r28,low(airthu) ;AVR-internal-RTC-hundredth
        brne l24520

        ldi r28,low(airthu+$10) ;AVR-internal-RTC-buffer end

l24520: cpi r28,low(dsdati+$50)     
        brne l24510

l24530: ldi r18,$03    ;initialize SD and reset actual-dir-cluster 

l24540: sts sdfldc,r18 ;SD flag disk change   set flag that SD is changed
                       ; => actual dir is resetted at next initialize
l24550:
       #endif

       #if partname == 7
        #message 644-NLQ-HD/full
                       ;hardware-reset: AVR makes reset, HD makes no reset

                       ;same SD          new SD      <---before reset
        lds r18,sdfldc ;#$00    / #$01 / #$03
        ori r18,$01    ;#$01    / #$01 / #$03
                       ;default for initialize SD and preserve actual-dir-cluster              
                       ;r19 can be used for CD
        lds r21,acemen ;actual emulation entry (#$00 / #$02)
 
        brts l24590    ;b.i.hardware-reset
        
                       ;=software-reset
                       ;r16=#$01 UI UJ  = actual dir stays   reset of actual drive only? 
                       ;r16=#$02 AUI    = actual dir = rootdir of all emulation-entries
                       ;r16=#$03 AUJ    = actual dir = rootdir of all emulation entries
                       ;                  & HD-hardware-reset
        cpi r16,$02
        brcc l24560    ;b.i.not #$01

                       ;=#$01 = UI / UJ r18=#$01  r21=#$00/02
                       ;don't change actual dir of HD
                       ;flag for initialize SD but don't change actual dir of SD
                       ;active DEB is in RAM
        cpi r21,$00
        breq l24670    ;b.i.HD => sdfldc stays unchanged

        rjmp l24660    ;=SD => #$01->sdfldc

l24560: breq l24640    ;b.i.#$02 = AUI

                       ;= #$03 = AUJ 
                       ;---------------------------------------------------------------------(1)-
/*
                       ;this is the routine when ata-reset is connected via a transistor to AREF
                       ; the 47kOhm resistors make that the current is 0.1mA
        ;ldi r16,$80    ;%10000000 Bit7=1 switch ADC on
        ;sts adcsra,r16 ;ADC Control and Status Register A

        ldi r16,$40    ;%01000000 Bit7,6=%01 = pin32 (AREF) connected to pin30 (AVCC +5V)
        sts admux,r16  ;AnalogDigitalConverter multiplexer selection 
                       ;=> AREF goes to +5V -> via an 47kOhm-resistor is a current of 0.1mA
                       ; to base of BC547(NPN) -> BC547 pulls input of 74LS244 to low
                       ; -> reset of ata-HD 
        ldi r16,$00    ;$0100=256
l24570: dec r16        ;1
        brne l24570    ;2  3*256=768    768/8= 96µs  =96µs-reset=active
                       ; (25µs are necessary, but transistor is a low speed type)       

        sts admux,r06  ;#$00 AREF (pin32) =connects pin32 (aref) to 0V = HD-Reset=inactive         
        ;sts adcsra,r06 ;#$00 switch ADC off
*/
                       ;this is the routine when ata-reset is connected to a pin of the
                       ; I2C-portexpander-chip (pin3)
        ldi r20,0b11110100 ;ata-reset-active  active-LED on  error-LED on  AtnOut=inactive...    
        rcall l23780   ;send r20 to I2C-parallel-port

        ldi r16,$00    ;$0100=256
l24580: dec r16        ;1
        brne l24580    ;2  3*256=768    768/8= 96µs  =96µs-reset=active
                       ; (25µs are necessary)
        ldi r20,0b11111100 ;ata-reset-inactive  active-LED on  error-LED on  AtnOut=inactive    
        rcall l23780   ;send r20 to I2C-parallel-port----------------------------------------(1)-
        clt            ;necessary???? 

                       ;T-flag=clear = flag that this is the first hardware-reset  

                       ;................................................
                       ;=hardware-reset
l24590: ldi r28,low(dsdati) ;dataspace date time  $10c0         test if first reset----------(2)- 
        ldi r29,high(dsdati) 

        ldi r30,low(txdati<<1) ;text date time      hardware: T=high               
        ldi r31,high(txdati<<1) ;                   AUJ-soft: T=low       

                       ;hardware-reset: T=set = default for RAM fits to FLASH

l24600: lpm r16,z+     ;read from flashram
        ld r17,y       ;read from RAM
        st y+,r16      ;write to RAM
        cp r16,r17
        breq l24610    ;b.i.correct text in memory = AVR isn't switched on 

        clt            ;flag that difference from RAM to FLASH (=first reset)

l24610: cpi r28,low(dsdati+$10)     
        brne l24600    ;---------------------------------------------------------------------(2)-

        brts l24650    ;b.i.not first reset r18=#$01 if SD hasn't been changed before reset
                       ;                   (r18=#$03 if SD has been changed before reset)

l24620: st y+,r06      ;=first hardwarereset  AUJ-softwarereset      
        cpi r28,low(dsdati+$50) ;clears at-reset-not-cleared-RAM
        brne l24620

l24630: ldi r28,$04    ;---------------------------------------------------------------------(3)-
        ldi r29,$00
        call l13770    ;EEPROM reads 0004 of table0 0001-0015
                       ;delay in tenth seconds    0.0-25 seconds possible 
        mov r23,r20
        cpi r23,$ff
        breq l24640    ;b.i.empty EEPROM

        rcall l23870   ;r23*0.1s delay = delay until HD finished its reset
                       ;(=waiting loop until HD finished reset)------------------------------(3)-   

l24640: ldi r16,$02    ;=HD (#$00)-----------------------------------------------------------(4)-
        sts cbadd0,r16 ;clusterbegin actual directory drive0  
        sts cbadd0+1,r06 ;                                     reset actual dir of HD
        sts cbadd0+2,r06 ;makes actual dir to rootdir 
        sts cbadd0+3,r06 ;-------------------------------------------------------------------(4)-

        ldi r18,$03    ;flag for                               reset actual dir of SD
 
l24650: ldi r21,$ff    ;flag for clear all DEBs 

l24660:   
                       ;=CD (#$01)

                       ;=SD (#$02)                               
        sts sdfldc,r18 ;SD flag disk change   set flag that SD is changed
                       ; => actual DEB (and perhaps actual dir) is resetted at next initialize

l24670: 
;*/
        lds r18,sdfldc
        sts $10fd,r18  ;sdfldc        
        sts $10fe,r21  ;acemen (00/02) or #$ff
        sts $10ff,r06  ;#$00  if r21=#02=SD then l24860 and l26160 is overjumped) 
        .db 0
;*/

        tst r21
        brmi l24680    ;b.i.clear all DEBs

        lds r16,acenfb ;actual emulation(entry)number (of sector) in FAT buffer
        cp r16,r21
        brne l24690    ;b.i. e.g. the HD is resetted, but a SD-sector is in the buffer

l24680: sts acsefb+3,r07 ;#$ff makes actual sector in FAT-buffer illegal

l24690: mov r00,r21    ;use r00 (r21 is cleared at clear RAM (r21 = position $0015 of clear))
        cpi r21, $02
        brne l24700    ;b.i.not UI-software-reset to SD
        
        rjmp l25250    ;= UI-software-reset to SD
                       ; actual DEB of SD is in RAM
                       ;clear DEB of SD only

l24700:                ;r00 must be unchanged until l24860

                       ;   software   software   software   software   hardware   hardware
                       ;   UI/UJ HD   UI/UJ SD     AUI        AUJ      first      not-first
                       ;   r18  r21   r18  r21   r18  r21   r18  r21   r18  r21   r18  r21 
                       ;   #00  #00   #01  #02   #03  #ff   #03  #ff   #03  #ff   #01  #ff
                      
                       ;   don't      don't                                       don't 
                       ;   change     change     ------reset-actual-dirs------    change
                       ;   actual     actual                                      actual
                       ;   dirs       dirs                                        dir
                       
                       ;   clear      clear
                       ;   HD-DEB     SD-DEB     --------------clear all DEBs------------
                      

                       ;action             first reset                   not-first resets
                       
                       ;UI-/UJ-software         -                   clear DEB of HD (4) or SD (5)
                       ;                                            (not of both) 
                       ;                                            (preserve actual dirs (both))
                       ;                                             r18=#$01  r21=#$00/02
                       
                       ;AUI-software            -                   (4) clear DEB of HD 
                       ;                                            (5) clear DEB of SD 
                       ;                                            (6) reset actual dir of HD
                       ;                                            (7) reset actual dir of SD
                       ;                                                 (both dirs)
                       ;                                             r18=#$03  r21=#$ff
                     
                       ;AUJ-software            -                   (1) HD-hardware-reset
                       ;                                            (3) wait until HD is ready
                       ;                                            (4) clear DEB of HD 
                       ;                                            (5) clear DEB of SD 
                       ;                                            (6) reset actual dir of HD
                       ;                                            (7) reset actual dir of SD
                       ;                                                 (both dirs)
                       ;                                             r18=#$03  r21=#$ff
                     
                       ;hardware reset (2) compare RAM and FLASH    (2) compare RAM and FLASH
                       ;                   if equal:                    if not equal:
                       ;               (3) wait until HD is ready   (4) clear DEB of HD
                       ;               (4) clear DEB of HD          (5) clear DEB of SD    
                       ;               (5) clear DEB of SD 
                       ;               (6) reset actual dir of HD   (preserve actual dirs (both))
                       ;               (7) reset actual dir of SD
                       ;                    (both dirs)
                       ;               r18=#$03  r21=#$ff            r18=#$01  r21=#$ff 
     
                       ;DEB=device emulation buffer                  
                        
                       ;problem: HD is initialized at once here at reset
                       ;         SD is initialized later (at firts access (open / command))

                            ;e.g.: when UI-/UJ-software-reset to HD:
                            ;in the FAT-buffer ther can be the FAT of the SD (not the HD)
                            ;this FAT can contain datas which must perhaps be rwritten to SD
                            ;=> FAT-buffer and values of FAT-buffer mustn't be cleared

       #endif          ;of l24570

;        call l10800    ;active LED off (temporary!!!!!)

l24710: ldi r26,$01    ; ----------clears registers and I/O----------
        ldi r27,$00    ;x=0001 (don't clear r00   important at l24670, l24860)
        ldi r25,$00

       #if partname == 1    
        #message 162-IEC-ATA-V2
l24720: st x+,r25      ;clears $00-$18 $1c-$23 $28-$2f $3c-$5c $60-$ff   
        
        cpi r26,$19
        brne l24730    ; not $19-$1b = r25-r27 
        ldi r26,$1c

l24730: cpi r26,$24
        brne l24740    ; not $24-$27 = I/O-$04-$07 = calibration-byte & PrtE 
        ldi r26,$28

l24740: cpi r26,$30
        brne l24750    ; not $30-$3b = I/O-$10-$1b = PrtD - PrtA
        ldi r26,$3c 

l24750: cpi r26,$5d
        brne l24760    ; not $5d-$5f = I/O-$3d-$3f = stack & statusregister
        ldi r26,$60

l24760: cpi r26,$00
        brne l24720
       #endif

       #if ((partname >= 3) & (partname <= 7))
         #message 644-NLQ-HD/644-all
     
       #if partname == 6    
        #message 644-NLQ-HD/SD
        cli            ;disable IRQs (because of r07)
       #endif

l24770: st x+,r25      ;clears $00-$18 $1c-$1f $2c-$5c $60-$65 $67-$ff   
        
        cpi r26,$19
        brne l24780    ; not $19-$1b = r25-r27 
        ldi r26,$1c

l24780: cpi r26,$20
        brne l24790    ; not $20-$2b = I/O-$00-$0b = PrtA - PrtD 
        ldi r26,$2c

l24790: cpi r26,$5d
        brne l24800    ; not $5d-$5f = I/O-$3d-$3f = stack & statusregister
        ldi r26,$60 

l24800: cpi r26,$66
        brne l24810    ; not $66     = calibration-byte
        ldi r26,$67

l24810: 
       #if partname == 6    
        #message 644-NLQ-HD/SD
        cpi r26,$70
        brne l24820    ; not $70 = timsk2 (IRQ of RTC-timer2) 
        ldi r26,$71

l24820: cpi r26,$b0
        brne l24830    ; not $b0-$b6 = timer2-values
        ldi r26,$b7 
                       ;not-clearing of $37 TIFR2 probably not necessary
                       ;The Output Compare Flag is automatically cleared when the interrupt is
                       ;executed. Alternatively, the Output Compare Flag can be cleared by
                       ;software by writing a logical one to its I/O bit location.

                       ;still test whether a IRQ is generated when a #$00 is written into TIFR2
l24830:         
       #endif

        cpi r26,$00
        brne l24770
       #endif                  
                       ;                  M162      M32       M644
                       ;r25-r27         $19-$1b   $19-$1b   $19-$1b
                       ;PrtA-PrtD       $3b-$30   $3b-$30   $20-$2b
                       ;PrtE            $25-$27      -         -
                       ;Calibrationbyte   $24       $51       $66
                       ;Stack           $5d,$5e   $5d,$5e   $5d,$5e
                       ;Statusregister    $5f       $5f       $5f

                       ;end clear 0000-00ff----------end  clear registers and I/O----------
                       ;r26,27 = $0100
        dec r07        ;r07 is cleared => #$00->#$ff

       #if partname == 6    
        #message 644-NLQ-HD/SD
        sei            ;enable IRQs
       #endif

       #if partname == 1       
        #message 162-IEC-ATA-V2 
        ldi r16,$82    ;mcucr is cleared at clearing RAM (clear mcucr is important at mega644)
        out Mcucr,r16  ;exmem on
       #endif ;162-IEC-ATA-V2

l24840: st x+,r25      ;clears 0100-10af 

       #if ((partname >= 3) & (partname <= 7))
         #message 644-NLQ-HD/644-all
         cpi r27,high(fabube) ;FAT-buffer-begin ($0400)
         brne l24850

         ldi r27,high(fabuen) ;FAT-buffer-end (+1) ($0600)
                       ;don't clear FAT-buffer
                       ;e.g.: when UI-/UJ-software-reset to HD:
                       ;in the FAT-buffer ther can be the FAT of the SD (not the HD)
                       ;this FAT can contain datas which must perhaps be rwritten to SD
                       ;=> FAT-buffer and values of FAT-buffer mustn't be cleared
l24850:
       #endif

        cpi r27,high(dsdati) ;external 32kB RAM from $0500-$84ff at M162
        brne l24840
        cpi r26,low(dsdati) ;dsdati  dataspace date time  = begin of not cleared RAM
        brne l24840    ;-------------------end clear RAM---------------------------------

        sts laprcb+3,r07 ;makes flag that there is no last program (for load"*")
        sts acsacb,r07 ;makes flag that there is nothing in actual SA in CBM-buffer (00-$11 0-17)
        sts seswfi+3,r07 ;makes that sector swapfile isn't set (important if there is an
                       ; error before the the Swapfile is searched and checked) 
        sts i2pova,r07 ;I2C-port-value (of 8bit port expander chip)
                       ; bits 2-0 are made later  important to set bits 7-3 here

        ldi r26,low(tasach+$12+$01) ;table secundaryaddress -> channel  022b,x
        ldi r27,high(tasach+$12+$01)
l24860: st -x,r07      ;#$ff clears tasach
        cpi r26,low(tasach) ;               make this also at every initialize?????
        brne l24860         
 
       #if partname == 6    
        #message 644-NLQ-HD/SD
        sts airtmb,r06 ;AVR-internal-RTC-mode-bits
        sts airtmr,r06 ;AVR-internal-RTC-mainroutine
        sts airtsl,r06 ;AVR-internal-RTC-stackpointer-low
       #endif

       #if partname == 7
        #message 644-NLQ-HD/full
        sts cm0086,r00 ;CBM-memory 0086 (temporary memory?)  set at l24650
                       ;not reached at UI/UJ to SD   only reached at UI/UJ to HD
                       ;at scratch: counter for deleted files
                       ;at reset: temp memory for actual device emulation
                       ; (mustn't be at DEB because of reset-routine)
                       ;pay attention that the routine which searches NLQ-SWAP.SYS in the dir
                       ; doesn't change cm0086     
       #endif
 
                       ;-------------------end initialice memory---------------------------------
        ;ldi r16,low(debube) ;$00 debugbufferbegin                 initialize debug-buffer-vector 
        ;mov r04,r16    ;X low ieee-debug buffer
        clr r04        ;shorter as long as debugbuffer begins at $xx00  

        sts amfrcl+3,r07 ;#$ff  important for l13260  temporary!!!!!!!!!!!!!!!!!!!!!!!!
                        ;           (freeze at debugbytes-writeing) 
        ;call l13090    ;===== 

        ;ldi r16,$e0    ;temporary for debugging of EEPROM routine
        ;mov r02,r16

        ;ldi r25,$90
        ;call l13090    ;90--

        ldi r16,$49    ;73,nlqhd (c) nowaranty ownrisk
        ldi r17,butrhi ;built track high
        ldi r18,buselo ;built sector low
        call l13900    ;copy 73,errormessage to buffer 
                       ;floker is cleared at clearing RAM => LED goes off in waitingloop

       #if partname == 6    
        #message 644-NLQ-HD/SD

        cli 
        ldi r31,$00    ;this routine reads the configurationbytes, set at flashing 
        ldi r17,0b00001001 ;sets blbset and spmem in spmcsr
                       ;at NLQHD-SD it's important that OCD, JTAG, watchdog and brownout is
                       ; disabled because they need to much power in sleep-mode

        ldi r30,$03
        out $37,r17    ;spmcsr
        lpm r16,z      ;fuse high
        andi r16,$d0   ;masks OCD-, JTAG- and watchdog-bit
        cpi r16,$d0
        brne l24870    ;b.i.OCD=on or JTAG=on or watchdog=always-on

        ldi r30,$02
        out $37,r17    ;spmcsr
        lpm r16,z      ;extended fuse
        andi r16,$07   ;mask brownout-bits
        cpi r16,$07
        breq l24880    ;b.i.brownout=disabled

l24870:
        ldi r16,$4e    ;78,system error r17=tracknumber=system-error-number
        ldi r17,$05    ;(05-- 05--)   
        call l13890    ;print errormessage into errorbuffer 
        call l10740    ;LED blink

l24880: sei
       #endif

       #if partname == 6    
        #message 644-NLQ-HD/SD








       #endif

       #if ((partname >= 3) & (partname <= 7))
         #message 644-NLQ-HD/644all
         rcall l23850  ;enables 100Hz-timer1 IRQs
                       ;!!! enables IRQs !!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                       ;important at sd2iec to see whether debugswitch is pressed 
         ;ldi r25,$91
         ;call l13090      ;91--
       #endif
                       ;-------------------------------------------------------------------------
                       ;                                         begin of reset-routine of EEPROM 
       #if partname >= 2    
        #message 644-non-IEC-ATA    
        ldi r23,$00    ;=counter for EEPROM errors
       #endif

l24890: ldi r16,$e0    ;default-value for r02 for debug-mode-byte
        ldi r28,$01
        ldi r29,$00    ;EEPROM-address = $0001-0015 = entry-table0

        ldi r30,low(raepbe) ;$00 ram for epromtest begin
        ldi r31,high(raepbe) ;$01  z RAM-vector = $0100
 
l24900: call l13770    ;EEPROM reads 0001-0015
        st z+,r20      ;RAM 0100-0114

        inc r28
        cpi r30,low(raepen) ;ram for epromtest end 
        brne l24900     

                       ;EEPROM-address = $0016 = entry-table1
   
l24910: ldi r30,low(raepbe) ;$00 ram for epromtest begin    z RAM-vector = $0100
    
l24920: call l13770    ;EEPROM read 0016-002a
        ld r21,z+      ;RAM 0100-0114
        cp r20,r21
        brne l24950    ;b.i.difference of EEPROM-table0 to table1

        inc r28        
        cpi r30,low(raepen) ;ram for epromtest end 
        brne l24920

                       ;after table1: EEPROM address = $002b
                       ;after table2: EEPROM address = $0040    
        cpi r28,$40
        brcs l24910    ;b.i.after table1 (-> make table2)---------

                       ;=no EEPROM-corruption
l24930: lds r02,raepbe+2 ;$0102  ;debug buffer mode   =no EEPROM-corruption or 
                       ;                                     repairable EEPROM-corruption
        ;sts $0182,r02  ;only for debugging

        cp r02,r07     ;#$ff                            repairable EEPROM-corruption
        brne l24940    ;b.i.not #$ff = not empty EEPROM
        
        mov r02,r16    ;#$e0 (=if empty EEPROM -> standard-debug-byte-saving) 

l24940: lds r20,raepbe+1 ;$0101  ;calibrationbyte from EEPROM
        ldi r30,$07    ;clears 0106-0100 (predecremented)
        rjmp l25130    ;=no EEPROM-corruption  --------------------------------------------------

l24950:                ;=EEPROM-corruption
       #if partname >= 2    
        #message 644-non-IEC-ATA    
        dec r23        ;counter for EEPROM errors
        brne l24970    ;b.i.1-255
l24960: rjmp l25120    ;=256 errors (important that no hanging-loop when defectiv EEPROM)

l24970: dec r30        ;restores to old value from z+ (incremented)            =EEPROM-corruption  

        ;ldi r25,$10    ;10----
        ;call l13090

        ;mov r25,r30    ;----
        ;call l13090

        mov r28,r30    ;RAM-vector low 00-14   
        subi r28,$ea   ;               16-2a

        ;mov r25,r28    ;----
        ;call l13090

        call l13770   ;EEPROM read 0016-002a table1
        mov r21,r20

        ;mov r25,r21    ;----
        ;call l13090

        subi r28,$eb   ;               2b-3f

        ;mov r25,r28    ;----
        ;call l13090
    
        call l13770   ;EEPROM read 002b-003f table2 ->r21
     
        ;mov r25,r20    ;----
        ;call l13090

        ld  r22,z      ;RAM =EEPROM-0001-0015       

        ;mov r25,r22    ;----
        ;call l13090

        cpi r30,$00    
        breq l24980    ;b.i.entry-possition 00 b.i.auto-repair EEPROM-corruption
 
        rjmp l25090    ;=not autorepair-byte

l24980:                ;flag f.autorepair is $aa or $55, nothing else possible  
                       ;r20=$0140 r21=$00c0 r28=$0040 of EEPROM
      
        ;ldi r25,$11    ;11--
        ;call l13090
                         
        ldi r24,$00    ;=amount of allowed values (55 or aa)

        cpi r20,$aa
        breq l24990
        cpi r20,$55
        brne l25000
l24990: inc r24

l25000: cpi r21,$aa
        breq l25010
        cpi r21,$55
        brne l25020
l25010: inc r24

l25020: cpi r22,$aa
        breq l25030
        cpi r22,$55
        brne l25040
l25030: inc r24

l25040: ;sts $0120,r20
        ;sts $0121,r21
        ;sts $0122,r22
        ;sts $0123,r24
        ;sts $0124,r23
        
        cpi r24,$01
        brcs l24960    ;b.i.#$00, no tableposition00 entry is legal  

        brne l25050    ;b.i.not #$01, not only 1 entry is correct (2 or 3 correct entries) 

        cpi r20,$aa    ;=1 correct entry
        breq l25070    ;b.i.r20 is allowed
        cpi r20,$55
        breq l25070    ;b.i.r20 is allowed  

        cpi r21,$aa
        breq l25060    ;b.i.r21 is allowed
        cpi r21,$55
        breq l25060    ;b.i.r21 is allowed
        
        mov r20,r22    ;r20 and r21 are not allowed => r22 must be allowed 
        rjmp l25070    ;repair EEPROM-corruption   r20=correct autorepair-value


l25050: cp r20,r21     ;=2 or 3 allowed entries (but 2 or 3 allowed entries can be different
        breq l25080    ;b.i.r20 = r21                                       55 aa ff  55 55 aa)
        cp r20,r22
        breq l25070
        cp r21,r22 
        brne l25120    ;=2 allowed, but different entries

l25060: mov r20,r21
l25070: mov r21,r20
l25080: rjmp l25110    ;repair EEPROM-corruption   r20=r21=correct autorepair-value---------


l25090:                ; RAM-vector low 0101-0114   =repair not-'auto-repair-EEPROM'-bytes
                       ;  r20=$002c r21=$0017 r22=$0002 of Eeprom

        ;ldi r25,$12    ;12--
        ;call l13090

        cp r20,r21
        breq l25100    ;b.i.table2-value=table1-value
        cp r20,r22      
        breq l25100    ;b.i.table2-value=table0-value
        mov r20,r21
        cp r21,r22
        brne l25120    ;b.i.table1-value=table0-value

l25100: lds r21,raepbe ;$0100       = repair EEPROM corruption   r20=correct value
l25110: cpi r21,$aa
        brne l25120    ;b.i.autorepair EEPROM is disabled

        ;ldi r25,$13    ;13--
        ;call l13090

        mov r28,r30    ;lowbyte RAM vector (00-14)   r20=correct to-write value        
        subi r28,$ff   ;                  ->01-15
        ldi r29,$00    ;necessary???

        ;mov r25,r28    ;----
        ;call l13090

        ;mov r25,r29    ;----
        ;call l13090

        ;mov r25,r20    ;----
        ;call l13090

        call l13750   ;EEPROM-write 0001-0015 table0 
        mov r20,r21
        subi r28,$eb   ;                  ->16-2a

        ;mov r25,r28    ;----
        ;call l13090

        ;mov r25,r29    ;----
        ;call l13090

        ;mov r25,r20    ;----
        ;call l13090

        call l13750   ;EEPROM-write 0016-002a table1 
        mov r20,r21
        subi r28,$eb   ;                  ->2b-3f

        ;mov r25,r28    ;----
        ;call l13090

        ;mov r25,r29    ;----
        ;call l13090

        ;mov r25,r20    ;----
        ;call l13090

        call l13750    ;EEPROM-write 002b-003f table2 

        ;clr r02        ;stops writing into debugbuffer     temporary

        rjmp l24890    ;again from beginning (easier)-------------
       #endif          ;of l24950

l25120:                ;=unrepairable EEPROM-corruption or auto-repair disabled
        ldi r16,$4e    ;78,system error     
        ldi r17,$03   
        call l13890    ;03-- system error  (prints errormessage)

        mov r02,r16    ;#$e0 (=if EEPROM-corruption -> standard-debug-byte-saving) 
        ldi r20,$ff    ;sets calibrationbyte to illegal
        ldi r30,$15    ;clears 0114-0100
                       ;.........................................................................
l25130: ldi r31,high(raepbe) ;$01 z RAM vector = $0106/0115  necessary???

l25140: st -z,r06      ;$00 clears 0105-0100 if correct, legal EEPROM
                       ;!!change here if 0105, 0104 ... should become important at later versions
                       ;    clears 0114-0100 if EEPROM error 
                       ; -z = predecremented     
        cpi r30,low(raepbe) ;$00   
        brne l25140
        
        ;sts $0181,r20  ;only for debugging  
        cpi r20,$ff    ;(ff=empty EEPROM or corruted EEPROM)
        brne l25150    ;b.i.EEPROM-calibratinbyte is legal 
      
        sts fljdal,r06 ;#$00 flag JiffyDOS allowed  disables JiffyDOS because calibrationbyte
                       ;is wrong    
        
        #if partname == 1
         #message 162-IEC-ATA-V2
         ldi r20,$40   ;default for average calibrationbyte  !!! wrong timing at JiffyDOS

        #else
         #message 644-NLQ-HD/non-iec-ata
         ldi r20,$80   ;default for average calibrationbyte  !!! wrong timing at JiffyDOS
        #endif
 
l25150: sts osccal,r20 ;calibrationbyte for internal 8MHz-oscilator
                       ;in/out-command doesn't work at 644  
 
       #if partname == 1    
        #message 162-IEC-ATA-V2
        lds r16,tadenu ;table device numbers
        cpi r16,$68
        brcs l25160    ;b.i.$00-$67  b.i.devicenumber < 8

        cpi r16,$7f
        brcs l25210    ;b.i.68-7e =devicenumber 8-30
                       ;=7f-ff   =devicenumber > 30 
l25160: ldi r16,$7e    ;default drivenumber 30
        sts tadenu,r16 ;
        
        ;sts devpar,r06 ;#$00 necessary???
       #endif

       #if (partname == 3) | (partname == 6)    
        #message 644-NLQ-HD/SD-only-routines
        sts tadenu,r07
        sts tadenu+1,r07
        lds r16,tadenu+2 ;table device numbers of SD
        cpi r16,$68
        brcs l25170    ;b.i.$00-$67  b.i.devicenumber < 8

        cpi r16,$7f
        brcs l25210    ;b.i.68-7e =devicenumber 8-30
                       ;=7f-ff   =devicenumber > 30 
l25170: ldi r16,$7e    ;default drivenumber 30
        sts tadenu+2,r16 ;
        
        ;sts devpar,r06 ;#$00 necessary???
       #endif

       #if (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/multiple emulations
        ldi r30,low(tadenu+3) 
        ldi r31,high(tadenu+3) ;necessary??
        ldi r17,$00    ;counter activated emulationentries

l25180: ld r16,-z      ;table device numbers

        cpi r16,$ff
        breq l25190    ;b.i.dectivated emulationentry  

        inc r17        ;increments counter activated emulationentries

        cpi r16,$68
        brcs l25200    ;b.i.$00-$67  b.i.illegal devicenumber < 8

        cpi r16,$7f
        brcc l25200    ;b.i.7f-ff    b.i.illegal devicenumber > 30 

                       ;=68-7e =legal devicenumber 8-30
l25190: cpi r30,low(tadenu)
        brne l25180

        cpi r17,$00    ;counter activated emulationentries
        brne l25210    ;b.i.1-3 legal devicemeulationentries

                       ;=error in devicemeulationentries  
l25200: ldi r16,$7e    ;default drivenumber 30
        sts tadenu,r16 ;HD = drivenumber 30
        sts tadenu+1,r07 ;deactivates CD
        sts tadenu+2,r07 ;deactivates SD
      
        ;sts devpar,r06 ;#$00 necessary???
       #endif 

l25210:                ;                                           end of reset-routine of EEPROM 
        ;ldi r25,$92
        ;call l13090   ;92--

                       ;-------------------------------------------------------------------------
        ;ldi r17,$aa
        ;ldi r16,$40    ;delay, only temporary, to see if AVR makes reset accidentially
l25220: ;dec r11   
        ;brne l25220
        ;dec r10
        ;brne l25220
        ;dec r16
        ;brne l25220
;................................................................................................        
l25230: rcall l23840   ;enable AtnIn-IRQ & SEI
;------------------------------------------------------------------------------------------------
l25240: ldi r25,$40    ;40---- (at part of reset-routine)
        call l13090

       #if partname == 1 
                       ;acemen stays #$00 = first emulation entry = HD                  
        call l18240    ;initialize drive (HD)
       #endif

       #if (partname == 3) | (partname == 6)    
        #message 644-NLQ-HD/SD-only-routines
        ldi r16,$02
        sts acemen,r16 ;actual emulated entry 
       #endif

       #if (partname == 4) | (partname == 5)
         #message 644-NLQ-HD/lite
                       ;acemen stays #$00 = first emulation entry = HD                  
        call l18240    ;initialize drive (HD)
       #endif

       #if partname == 7
        #message 644-NLQ-HD/full
                       ;acemen stays #$00 = first emulation entry = HD                  
        call l18240    ;initialize HD drive

        lds r16,cm0086 ;CBM-memory 0086 (temporary memory?)  set at l24650, l24860
                       ;not set at UI/UJ to SD   only set at UI/UJ to HD
                       ;at scratch: counter for deleted files
                       ;at open/rename
                       ;at reset: temp memory for actual device emulation
                       ; (mustn't be at DEB because of reset-routine)
                       ;pay attention that the routine which searches NLQ-SWAP.SYS in the dir
                       ; doesn't change cm0086     
;/*
        sts $10ff,r16  ;acemen (00=UI-/UJ to HD  (02 not possible) #$ff=AUI/AUJ/hardwarereset)
        .db 0
;*/

        cpi r16,$ff
        brne l25280    ;b.i.not clear all DEBs
 
        ldi r16,$02    ;=clear DEB of SD
        call l14330    ;swap device-emulation-buffer   r16=wanted new device-emulation-entry

                       ;from l24660 (UI-software-reset to SD)
l25250: ldi r26,low(deembb) ;device-emulation-buffer-begin ($0800)
        ldi r27,high(deembb)

l25260: st x+,r06      ;#$00  clears DEB  !!!temporary 
        cpi r27,high(deembe) ;device-emulation-buffer-end ((0fff/)$1000)
        brne l25260

        ldi r26,low(tasach+$12+$01) ;table secundaryaddress -> channel  022b,x
        ldi r27,high(tasach+$12+$01)
l25270: st -x,r07      ;#$ff clears tasach
        cpi r26,low(tasach) ;               make this also at every initialize?????
        brne l25270         

        ldi r16,$49    ;73,nlqhd (c) nowaranty ownrisk
        ldi r17,butrhi ;built track high
        ldi r18,buselo ;built sector low
        call l13900    ;copy 73,errormessage to buffer 

        sts acsacb,r07 ;makes flag that there is nothing in actual SA in CBM-buffer (00-$11 0-17)
l25280:
       #endif

        ldi r25,$54    ;54----
        call l13090

                       ;set bit for HD is accessable here (not earlier)!!!!!!!!!!!!!!!!!!!!!!!!!! 
                       ;active LED off is made in waitingloop (when floker is cleared
;------------------------------------------------------------------------------------------------        
                       ;from l11190, l11860, l12100, l12190, l12250, l12360, l13370
                       ;     l13450, l13500, l13540, l14000, l27250, l27390
l25290: ldi r16,low(stpobe) ;                                                mainwaitingloop ebe7       
        out Spl,r16    ;stackpointerlow = ff               (after receiving of a command
        ldi r16,high(stpobe) ;                               DtaOut is still Active???)   
        out Sph,r16    ;stackpointer high to 01 => stackpointer to 01ff    
      
        sts debyhi,r06 ;#$00 clears debug-byte-high            
      
        mov r25,r06    ;00----
        call l13090
      
        mov r25,r07    ;ff----
        call l13090 

        in r25,DdrA    ;xx-- DdrA
        call l13090 
        in r25,PrtA    ;xx-- PrtA 
        call l13090 
        in r25,PinA    ;xx-- PinA
        call l13090 
       
        in r25,DdrB    ;xx-- DdrB
        call l13090 
        in r25,PrtB    ;xx-- PrtB 
        call l13090 
        in r25,PinB    ;xx-- PinB
        call l13090 
       
        in r25,DdrC    ;xx-- DdrC
        call l13090 
        in r25,PrtC    ;xx-- PrtC 
        call l13090 
        in r25,PinC    ;xx-- PinC
        call l13090 

        in r25,DdrD    ;xx-- DdrD
        call l13090 
        in r25,PrtD    ;xx-- PrtD 
        call l13090 
        in r25,PinD    ;xx-- PinD
        call l13090 

       #if partname == 7
        #message 644-NLQ-HD/full
        rcall l23820   ;read I2C-parallel-port to r20
        mov r25,r20
        call l13090    ;xx-- i2c-port
       #endif

/*
        ldi r31,$00    ;this routine reads the configurationbytes, set at flashing 
        ldi r17,0b00001001 ;sets blbset and spmem in spmcsr
        
        ldi r30,$01
        out $37,r17    ;spmcsr
        lpm r16,z      
        sts $0c10,r16  ;lock bits
        
        ldi r30,$00
        out $37,r17    ;spmcsr
        lpm r16,z      
        sts $0c11,r16  ;fuse low

        ldi r30,$03
        out $37,r17    ;spmcsr
        lpm r16,z      
        sts $0c12,r16  ;fuse high

        ldi r30,$02
        out $37,r17    ;spmcsr
        lpm r16,z      
        sts $0c13,r16  ;extended fuse

        ldi r17,0b00100001 ;sets sigrd and spmem in spmcsr
        
        ldi r30,$00
        out $37,r17    ;spmcsr
        lpm r16,z      
        sts $0c14,r16  ;1. signature byte
        
        ldi r30,$02
        out $37,r17    ;spmcsr
        lpm r16,z      
        sts $0c15,r16  ;2. signature byte

        ldi r30,$04
        out $37,r17    ;spmcsr
        lpm r16,z      
        sts $0c16,r16  ;3. signature byte

        ldi r30,$01
        out $37,r17    ;spmcsr
        lpm r16,z      
        sts $0c17,r16  ;calibration byte
*/

       #if ((partname >= 2) & (partname <= 7))
        #message 644-NLQ-HD/2-7
        rcall l23850   ;initialize timer1 to 100IRQs/s + enable IRQ
                       ;but AtnAck-IRQ ist still disabled because there is still 
                       ;a #$00 in iratin IRQ-register AtnIn-pin ??? 
        #endif
ldi r25,$90
call l13090    ;90--
    
        sts flicbb,r06 ;#$00 clears flag f. IECAtnMode   = in dataMode (important f.rcall l11260)

                       ;1541 makes all IECLines = inactive
                       ;AVR shouldn't make DataOut=active because there is no AtnAck-hardware
        lds r16,avinco ;AVR-internal command                                                 ebf0
        cpi r16,$00    ;00=no command   01-ff=command
        breq l25300    ;b.i.no command                                                       ebf3
        
        sts avinco,r06 ;#$00                                                                 ebf7
        call l17150    ;10-- analyse & execute new command  -> debugbyte 10--                     ebfc
                       ; (error-LED is on??)
                       ; Is the AtnAck-IRQ enabled????                         

l25300: call l11260    ;test if IECAtn change (if IECAtn=active -> 
                       ;                        l10860 serves bus after Atn-active-edge) 
                       ;important that bit7 of flicbb is low 
      
        call l12990    ;make all lines of IEC-port inactive                                  ebed
        rcall l23840   ;enable AtnIn-/AtnAck-IRQ & SEI

        call l10390    ;external IRQ 0/2 pin-toggle-IRQ-routine
                       ;problem: IRQ must be disabled to avoid second IRQ within first IRQ
                       ; because r06, r07 would be wrong
                       ;important at sd2iec where an AtnIn-pin-change only can be detected
                       ; if there is a change of Atn from inactive to active between l25300
                       ; and here then this wouldn't be read
                       
                       ;problem: C64 makes first all IEC-line inactive (ebed)
                       ; if the C64 makes Atn again active then the DtaOut-line nevertheless
                       ;  stays active because the AtnAck-hardware makes it active
                       ;There is now AtnAck.hardware at the AVR. => you cannot make DtaOut (and
                       ; so all IEC-line) = inactive at the beginning of this routine.
                       ; When the C64 makes Atn again active and when the AVR would make DtaOut
                       ;  = inactive then the C64 would think that the AVR is ready and would
                       ; start to send a byte.
                       ; => one must first check whether the C64 makes Atn acrtive or inactive
                       ;  -if the C64 makes Atn=active: DtaOut must stay active and the routine
                       ;   after receiving an AtnActive-edge must be made (this is made with
                       ;   rcall l11260)
                       ;  -if the C64 lets Atn=inactive: AVR must make all IEC-lines inactive
                       ;   and wait until C64 makes Atn=active (this is seen when then the
                       ;   AtnAck-IRQ makes iratin=#$00
        ldi r25,$01    ;01----
        call l13090
;................................................................................................ 
                       ;from l25500
                       ;r22 = counter for switch-reading
l25310:                ;                                             loop of mainwaitingloop ebff
                       ;-------------------------------------------------------------------------
        lds r16,flated ;flag Atn-edge 0=no Atn-edge received 1=Atn-edge received  ($7c)      ec00
        andi r16,$01   ;masks bit for Atn-edge
        breq l25320    ;b.i.no Atn-edge                                                      ec02

                       ;  =Atn-active-edge received
       #if partname == 7
        #message 644-NLQ-HD/full
        call l10750    ;LED-on (important when error-LED is off at blinking) 
                       ;probably not necessary   shouldn't be possible 
       #endif ;644-NLQ-HD/full

        jmp l10860     ;serves bus after Atn-active-edge                                     ec04
                       ;------------------------- back with jmp l25290  jmp $ebe7   
l25320: 
       #if partname == 1 ;------------------------------------------------------------LED-162----    
        #message 162-IEC-ATA-V2

        in r16,ddleer  ;Ddr LED error
        ori r16,1<<bileer ;error-LED-pin = output  (-> LED on)
        
        ;ldi r25,$10    ;10----
        ;call l13090
        
        ;in r25,tcnt1h    ;..--
        ;rcall l23560
       
        ;mov r25,r16    ;..--
        ;rcall l23560

        ldi r26,low(tasach+$0e+$01) ;table secundaryaddreess -> channel  022b,x
        ldi r27,high(tasach+$0e+$01)
l25330: ld r17,-x
        cpi r17,$ff
        brne l25340    ;b.i.wanted SA is opened    
 
        cpi r26,low(tasach)
        brne l25330
       
        ;mov r25,r17    ;..--
        ;rcall l23560

        ;mov r25,r18    ;..--
        ;rcall l23560

        andi r16,$ff-(1<<bileer) ;error-LED-pin = input  (-> LED off)

l25340: 
        ;mov r25,r16    ;..--
        ;rcall l23560
            
        lds r17,floker ;flag ok / error     errorflag  026c at 1541                          ec72
       
        ;mov r25,r17    ;..--
        ;rcall l23560

        andi r17,$ff
        breq l25350    ;b.i.no error-LED blink
        
        in r17,met1oc  ;timer IRQ flag register
                       ;memory timer1 output compare
                       ;different 162: $38 
                       ;      and 644: $16
     
        andi r17,1<<bit1oc ;masks Timer/Counter1 output compare A match flag  ocf1a
                        ; bit6 of tifr $40 at M162
                        ; bit1 of tifr $02 at M644
                       
        ;mov r25,r17    ;..--
        ;rcall l23560
     
        breq l25500    ;=timer 1 not yet reached TOP (=T/C1 Output Compare Register A)    
        
        out met1oc,r17;clears IRQ-bit    memory timer1 output compare
                             ;different 162 and 644

        andi r16,$ff-(1<<bileer) ;error-LED-pin = input  (-> LED off)
        sbis ddleer,bileer ;s.i.error-LED-pin=output = 0v = LED on 
  
        ori r16,1<<bileer ;error-LED-pin = output  (-> LED on)
                       ;error-LED-pin is open collector => pulldown-switch is possible
                       ; at M162 and M644

l25350: out ddleer,r16 ;switch error-LED on/off (in mainwaitingloop)

       #endif ;162-IEC-ATA-V2----------------------------------------------------------LED162----

       #if partname == 3 ;--------------------------------------------------------LED--sd2iec----
        sbi ddleer,bileer ;error-LED = output      initialize the one register of LEDs
        sbi ddleac,bileac ;active-LED = output     which stays always the same

        in r16,poleac  ;Port LED active                              ----begin LEDactive----
        ori r16,1<<bileac ;pc0 active-LED-pin = output  (later: LED on)

        ;ldi r25,$10    ;10----
        ;call l13090
        
        ;in r25,tcnt1h    ;..--
        ;rcall l23560
       
        ;mov r25,r16    ;..--
        ;rcall l23560
 
        ldi r26,low(tasach+$0e+$01) ;table secundaryaddress -> channel  022b,x
        ldi r27,high(tasach+$0e+$01)
l25360: ld r17,-x
        cpi r17,$ff
        brne l25370    ;b.i.wanted SA is opened    
 
        cpi r26,low(tasach)
        brne l25360
                       ;perhaps still make jobcodes
        andi r16,$ff-(1<<bileac) ;0 active-LED-pin = input  (later: LED off)

l25370: out poleac,r16 ;switch active-LED on/off (in mainwaitingloop)  ----end LEDactive----

        in r16,poleer  ;pc1 Port LED error                             ----begin LEDerror----
        bst r16,bileer ;copies LEDerror-bit to T-flag
                       ;t=c: LEDerror=off  t=s: LEDerror=on
        ori r16,1<<bileer ;error-LED = +5V  (later: LED on)
        lds r17,floker ;flag ok / error     errorflag  026c at 1541                          ec72
        tst r17
        breq l25380    ;b.i.no error-LED blink (->LED on)
        
        brmi l25500    ;b.i.100Hz-IRQ not yet counted to end

        ldi r17,$8b
        sts floker,r17 ;initialize value for 100Hz-IRQ-counter

        brtc l25380    ;b.i.error-LED = 0V  => ->5V = LED is off (LED-off -> LED-on)
  
        andi r16,$ff-(1<<bileer) ;error-LED = 5V => -> 0V  LED is on (LED-on -> LED-off)

l25380: out poleer,r16 ;switch error-LED on/off (in mainwaitingloop)
       #endif            ;--------------------------------------------------------LED--sd2iec----

       #if partname == 4 ;-------------------------------------------------------------LED644----
        #message 644-NLQ-HD/lite
        cbi poleer,bileer ;error-LED-pin = 0V / pullup-off 
        cbi poleac,bileac ;active-LED-pin = 0V / pullup-off 

        in r16,ddleac  ;Ddr active-LED
        ori r16,1<<bileac ;active-LED-pin = output  (-> LED on)

        ;ldi r25,$10    ;10----
        ;call l13090
        
        ;in r25,tcnt1h    ;..--
        ;rcall l23560
       
        ;mov r25,r16    ;..--
        ;rcall l23560

        ldi r26,low(tasach+$0e+$01) ;table secundaryaddress -> channel  022b,x
        ldi r27,high(tasach+$0e+$01)
l25390: ld r17,-x
        cpi r17,$ff
        brne l25400    ;b.i.wanted SA is opened    
 
        cpi r26,low(tasach)
        brne l25390
                       ;perhaps still make jobcodes

        andi r16,$ff-(1<<bileac) ;0 active-LED-pin = input  (-> LED off)

l25400: out ddleac,r16 ;switch active-LED on/off (in mainwaitingloop)  ----active-LED----

        in r16,ddleer  ;Ddr LED error                                  ----error-LED----
        ori r16,1<<bileer ;error-LED-pin = output  (-> LED on)
                       ;error-LED-pin is open collector => pulldown-switch is possible

        lds r17,floker ;flag ok / error     errorflag  026c at 1541                          ec72
        tst r17
        breq l25410    ;b.i.no error-LED blink (->LED on)
        
        brmi l25500    ;b.i.100Hz-IRQ not yet counted to end

        ldi r17,$8b
        sts floker,r17 ;initialize value for 100Hz-IRQ-counter

        in r16,ddleer  ;Ddr LED error
        ldi r17,1<<bileer
        eor r16,r17    ;changes Ddr of error-LED -> LED blinks

l25410: out ddleer,r16 ;switch error-LED on/off (in mainwaitingloop)    ----error-LED----

       #endif ;644-NLQ-HD/lite-----------------------------------------------------------LED644----

       #if partname == 6 ;-------------------------------------------------------------LED644----
        #message 644-NLQ-HD/SD
        cbi poleer,bileer ;error-LED-pin = 0V / pullup-off 
        cbi poleac,bileac ;active-LED-pin = 0V / pullup-off 

        ;cli            ;important to prevent that timer2-RTC changes ddlert
                       ;not necessary as long as RTC-LED is at a different port as 
                       ;error- &active-LED
        in r16,ddleac  ;Ddr active-LED
        ori r16,1<<bileac ;active-LED-pin = output  (-> LED on)

        ;ldi r25,$10    ;10----
        ;call l13090
        
        ;in r25,tcnt1h    ;..--
        ;rcall l23560
       
        ;mov r25,r16    ;..--
        ;rcall l23560

        ldi r26,low(tasach+$0e+$01) ;table secundaryaddress -> channel  022b,x
        ldi r27,high(tasach+$0e+$01)
l25390: ld r17,-x
        cpi r17,$ff
        brne l25400    ;b.i.wanted SA is opened    
 
        cpi r26,low(tasach)
        brne l25390
                       ;perhaps still make jobcodes

        andi r16,$ff-(1<<bileac) ;0 active-LED-pin = input  (-> LED off)

l25400: 

        ;andi r16,$ff-(1<<bileac) ;0 active-LED-pin = input  (-> LED off)
                       ;add this command when it's important to measure the currency
                       ; of the circuit to see how long the backup-battery works

        out ddleac,r16 ;switch active-LED on/off (in mainwaitingloop)  ----active-LED----
        ;sei
        ;nop
        
        ;cli            ;important to prevent that timer2-RTC changes ddlert
        in r16,ddleer  ;Ddr LED error                                  ----error-LED----
        ori r16,1<<bileer ;error-LED-pin = output  (-> LED on)
                       ;error-LED-pin is open collector => pulldown-switch is possible

        lds r17,floker ;flag ok / error     errorflag  026c at 1541                          ec72
        tst r17
        breq l25410    ;b.i.no error-LED blink (->LED on)
        
        brmi l25450    ;b.i.100Hz-IRQ not yet counted to end

        ldi r17,$8b
        sts floker,r17 ;initialize value for 100Hz-IRQ-counter

        in r16,ddleer  ;Ddr LED error
        ldi r17,1<<bileer
        eor r16,r17    ;changes Ddr of error-LED -> LED blinks

l25410: 

        ;andi r16,$ff-(1<<bileer) ;0 error-LED-pin = input  (-> LED off)
                       ;add this command when it's important to measure the currency
                       ; of the circuit to see how long the backup-battery works
 
        out ddleer,r16 ;switch error-LED on/off (in mainwaitingloop) 

l25450: ;sei            ;                                                ----error-LED----

       #endif ;644-NLQ-HD/SD-----------------------------------------------------------LED644----


       #if partname == 7 ;-------------------------------------------------------------LED644----
        #message 644-NLQ-HD/full

         lds r20,i2pova ;I2C-port-value (of 8bit port expander chip)
                        ;                                                    ----active-LED---- 
         andi r20,$ff-(1<<bileac) ;I2C-bit-active-LED-pin = low-output  (-> active-LED on)
                        ;doesn't change error-LED
        ;ldi r25,$10    ;10----
        ;call l13090
        
        ;in r25,tcnt1h    ;..--
        ;rcall l23560
       
        ;mov r25,r16    ;..--
        ;rcall l23560
 
        ldi r26,low(tasach+$0e+$01) ;table secundaryaddress -> channel  022b,x
        ldi r27,high(tasach+$0e+$01)
l25460: ld r17,-x
        cpi r17,$ff
        brne l25470    ;b.i.wanted SA is opened    
 
        cpi r26,low(tasach)
        brne l25460
                       ;perhaps still make jobcodes

        ori r20,1<<bileac ;I2C-bit-active-LED-pin = high-input  (later: -> LED off)

l25470:                ;                                                     ----active-LED----
                       ;                                                     ----error-LED----
        lds r17,floker ;flag ok / error     errorflag  026c at 1541                          ec72
        tst r17
        brne l25480    ;b.i.error-LED blink 

                       ;=no error-LED-blink (=error-LED on)
        andi r20,$ff-(1<<bileer) ;I2C-bit-error-LED = low-output = error-LED=on
        rjmp l25490

l25480: brmi l25490    ;b.i.100Hz-IRQ not yet counted to end

        ldi r17,$8b
        sts floker,r17 ;initialize value for 100Hz-IRQ-counter

        ldi r17,1<<bileer ;I2C-bit-error-LED         
        eor r20,r17   ;inverts value of error-LED                        ----error-LED----

l25490: lds r16,i2pova ;I2C-port-value (of 8bit port expander chip) old value
        cp r20,r16     ;I2C-port-value: compares new and old value
        breq l25500    ;b.i.no change

        rcall l23790   ;writes r20 to I2C-parallel-port (nad don't write debugbytes)    
                       ;switch error-LED on/off (in mainwaitingloop)
                       ;switch active-LED on/off (in mainwaitingloop)  
       #endif ;644-NLQ-HD/full-----------------------------------------------------------LED644----
;================================================================================================
l25500: 
       #if partname == 1    
        #message 162-IEC-ATA-V2
                       ;error-LED is now open-collector also at MEGA162
                       ;one could connect a switch to the LED-pin and use it for device swap???? 
        rjmp l25310    ;-------------------------------------------------
       #endif ;162-IEC-ATA-V2
        
       #if ((partname >= 3) & (partname <= 7))
         #message 644-NLQ-HD/all

        dec r22        ;decrements counter for switch-testing                           =switches
        ;brne l25310    ;b.i.not yet possible
         
        breq l25510     ;b.i.possible
        rjmp l25310    ;=not yet possible !!!!!!!!!!!!!!temp!!!!!!!!!!!!!!!!!
        .db 0
l25510:
                       ;the switch and a LED is at the same AVR-pin
                       ;it's impossible to read the switch when the LED is on
                       ;=> one must switch off the LED for reading the pin
                       ; the LED cannot be switched off too long, else the user would see this
                       ;=> switch off the LED in 1 of 256 loops
                     
                       ;r08=temp-pin-value
                       ;r09=temp counter for blinking
                       ;r10=Ddr-backup
                       ;r11-15 aren't changed to see at error what cluster/sector the error was
                       ;r16=mode-value
                       ;r17=value-value 
                       ;r18=amount of display cycles
                       ;r19=pin of LEDs (PrtD or I2C-port)
                       ;r20=for I2C-access
                       ;r21=counter 
                       ;r22=#$00 counter
                       ;r23=counter  
                       ;r24=perhaps changed at read I2C-port
                       ;r25=changed at read/write I2C-port       
                       ;r26=counter for result-loop at declicking switch-ports
                       ;r27=result of switch-ports
                       ;r28=SD-card-detect (bit like 1541)

l25520: rcall l25980   ;reads switches-port->r19 (reads one time only, doesn't compute average)
                       ;reads SD-card-detect->r28
                             
                       ;--------------------------------------------------------media-change-test
                       ;1541: polls write-protect-switch at 100Hz-IRQ
                       ;       if state of write protect switch is changed 
                       ;        then bit 0 of $1c is set (#$01->$1c)
                       ;NLQ-HD: this is in IRQ not possible, because at NLQ-HD/full
                       ;       the SD-carddetect-switch must be read via the I2C-bus
                       ;       this takes too much time in the IRQ
                       ;      => the polling must be made in the main-waitingloop
       #if (partname == 3) | (partname == 6) | (partname == 7)
        #message nlq-hd/SD-routines
        lds r16,sdfldc ;SD flag disk change                                 (bit0-3=$1c at 1541)
                       ;                                                    (bit4-7=$1e at 1541)
        andi r16,$10   ;mask bit for old state of SD-card-detect-switch
        cp r16,r28     ;compares actual and old state of SD-card-detect-switch           IRQ-f9a7
        breq l25530    ;b.i.no change of state of SD-card-detect-switch                      ec53
        
        bst r28,4      ;copies port-bit to T-flag
        bld r16,4      ;copies T-flag to old state of SD-card-detect-switch
        ori r16,$03    ;                                                                 IRQ-f9ad
        sts sdfldc,r16 ;sets bit 0 of SD flag disk change                   $1c at 1541  IRQ-f9af   

       #if (partname == 3) | (partname == 6)    
        #message 644-NLQ-HD/SD-only-routines
        sts seswfi+3,r07 ;#$ff sets flag that swapfile is illegal  
       #endif       
                       ;it's impossible to free the buffers here always
                       ; ec55 jsr d313  
                       ;because it's possible that a different device-emulation-buffer
                       ; is actually in the AVR-RAM
                       ;=> this routine is also made at l11130 (end of receive commandbyte)
                       ; a HD cannot be changed
                       ; only a SD (and later a CD) can be changed
        lds r16,acemen ;actual emulation entry
        cpi r16,$02    
        brne l25530    ;b.i.not SD

        ldi r25,$cf    ;cf--
        rcall l23560

        call l18950    ;free all buffers (without closing them) of SD,
                       ; because a SD can be changed, a HD cannot be changed
                       ;  changes r26,r27 X
                       
        rjmp l25310    ;to begin of loop of mainwaitingloop (because r19 is changed)          
       #endif          ;--------------------------------------------------------media-change-test
      
l25530: cpi r19,0b01010000 ;checks whether any switch pressed
        brne l25540    ;b.i.any switch pressed 

        rjmp l25310    ;to begin of loop of mainwaitingloop  (=no switch pressed)----------------

l25540: ldi r25,$c8    ;c8--
        rcall l23560

        ldi r16,$00    ;sets mode 0  => press value-switch makes device-swap

l25550: rcall l25960   ;reads switches (and switches error-LEDs off and restores)
                       ;and makes average (if switch swings)
                       ; ->r27 contains error-LED/switch-pin

        mov r25,r27    ;..-- (I2C-port-byte)
        rcall l23560

l25560: bst r27,7      ;copies result-bit of mode-LED to T-flag
        brts l25600    ;b.i.mode-switch not pressed

                       ;=left 'mode' (error) switch pressed
                       ; => error-LED is on by switch independat of AVR-pin
l25570: rcall l25950   ;100000µs =0.1s waitingloop
                       ;it could be that the switch swings = it could be that 1 switch-press
                       ; makes several contacts
                       ; to avoid this after every change of the switch-level the AVR waits
                       ; 0.1s until the swinging (probably) ended    
                       ; => maximal 5 switch-presse per second are possible
        
l25580: rcall l25960   ;reads switches
        bst r27,7      ;copies result-bit of mode-LED to T-flag
        brtc l25580    ;b.i.mode-switch still pressed = waits until mode-switch get switched off
                       ;doesn't matter that LED is often switched off, because LED is on
                       ;because switch is pressed

        inc r16        ;r16=mode-blink
        cpi r16,$0a
        brcs l25690    ;b.i.mode not 9->10
                       ; displays mode amd value to LEDs
      
l25590: rjmp l25310    ;=10 = leave switches   to begin of loop of mainwaitingloop--------------- 
        
l25600:                ;r27 contains still LED/switch-pins
        bst r27,5      ;copies resultbit of value-switch to T-flag
        brtc l25610    ;b.i.value-switch not pressed

        rjmp l25310    ;to begin of loop of mainwaitingloop

                       ;=value-switch pressed
                       ; => error-LED is on by switch independat of AVR-pin
l25610: rcall l25950   ;100000µs =0.1s waitingloop
                       ;it could be that the switch swings = it could be that 1 switch-press
                       ; makes several contacts
                       ; to avoid this after every change of the switch-level the AVR waits
                       ; 0.1s until the swinging (probably) ended    
                       ; => maximal 5 switch-presse per second are possible
        ldi r21,$00    ;256  counter for sleep-mode

l25620: rcall l25960   ;7800µs reads active-switch 
        
        mov r25,r27    ;..--
        rcall l23560

        mov r25,r21    ;..--
        rcall l23560
 
        dec r21        ;256*7800=2000000µs = 2s
        brne l25630    ;b.i.value-switch (right) not 2s pressed
      
        rjmp l25890    ;=value-switch (right) 2s pressed -> standby-mode       

l25630: bst r27,5      ;copies result-bit of value-switch to T-flag
        brtc l25620    ;b.i.value-switch still pressed=waits until valueswitch gets switched off
                       ;doesn't matter that LED is often switched off, because LED is on
                       ;because switch is pressed
        ldi r22,$00    ;=mode switch isn't pressed any more

        cpi r16,$01    ;mode-value
        brne l25650    
                       ;=mode=1 = emulation entry
       #if partname == 3
        #message 644-NLQ-HD/SD2IEC
        rjmp l25730     
       #endif

       #if (partname == 4) | (partname == 5)
         #message 644-NLQ-HD/lite
        rjmp l25730    ;temporary as long as there is no CD
       #endif
 
       #if partname == 6    
        #message 644-NLQ-HD/SD
        rjmp l25730
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
        lds r16,acemen ;actual emulation entry 0-2
        inc r16
        cpi r16,$03             
        brcs l25640

        ldi r16,$00

l25640: call l14330  ;save old device-buffer to swapfile and load new device-buffer from swapfile
        ldi r16,$01
        rjmp l25730
       #endif

l25650: cpi r16,$02    ;mode-value
        brne l25660    
                       ;=mode=2 = do action from file
        rjmp l25730    ;temporary

l25660: ldi r18,$64    ;100
        cpi r16,$03    ;mode-value
        breq l25670    ;b.i.first digit of partition-number

        ldi r18,$0a    ;10
        cpi r16,$04    ;mode-value
        breq l25670    ;b.i.second digit of partition-number    

        ldi r18,$01
        cpi r16,$05    ;mode-value
        brne l25700    

                       ;=third digit of partition-number
l25670: lds r17,acpanu ;actual partition number
        add r17,r18
        brcc l25680
        
        ldi r17,$00
         
l25680: sts acpanu,r17
l25690: rjmp l25730

l25700: cpi r16,$06    ;mode-value
        breq l25590    ;b.i.mode=6 = leave switch-mode

        cpi r16,$08    ;mode-value
        breq l25710    ;b.i.device swap with devicenumber 8

        cpi r16,$09    ;mode-value
        brne l25720    ;b.i.device swap with devicenumber 9

l25710: call l12730    ;device-swap        device-swap-key wanted
        rjmp l25290    ;to mainwaitingloop (not l25310)
                       ;Atn was active => Atn-active-flag is set => this must be read,
                       ; else a new Atn-active-edge isn't recognized => endlessloop----

l25720: inc r17        ;r17=value-blink
        cpi r17,$0a
        brcs l25730

        ldi r17,$00

l25730:                ;------------------------------------------display mode amd value to LEDs
        lds r17,acemen
        cpi r16,$01
        breq l25790    ;b.i.1 = actual emulation entry
 
        cpi r16,$02
        breq l25780    ;b.i.2 = do job from file

        lds r18,acpanu ;actual partition number
        ldi r17,$00
l25740: cpi r18,$64
        brcs l25750    ;b.i.0-99
        
        subi r18,$64
        inc r17         
        rjmp l25740
    
l25750: cpi r16,$03
        breq l25790    ;b.i.3 = first digit of actual partition number
    
        ldi r17,$00
l25760: cpi r18,$0a
        brcs l25770    ;b.i.0-9 
        
        subi r18,$0a
        inc r17         
        rjmp l25760
    
l25770: cpi r16,$04
        breq l25790    ;b.i.4 = second digit of actual partition number 

        mov r17,r18 
        cpi r16,$05
        breq l25790    ;b.i.5 = third digit of actual partition number  
        
l25780: ldi r17,$00     
        
l25790: call l10770    ;switch error-LED off
        call l10800    ;switch active-LED off

                       ;as long as NLQ-HD displays the partition-values to the LEDs
                       ; the IEC-bus is locked
                       ; => one must change the mode to '6' and exit the partition-select-mode

        rcall l25950   ;100000µs waitingloop                     
                       ;(to prevent that switch swings at switching off)

        ldi r18,$0a    ;counter for amount of display-cycles

l25800: ldi r21,$02    ;2*0.25 = 0.5s
l25810: rcall l25920   ;0.25s delay       
        brtc l25850    ;b.i.any switch pressed
        dec r21
        brne l25810

        mov r09,r16    ;counter for amount of mode-blinks

l25820: call l10750    ;switch error-LED on
        rcall l25920   ;test switch for 0.25s   ends if switch pressed
        brtc l25850    ;b.i.any switch pressed
                  
        call l10770    ;error-LED off

        rcall l25920   ;test switch for 0.25s   ends if switch pressed
        brtc l25850    ;b.i.any switch pressed

        dec r09        ;counter for amount of mode-blinks
        brne l25820

l25830: mov r09,r17    ;counter for amount of value-blinks
        tst r09
        breq l25870    ;b.i.0 = b.i.no blink at all

l25840: rcall l25920   ;test switch for 0.25s   ends if switch pressed
        brtc l25850    ;b.i.any switch pressed

        call l10780    ;switch active-LED on

        rcall l25920   ;test switch for 0.25s   ends if switch pressed
        brts l25860    ;b.i.no switch pressed
      
l25850: rjmp l25560    ;=any switch pressed
      
l25860: call l10800    ;active-LED off

        dec r09        ;counter for amount of value-blinks
        brne l25840

l25870: dec r18        ;counter for amount of display-cycles
        brne l25800    

l25880: rjmp l25310    ;to begin of loop of mainwaitingloop
                       

                       ;left switch determines mode   
                       ; red (error-)LED displays mode
                       ; (=> connect left switch to red error-LED
                       ;right switch determines value of this mode
                       ; green (active-)LED displays value
                       ; (=> connect right switch to green active-LED
                       ; don't press right switch at all = don't change actual value
                       ; => one must press right switch 10 times to receive value 0
                       ;left switch wakes AVR up from Off-/sleep-mode
                       ;   => left switch must be connected to PD2 if input pin would be changed
                       ;       because only PD2 can generate an IRQ to wake up AVR
                       ;       (left switch and red-error-LED must be connected to PD2)
                       ;right switch puts AVR and HD to off or sleep-mode (if pressed >4sec)
                       ;       (right switch and green-active-LED must be connected to PD1)


                       ;mode:
                       ; 0 = nothing: to prevent accidential action
                       ; 1 = set emulation-entry (0-2)
                       ; 2 = right switch pressed (<2s) without having pressed left switch before
                       ;     -> make thing what is in the partition-text-file defined for actual
                       ;        partition (e.g.switch to special partition and change device?
                       ; 3 = left switch pressed three times
                       ;     set first digit of partition number
                       ; 4 = left switch pressed four times
                       ;     set second digit of partition number
                       ; 5 = left switch pressed five times
                       ;     set third digit of partition number
                       ; 6 = leave partition-select-mode when value switch is pressed
                       
                       ; 8 = device swap with device 8
                       ; 9 = device swap with device 9
                       ;10 = leave partition-select-mode always
;================================================================================================
l25890:                ;                                                               sleep-mode
       #if (partname == 4) | (partname == 5) | (partname == 7)    
        #message nlq-hd/HD-routines
        ldi r16,$20    ;%00......
        sts ovhbtr,r16 ;overwrite HD-buffer-transfer read
                            ; 0=IDE-HD (always master)
                            ; 1=IDE-CDROM (not supported) (always slave)
                            ; 2=SD/MMC-card
                       ;sets override flag for IDE-HD-hardware 
                       ; at least one bit of bit5-0 must be set to avoid $00 waht whould be
                       ;  no override function  
        ldi r17,$e6    ;sleep-command (or $99?)
        call l14580    ;sends command
       #endif

        cli            ;disables IRQs     
        sts dsdati,r06 ;#$00 dataspace date time (important that reset routine makes ata-reset
                       ; active        
        call l12990    ;makes all lines of IEC-port inactive
        call l10800    ;active-LED=off
        call l10770    ;error-LED=off

l25900: rcall l25960   ;reads mode-switch
        bst r27,7
        brts l25900    ;b.i.mode-switch not pressed  waits until mode switch pressed

        rcall l25950   ;100000µs =0.1s waitingloop
                       ;it could be that the switch swings = it could be that 1 switch-press
                       ; makes several contacts
                       ; to avoid this after every change of the switch-level the AVR waits
                       ; 0.1s until the swinging (probably) ended    
                       ; => maximal 5 switch-presse per second are possible
        
l25910: rcall l25960   ;reads switches
        bst r27,7      ;copies result-bit of mode-LED to T-flag
        brtc l25910    ;b.i.mode-switch still pressed = waits until mode-switch get switched off
                       ;doesn't matter that LED is often switched off, because LED is on
                       ;because switch is pressed

        ldi r16,$03    ;flag for AUJ => hardware reset of HD
        clt            ;flag for software-reset    
        rjmp l23970    ;software reset
;------------------------------------------------------------------------------------------------
l25920: ldi r22,$20    ;                           test switch for 0.25s   ends if switch pressed

l25930: rcall l25960   ;reads switches (39000µs) and makes average
        bst r27,7      ;result-bit of error/mode-switch
        brtc l25940    ;b.i.mode-switch pressed

        bst r27,5      ;result-bit of active/value-switch
        brtc l25940    ;b.i.value-switch pressed

        dec r22        ;32*7800=250000 = 0.234s
        brne l25930        

l25940: ldi r22,$00
        ret            ;T-flag=clear=switch pressed  set=not pressed
;------------------------------------------------------------------------------------------------
l25950: ldi r25,$27    ;$27=39                                               100000µs waitingloop
        call l10840    ;390µs waiting loop                                       r22 must be #$00 
        dec r22
        brne l25950    ;256*390=99840µs
        ret            ;r22=#$00 again
         #endif ;644-NLQ-HD/all
;------------------------------------------------------------------------------------------------
l25960: ldi r26,$03    ;counter for 3 loops

        ldi r27,$00    ;clears result-register of switches

        ldi r25,$c9    ;c9--
        rcall l23560

l25970: ldi r25,$c8    ;200*10=2000
        call l10840    ;2000µs delay (,where LED are not switched off) 

        rcall l25980   ;read switches 600µs (200µs LED off)

        mov r25,r19    ;..-- (I2C-port)
        rcall l23560

        in r25,PinB    ;..-- (PinB)
        rcall l23560

        in r25,PinD    ;..-- (PinD)
        rcall l23560
       
        add r27,r19

        dec r26
        brne l25970    ;

        ret
                       ;LED is 200µs of 2600µs off =  10%off 90%on
                       ; => user doesn't see that LED is darker
                       
                       ;2600µs * 3 = 7800µs

                       ;reads ports 3 times and makes average
                       ;bit7 = result of error-LED  0=pressed  1=notpressed
                       ;bit5 = result of active-LED  0=pressed  1=notpressed
;------------------------------------------------------------------------------------------------
                       ;from l25500, l25970
l25980:                ;                                                   reads port of switches
       #if partname == 3 
        #message 644-NLQ-HD/sd2iec
        rcall l23910       ;81    10µs waiting loop                
        in r08,piswva     ;1 reads pin switch value (same as piswmo)
        clr r19           ;1
        bst r08,biswmo    ;1 copies switch-mode-bit to T-flag
        bld r19,6         ;1 copies switch-mode-bit to bit 6 of r19
        bst r08,biswva    ;1 copies switch-value-bit to T-flag
        bld r19,4         ;1 copies switch-value-bit to bit 4 of r19
        in r08,pisdcd     ;1 pin sd-card-detect
        bst r08,bisdcd    ;1 copies sd-card-detect-bit to T-flag
        clr r28           ;1
        bld r28,4         ;1 copies sd-card-detect-bit to bit 4 of r28
                          ; = 90cycles = 11µs
        ldi r25,$3b       ;$3d=59  
        jmp l10840        ;590µs delay so that this direct routine is as long as the 
                          ;  I2C-port one 
       #endif ;644-NLQ-HD/sd2iec

       #if partname == 4   ;                              (and switch error-LED off and restores)
        #message 644-NLQ-HD/lite
        in r10,ddleer     ;1 backups datadirection LED error & active
        cbi ddleer,bileer ;1 datadirection errorLED=input 
        sbi poleer,bileer ;1 port LED error = pullup-resistor on
                          ;it's important to activate the pullup-resistor because the 
                          ;74LS244-input alone doesn't pull up the AVR-input to high
                          ;=> it takes 0.75µs until AVR-pins goes to high
        cbi ddleac,bileac ;1 datadirection LED active=input 
        sbi poleac,bileac ;1 port LED active = pullup-resistor on
        rcall l23910       ;81    10µs waiting loop                
        in r08,pileer     ;1 reads pin LED error
        cbi poleer,bileer ;1 port LED error = pullup-resistor off / 0V
        cbi poleac,bileac ;1 port LED active = pullup-resistor off / 0V
        out ddleer,r10    ;1 restores datadirection LED error
        clr r19           ;1
        bst r08,biswmo    ;1 copies switch-mode-bit to T-flag
        bld r19,6         ;1 copies switch-mode-bit to bit 6 of r19
        bst r08,biswva    ;1 copies switch-value-bit to T-flag
        bld r19,4         ;1 copies switch-value-bit to bit 4 of r19
                             ; = 90cycles = 11µs
        ldi r25,$3b       ;$3d=59  
        jmp l10840        ;590µs delay so that this direct routine is as long as the 
                          ;  I2C-port one 
        
        
                          ;LED is switched of for 10µs
                ;time from  LED-pin is made from low-output to input
                ;     to    pin isn't read low but is read high
                ;    -NLQ-HD-lite (without driver chips at LEDs): -0.125µs still low
                ;                 (with 2mA-LED)                  -0.250µs already high
                ;    -NLQ-HD-normal (with driver chips at LEDs):
                ;             -without internal pullup-resistors: even after 25000µs still low
                ;             -with internal pullup-resistors:    -0.625µs still low
                ;                                                 -0.750µs already high
                ;     (driver chip: 74LS244 (but probably the same with 74LS07 ????))
                ;      a 7407 (not LS) works: At the IEC-pins it pulls the pins fast enought
                ;                             to high (there are no pullups activated 
                ;                             at IEC2IEEE and NLQ-HD (Nov.2007)) 
       #endif ;644-NLQ-HD/lite
    
      #if partname == 6   ;                         (and switch error-LED off and restores)
        #message 644-NLQ-HD/SDonly
        ;cli               ;perhaps important for RTC-LED?        
                       ;not necessary as long as RTC-LED is at a different port as 
                       ;error- &active-LED
        in r10,ddleer     ;1 backups datadirection LED error & active
        cbi ddleer,bileer ;1 datadirection errorLED=input 
        sbi poleer,bileer ;1 port LED error = pullup-resistor on
                          ;=> it takes 0.75µs until AVR-pins goes to high
        cbi ddleac,bileac ;1 datadirection LED active=input 
        sbi poleac,bileac ;1 port LED active = pullup-resistor on
        rcall l23910       ;81    10µs waiting loop                
        in r08,pileer     ;1 reads pin LED error
        cbi poleer,bileer ;1 port LED error = pullup-resistor off / 0V
        cbi poleac,bileac ;1 port LED active = pullup-resistor off / 0V

        in r25,ddlert     ;same ddr as ddleer and ddleac (DdrD)
        bst r25,bilert    ;copies LED-RTC-bit to T-flag
        bld r10,bilert    ;copies T-flag 
        out ddleer,r10    ;1 restores datadirection LED error
        ;sei
        
        clr r19           ;1
        bst r08,biswmo    ;1 copies switch-mode-bit to T-flag
        bld r19,6         ;1 copies switch-mode-bit to bit 6 of r19
        bst r08,biswva    ;1 copies switch-value-bit to T-flag
        bld r19,4         ;1 copies switch-value-bit to bit 4 of r19
                          ; = 90cycles = 11µs
        
        in r08,pisdcd     ;1 pin sd-card-detect
        bst r08,bisdcd    ;1 copies sd-card-detect-bit to T-flag
        clr r28           ;1
        bld r28,4         ;1 copies sd-card-detect-bit to bit 4 of r28
                          ; = 90cycles = 11µs
        ldi r25,$3b       ;$3d=59  
        jmp l10840        ;590µs delay so that this direct routine is as long as the 
                          ;  I2C-port one 
       #endif

       #if partname == 7
        #message 644-NLQ-HD/full
                       ;I2C: 100kHz => 1bit = 10µs
                       ;    => 1byte = 100µs
                       ;    => 6bytes = 600µs
                       ; reading switches at I2C-port.chip is 300µs
        lds r10,i2pova ;backups I2C-port-value
     
        lds r20,i2pova ;I2C-port-value                              sets r20 to I2C-parallel-port
        ori r20,$03    ;or-mask for switching both LEDs off
        rcall l23790   ; not rcall l23770, because then the debugbuffer would be overwritten
    
        rcall l23820   ;reads I2C-parallel-port to r20  (and don't print debugbytes)
        clr r19
        bst r20,biswmo ;copies switch-mode-bit to T-flag
        bld r19,6      ;copies switch-mode-bit to bit 6 of r19
        bst r20,biswva ;copies switch-value-bit to T-flag
        bld r19,4      ;copies switch-value-bit to bit 4 of r19
        
        bst r20,bisdcd ;1 copies sd-card-detect-bit to T-flag
        clr r28        ;1
        bld r28,4      ;1 copies sd-card-detect-bit to bit 4 of r28

        mov r20,r10    ;restores I2C-port-value  (switch LED on again => LED is about 200µs off)
        rjmp l23790    ;writes r20 to I2C-parallel-port (and don't write debugbytes)    
       #endif
;================================================================================================
/*
                       ;still make for all 3 device-emulation-entries

                       ;compute free clusters and first free cluster from FAT
l25990:                ;                          -------begin free clusters---------------------
                       ;still make an EEPROM configuration flag for (not) reading free clusters
                       ; from HD at every reset 
        rcall l24260   ;test if first reset (sets r28,r29=Y) 
                       ;Y shows to a position in dsdati ($10b0-10bf)
        brne l26000    ;b.i.first reset after switched on
        rjmp l26200    ;in at-reset-not-cleared-memory there are already the correct values
                       ; => AVR not switched on-reset, but reset of reset-in
                       ; => don't calculate free clusters again (it's too slow)
                          
l26000: st y+,r06      ;clears 10b0/10b1/10c0 - 10ff
        cpi r28,$00    ;(sometimes doesn't clear 10b0-10bf but doesn't matter
        brne l26000    ;  is overwritten with date&time later)   

                       ;problem: The last FAT-sector doesn't contain until the end FAT-entries
                       ;it contains waste but this waste is filled with #$00
                       ;you cannot add of all FAT-sectors the FATentries with 00000000.
                       ;there would be too many free clusters because the waste-one would als be 
                       ; added.
                       ;=> one must compute the amount of to-add clusters from the length of the
                       ; data area

                       ;(1) compute length of data-area (in sectors)
        lds r12,sbpada ;sectorbegin partition data                                    00000533               
        lds r13,sbpada+1
        lds r14,sbpada+2
        lds r15,sbpada+3
        
        lds r16,sbpaen ;sectorbegin partition end+1                                   000139c5               
        lds r17,sbpaen+1
        lds r18,sbpaen+2
        lds r19,sbpaen+3

        sub r16,r12    ;subtracts   sb partition end+1                                000139c5 
        sbc r17,r13    ;  minus     sb partition data                                -00000533 
        sbc r18,r14    ;                                                           ----------- 
        sbc r19,r15    ;result= length of dataarea in sectors (not clusters)          00013492
   
                       ;(2) compute length of data-area (in clusters)
        lds r20,sepecl ;sectors per cluster 01, 02, 04, 08, $10, $20, $40
        rjmp l26020
      
l26010: lsr r19        ;divission by 2
        ror r18
        ror r17
        ror r16
        
l26020: lsr r20        ;counter for amount of loops
        brcc l26010    ;                                                              00013492 
                       ;if there was a at the end an amount of sector which are less
                       ; than sectors-per-cluster then this sectors wouldn't be used
                        
                       ;(3) add 2 clusters (because cluster 00000000 and 00000001
                       ;                don't exist physically but there are
                       ;                FAT-entries for them)
        ldi r20,$02
        add r16,r20
        adc r17,r06    ;#$00 adds carry
        adc r18,r06
        adc r19,r06    ;                                                              00013494

                       ;(4) compute amount of FAT-sectors
                       ;     1 FAT-entry = 4 bytes
                       ;     1 FAT-sector contains $80 = 128 FAT-entries 
                       ;     => divide amount of cluster by $80
                       ;     (remainder contains amount of FAT-entries of last
                       ;      FAT-sector)
        ldi r20,$07    ;7 divission by 2 = divission by $80
        
l26030: lsr r19        ;divission by 2 
        ror r18
        ror r17
        ror r16
        ror r21        ;remainder
        dec r20
        brne l26030    ;                                                              00000269

        lsr r21        ;make bits of remainder to correct position ($00-7f)                    14
                       ; 1 FAT-sector contains maximal $80 FAT-entries ($00-7f)
                       ;if #$00 then -there is no partially filled last FAT-sector
                       ;             -all FAT-entries fit exactly in last FAT-sector
                       ;if #$01-7f then there is a partially filled last FAT-sector

        ldi r24,$80
        sts innash+5,r24 ;default for $80 FAT-entries in 1 FAT-sector
                       ;=default for non-last FAT-sectors which contain all $80 FAT-entries
        sts innash+4,r24 ; remainder = amount of FAT-entries of last FAT-sector
                       ;    =default for all FAT-entries fit exactly in last FAT-sector

        cpi r21,$00
        breq l26040    ;b.i.all FAT-entries fit exactly in last FAT-sector 

                       ;= there is a last FAT-sector which is filled partially only
                       ;=> load this additional one sector too
        ldi r20,$01
        add r16,r20
        adc r17,r06    ;#$00 adds carry
        adc r18,r06
        adc r19,r06    ;                                                               0000026a

        sts innash+4,r21 ; remainder = amount of FAT-entries of last FAT-sector                14  

                       ;r16-r19 = amount of FAT-sectors 
                       ;          (with last one which isn't filled completely)
                       ;          if all FAT-entries fit exactly in 1 FAT-sector
                       ;          then there is no additionally to-loaded FAT-sector


l26040: lds r12,sbpaf1 ;sectorbegin partition FAT1
        lds r13,sbpaf1+1
        lds r14,sbpaf1+2
        lds r15,sbpaf1+3

        ldi r20,$00    ;clears counter for free clusters
        ldi r21,$00
        ldi r22,$00
        ldi r23,$00

        ldi r24,$01     ;....0001 request sector only without copying datas from HD 
        sts ashbtr,r24  ;actual SA HD-buffer-transfer read (0-17)
                        
        sts fifrcl+3,r07 ;#$ff sets flag that first free cluster isn't already found
                        
                         ;r11     counter for sectors in this loop  
                         ;r12-r15 LBA-address of first of $0001-0100 requested FAT-sectors
                         ;r16-r19 amount of remaining FAT-sectors which must be read from HD
                         ;r20-r23 counter free clusters  
                         
                         ;r28     counter for FAT-entries in 1 sector 00-7f
                         ;r29     amount of FAT-entries
                         ;r30     amount of requested sectors in this loop
                         ;           = lowbyte requested sectors
           
        ;ldi r26,$00
        ;ldi r27,$04

        rjmp l26140      ;-------------------------------

l26050:                  ;----------------------------------loop---------------------------------   
        mov r30,r16     ;backup amount of requested sectors?
  
        ;st x+,r12
        ;st x+,r13
        ;st x+,r14
        ;st x+,r15

        ;lds r24,innash
        ;st x+,r24
        ;st x+,r17
        ;st x+,r18
        ;st x+,r19

        ;st x+,r20
        ;st x+,r21
        ;st x+,r22
        ;st x+,r23

        ;st x+,r16
        ;lds r24,innash+4
        ;st x+,r24
        ;lds r24,innash+5
        ;st x+,r24
        ;st x+,r06
 
        ldi r17,$20     ;command: read with retry
        call l14940     ;r16 = amount of requested sectors
                        ; at CHS-HDs: r12-r15 is changed

        clr r11        ;counter for sectors in this loop

l26060: ldi r25,$3d    ;3d-- xx-- xx-- xx-- xx--                          --------loop-----------
        call l13060    ;first sector of this loop (LBA)
                       ;external RAM must be on to write into debugbuffer

        call l14070    ;wait until drive isn't busy and read statusregister
                       ;!!!switches external RAM on++++++++++++++++++++++++++++++++++++++++++++++
        andi r18,$08   ;masks data Request bit
        brne l26070    ;b.i.data

        ldi r17,$10    ;10-- 16--
        jmp syserr     ;------

l26070: mov r25,r18    ;  -- data request bit
        rcall l23560
        
        mov r25,r11    ;  -- counter sectors in this loop
        rcall l23560

        mov r25,r30    ;  -- amount of sectors in this loop
        rcall l23560
       

        ldi r16,idreda ;IDE register data %..000...
        out PrtD,r16  ;addresses register fe=Status

        ldi r28,$00    ;counter for FAT-entries in 1 sector  (counts 0-7f) 
                       ;$200 (512) bytes in 1 sector     4bytes=1FATentry
                       ;$0200/4=$80

        ldi r29,$80    ;default for $80 FAT-entries in this FAT-sector
        mov r16,r11    ;counter sectors in this loop
                       ;it's important not to increment r11 here, because it's later needed
                       ; for computing first free cluster
        inc r16
        cp r16,r30     ;tests whether it's the last FAT-sector in this $0100 FAT-sector-loop
        brne l26080    ;b.i.this is not the last FAT-sector in this $0100 FAT-sector-loop

                       ;=the last FAT-sector in this $0100 FAT-sector-loop
        lds r29,innash+5 ;amount of FAT-entries in this FAT-sector
                       ;$01-7f = last sector of FAT which is 
                       ;         partially filled only with FAT-entries
                       ;$80    = last sector of FAT which is filled completely with FAT-entries
                       ;$80    = not last FAT-sector (this is not the last $0100-FAT-sector-loop)
                       ;!! $80 can be both !!

l26080: mov r25,r28    ;  -- counter FAT-entries in this FAT-sector
        rcall l23560

        mov r25,r29    ;  -- amount of FAT-entries in this FAT-sector
        rcall l23560

        lds r16,fifrcl+3 ;first free cluster highestbyte
        bst r16,7      ;copies bit 7 of first free cluster highestbyte into T-flag
                       ;0=first free cluster already found
                       ;1=first free cluster not yet found

       #if partname == 1 ;                        
        #message 162-IEC-ATA-V2 ;                 
        ldi r25,$02
        out Mcucr,r25  ;exmem off ($00)----------------------------------------------------------
       #endif ;162-IEC-ATA-V2
 


                       ;125ns delay  (should be >=70ns) 
    
l26090: cbi poatdr,biatdr ;dioR = active (=low)                      ----sectorloop----

        nop
        nop
        nop            ;5*125ns=625ns delay (should be >=600ns)
        nop
        nop    
 
        in r16,PinA    ;reads data0-7
        in r17,PinC    ;reads data8-15

        sbi poatdr,biatdr ;dioR =inactive (=high)
 
        mov r24,r16    ;for test wehther FATentry is free 
        or r24,r17     ;for test wehther FATentry is free 
        nop
        nop
        nop

        
        cbi poatdr,biatdr ;dioR = active (=low)

        nop
        nop
        nop            ;5*125ns=625ns delay (should be >=600ns)
        nop
        nop    
 
        in r18,PinA    ;reads data0- 7 (16-23)
        in r19,PinC    ;reads data8-15 (24-27)

        sbi poatdr,biatdr ;dioR =inactive (=high)

        andi r19,$0f   ;cluster highestbyte: masks off bit 31-28 because clusers are bit0-27 only

        or r24,r18     ;for test whether FATentry is free 
        or r24,r19

        brne l26110    ;b.i.this FAT-entry isn't free
        
        brtc l26100    ;b.i.first free cluster is already found   
        
       #if partname == 1       
        #message 162-IEC-ATA-V2 
        ldi r19,$82
        out Mcucr,r19  ;exmem on+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       #endif ;162-IEC-ATA-V2
                       ;problem: after last loop acsehb (low) can be different from begin value
                      
                       ;example: FAT1 begins at $000646a0
                       ;                  (=LBA0-3:a0 46 06 00)  000646a0   000646a0   000646a0
                       ;first free cluster is                    00000003   00004003   00008003
                       ;FATstartsector of $0100 loaded sectors   000646a0   000646a0   000647a0
                       ;counter FATsectors in this loop = r11          00         80         00
                       ;counter for FATentries in 1 sector = r28         03         03         03
        lds r17,acsehb+1 ;actual loaded FATsector high               46         46         47
        lds r18,acsehb+2 ; (first of $100 loaded) higher           06         06         06
       ;lds r19,acsehb+3 ; (later: -> waste)      highest        00         00         00  

        lds r16,sbpaf1+1 ;sectorbegin partition FAT1 high            46         46         47   
        sub r17,r16    ;subtracts actual loaded sector               46         46         46
                       ; minus secor of FAT1-begin      (result)     00         00         01         

        lds r16,sbpaf1+2 ;sectorbegin partition FAT1 higher        06         06         06 
        sbc r18,r16    ;(r12 (lowbyte) changes never               06         06         06
                       ;=> subtraction not necessary)   (result)   00         00         00
                       ;   (#$a0 - #$a0 = #$00) 

       ;lds r16,sbpaf1+3 ;sectorbegin partition FAT1 highest     00         00         00  
                       ; (later: -> waste)                       00         00         00 
       ;sbc r19,r16    ;result = in which sector of FAT the
                       ; free cluster is found (result always)   00         00         00  
                       ;(lowbyte = r11)                 (result) 000000     000000     000001
    
        mov r16,r11    ;= counter for sectors in this loop             00         80         00
                       ;   = lowbyte                          
                       ;result = in which sector of FAT the      00000000   00000080   00000100 
                       ;free cluster is found     
                       
                       ;1 FATentry = 4 bytes of a FATsector
                       ; => 1 FATsector = 512 bytes = 128 FATentries
                       ; => FATsector contains values for cluster
                       ;    00000000           00000000-0000007f
                       ;    00000001           00000080-000000ff

                       ;    000001ff           0000ff80-0000ffff
                       ;    00000200           00010000-0001007f  (min clusteramount = 00010000)

                       ;    001fffff           0fffff80-0fffffff  (max clusteramount = 0fffffff)
                       ;FAT32 is 28bit only, not 32bit     FAT28 would be a better name
                       ;maximal size of a FAT: $200000*512bytes = 1073741824bytes = 1024mb = 1gb
                       ;minimal size of a FAT: $000200*512bytes =     262144bytes = 256kb
                       ;maximal size of FAT is $00200000 
                       ; => highestbyte of FAT-length is always #$00
                       ;  => it's perhaps not necessary to decrement r19 at l26130 ??

                       ;=> clusteraddress = FATsector * $80
                       ; multiplicate FATsector with $80 to receive cluster 
                       ;= division by 2  = same as multiplication by $80 (128) but shorter)
                       ;                              FATsector
                       ;                              001fffff   00000000   00000080   00000100 
       ;lsr r19        ;highestbyte -> waste
                       ;(always #$00 not necessary)   00c        00c        00c        00c
        ror r18        ;higherbyte->highestbyte         0fs        00c        00c        00c  
        ror r17        ;higbyte->higherbyte               ffs        00c        00c        00s
        ror r16        ;lowbyte->highbyte                   ffs        00c        40c        80c
                       ;                                0fffffs    000000c    000040c    000080c
        clr r24       
        ror r24        ;->bit7 of lowbyte               0fffff80   00000000   00004000   00008000
                       ;counter for FATentries in 
                       ;1 sector = r28                        7f         03         03         03
        or r24,r28     ; bit6-0 of lowbyte                    7f         03         03         03         
                       ;r28=counter for FATentries      0fffffff   00000003   00004003   00008003
                       ; in one FATsector ($00-$7f)     Cluster

                       ;the test whether it's a legal cluster is at l26180 - l26190

        sts fifrcl,r24 ;first free cluster
        sts fifrcl+1,r16
        sts fifrcl+2,r17
        sts fifrcl+3,r18

        clt            ;makes flag that first free cluster is already found

       #if partname == 1 ;                        
        #message 162-IEC-ATA-V2 ;                 
        ldi r25,$02
        out Mcucr,r25  ;exmem off ($00)----------------------------------------------------------
       #endif ;162-IEC-ATA-V2

l26100: inc r20        ;increments counter for free clusters
        brne l26110 
        inc r21
        brne l26110 
        inc r22
        brne l26110 
        inc r23
        
l26110: inc r28        ;counter for FAT-entries in 1 sector 00-7f
        cp r28,r29     ;compares counter of FAT-entries and amount of FAT-entries
        breq l26120    ;b.i.all wanted FAT-entries read (usually $80)
        rjmp l26090    ;=read next FAT-entry of this FAT-sector (usually $00-$7f)---sectorloop---
        
l26120:
       #if partname == 1       
        #message 162-IEC-ATA-V2 
        ldi r16,$82
        out Mcucr,r16  ;exmem on+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       #endif ;162-IEC-ATA-V2 ;
    
        inc r11        ;increments counter for sectors in this loop 
        cp r11,r30     ;compares counter for sectors and amount of sectors in this loop
        breq l26130
        rjmp l26060 
                       
l26130:                ;=all sectors of actual sector-loop have been read 
        lds r12,acsehb ;actual sector HD-buffer  
        lds r13,acsehb+1 ;always in LBA-format 
        lds r14,acsehb+2 ; this is the first of the requested $100 sectors
        lds r15,acsehb+3 ; this is necessayr because r12-r15 is changed at LBA->CHS-computing      
                       ;this wouldn't be necessary at a LBA-HD (no LBA->CHS-computing)      
       
        lds r16,innash ;amount of FAT-sectors which must be still read from HD   
        lds r17,innash+1    
        lds r18,innash+2 
        lds r19,innash+3 
        
        ldi r24,$01    ;highbyte of requested $0100 sectors
        add r13,r24    ;adds higbyte requested $0100 sectors
        adc r14,r06    ;#$00 adds carry
        adc r15,r06

        subi r17,$01   ;subtracts amount of requested $0100 FAT-sectors
        sbci r18,$00
        sbci r19,$00
        brcs l26180    ;b.i.there have been less than $0100 sectors requested  in actual
                       ;loop before = end

l26140: sts acsehb,r12 ;stores to actual sector HD-buffer  
        sts acsehb+1,r13 ;stores allways in LBA-format
        sts acsehb+2,r14 ;flag for don't write into HD-buffer is cleared
        sts acsehb+3,r15 ;=> this isn't made at rcall l14940
                         ; this is the first of the requested $100 sectors

        sts innash,r16 ; inputname short   !!!!temporary!!!!
        sts innash+1,r17 ; store to any memory which is cleared later before its use !!!!
        sts innash+2,r18 ;= amount of FAT-sectors which still must be read from HD
        sts innash+3,r19
                
        or r19,r18      ;checks whether the two higher bytes of the still to load FAT-sectors
                        ;are equal or not
        brne l26160     ;b.i.remaining amount of to-read FAT-sectors > 0000ffff (65535) sectors
                         
        cpi r17,$01     ;        $00  $01  $02-ff
                        ;          s    c    c  c
        brcs l26170     ;b.i.$00-$ff sectors still to read
        
                        ;=still $0100-ffff sectors to read
        brne l26160     ;b.i.$0200-ffff sectors to read
        
                        ;= still $0100-01ff sectors to read
        cpi r16,$00     
        brne l26160    ;b.i.$0101-01ff sectors to read
        
                        ;= still exactly $0100 sectors to read                                  

l26150:                 ; => there are 2 possibilities:
                        ;  - the last FAT-sector is completely filled with FAT-entries
                        ;  - the last FAT-sector isn't completely filled with FAT-entries 

                        ;=this will be the last sector-loop 
                        ; it's now possible that the last FAT-sector 
                        ;contains partially only FAT-entries (and waste at the end) 

        lds r29,innash+4 ;amount of FAT-entries of last FAT-sector (former remainder)
        sts innash+5,r29 ;amount of FAT-entries in last FAT-sector of this next sector-loop
                       ;   ($01 -$80)   
        rjmp l26050    ;request last FAT-sector-loop 
                       ;   with FAT-sector which filled perhaps partially only-------------------

l26160: ldi r16,$00    ;#$00 = request $100=256 sectors from HD
        rjmp l26050    ;requests next $01-$0100 sectors (1-256)----------------------------------

l26170: cpi r16,$00    ;=remainig FAT-length 00 - ff sectors
        brne l26150    ;b.i.not all FAT-sectors have been read = b.i.01-ff
                       ;amount of FAT-sectors to load from HD = 00000000-------------------------

l26180:
       #if partname == 1     
        #message 162-IEC-ATA-V2

        out PrtD,r07  ;addressregister to high (saves energy?)

       #endif ;162-IEC-ATA-V2

       #if (partname == 4) | (partname == 7)    
        #message 644-NLQ-HD/full

        ldi r16,idrecs ;IDE register command/status  %..111...  = also value for inactive
        out PrtD,r16

       #endif ;644-NLQ-HD/lite-lite & full

        lds r16,fifrcl+3 ;highestbyte first free cluster
        cpi r16,$10
        brcs l26190    ;b.i.there was a free cluster found and it is legal

        sts fifrcl,r06 ;#$00 clears first free cluster
        sts fifrcl+1,r06
        sts fifrcl+2,r06
        sts fifrcl+3,r06
 
l26190:                ;r20-23 contain now number of free clusters
        ldi r25,$3e    ;3e----
        call l13090

        mov r25,r20 
        rcall l23560

        mov r25,r21 
        rcall l23560

        mov r25,r22
        rcall l23560

        mov r25,r23
        rcall l23560

        ldi r25,$3f    ;3f--
        rcall l23560

        sts acsehb+3,r07 ;#$ff  makes flag that there is no sector in actual HD-buffer
  
        sts amfrcl,r20
        sts amfrcl+1,r21
        sts amfrcl+2,r22
        sts amfrcl+3,r23

l26200:                ;                          -------end free clusters---------------------

*/
;================================================================================================
       #if (partname == 3) | (partname == 6) | (partname == 7)   
        #message 644-NLQ-HD/SD-routines
                       ;SD:   <= 2GB
                       ;SDHC: <=32GB (high capacity)
                       ;SDXC: <= 2TB (extended capacity)         

                       ;Probably:
                       ;bit7 is sent first   bit0 last
                       ;Clock-edge from high to low:
                       ; -AVR can make AVR-DtaOut (=SD-DtaIn) to bus immediately
                       ; -SD-card makes SD-DtaOut (=AVR-DtaIn) to bus
                       ;Clock edge from low to high:
                       ; -AVR must hold AVR-DtaOut constant 5ns before and 5ns later 
                       ;   -> SD-card reads at edge the data-line
                       ; -SD-card holds at this edge the SD-DtaOut-line constant
                       ;   -> AVR reads at edge the data-line   

                       ;sd.pdf   Benutzen einer SD-Speicherkarte mit dem ATmega-Microcontroller
                       ; uses SPI-Mode 0 (p8)
                       ; p11: LBA-addresses are sent highbyte first (!!opposite to IDE and 
                       ;  AVR-memory!!)
                       ; p13: CRC is ignored, but 2 bytes must be sent or read

                       ;========================================================================= 
                       ;SPL=Simplified_Physical_Layer_Spec.pdf
                       ;commands:
                       ; length: 6bytes (p101)
                       ; bit47:    0 startbit
                       ; bit46:    1 transmission
                       ; bit45-40:   command index (=0 for CMD0, 8 for CMD8, $29 for ACMD41???)   
                       ;                            (=> CMD0-63 possible???)
                       ; bit39-08:   argument (4 bytes = bit31-0 of argument)
                       ; bit07-01:   CRC7
                       ; bit00:    1 stoppbit
                       ;-------------------------------------------------------------------------
                       ;response:
                       ;  direct answer of SD after a 6bytes-command?
                       ;-R1 (=normal response)
                       ; length: 1byte (p109) 
                       ; bit7: 0 (startbit?)
                       ; bit6: parameter error
                       ; bit5: address error 
                       ; bit4: erase sequence error
                       ; bit3: com crc error
                       ; bit2: illegal command
                       ; bit1: crasc reset
                       ; bit0: in idle state: if 1 then: the card is in idle state and
                       ;                              running the initializing process
                       
                       ;-R1b (=busy-response???)
                       ; legth: 1byte
                       ; $00: card is busy
                       ; $01-ff: card isn't busy  
                       ;perhaps: normal R1-response but afterwards card makes dataOut = low
                       ; to signal that it is busy?????

                       ;-R2 (=answer to send-status-command)
                       ; length: 2bytes
                       ; see SPL p110

                       ;-R3
                       ; length: 5bytes = 1byte-R1 + 4bytes-OCR
                       ; response of CMD58 (read OCR)
                       ;-R4, R5

                       ;-R7 (answer to send-if-command CMD8, e.g.supply voltage )
                       ;length: 5bytes
                       ;-------------------------------------------------------------------------
                       ;-Start Block Tokens and Stop Tran Token
                       ; control data-transfer at read- and write-commands
                       ; sent as beginn of a 512databytes+2CRC-block?
                       ; byte$0000:                 token
                       ; byte$0001-$0200 (1-512):   datablock
                       ; byte$0201,$0202 (513,514): CRC
                       ; -For Single Block Read
                       ;      Single Block Write
                       ;      Multiple Block Read
                       ;          start block: %11111110
                       ; -For Multiple Block Write
                       ;          start block token: %11111100
                       ;          stop tran token:   %11111101 (stop transmission) 
                       ;-Data Tokens
                       ;Start Block Single Block Read    %11111110 $fe
                       ;Start Block Multiple Block Read  %11111110 $fe
                       ;Start Block Single Block Write   %11111110 $fe
                       ;Start Block Multiple Block Write %11111100 $fc
                       ;Stop Tran Multiple Block Write   %11111101 $fd
                      
                       ;-Data Error Token
                       ; bit7-3: %000
                       ; bit4:   %0 or card is locked (not clear what's correct)
                       ; bit3:   out of range
                       ; bit2:   card ECC failed
                       ; bit1:   CC error
                       ; bit0:   Error 
                       ;-------------------------------------------------------------------------
                       ;control tokens (p112) (=data-response?)
                       ;  controll data block transfer
                       ;  answer of SD after AVR had sent 512bytes+CRC at write command?
                       ;    (and answer of SD after AVR had sent CSD write command?)
                       ;   sd.pdf p16:
                       ;-data response token  (usually $e5)
                       ; =acknowledge of every data block written to the card
                       ; bit7: x
                       ; bit6: x
                       ; bit5: x
                       ; bit4: 0
                       ; bit3-1: %010 Data accepted   (=%...00101 e.g.e5,05...)  (usually $e5)
                       ;         %101 Data rejected due to a CRC error.
                       ;         %110 Data Rejected due to a Write Error
                       ; bit0: 1
                       ; after the $e5 the SD makes low (= AVR recieves $00) until SD has written
                       ;  block to flash (=busy)
                       ;-------------------------------------------------------------------------
                       ;CMD0-command:
                       ; go idle state
                       ; make ChipSelect-pin to 0V while command to switch
                       ;  from SD- to SPI-bus-routines
                       ; card sends R1-response (if in SPI-mode)
                       ; (no response if in SD-mode)
                      
                       ;CMD1 for MMC (and SD after having made ACMD41
                       ; ->R1 response in SPI-mode (MMC41) (R3-response in SD-mode ) 
                
                       ;CMD13 send status 
                       ; ->R1-response

                       ;CMD17 read single block
                       ; -> R1-response

                       ;CMD24 write single block
                       ; -> R1 response    
                       
                       ;CMD55
                       ; next command is a ACMD- (not CMD-) -command
                       ; ->R1 response

                       ;CMD58
                       ; read OCR
                       ; ->R3-response (5bytes = 1byte-R1 + 4bytes-OCR)

                       ;ACMD41
                       ; ->R1 response in SPI-mode (SPL107) (R3-response in SD-mode (SPL55)



                       ;OCR = 4bytes
                       ;CCS = bit of OCR



                       ;OCR  operation conditions register
                       ;      contains operation-voltage
                       ;     bit
                       ;     31: busy-bit  card power up status bit
                       ;          0=busy 1=not-busy (name is wrong,
                       ;                        should be 'ready-bit' or '-busy-bit')
                       ;     30: CCS  Card Capacity Status 
                       ;          0=standart capacity (<=2GB) 1=high capacity (>=4GB)
                       ;     29-24: reserved
                       ;     23: 3.5-3.6V  (bit7 of byte1) 
                       ;     22: 3.4-3.5
                       ;     21: 3.3-3.4
                       ;     20: 3.2-3.3V  <---   voltage of card / host
                       ;     19: 3.1-3.2
                       ;     18: 3.0-3.1
                       ;     17: 2.9-3.0
                       ;     16: 2.8-2.9   (bit0 of byte1)
                       ;     15: 2.7-2.8   (bit7 of byte2)
                       ;     14-0: reserved



                       ;PMS4-7: CMD0, 1, 2 do not clear the status register
                       ; The MultiMediaCard will not respond to ACMD41 (actually it will not
                       ; respond to APP_CMDCMD55, that precedes it). The MultiMediaCard will
                       ; be initialized as per the MultiMediaCard spec, using SEND_OP_COND
                       ; command (CMD1 of MultiMediaCard). The host should ignore an
                       ; ILLEGAL_COMMAND status in the MultiMediaCard response to CMD3, since it
                       ; is a residue of ACMD41 which is invalid in the MultiMediaCard
                       ; (CMD0, 1, 2 do not clear the status register). Actually, ACMD41 and CMD1
                       ; will be used by the host to distinguish between MultiMediaCard and SD
                       ; Cards in a system.
 
                       ;SPL113: As in the SD mode, error bits are cleared when read by the
                       ; host, regardless of the response format.
                       ; State indicators are either cleared by reading or are cleared in
                       ; accordance with the card state.
                       ; => illegal-command-error-bit seems to be cleared ar reading R1-response?

                       ;difference of MMC and SD:
                       ;SPL94: 2.1mm SD Memory Card can be initialized using CMD1 and Thin
                       ; (1.4mm) SD Memory Card can be initialized using CMD1 only after
                       ; firstly initialized by using CMD0 and ACMD41. In any of the cases
                       ; CMD1 is not recommended because it may be difficult for the host
                       ; to distinguish between MultiMediaCard and SD Memory Card.
                       ; If the SD card is initialized by CMD1 and the host treat it as 
                       ; MMC card, not SD card, the Data of the card may be damaged because of
                       ; wrong interpretation of CSD and CID registers.
                     
                       ;MMC4: V2.11 doesn't support multiple block read/write in SPI-mode
                       ;MMC1-3: V3.1 supppotrs multiple block read/write in SPI-mode
                       ; !!MMC-cards only (SD-cards support multiple-block-operations always)
                       ;V3.1 was released in June 2001 

                       ;MMC95: The CSD register is read. Unlike MMC mode, in which special
                       ; commands are used to read register values, in SPI mode CSD and CID
                       ; register contents are acquired by means of an ordinary simple read
                       ; block transfer. In response to a request from the host, an MMC returns
                       ; data by means of a standard Response token. That is, a request is
                       ; answered with a 16-byte data block and an associated 16-bit CRC.


                       ;Registers:
                       ;Each card has a set of information registers
                       ;CID  Card identification number   length: 16bytes              send CID
                       ;      card individual number for identification                CMD10
                       ;RCA  Relative card address 2bytes (not in SPI-mode)
                       ;DSR  Driver Stage Register 2bytes
                       ;      to configure the cards output drivers (Optional)
                       ;CSD  Card Specific Data 16bytes                                send CSD
                       ;      information about the card operation conditions          CMD9
                       ;SCR  SD Configuration Register 8bytes                          send SCR
                       ;      information about the SD Memory Cards Special Features  ACMD51
                       ;      capabilities
                       ;OCR   Operation conditions register 4bytes                     read OCR           
                       ;                                                               CMD58
                       ;SSR   SD Status 64bytes 
                       ;      information about the card proprietary features
                       ;CSR   Card Status 4bytes
                       ; information about the card status
                       ;-------------------------------------------------------------------------
                       ;CSD  Card Specific Data 16bytes
                       ;      information about the card operation conditions 
                       ; 
             ;byte bit ;bit      MMC                  SD-V1.0              SD-V2.0(>=4GB)  
             ; |    |  ;                              SD-V2.0 (<=2GB)            
             ; V    V 
             ; 00  7-6 ;127-126  csd_structure        csd_structure        csd_structure         
                       ;         %00 csd-v1.0         reserved %00        (%00 standard capacity)
                       ;         %01 csd-v1.1                              %01 high capacity   
                       ;        (%10, %11 reserved)                       (%10, %11 reserved)
                      
             ; 05  3-0 ;83-80    read_bl_len          read_bl_len          read_bl_len
                       ;         0-11                 9-11                 9 (fixed)
                       ;         (=> 1-2048)          (=> 512-2048)        (=> 512)
                       
             ; 06  1-0 ;73-62    c_size               c_size    
             ; 08  7-6 ;         (3nibbles)           (3nibbles)

             ; 09  1-0 ;49-47    c_size_mult          c_size_mult                noch falsch
             ; 0a   7  ;         (power of 2)         (power of 2)
                       ;         0-7                  0-7
                       ;         (=> 4-512)           (=> 4-512) 

             ; 06  3-0 ;75-70                                               reserved (%0..0)
                       ;69-48                                               c_size
             ; 0a   7  ;47                                                  reserved (%0)


                       ;read_bl_len = max. read data block length 
                       ; power of 2 (2^read-bl-len)
                       ;  0-8  reserved
                       ;   9   2^9 = 512 Bytes
                       ;  10   2^10 = 1024 Bytes
                       ;  11   2^11 = 2048 Bytes
                       ; 12-15 reserved
                       ;standard-capacity: 9 2^9   512bytes (always or usually???)
                       ;high-capacity:    10 2^10 1024bytes (always or usually???)
                       
                       ;read_bl_len: 512-2048bytes
                       ;c_size:        0-4095  ($000-$fff)
                       ;c_size_mult:   4-512
                       
                       
                       ;MMC & SD<=2GB  standard capacity                             block
                       ;blocknumbers = (c_size + 1) * (2 ^ (c-size-mult + 2))        length 
                       ;examples:                                                      | 
                       ;    8MB        ( 831   + 1) * (2 ^ ( 2          + 2))= 13312(*512=6.8MB
                       ;   16MB        ( 899   + 1) * (2 ^ ( 3          + 2))= 28768(*512=14.7MB) 
                       ;   32MB        (1867   + 1) * (2 ^ ( 3          + 2))= 59776(*512=30.6MB) 
                       ;   32MB        (2000   + 1) * (2 ^ ( 3          + 2))= 64032(*512=32MB)
                       ;   64MB        (3807   + 1) * (2 ^ ( 3          + 2))=121856(*512=62.3MB)
                       ;  128MB        (3843   + 1) * (2 ^ ( 4          + 2))=246016(*512=126MB)
                       ;    2GB        (4095   + 1) * (2 ^ ( 7          + 2))=2097152(*1024=2GB)   
                       ;(memory capacity = blocknumbers * read_bl_len)

                       ;SD>=4GB  high capacity
                       ;blocknumbers = (c_size + 1)  
                       ;(memory capacity = blocknumbers * 512)
                       ;max size: theoretical:  2TB (because 22bits length of c_size)
                       ;          at V2.00:    32GB (because upper 6 bits shall be %0...0)

                       ;attention:
                       ;  if csd_structure = %00 then it doesn't matter wheter MMC or SD
                       ;                               ( always standard capacity)
                       ;  if csd_structure = %01 then it's important to know wheter MMC or SD
                       ;                              if MMC then standard capacity
                       ;                              if SD  then high capacity

             ; 0e   7  ;15       file_format_grp      file_format_grp      file_format_grp
             ; 0e  3-2 ;11-10    file_format          file_format          file-format

                       ;file_format_grp   file_format
                       ;      %0             %00       hard disk like file system
                       ;                                with partition table
                       ;      %0             %01       DOS FAT (floppy like) with boot sector
                       ;                                only (no partition table)
                       ;      %0             %10       Universal file format 
                       ;      %0             %11       others / unknown
                       ;      %1           %00-%11     reserved
             ; ^    ^
             ; |    |
             ;byte bit ;bit      MMC                  SD-V1.0              SD-V2.0(>=4GB)  
                       ;                              SD-V2.0 (<=2GB)            

                       ;CSD  Card Specific Data 16bytes
                       ;      information about the card operation conditions 
                       ;-------------------------------------------------------------------------
                       ;AVR-644-doc: CS must be high after every datapacket???

                       ;sd.pdf: clock is low (0V) when in sd card id unused???

                       ;!!!!!!!!!!!!!!!!!!!!!!!!!!!
                       ;SPI-AVR-hardware-routines: SPI-clock is low when inactive (=correct)
                       ;SPI-software routines: SPI-clock is high when inactive (=wrong)
                       ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  

                       ;read time-out:  125ms (0.125s)
                       ;write time out: 250ms (0.25s)

;http://www.forum64.de/wbb3/index.php?page=Thread&postID=342270#post342270
;Unseen: Cheap SD-cards don't support SPI
;------------------------------------------------------------------------------------------------
/*
l26210: cbi pospdo,bispdo ;SPI-dtaOut = output-0V                                 SPI-DtaOut->low
        rjmp l26250    ; (SPI-dtaOut = open-collector)                  mustn't change carry
;------------------------------------------------------------------------------------------------
l26220: sbi pospdo,bispdo ;SPI-dtaOut = output-5V                                SPI-DtaOut->high
        rjmp l26250    ;                                                mustn't change carry
;------------------------------------------------------------------------------------------------
l26230: cbi pospcl,bispcl ;SPI-clock = output-0V (AVR not opencollector)             SPI-Clk->low
        rjmp l26250    ;                                                mustn't change carry
;------------------------------------------------------------------------------------------------
l26240: sbi pospcl,bispcl ;SPI-clock = output-5V (AVR not opencollector)            SPI-Clk->high
                        ; (SPI-clock = open-collector)                  mustn't change carry
                        ;........................................................................
l26250: ldi r25,$08     ;8                                                              3µs-delay
l26260: dec r25         ;1                                              mustn't change carry
        brne l26260     ;2 3*8=24 = 3µs
        ret
*/
;------------------------------------------------------------------------------------------------
                       ;from l
l26270: lds r20,msspcs ;memoryspace SPI-CS                          initialize SPI-SD-card-access
                       ; sd2iec:Pinb+$20                            if not yet active
                       ; NLQ-HD:I2C-port-value         
        andi r20,1<<bispcs ;masks SPI-CS
        breq l26290    ;b.i.SPI-CS is already active (0V)
                       ;.........................................................................
                       ;from l
l26280:                ;                                            initialize SPI-SD-card-access
                       ;                                           change r20, r25 
       #if partname == 3    
        ldi r20,0b01111111 ;                                         DtaIn  DtaOut  ClkOut  CSOut
        sts PrtB,r20
        ldi r20,0b10110000
        out DdrB,r20   ;DdrB                   DdrB PrtB             
                       ;7 AVR-SPI-ClkOut  o      1     0  0.0V                        0V
                       ;6 AVR-SPI-DtaIn   i      0     1  (to prevent inpt
                       ;                                    swinging)   
                       ;5 AVR-SPI-DtaOut  o      1     1  3.3V        inpt   3.3V     0V
                       ;4 AVR-SPI-CS      o      1     1  3.3V        inpt   3.3V     0V    3.3V 
                       ;3                 i      0     1 
                       ;2 (?IEC-AtnIn?)   i      0     1
                       ;1                 i      0     1 
                       ;0                 i      0     1
        
        ldi r20,0b01010001
        sts spcr,r20   ;SPI Control Register
                       ;7 SPI IRQ enable      0
                       ;6 SPI enable          1
                       ;5 data order          0  (highbit first)
                       ;4 master/slave select 1  (master)
                       ;3 clock polarity      0  (bit3&2:
                       ;2 clock phase         0      SPI-mode0)
                       ;1 spr1                0  500kHz
                       ;0 spr0                1  500kHz

                       ;spi2x spr1 spr0
                       ;  0     0    1    = 8MHz / 16 = 500kHz
                       ;  1     0    1    = 8MHz /  8 = 1MHz (used by iec2sd-software) 

        ldi r20,0b00000000
        sts spsr,r20   ;SPI status Register
                       ;7 SPI IRQ flag        0
                       ;6 SPI write colision  0
                       ;5                     0
                       ;4                     0
                       ;3                     0
                       ;2                     0
                       ;1                     0
                       ;0 spi2x               0  500kHz

        ;brcc l26290   :perhaps skips activating CS to make 74 clockcycles at 
                       ;hardware initialitation of SMC?????????????

        cbi pospcs,bispcs ; port-SPI-ChipSelect = low  = active       inpt   3.3V     0V     0V 
                       ;SPI-CS inactivated/activated 
                       ;= also flag for uart inactive/active for SPI
       #endif
  
       #if partname == 6    
                       ;problem: SPI-Clk must be probably low when inactive
                       ; but this causes 3.3mA current because of pullup-resistors
                       ; => make SPI-Clk high when SPI-CS is inactive (saves energy)
                       ;    and make SPI-Clk low before SPI-CS is activated (low)
                       ;SPI-Clk is also used as read-signal to IDE-HD

                       ;                                                DtaIn DtaOut ClkOut CSOut
        cbi ddspcs,bispcs ;                                                                 3.3V
        cbi pospcs,bispcs
                       ;pc3 SPI-chipselect  o    0    0   via diode                         3.3V 
                       ;                                  and resistor
                       ;                                  to SD-card
        
        sbi pospdo,bispdo
        sbi ddspdo,bispdo     
                       ;pd1 AVR-SPI-DtaOut  o    1    1   via resistors        3.3V         3.3V 
                       ;                                 to SDcardDtaIn
        
        cbi ddspdi,bispdi ;                                                                 3.3V
        cbi pospdi,bispdi
                       ;pd2 AVR-SPI-DtaIn   i    0    0   via resistors  inpt  3.3V         3.3V        
                       ;                                  fr.SDcardDtaOut

        cbi pospcl,bispcl ; port-SPI-ClkOut = low  probably not necessary 
                       ; SPI-USART initialisation makes this
        sbi ddspcl,bispcl ; Ddr-SPI-ClkOut = output                      inpt  3.3V   0V    3.3V   
                       ;b0 AVR-SPI-ClkOut 0    1    0
                       ;=> active to 0V =low  (necessary)

        sts ubr0h,r06  ;#$00 clears baudrate-register to ensure immediate initialization of
        sts ubr0l,r06  ;#$00  the XCKn (PB0) output

        ldi r20,0b11000000
        sts ucsr0c,r20 ;usart mspim control and status register 0 c
                       ;bit7,6: %11 = SPI-mode
                       ;bit2:    %0 = highbyte first
                       ;bit1:    %0 = clock-phase = idle low (=0V when inactive) 
                       ;bit0:    %0 = clock polarity 
                       ;              bit1&0: = SPI-mode0

        ldi r20,0b00011000
        sts ucsr0b,r20
                       ;bit4: %1 = receive enable
                       ;bit3: %1 = transmit enable   

        ldi r20,$09    ;set baudrate to 400kHz
        sts ubr0l,r20  ;the Baud Rate must be set after the transmitter is enabled 

        ;brcc l26290   :perhaps skips activating CS to make 74 clockcycles at 
                       ;hardware initialitation of SMC?????????????

        sbi ddspcs,bispcs ; port-SPI-ChipSelect = low  = active       inpt   3.3V     0V     0V 
                       ;4 SPI-chipselect  o    1    0          
                       ;SPI-CS inactivated/activated 
                       ;= also flag for uart inactive/active for SPI
       #endif

       #if partname == 7    
  
                       ;problem: SPI-Clk must be probably low when inactive
                       ; but this causes 3.3mA current because of pullup-resistors
                       ; => make SPI-Clk high when SPI-CS is inactive (saves energy)
                       ;    and make SPI-Clk low before SPI-CS is activated (low)
                       ;SPI-Clk is also used as read-signal to IDE-HD

        ldi r20,0b00111110 ;DdrD                                     DtaIn  DtaOut  ClkOut  CSOut                          
        out PrtD,r20  ;PrtD                                                                ?3.3V?
        ;ldi r20,0b00111110 ;PrtD
        out DdrD,r20   ;DdrD                  DdrD PrtD
                       ;7 I2C-Dta        i/o   0     0  p (3.3V)
                       ;6 I2C-Clk        i/o   0     0  p (3.3V)
                       ;5 ATA-DA2         o    1     1        
                       ;4 ATA-DA1         o    1     1
                       ;3 ATA-DA0         o    1     1 
                       ;2 ATA-DioW        o    1     1
                       ;1 AVR-SPI-DtaOut  o    1     1  via LS07 to          3.3V
                       ;                                SDcardDtaIn
                       ;0 AVR-SPI-DtaIn   i    0     0  via LS244 fr. inpt   3.3V
                       ;                                SDcardDtaOut
                       
                       ;I2C-pins have +3.3V only
                       ;NEVER pull active to +5V
                       ;NEVER activate internal pullup-resistor
                       ;I2C-pins have external 3.3V-pullup-resistors
                       ;activity of I2C-lines is made by Ddr, not by Port.
                       ;=> I2C-ports must be allways %0

                       ;first Port,  then Ddr

        cbi pospcl,bispcl ; port-SPI-ClkOut = low
                       ; probably not necessary 
                       ; SPI-USART initialisation makes this
        sbi ddspcl,bispcl ; Ddr-SPI-ClkOut = output                   inpt   3.3V     0V        
                       ; => active to 0V =low  (necessary)

        sts ubr0h,r06  ;#$00 clears baudrate-register to ensure
                       ;      immediate initialization of
        sts ubr0l,r06  ;#$00  the XCKn (PB0) output

        ldi r20,0b11000000
        sts ucsr0c,r20 ;usart mspim control and status register 0 c
                       ;bit7,6: %11 = SPI-mode
                       ;bit2:    %0 = highbyte first
                       ;bit1:    %0 = clock-phase = idle low 
                       ;              (=0V when inactive) 
                       ;bit0:    %0 = clock polarity 
                       ;              bit1&0: = SPI-mode0

        ldi r20,0b00011000
        sts ucsr0b,r20
                       ;bit4: %1 = receive enable
                       ;bit3: %1 = transmit enable   

        ldi r20,$09    ;set baudrate to 400kHz
        sts ubr0l,r20  ;the Baud Rate must be set after the transmitter is enabled 

        out DdrA,r06   ;$00 PrtA = input
        out DdrC,r06   ;$00 PrtC = input
        out PrtA,r07  ;$00 PrtA: enable pullups
        out PrtC,r07  ;$00 PrtC: enable pullups

        ;brcc l26290   :perhaps skips activating CS to make 74 clockcycles at 
                       ;hardware initialitation of SMC?????????????

        ldi r25,0b11011111 ;clears (=activates) SPI-ChipSelect-bit    inpt   3.3V     0V     0V 
        call l23760    ;clears r25 to I2C-parallel-port   (bit5)

                       ;SPI-CS inactivated/activated 
                       ;= also flag for uart inactive/active for SPI
       #endif

l26290: ret
;------------------------------------------------------------------------------------------------
l26300: ldi r20,$0a    ;                                                finish SPI-SD-card-access
l26310: rcall l26430   ;sends 8 clock-cycles                            change r20,r25
        dec r20        ;there must be 8? bytes sent before inactivating SPI-CS
        brne l26310    ;(there are still 2 CRC bytes to read before)

       #if partname == 3    
        sbi pospcs,bispcs ; port-SPI-ChipSelect = high  = inactive
        sts spcr,r06   ;#$00 SPI Control Register   disables SPI
                       ;SPI-CS inactivated/activated = also flag for uart inactive/active for SPI
        ret
       #endif
        
       #if partname == 6    
        cbi ddspcs,bispcs ;port-SPI-chipselect=input=high 
  
l26320: dec r20  
        brne l26320
  
        sts ucsr0c,r06 ;usart mspim control and status register 0 c
                       ;bit7,6: %00 = Asynchronous USART (not SPI-mode)
                       ;              ?important to disable override-function of SPI-Clk-Out?
                       ;bit2:    %0 = highbyte first
                       ;bit1:    %0 = clock-phase = idle low (=0V when inactive) 
                       ;bit0:    %0 = clock polarity 
                       ;              bit1&0: = SPI-mode0
        sts ucsr0b,r06 ;#$00
                       ;bit4: %0 = receive disable
                       ;bit3: %0 = transmit disable   
        cbi ddspdo,bispdo ;SPI-dtaOut=low-input     SPI-dtaOut->low
                       ;perhaps not necessary if not cleared at initialisation???
        cbi ddspcl,bispcl ; port-SPI-ClkOut = low-input (probably not necessary)
                       ;problem: SPI-Clk must be probably low when inactive
                       ; but this causes 3.3mA current because of pullup-resistors
                       ; => make SPI-Clk high when SPI-CS is inactive (saves energy)
                       ;    and make SPI-Clk low before SPI-CS is activated (low)
                       ;SPI-CS inactivated/activated = also flag for uart inactive/active for SPI
        ret
       #endif

       #if partname == 7   
        ldi r25,0b00100000 ;sets (=inactivates) SPI-ChipSelect 
        call l23770     ;sets r20 to I2C-parallel-port
        sts ucsr0c,r06 ;usart mspim control and status register 0 c
                       ;bit7,6: %00 = Asynchronous USART (not SPI-mode)
                       ;              ?important to disable override-function of SPI-Clk-Out?
                       ;bit2:    %0 = highbyte first
                       ;bit1:    %0 = clock-phase = idle low (=0V when inactive) 
                       ;bit0:    %0 = clock polarity 
                       ;              bit1&0: = SPI-mode0
        sts ucsr0b,r06 ;#$00
                       ;bit4: %0 = receive disable
                       ;bit3: %0 = transmit disable   
        sbi pospdo,bispdo ;SPI-dtaOut=high-output     SPI-dtaOut->high
                       ;perhaps not necessary if not cleared at initialisation???
        sbi pospcl,bispcl ; port-SPI-ClkOut = high-output (probably not necessary)
                       ;problem: SPI-Clk must be probably low when inactive
                       ; but this causes 3.3mA current because of pullup-resistors
                       ; => make SPI-Clk high when SPI-CS is inactive (saves energy)
                       ;    and make SPI-Clk low before SPI-CS is activated (low)
                       ;SPI-CS inactivated/activated = also flag for uart inactive/active for SPI
        ret
       #endif
;------------------------------------------------------------------------------------------------
l26330: nop            ;    1
l26340: nop            ;    1
l26350: nop            ;    1
l26360: nop            ;    1
l26370: nop            ;    1
        ret            ;    4
;------------------------------------------------------------------------------------------------
                       ;from l26610, l26650, l26680, l26690, l26710, l26740, l26780, l26780
                       ;from l26880, l27030, l27430  
l26380: ldi r25,$93    ;93--                                                       reads response
        call l13130    ;                                                  (must begin with 0-bit)
/*        
        sbi pospdo,bispdo ;    SPI-dtaOut = high-output  SPI-DtaOut->high 
        
        ldi r16,$00

l26390: nop            ;    1
        nop            ;    1 
        nop            ;    1
        nop            ;    1
        cbi pospcl,bispcl ; 1  SPI-clock=(output-)0V  SPI-Clk->low 
                       ;---------------------
        rcall l26360   ;    9 = 3+6  
        sbi pospcl,bispcl ; 1  SPI-clock = (output-)5V   SPI-Clk->high  
                       ;---------------------
        sbis pispdi,bispdi ;2  skips if SD-card makes SPI-data high as transfer of 1-bit
        
        rjmp l26400    ;       SD-card makes SPI-data high as transfer of 0-bi
                
        dec r24        ;    1  256*3/12µs = 768µs / 3072µs
        brne l26390    ;    2

        dec r16        ;       768µs*256= 196000µs = 0.2s / 3072µs*256= 768000µs = 0.8s
        brne l26390    ;       => timeout error if SD-card doesn't answer within 0.2s (400kHz) 
                       ;                                                         0.8s (100kHz)      
        ldi r25,$94    ;       94--  = SD-card time out error
        call l13130    ;            

        ldi r16,$ff    ;       not necessary,  only that debupprinting writes
    
        sec            ;flag for error
        ret            ;-----------
        
l26400: ldi r24,$fe    ;    1                =SD-card sent 0-bit                                             
        ldi r16,$ff    ;    1    
        rjmp l26480    ;    2  receive byte
*/

        clr r09

l26410: rcall l26430   ;reads byte from spi
        cpi r16,$ff
        clc            ;default flag for no timeout
        brne l26420    ;b.i.first byte of response read

        dec r08
        brne l26410

        dec r09
        brne l26410

        ldi r25,$94    ;       94--  = SD-card time out error
        call l13130    ;            

        sec            ;flag for time-out-error (r16 = #$ff)

l26420: tst r16
        ret            ;equal=ok  notequal=error
;------------------------------------------------------------------------------------------------
l26430: ldi r16,$ff    ;   1  =to sent byte = byte for send nothing, read byte only
                       ;........................................................................
l26440:                 ;                                                    sends r16 to SPI-bus
                        ;                                                  reads r16 from SPI-bus
        ;ldi r25,$95    ;      95--    
        ;call l13130    

        ;mov r25,r16    ;      --
        ;call l13130    

/*;----------------------------------------------------------------------------------------------

        ldi r24,$fe     ;   1     counter for 8 bits per byte                sends r16 to SPI-bus
                        ;                                                  reads r16 from SPI-bus
                        ;                                                   changes r16, r24, r25
        ;mov r25,r24    ;      --
        ;call l13130    
        
        ;in r25,pinb    ;      --
        ;call l13130    

        ;in r25,pind    ;      --
        ;call l13130    
                        ;...........................................................bitloop
l26450: cbi pospcl,bispcl ; 1  SPI-clock=(output-)0V  SPI-Clk->low
                        ;-------------------- (SD-card makes new value to line)

        ;ldi r25,$96    ;      96--
        ;call l13130    

        ;mov r25,r16    ;      --
        ;call l13130    

        ;mov r25,r24    ;      --
        ;call l13130    

        ;in r25,pinb    ;      --
        ;call l13130    

        ;in r25,pind    ;      --
        ;call l13130    

        rol r16        ;    1  sends bit7 first, bit0 last
        brcc l26460    ;   1/2 b.i.low-bit to send

        ;ldi r25,$97    ;      97--
        ;call l13130    
        
        sbi pospdo,bispdo ;1/0 SPI-dtaOut = highoutput  SPI-DtaOut->high 
        rjmp l26470    ;   2/0

l26460: ;ldi r25,$98    ;      98--
        ;call l13130    

        cbi pospdo,bispdo ;0/1 SPI-dtaOut = lowoutput  SPI-DtaOut->low  
        nop            ;   0/1

l26470: ;in r25,pinb    ;       --
        ;call l13130    

        ;in r25,pind    ;       --
        ;call l13130        

        nop            ;    1   10cycles = 1.25µs (at 8MHz) = 400kHz
        nop            ;    1   
        nop            ;    1
        nop            ;    1
        sbi pospcl,bispcl ; 1  SPI-clock = (output-)5V   SPI-Clk->high  SD-card takes value
                       ;-------------------- 
        sec            ;    1 
        sbis pispdi,bispdi;1/2  skips if SD-card makes SPI-data high as transfer of 1-bit
                       ;        = AVR redas value from SD-card
                       ;        here or better before SPI-Clk->high
l26480: clc            ;   1/0  = SD-card makes SPI-data high as transfer of 0-bit

        rol r24        ;    1  shifts also counter-bit into carry

        ;ldi r25,$9a    ;      9a--
        ;call l13130    

        ;in r25,pinb    ;      --
        ;call l13130    

        ;in r25,pind    ;      --
        ;call l13130    
 
        brcs l26450    ;   1/2 b.i.end of byte not yet reached
      
        ;ldi r25,$9b    ;      9b--
        ;call l13130    

        ;mov r25,r24    ;      --
        ;call l13130    
        
        ;in r25,pinb    ;      --
        ;call l13130    

        ;in r25,pind    ;      --
        ;call l13130    

        mov r16,r24    ;   1/0  at end: carry = clear = ok-flag 
        ret            ;   4/0  !!SPI-DtaOut can still be low!!!!...............end

l26490: nop            ;   0/1  10cycles = 1.25µs (at 8MHz) = 400kHz   
        rjmp l26450    ;   0/2  reads 8 bits of a byte.........................bitloop
*/;----------------------------------------------------------------------------------------------
                       ;                                                     sends r16 to SPI-bus
                       ;                                                  reads r16 from SPI-bus
                       ;                                                   changes r16, r25
        sts spdaio,r16 ;stores outputbyte to SPI-data-in/out-register
        ldi r25,$20    ;counter for timeout 400kHZ=20cycles per clock
                       ;                          =160 cycles per byte  
        clc            ;default-flag for ok

l26500: lds r16,pisptc ;    2 pin SPI transmission complete
                       ;      sd2iec: spsr   SPI Status Register
                       ;      NLQ-HD: ucsr0a usart mspim control and status register 0 a
        andi r16,1<<bisptc ;1 masks bit SPI transmission complete
                       ;      sd2iec: irq-flag (bit7)
                       ;      NLQ-HD: rxc-bit (bit7)
        brne l26510    ;    1 b.i.complete SPI-databyte received
                       ;      waits until complete SPI-databyte received

        dec r25        ;    1    32*7=224
        brne l26500    ;    2

        sec            ;flag for error

l26510: lds r16,spdaio ;reads received SPI-databyte
              
                       ;when 1 byte is completely received then the one to-sent byte 
                       ; is also completely sent
        ret
;------------------------------------------------------------------------------------------------
                       ;from l17090, l27090
l26520: clt            ;flag for don't deactivate SPI-CS at end

l26530: ldi r30,low(txcm13<<1) ;txt CMD13send status  send read-status-command via SPI to SD-card
        ldi r31,high(txcm13<<1) ;                        and read response
                       ;.........................................................................
l26540: rcall l26270   ;initialize SDI if not yet active       send SD-command via SPI to SD-card
                       ;                                       and read response
        ldi r16,$06    ;counter for 6 bytes                  change r08,r09,r16,r20,r25,r30,r31
        mov r08,r16

        ldi r25,$b0    ;b0--                          
        call l13130    

l26550: lpm r16,z+     ;reads character from text

mov r25,r16
call l13130

        rcall l26440   ;send CMD to SD-card 

mov r25,r16
call l13130

        dec r08
        brne l26550

        rcall l26380   ;read response (clc=ok+r16 contains response from SD   sec=time-out-error)

        brtc l26560    ;b.i.don't deactivate SPI-access (don't deactivate SPI-CS)

        in r08,Sreg    ;backups status register           
        rcall l26300   ;finish SPI-SD-card-access  change r20,r25
        out Sreg,r08   ;restores status register (clc/sec)

l26560: ret            ;(clc=ok+r16 contains response from SD   sec=time-out-error)
;------------------------------------------------------------------------------------------------
                       ;from l25240
l26570:                ;                                                       initialize SD-card
        ldi r25,$cd    ;cd--                                 changes r16,r20,r24,r25,r30,r31
        call l13130    

       #if (partname == 3) | (partname == 6)
        #message 644-NLQ-HD/SD-only routines
        in r20,pisdcd  ;AVR-pin SD-CardDetect
        andi r20,1<<bisdcd ;bit AVR-SD-CardDetect
        brne l26630    ;b.i.no SD inserted 
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
        rcall l23810   ;reads I2C-parallel-port to r20
        andi r20,1<<bisdcd ;bit AVR-SD-CardDetect
        brne l26630    ;b.i.no SD inserted 
       #endif

        ;ldi r25,$20
        ;call l23770    ;sets r20 to I2C-parallel-port inactivtes ChipSelect (->SPL, p92)

                        ;try to activate this again!!!
                        ;there was a bug with the chipselect line when i tried
                        ;this first and it didn't work!!!!!!!!!!!
        ;clc 
        ;rcall l26280   ;initializes SPI-SD-card-access but leaves ChipSelect high (=inactive)

        ;ldi r30,$0a    ;send 10*8 high-bits??? 74 are necessary???
l26580: ;rcall l26430   ;send highbits
        ;dec r30
        ;brne l26580

        rcall l26280   ;initializes SPI-SD-card-access and makes ChipSelect low (=active)
      
        ldi r25,$ce    ;ce--
        call l13130    

        ldi r30,$0a    ;send 10*8 high-bits??? 74 are necessary???
l26590: rcall l26430   ;send highbits
        dec r30
        brne l26590
      
        ldi r25,$cf    ;cf--
        call l13130    

        ldi r30,$00    ;reads 512 bytes from SD-card
l26600: rcall l26430   ;if there is a hardware-reset when the AVR just requests a sector 
        rcall l26430   ;from SMC => the next 512 bytes read from the SMC aren't answer
        dec r30        ; of a command byte the former requeseted sector
        brne l26600

        ldi r25,$d0    ;d0--
        call l13130    

        ldi r30,low(txcmd0<<1)  ;text command 0  = reset-command                   ----CMD0----
        ldi r31,high(txcmd0<<1) 

l26610: lpm r16,z+     ;reads character from text
        rcall l26440   ;send CMD0 to SD-card / ChipSelect=low => switches from SD- to SPI-bus

        cpi r30,low((txcmd0<<1)+$06)
        brne l26610

        rcall l26380  ;read response

        ldi r25,$d1    ;d1--
        call l13130    

        mov r25,r16    ;---- R1-response (should be #$01?)
        call l13130    

        sts $0190,r17  ;temporary!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        sts $01a0,r16        

        brcc l26640    ;b.i.no error = b.i.SD-card sent response

l26620: rcall l26300   ;finish SPI-SD-card-access
l26630: jmp l16660     ;74,drive not ready error       

l26640: ldi r30,low(txcmd8<<1)  ;text command 8  = Send Interface Condition        ----CMD8----
        ldi r31,high(txcmd8<<1) 
           
l26650: lpm r16,z+     ;reads character from text
        rcall l26440   ;send CMD8

        cpi r30,low((txcmd8<<1)+$06)
        brne l26650

        rcall l26380  ;read response
     
        ldi r25,$d3    ;d3--
        call l13130    

        mov r25,r16    ;---- R1-response 
        call l13130    
 
        sts $0191,r17  ;temporary!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        sts $01a1,r16        
 
        brcs l26620

        andi r16,04    ;masks illegal-command-error-bit 
        brne l26670    ;b.i.illegal command = b.i.low capacity card (0-2GB) ??or MMC-card??

        ldi r16,$80    ;sets flag for high capacity card (not yet supported)
        sts smcaty,r16 ;SD/MMC card type
                            ;bit7-5: %000 = no card
                            ;        %001 = MMC
                            ;        %010 = thin SD (?standart capacity <=2GB?)  difference not
                            ;        %011 = thick SD (?standart capacity <=2GB?   supported
                            ;        %100 = high capacity SD (4GB - 16GB
                            ;        %101 = for future (e.g.32GB-SD) 

        ldi r17,$d2    ;d2-- 210--   high capacity card (not yet supported) error
l26660: rcall l26300   ;finish SPI-SD-card-access
        jmp syserr     ;system error 
l26670:                ;-----------------------------------------------------------CMD58----
                       ;same at SD and MMC
                       ;a 16MB-SD card made an error: #$05 = illegal command ?????
        ldi r30,low(txcm58<<1)  ;text command 58  = read OCR                   
        ldi r31,high(txcm58<<1) ;(-> R3 response   5 bytes)
           
l26680: lpm r16,z+     ;reads character from text
        rcall l26440   ;send CMD55 to SD-card
                       ;next command is an application specific command (ACMDxx instead of CMDxx)
        cpi r30,low((txcm58<<1)+$06)
        brne l26680

        rcall l26380   ;read response (-> R3 response   5 bytes)
     
        ldi r25,$d4    ;d4--
        call l13130    

        mov r25,r16    ;---- R3-response 
        call l13130    
     
        sts $0192,r17  ;0 temporary!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        sts $01a2,r16

        andi r16,$fe   ;masks errorbits
                       ;what to do if error?????  

        rcall l26430   ;reads byte 
        mov r25,r16    
        call l13130    
        sts $0193,r17  ;1 temporary!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        sts $01a3,r16

        rcall l26430   ;reads byte 
        mov r25,r16    
        call l13130    
        sts $0194,r17  ;2 temporary!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        sts $01a4,r16

        rcall l26430   ;reads byte 
        mov r25,r16    
        call l13130    
        sts $0195,r17  ;3 temporary!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        sts $01a5,r16
      
        rcall l26430   ;reads byte 
        mov r25,r16    
        call l13130    
        sts $0196,r17  ;4 temporary!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        sts $01a6,r16

                       ;--------------------------------------------------------------CMD55----   
                       ;every SD must understand CMD55
                       ;but a 16MB-SD made a respons1=#$05 = illegal command??
                       ;MMC doesn't support this command (-> response1=#$05 
        ldi r30,low(txcm55<<1)  ;text command 55 =                                
        ldi r31,high(txcm55<<1) ;(-> R1 response)
           
l26690: lpm r16,z+     ;reads character from text
        rcall l26440   ;send CMD55 to SD-card
                       ;next command is an application specific command (ACMDxx instead of CMDxx)
        cpi r30,low((txcm55<<1)+$06)
        brne l26690

        rcall l26380   ;read response (-> R1 response)
     
        ldi r25,$d5    ;d5--
        call l13130    

        mov r25,r16    ;---- R1-response (is #$05???)
        call l13130    
        
        sts $01a7,r16
        sts $0197,r17  ;temporary!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        brcc l26700    ;b.i.no error = b.i.SD-card sent response

        nop

l26700:                ;after the CMD55 the errorstat could still be #$05 
                       ;it must be cleared by a???? command
                       ;this is difficult
                       ;or does the 16MB-SD also send #$05 at the ACMD41 command????





                       ;--------------------------------------------------------------ACMD41----
                       ;every SD must understand ACMD41
                       ;
                       ;MMC doesn't support this command (-> response1=#$05  
                       ;use this command to find out whether SD / MMC
        ldi r30,low(txac41<<1)  ;text command 0  = reset-command                  
        ldi r31,high(txac41<<1) ;(-> R3 response   6 bytes)
           
l26710: lpm r16,z+     ;reads character from text
        rcall l26440   ;send CMD55 to SD-card
                       ;next command is an application specific command (ACMDxx instead of CMDxx)
        cpi r30,low((txac41<<1)+$06)
        brne l26710

        rcall l26380   ;read response (-> R1 response   1 byte)
     
        ldi r25,$d6    ;d6--
        call l13130    

        mov r25,r16    ;---- R1-response 
        call l13130    
     
        sts $0198,r17  ;temporary!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        sts $01a8,r16

        andi r16,$04   ;masks illegal-command-error-bit
        breq l26750    ;b.i.ACMD41 was legal => must be a SD (not MMC)

                       ;------------------------------------------------------------CMD1------- 
                       ;                                                   = MMC (not SD)
                       ;error-bits are cleared by reading R1-response???
        ldi r25,$d7    ;d7--
        call l13130    

l26720: ldi r30,low(txcmd1<<1)  ;text                  
        ldi r31,high(txcmd1<<1) ;(-> R1 response   1 byte)
           
l26730: lpm r16,z+     ;reads character from text
        rcall l26440   ;send CMD1 to MMC-card
        cpi r30,low((txcmd1<<1)+$06)
        brne l26730

        rcall l26380   ;read response (-> R1 response   1 byte)
     
        mov r25,r16    ;---- R1-response 
        call l13130    
     
        sts $0199,r17  ;temporary!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        sts $01a9,r16

        cpi r16,$01    ;masks in-idle-state-bit
        breq l26720    ;b.i.still in idle state = b.i.not yet in ready-mode
                       ;SPL57: busy=0 = ready-mode??
                       ;       busy=1 = idle-mode??  
        ldi r16,$20    ;flag for MMC-card
        brcs l26790    ;b.i.#$00 = b.i.ready-mode 

        ldi r17,$d3    ;d3-- 211--   
l26740: rcall l26300   ;finish SPI-SD-card-access
        rjmp l26660    ;system error (error at MMC-CMD1) 
l26750:                ;--------------------------------------------------------------ACMD41----
                       ;                                                         = SD (not MMC)   
     
        ldi r25,$d8    ;d8--
        call l13130    

l26760: ldi r30,low(txcm55<<1)  ;text command 55 =                                
        ldi r31,high(txcm55<<1) ;(-> R1 response)
           
l26770: lpm r16,z+     ;reads character from text
        rcall l26440   ;send CMD55 to SD-card
                       ;next command is an application specific command (ACMDxx instead of CMDxx)
        cpi r30,low((txcm55<<1)+$06)
        brne l26770

        rcall l26380   ;read response (-> R1 response)-------------------------------
    
        ldi r30,low(txac41<<1)  ;text                  
        ldi r31,high(txac41<<1) ;(-> R1 response   1 byte)
           
l26780: lpm r16,z+     ;reads character from text
        rcall l26440   ;send ACMD41 to SD-card
        cpi r30,low((txac41<<1)+$06)
        brne l26780

        rcall l26380   ;read response (-> R1 response   1 byte)
     
        mov r25,r16    ;---- R1-response 
        call l13130    
     
        sts $019a,r17  ;temporary!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        sts $01aa,r16

        cpi r16,$01   ;masks in-idle-state-bit
        breq l26760    ;b.i.still in idle state = b.i.not yet in ready-mode
                       ;SPL57: busy=0 = ready-mode??
                       ;       busy=1 = idle-mode??  
        ldi r17,$d4    ;d4-- 212--
        brcc l26740    ;b.i.any error-bit set -> system error
        
        ldi r16,$40    ;flag for standart-SD-card
                       ;------------------------------------------------------------                      
l26790: sts smcaty,r16 ;SD/MMC card type
                            ;bit7-5: %000 = no card
                            ;        %001 = MMC
                            ;        %010 = thin SD (?standart capacity <=2GB?)  difference not
                            ;        %011 = thick SD (?standart capacity <=2GB?   supported
                            ;        %100 = high capacity SD (4GB - 16GB
                            ;        %101 = for future (e.g.32GB-SD) 
/*
        ldi r30,low(txcm16<<1)  ;text                  
        ldi r31,high(txcm16<<1) ;(-> R1 response   1 byte)
           
l26800: lpm r16,z+     ;reads character from text
        rcall l26440   ;send CMD16 to SD-card  sets blocklength to $0200 = 512 bytes
        cpi r30,low((txcm16<<1)+$06)
        brne l26800

        rcall l26380   ;reads response (-> R1 response   1 byte)
     
        mov r25,r16    ;---- R1-response 
        call l13130    
     
        sts $019b,r17  ;temporary!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        sts $01ab,r16

        cpi r16,$00   ;masks in-idle-state-bit
        breq l26810    ;b.i.no error

        ldi r17,$d5    ;d5-- 213--
        rjmp l26660    ;system error at set blocklength
        
l26810:
*/











        rcall l26300  ;finish SPI-SD-card-access

        ldi r25,$9c    ;9c--
        call l13130    
        
        ret
;================================================================================================
                       ;from l15140
l26820: ldi r25,$40    ;40--                                         sector read/write of SM-card
        call l13130
 
        lds r18,idcore ;IDE-command-register
                       ; $20 read sector with retry command
                       ; $30 write sector with retry command
                       ; $40 verify
                       ; $e6 sleep
                       ; $ec identify device
        cpi r18,$20
        breq l26850  

        cpi r18,$30
        brne l26830

        rjmp l27000    ;= write to SM-card

l26830: ldi r17,$dc    ;dc--  220-- (illegal command to SM-card)
l26840: jmp syserr

l26850: ldi r25,$41    ;41--                                             sector read from SM-card
        call l13130

;AVR: CMD17            
;SMC:       R1(#$00) starttoken(#$fe)+512databytes+2CRCbytes                  

        push r20       ;r20 is used at activating SPI-CS via I2C-bus
                       ;look perhaps whether it's possible to change this to r24 or r16-r19???
        lds r16,msspcs ;memoryspace SPI-CS  sd2iec:Pinb+$20  NLQ-HD:I2C-port-value         
        
        mov r25,r16
        call l13130    ;---- (SPI-CS-port-value)

        andi r16,1<<bispcs ;masks SPI-CS
        breq l26860    ;b.i.SPI-CS is already active

        rcall l26280   ;initialize SPI-SD-card-access
                       ; (at NH-full: writes 2 bytes to debugbuffer: #$ae + xx)
                       ; changes r20 !!!! must berhaps be backuped at save (for verify??)!!!!! 
      
l26860: call l13070    ;xx-- xx-- xx-- xx-- xx-- LBA0 - LBA3 

/*
        sts $10f0,r12  ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        sts $10f1,r13  ; for l26950

        cli
*/

        lsl r12        ;multiplication * 512 *$0200
        rol r13        ;because SMC-address is byte while r12-15 is secttor
        rol r14
        rol r15
        brcs l26870
        breq l26880    ;b.i.address is legal  isn't too big

l26870: rcall l26300   ;finish SPI-SD-card-access
        ldi r17,$dd    ;(dd--)  221-- (illegal address at smc)
        rjmp l26840

l26880: ldi r16,$51    ;  1  CMD17
        rcall l26440   ;  3  sends r16 to SPI-bus  

        mov r16,r14    ;Highestbyte byteaddress (LBA2 *2)
        rcall l26440

        mov r16,r13    ;Higherbyte byteaddress  (LBA1 *2)
        rcall l26440

        mov r16,r12    ;Highbyte byteaddress  (LBA0 *2)
        rcall l26440

        ldi r16,$00    ;Lowbyte byteaddress (#$00)
        rcall l26440

        ldi r16,$01    ;endbyte
        rcall l26440   ;----------  

        rcall l26380   ;reads response

        ldi r25,$42    ;42--
        call l13130
        mov r25,r16    ;----  (R1 response)
        call l13130
  
        tst r16
        breq l26890    ;b.i.no error

        rcall l26300   ;finish SPI-SD-card-access
        ldi r17,$de    ;(de--)  222-- (R1-error at reading from SMC)
        mov r18,r16    ;error-sector = R1-response-error
        jmp syer18     ;system error / r18 contains sectornumber
 
l26890: ldi r25,$43    ;43--
        call l13130

        ldi r18,$00
        
l26900: rcall l26430   ;reads byte (changes r16, (r17,) r24, r25)
        cpi r16,$ff
        brne l26910

        dec r00        ;use which register?????????????
        brne l26900

        dec r18
        brne l26900

        ldi r25,$44    ;(44--) 
        call l13130
    
        rcall l26300   ;finish SPI-SD-card-access
        ldi r17,$df    ;(df--)  223-- (start token not received at reading from SMC)
        rjmp l26840

l26910: cpi r16,$fe    ;start token
        breq l26920    ;b.i.ok-start token (#$fe) found

        ldi r25,$45    ;(45--)
        call l13130
    
        mov r25,r16    ;----  (error-token after R1 response)
        call l13130
jmp freeze
.db 0        
        rcall l26300   ;finish SPI-SD-card-access
        ldi r17,$e0    ;(e0--)  224-- (error token received at reading from SMC)
        rjmp l26840

l26920: ldi r25,$46    ;46-- 
        call l13130

        call l15510   ;actual SA HD-buffer-transfer read -> r16
                       ;and swaps and masks active bits
        cpi r16,$02
        brcc l26930    ;#$03-0f = copy
        rjmp l26990    ;#$01-02 = don't copy (important not to change r30,31)

                       ;r12-r15 still contain lba/chs; (this is important for the verify!!!
                       ;                                 at save)   
                       ;r20-r23 is used for something (because they must be backuped at 
                       ;         LBA->CHS-computing)
                       ;
                       ;r30     amount of requested sectors in this loop  at free cluster-calcul.
                       ;           = lowbyte requested sectors
     
                       ;=0c-0f = copy into/over HD-buffer 
                       ;perhaps load values for the copy command from a table of the flash??????  
                       ;!!! but this would change always r30,r31        
                       ;still make swapbuffer and buffer at 0800 0a00!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                      
                       ;    -------------------------------read from SMC to HD-buffer--------
l26930: ldi r25,$47    ;47--
        call l13130
  
        call l15510   ;actual actual SA HD-buffer-transfer read -> r16 
        call l15580   ;sets Z to begin of correct tabt02-tabt0d 
                 
l26940: ldi r25,$48    ;48--          ----loop----
        call l13130
     
        clr r05        ;default for no error at compare
     
        call l15620   ;reads next action from tabt02-tabt0d
         
l26950:                ;                                   r16=DataIn      
                       ;                                   changes: r18,r19
                       ;                                   uses r05,r30,31 or r28/29
        rcall l26430   ;reads byte (changes r16, (r17,) r24, r25)

/*
        sts $0cf0,r00
        sts $0cf1,r01
        sts $0cf2,r28
        sts $0cf3,r29
        sts $0cf4,r18
        in r25,sreg
        sts $0cf5,r25
        ldi r25,$90
        sts $0cf7,r25

        ldi r25,$49    ;49--   !!!!!!!!!!!!!!!!!!!!!!!!
        call l13130

        in r25,sreg    ;--  sreg
        call l13130 

        lds r25,$01f0  ;--  lba0
        call l13130

        lds r25,$01f1  ;--  lba1
        call l13130

        mov r25,r00    ;--  counter low
        call l13130

        mov r25,r01    ;--  counter high      see l26860
        call l13130

        mov r25,r28    ;--  vector low
        call l13130

        mov r25,r29    ;--  vector high
        call l13130    ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*/
        ;ldi r25,$91
        ;sts $0cf7,r25

        brts l26970    ;b.i.write into HD-buffer (not skip)

        ;ldi r25,$92
        ;sts $0cf7,r25

   
        tst r05        ;=skip/compare (don't write into HD-buffer)
        brne l26960    ;b.i.already former compare error detected

        ld r05,y+
        eor r05,r16
        rjmp l26980    ;r05=equal/notequal

l26960: ld r16,y+      ;=skip/compare (don't write into HD-buffer)  just to increment Y
        rjmp l26980

l26970: 
        ;ldi r25,$94
        ;sts $0cf7,r25

        st y+,r16      ;
    
        ;ldi r25,$95
        ;sts $0cf7,r25

l26980: dec r00        ;decrements counter low 
        
        ;ldi r25,$96
        ;sts $0cf7,r25

        brne l26950

        ;ldi r25,$97
        ;sts $0cf7,r25

        dec r01        ;decrements counter high

        ;ldi r25,$98
        ;sts $0cf7,r25

        brne l26950
              
        ;ldi r25,$99
        ;sts $0cf7,r25

        ;ldi r25,$9a
        ;sts $0cf7,r25

        tst r18        ;tests end-flag

        ;ldi r25,$9b
        ;sts $0cf7,r25

        brpl l26940    ;b.i.not yet read to end

        ;ldi r25,$9c
        ;sts $0cf7,r25

        ldi r25,$4a    ;4a--
        call l13130

        ;ldi r25,$9d
        ;sts $0cf7,r25

        rcall l26300   ;finish SPI-SD-card-access
                       ; (at NH-full: writes 2 bytes to debugbuffer: #$ae + xx)

        ;ldi r25,$9e
        ;sts $0cf7,r25

        ldi r25,$4b    ;4b--
        call l13130

        ;ldi r25,$9f
        ;sts $0cf7,r25

        pop r20        ;restores r20

        ;ldi r25,$a0
        ;sts $0cf7,r25

sei

        ;ldi r25,$a1
        ;sts $0cf7,r25

        jmp l15380     ;jump to 'copy perhaps from HD to CBM-buffer'--------

l26990: 
        ;ldi r25,$a2
        ;sts $0cf7,r25

        pop r20        ;restores r20

        ;ldi r25,$a3
        ;sts $0cf7,r25

sei
        ;ldi r25,$a4
        ;sts $0cf7,r25

        jmp l15400     ;to end of ATA-IDE routine
                       ; (SPI-CS stays active  =  important e.g. at load)
;------------------------------------------------------------------------------------------------
;AVR: CMD24          starttoken(#$fe)+512databytes+2CRCbytes 
;SMC:       R1(#$00)                                         DataResponseToken(05-e5)Busy(#$00)                  

l27000: ldi r25,$61    ;61--                                              sector write to SM-card
        call l13130

        push r20       ;r20 is used at activating SPI-CS via I2C-bus
                       ;look perhaps whether it's possible to change this to r24 or r16-r19???
    
        lds r16,msspcs ;memoryspace SPI-CS  sd2iec:Pinb+$20  NLQ-HD:I2C-port-value         
        
        mov r25,r16
        call l13130    ;---- (i2c-port-value)

        andi r16,1<<bispcs ;masks SPI-CS
        breq l27010    ;b.i.SPI-CS is already active

        rcall l26280   ;initialize SPI-SD-card-access
                       ; ae-- xx-- (I2C-portbyte)
                       ; changes r20 !!!! must berhaps be backuped at save (for verify??)!!!!! 
      
        mov r25,r06    ;00----
        call l13090
      
        mov r25,r07    ;ff----
        call l13090 

        in r25,DdrA    ;xx-- DdrA
        call l13090 
        in r25,PrtA    ;xx-- PrtA 
        call l13090 
        in r25,PinA    ;xx-- PinA
        call l13090 
       
        in r25,DdrB    ;xx-- DdrB
        call l13090 
        in r25,PrtB    ;xx-- PrtB 
        call l13090 
        in r25,PinB    ;xx-- PinB
        call l13090 
       
        in r25,DdrC    ;xx-- DdrC
        call l13090 
        in r25,PrtC    ;xx-- PrtC 
        call l13090 
        in r25,PinC    ;xx-- PinC
        call l13090 

        in r25,DdrD    ;xx-- DdrD
        call l13090 
        in r25,PrtD    ;xx-- PrtD 
        call l13090 
        in r25,PinD    ;xx-- PinD
        call l13090 

       #if partname == 7
        #message 644-NLQ-HD/full
        rcall l23820   ;read I2C-parallel-port to r20
        mov r25,r20
        call l13090    ;xx-- i2c-port
       #endif
     
l27010: call l13070    ;xx-- xx-- xx-- xx-- xx-- LBA0 - LBA3

        lsl r12        ;multiplication * 512 *$0200
        rol r13        ;because SMC-address is byte while r12-15 is secttor
        rol r14
        rol r15

        call l13070    ;xx-- xx-- xx-- xx-- xx-- LBA0*512 - LBA3*512

        brcs l27020
        breq l27030    ;b.i.address is legal  isn't too big

l27020: rcall l26300   ;finish SPI-SD-card-access
        ldi r17,$e1    ;(e1--  225--) (illegal address at writing smc)
        rjmp l26840

l27030: ldi r16,$58    ;  1  CMD24  write single block
        rcall l26440   ;  3  sends r16 to SPI-bus  

        mov r16,r14    ;Highestbyte byteaddress (LBA2 *2)
        rcall l26440

        mov r16,r13    ;Higherbyte byteaddress  (LBA1 *2)
        rcall l26440

        mov r16,r12    ;Highbyte byteaddress  (LBA0 *2)
        rcall l26440

        ldi r16,$00    ;Lowbyte byteaddress (#$00)
        rcall l26440
     
        ldi r16,$01    ;endbyte
        rcall l26440   ;----------  

        rcall l26380   ;93-- reads response

        ldi r25,$62    ;62--
        call l13130
        mov r25,r16    ;----  (R1 response  usually #$00)
        call l13130
        
        tst r16
        breq l27040    ;b.i.no error
        
        rcall l26300   ;finish SPI-SD-card-access
        ldi r17,$e2    ;e2--  226-- (R1-error at writing SMC)
        mov r18,r16    ;error-sector = R1-response-error
        jmp syer18     ;system error / r18 contains sectornumber
 
l27040: ldi r25,$63    ;63--
        call l13130
                       ;    -------------------------------write from HD-buffer to SMC --------
        ldi r25,$68    ;68----                                         write AVR-HD-buffer to SMC
        call l13090
        
        call l15520    ;actual SA HD-buffer-transfer write of actual SA -> r16
                       ;swaps and masks active bits 
        cpi r16,$02
        brcc l27050    ;#$03-0f = copy

        rjmp l26990    ;#$01-02 = don't copy (important not to change r30,31)

                       ;r12-r15 still contain lba/chs; (this is important for the verify!!!
                       ;                                 at save)   
                       ;r20-r23 is used for something (because they must be backuped at 
                       ;         LBA->CHS-computing)
                       ;
                       ;r30     amount of requested sectors in this loop  at free cluster-calcul.
                       ;           = lowbyte requested sectors
     
                       ;=0c-0f = copy into/over HD-buffer 
                       ;perhaps load values for the copy command from a table of the flash??????  
                       ;!!! but this would change always r30,r31        
                       ;still make swapbuffer and buffer at 0800 0a00!!!!!!!!!!!!!!!!!!!!!!!!!!!!

l27050: call l15580    ;sets Z to begin of correct tabt02-tabt0d 
                       ;5e-- xx-- yl-- yh-- zl-- zh--
                       ;     xx=ashbtr/wr (correctly (swapped))
                       ;          y=flash-pos of table z=flash-pos of table 
                       ;r16 must still contain active actual SA HD-buffer-transfer write of actual SA
 
        ldi r16,$fe    ;start token
        rcall l26440   ;sends r16 to SPI-bus
                 
l27060: ldi r25,$69    ;69--          ----loop----
        call l13130

        call l15620    ;reads next action from tabt02-tabt0d
                       ;5f-- cl-- ch-- vl-- vh--
                       ;     counter   vecttor
                       ;sets r28,29 = Y correctly  / Z incremented by 4 to next entry

l27070: ld r16,y+      ;             ----loop----
        rcall l26440   ;sends r16 to SPI-bus

        dec r00        ;decrements counter low
        brne l27070

        dec r01        ;decrements counter high
        brne l27070

        tst r18        ;tests end-flag
        brpl l27060    ;b.i.not yet written to end

        ldi r25,$6a    ;6a--
        call l13130

        rcall l26430   ;send byte to SPI CRC (#$ff)

        rcall l26430   ;send byte to SPI CRC (#$ff)

        ldi r25,$6b    ;6b-- 
        call l13130
        mov r25,r16    ;--  (accidentially read byte at sending second CRC)
        call l13130

        rcall l26430   ;reads data response byte from SMC = data response token
        mov r25,r16    ;--  (data response byte/token (often #$e5?))
        call l13130
      
        cpi r16,$ff
        brne l27080 

        ldi r25,$6c    ;6c-- 
        call l13130
                      ;I don't know why, but:
                       ;very seldom: it's not read #$e5 at once
                       ;             but first #$ff and then #$e5??????????
                       ;reproducable:
                       ;dn25: cd:fcopytest
                       ;fcopy-PRG: copy 202blocks to dn25
                       ;fcopy copy all files from dn26/fcopytest to dn25/fcopytest
                       ;          (must copy 202blocks again)
                       ;=> exatly here at scratching 202blocks this error comes
                       ;    at writing dirsector back to SD  
        rcall l26430   ;reads data response byte from SMC = data response token
        mov r25,r16    ;--  (data response byte/token (often #$e5?))
        call l13130
 
l27080: andi r16,$1f   ;masks off bit7-5
        cpi r16,$05    
        breq l27090    ;b.i.no error at data response token

        rcall l26300   ;ae-- xx-- finish SPI-SD-card-access
        ldi r17,$e3    ;e3--  227-- (error at data response token)
        mov r18,r16    ;error-sector = data response token
        jmp syer18     ;system error / r18 contains sectornumber
       
l27090: rcall l26430   ;reads bytes after data response token
                       ; (former: rcall l26380 was probably wrong??)
        cpi r16,$00
        breq l27090    ;waits until SMC has finished writing the block

        ldi r25,$6d    ;6d-- 
        call l13130

        rcall l26520   ;send send-status-command and read response 
        breq l27100    ;b.i.ok

                       ;=error after SD has written sector to SD
        ldi r17,$e4    ;e4--  228-- (error at response after having written sector to HD)
        mov r18,r16    ;error-sector = data response token
        jmp syer18     ;system error / r18 contains sectornumber

l27100: lds r23,idscre ;amount of to-write sectors (usually 1    1-$0100 only at clear sector)
        dec r23        ;counter for amount of to-write sectors 1-$ff  #$00=#$0100
        breq l27110    ;b.i.all wanted sectors cleared
        sts idscre,r23 ;amount of to-write sectors (usually 1    1-$0100 only at clear sector)

        ldi r25,$a5    ;a5--
        jmp freeze     ;still make for format prg!!!!!!!!!!!!!!!!!!


l27110: ldi r25,$6e    ;6e--   =no error
        call l13130

        rcall l26300   ;finish SPI-SD-card-access

                       ;don't make verify at SMC  (SMC makes this????) 

        rjmp l26990    ; to end of IDE-HD-routine
;------------------------------------------------------------------------------------------------
l27120: 
/*        
                          ;                                   receive 2 SPI-bits from SD/MMC-card
                          ;                                     and send 2 bits to C86 at JD-LOAD
        cbi pospcl,bispcl ; 1 SPI-clock = output-0V    SPI-Clk->low
                       ;----------------
        ldi r25,$03    ;    1
l27130: dec r25        ;    1     1+ 1+2 + 1+2 + 1+1 +1 = 10cycles = 1.25µs per halfwave
        brne l27130    ;   2/1                                     = 2.5ms per fullwave
                       ;                                           = 400kHz SPI-frequency  
        sbi pospcl,bispcl ; 1 SPI-clock = output-5V    SPI-Clk->high
                       ;----------------
        sec            ;    1    
        sbis pispdi,bispdi;1/2 skips if SD-card makes SPI-data high as transfer of 1-bit
                       ;       = AVR reads value from SD-card
        clc            ;   1/0 = SD-card makes SPI-data high as transfer of 0-bit

        rol r24        ;    1     reads bit 0,2,4,6 
        nop            ;    1  
        nop            ;    1                                      = 10cycles = 1.25µs per halfwave
        nop            ;    1                                      = 2.5ms per fullwave
        nop            ;    1                                      = 400kHz SPI-frequency  
        nop            ;    1   
        cbi pospcl,bispcl ; 1 SPI-clock = output-0V    SPI-Clk->low
                       ;----------------
        ldi r25,$03    ;    1
l27140: dec r25        ;    1     1+ 1+2 + 1+2 + 1+1 +1 = 10cycles = 1.25µs per halfwave
        brne l27140    ;   2/1                                     = 2.5ms per fullwave
                       ;                                      
        sbi pospcl,bispcl ; 1 SPI-clock = output-5V    SPI-Clk->high
                       ;----------------
        sec            ;    1    
        sbis pispdi,bispdi;1/2 skips if SD-card makes SPI-data high as transfer of 1-bit
                       ;       = AVR reads value from SD-card
        clc            ;   1/0 = SD-card makes SPI-data high as transfer of 0-bit

        rol r24        ;    1     reads bit 1,3,5,7 
*/

       #if partname == 3
         #message 644-NLQ-HD/sd2iec
        in r17,PrtA   ;     1 reads PrtA
        andi r17,0b10011111 ;1 masks off bit6&5   ClkOut & DatOut (default for inactive)
        lsr r16        ;     1 to send IECOUT-byte  bit0,2,4,6->carry
        brcs l27150    ;    1/2 b.i.1-bit to send = inverted 0-bit

        ori r17,$40    ;    1/0 sets clkOut bit of port to active

l27150: lsr r16        ;     1 bit1,3,5,7->carry
        brcs l27160    ;    1/2 

        ori r17,$20    ;    1/0 sets DtaOut bit of port to active

l27160: in r18,Tcnt0   ;     1 reads timer0
        cp r18,r19     ;     1
        brcs l27160    ;     1 waits
         
        out PrtA,r17  ;     1 makes bit0,2,4,6->ClockOut  bit1,3,5,7->DataOut

        sbic piatin,biatin ; 1 s.i.C64-Atn=active
        
        ret            ;     4     

        rjmp l27400    ; = C64 made Atn=active
                       ;never sends command-bytes => Atn is allways inactive
       #endif

       #if partname == 6
        #message 644-NLQ-HD/SD
                       ;the AtnIn-IRQ is disabled => DtaOut cannot be changed by AtnIn-IRQ       
        ldi r17,$00    ;DdrA default: DtaOut & ClkOut inactive
        ldi r25,$7f    ;PrtA default: DtaOut & ClkOut inactive
                       ;bit7= input & pullup=off (VCC)
                       ;bit6= input & pullup=on (voltage divider  so far not connected)

        lsr r16        ;to send IECOUT-byte  bit0,2,4,6->carry
        brcs l27170    ;b.i.1-bit to send = inverted 0-bit

        ori r17,$07    ;sets clkOut bit of DdrA
        andi r25,$f8   ;clears ClkOut-bit of PrtA

l27170: lsr r16        ;bit1,3,5,7->carry
        brcs l27180     

        ori r17,$38    ;sets DataOut bit of DdrA
        andi r25,$c7   ;clears DtaOut-bit of Prta
     
l27180: in r18,Tcnt0   ;reads timer0
        cp r18,r19
        brcs l27180    ;waits
         
        out DdrA,r06   ;#$00 to prevent that AVR pulls active to +5V
                       ;low-bit         high-bit
        out PrtA,r25   ;pullups-on (1)  (nothing (0))
        out DdrA,r17   ;(nothing (0))   output loq 0V (1)
                       ;makes bit0,2,4,6->ClockOut  bit1,3,5,7->DataOut
        sbic piatin,biatin ; 1 s.i.C64-Atn=active
        
        ret            ;     4     

        rjmp l27400    ; = C64 made Atn=active
                       ;never sends command-bytes => Atn is allways inactive
       #endif

       #if partname == 7    
        #message 644-NLQ-HD/full
        in r17,PrtB    ;     1 reads PrtB
        ori r17,0b00011000  ;1 sets bit4&3  DatOut & ClkOut (default for inactive)
        lsr r16        ;     1 to send IECOUT-byte  bit0,2,4,6->carry
        brcs l27190    ;    1/2 b.i.1-bit to send = inverted 0-bit

        andi r17,$f7   ;    1/0 sets clkOut bit of port to active

l27190: lsr r16        ;     1 bit1,3,5,7->carry
        brcs l27200    ;    1/2 

        andi r17,$ef   ;    1/0 sets DtaOut bit of port to active

l27200: in r18,Tcnt0   ;     1 reads timer0
        cp r18,r19     ;     1
        brcs l27200    ;     1 waits
         
        out PrtB,r17   ;     1 makes bit0,2,4,6->ClockOut  bit1,3,5,7->DataOut

        sbic piatin,biatin ; 1 s.i.C64-Atn=active
        
        ret            ;     4     

        rjmp l27400    ; = C64 made Atn=active
                       ;never sends command-bytes => Atn is allways inactive
       #endif
;------------------------------------------------------------------------------------------------
                       ;                                      partial routines of JD-LOAD for SMC
                       ;from l12320
                       ;...............................................................sectorloop
                       ;                                                    begin read loadbuffer
l27210:                ;start timer to compute time which C64 needs for stop-key
       
        call l14760   ;read follow-512-HD-sector of actual cluster             
                       ;but don't write into HD-buffer
                       ;!!! only at manual software-SPI-routines: SPI-DtaOut must be high
                       ; => it's important that the last sent bit is a high-bit       
                       ;also reads starttoken of datablock

        rcall l26430   ;reads byte (changes r16, (r17,) r24, r25)
                       ;reads first byte of sector which must be sent to C64 -> r16

        sts spdaio,r07 ;#$ff reads next SPI-byte by sending a #$ff-byte
                       ;=> SPI-AVR-hardware reads second databyte from SMC
                        
                       ;                                   begin send 1 sector (512 bytes) to C64

                       ;r12-r15=actual cluster?????

                       ;r20-r23=remainig filelength
                     
        ldi r28,$00    ;counter 256 words in one sector
        ldi r29,$02    ;highbyte counter  !!! different to IDE-HD-routines!!
      
        lds r20,asflre ;actual SA filelength (remaining) (for EOI-calculating)
        lds r21,asflre+1
        lds r22,asflre+2
        lds r23,asflre+3

l27220: ldi r25,$c5    ;c5--
        call l13130

        ;st z+,r25
        ;andi r30,$7f    
 
        ;st z+,r20
        ;andi r30,$7f    

        ;in r16,PinB
        ;st z+,r16
        ;andi r30,$7f   
    
       #if partname == 6    
        #message 644-NLQ-HD/SD
        ldi r17,$07    ;flag for JD-LOAD from SD-card directly 
        jmp l12370    
       .db $0          ;r17 is used by all 5 IECroutines and isn't set at begin of all 5 routines  
                
                       ;from l10030 (RTC-JD-LOAD from AVR-RAM)
                       ;=C64 makes Dta=inactive or C64 makes Atn=active
l27230: 

       #else 
        cli            ;disables 100Hz-IRQ  => at sd2iec the debug switch isn't polled
       #endif 

        ldi r25,$c6    ;c6--
        call l13130

l27240: ldi r25,$14    ;=20  =200µs                                                         DI CA
        lds r17,fljdal ;flag JiffyDOS allowed
        andi r17,$01
        breq l27260    ;b.i.waiting-loop-way    

l27250: sbis piatin,biatin ;s.i.C64-Atn=inactive    = waiting-loop-way
        rjmp l27400     ;  finish SPI & main waiting loop 
                       
        sbis piiema,bidain ;s.i.C64 makes data=Inactive
        rjmp l27250    ;waits until C64 makes data=Inactive (fb06)  
        ldi r25,$06    ;60µs waitingloop because C64 needs
                       ;from making C64-DataOut=inactive (fb06)
                       ;to reading bus (fb0c)
                       ;8 + 43 (badline) = 51µs   

                       ;waits until C64 has finished stop-key-routine
                       ;and C64 is ready to receive next block
                       ; 60µs  

l27260: call l10840   ;200µs waiting loop because C64 must have enought time for STOP-key
                       ;routine (important if HD would read requested sector very fast 
                       ;(perhaps from cache?) and this would be shorter than 200µs)

                       ;D=I C=A => C64 is in loop at fb0c?
        ldi r25,$c7    ;c7--
        call l13130

        call l12870   ;DataOut=Active                     (ff98)                          DA CA
        rcall l23910  ;waits 10µs
        call l12910   ;ClockOut=inactive                  (ff9d)                          DA CI
                       ;=> C64 leaves loop at fb0e and
                       ;branches to fb3e

        ldi r25,$08
        call l10840   ;80µs waiting loop             (ffa0-ffb5)

        ;in r16,PinB
        ;st z+,r16
        ;andi r30,$7f    
 
                       
                       ;.................................................................byteloop

l27270: 
l27280:                ;read directly from SD/MMC-card-SPI without buffering

                       ;is here a delay-loop necessary where the IDE-HD-routine reads the
                       ; datrabyte from the HD?

l27290: call l12840    ;  DataOut=inactive  r16=to sent byte                        
        call l12910    ;1 ClockOut=inactive  (important at first byte in loop)   (ffb5)    DI CI

        ldi r17,$08    ;1
l27300: dec r17        ;1
        brne l27300    ;3/2  
                       ;30cycles=4µs at 8MHz = enought time that data-line goes inactive 
                         


        ldi r17,$02    ;1 %.....010
        ldi r19,$10    ;1 startvalue counter

        ;in r25,PinB
        ;st z+,r25
        ;andi r30,$7f    

l27310: sbis piatin,biatin ;2 s.i.C64-Atn=inactive
        rjmp l27400     ;  finish SPI & main waiting loop                         uni-
                       ;                                                    1541 versal NTSC PAL
l27320: sbic piiema,bidain ;1/2  s.i.C64 makes data=active
        rjmp l27310    ;2 waits until C64 makes data=active       (ffbb)     0µs    0µs
                       ;    1 loop = 5cycles =0.63µs at 8MHz  
  
        out tccr0_,r17 ;1 #$02 %.....010 starts timer0 (8bit) with 8MHz/8 = 1count per 1µs
                       ;    (wgm make normal mode)
l27330: out Tcnt0,r19  ;1 $10 to timer0 counts up from $10                  (0µs) 0.38-1µs 
         
                       ;when C64 makes data=inactive then the AVR needs
                       ;from l27320 to l27330 3cycles =0.38µs

                       ;when the C64 makes data=inactive 0.001µs after
                       ;the AVR has read the line at l27320 then the AVR
                       ;must wait one complete loop l27310 - l27320 
                       ;=>delay is 0.38+0.63µs=1µs


        ;ldi r25,$c6   ;(c6--)
        ;st z+,r25
        ;andi r30,$7f     

        ;in r25,PinB
        ;st z+,r25
        ;andi r30,$7f       


                       ;1541 sends inverted to sent byte

        ldi r19,$19
        rcall l27120   ; 3  sends bit 0&1                         (ffbd)    06-0d $09µs    D1 C0
                       ; and reads SMC-SPI-bit 7&6
        ldi r19,$23    
        rcall l27120   ;sends bit 2&3                             (ffc4)    10-17 $13µs    D3 C2
                       ; and reads SMC-SPI-bit 5&4        
        ldi r19,$2e    
        rcall l27120   ;sends bit 4&5                             (ffcc)    1b-22 $1eµs    D5 C4
                       ; and reads SMC-SPI-bit 3&2
        ldi r19,$38    
        rcall l27120   ;sends bit 6&7                             (ffd3)    25-2c $28µs    D7 C6
                       ; and reads SMC-SPI-bit 2&0
        rcall l23910   ;waits 10µs (1541 holds bit 7&6 at IECOUT 10µs long
                       ;=> this must be enough also at JD-LOAD) 
        subi r20,$01   ;decrements remaing filelength by 1
        sbci r21,$00
        sbci r22,$00
        sbci r23,$00

        mov r19,r20
        or r19,r21
        or r19,r22
        or r19,r22
        breq l27340    ;b.i.last byte =EOI (r19=#$00 = flag that EOI finished loop)
        
        ;mov r16,r24    ;copies read SMC-SPI-byte to actual to send byte
                        ;this is the old SPI-software-routine
        
        lds r16,spdaio ;loads actually read AVR-SPI-DtaIn-byte from SMC
        sts spdaio,r07 ;#$ff reads next SPI-byte by sending a #$ff-byte
                       ;=> SPI-AVR-hardware reads next databyte from SMC
                       ; while AVR sends actual one to C64
                         
        dec r28        ;decrements counter  
        brne l27280    ;send next byte
                
        dec r29        ;   
        brne l27280    ;send next byte in this SDC-sector................................byteloop
        
                       ;=end of 1 sector
        ldi r19,$01    ;flag that end of 1 sector finished loop  
                         
                       ;                                         = end of load or end of 1 sector
l27340: sts asflre,r20 ;actual SA filelength (remaining) (for EOI-calculating)
        sts asflre+1,r21
        sts asflre+2,r22
        sts asflre+3,r23
                       ;read next HD-block from HD = end of 512 bytes HD-sector
                       ;loop must be finished if:
                       ; - 512 bytes sector is transmitted
                       ; - last byte was sent (Then EOI must still be made) 
                      

        ;ldi r25,$c8    ;(c8--)               
        ;mov r03,r25
        ;st z+,r25
        ;andi r30,$7f  

        call l12880   ;ClockOut=Active       (about 11µs later than bit    30-37 $33µs 
        call l12840   ;DataOut=Inactive   (ffdb)    7&6 set to bus)                    
        rcall l23910   ;waits 10µs                                                         DI CA
         
        ldi r25,$c9    ;c9-- 
        call l13130
               
        ;ldi r25,$c9    ;(c9--)
        ;mov r03,r25        
        ;st z+,r25
        ;andi r30,$7f    

        ;in r25,PinB
        ;st z+,r25 
        ;andi r30,$7f    

l27350: sbis piatin,biatin ;s.i.C64-Atn=inactive (=l12310)
        rjmp l27400    ; = C64 made Atn=active
                        
        sbic piiema,bidain ;s.i.C64 makes data=active
        rjmp l27350    ;waits until C64 makes data=active (fb51)  

        sei            ;enable 100Hz-IRQ------------------------------------

        ldi r25,$ca    ;ca-- 
        call l13130

       #if partname == 6    
        #message 644-NLQ-HD/SD
        lds r25,airtmb ;AVR-internal-RTC-mode-bits
                       ;7=sleep-IRQ finished routine
                       ;6=reset-IRQ finished routine
                       ;5=watchdog time-out finished routine
                       ;4=IEC-error finished routine 
                       ;3=IEC-Atn-change finished routine (in databyte-mode but AtnIn=active)
                       ;2=IEC-Atn-change finished routn (in commandbyte-mode but AtnIn=inactive)
                       ;1=normal end of routine

                       ;0= 0=RTC-values changed by timer2-IRQ   (direct-IEC- & IRQ-RTC-mode)
                       ;   1=RTC-values changed by mainprogram  IRQ-IEC- & direct-RTC-mode
        ori r25,$02    ;sets bit that normal end of routine finished routine
        sts airtmb,r25 ;AVR-internal-RTC-mode-bits      
        out Sreg,r08   ;restores status register 
                       ;r19=#$00 = flag that EOI finished loop
        ret            ;r19=#$01 =end of 1 sector finished loop 
l27360:       
       
       #endif

        ldi r18,$06    ;flag f. reading 6 CRC-bytes 
        
l27370: sbis piatin,biatin ;s.i.C64-Atn=inactive

        rjmp l27400    ; = C64 made Atn=active
    
        rcall l26430   ;reads SMC-SPI byte (changes r16, (r17,) r24, r25)       
                       ;reads second CRC and one additional byte
        dec r18        ;(first CRC was read at sending last byte of sector)
        brpl l27370    
      
l27380: ldi r25,$cb    ;cb-- 
        call l13130
      
        ;ldi r25,$cb    ;(cb--)
        ;mov r03,r25        
        ;st z+,r25 
        ;andi r30,$7f    
        
        ;in r25,PinB
        ;st z+,r25
        ;andi r30,$7f    
   
        cpi r19,$00
        breq l27390    ;b.i.last byte =EOI (r19=#$00 = flag that EOI finished loop)

        ldi r25,$cc    ;cc--                                                               DI CA
        call l13130
       
        ;st z+,r25
        ;andi r30,$7f    
      
        ;in r25,PinB
        ;st z+,r25
        ;andi r30,$7f    

        rjmp l27210    ;noEOI = load next sector from HD...............................sectorloop

l27390:                ;= end of load (=l12340)
        rcall l26430   ;reads byte from SD/MMC-card-SPI (changes r16, (r17,) r24, r25)
        sbis piatin,biatin ;s.i.C64-Atn=inactive

        rjmp l27400    ; = C64 made Atn=active
        
        dec r28        ;
        brne l27390    ;reads rest of sector

        dec r29
        brne l27390

        rcall l26300   ;finish SPI-SD-card-access
        jmp l12340     ;to end of JD-LOAD of IDE-HD------------------------------------------

l27400: call l12870    ;DtaOut = active     = C64 made Atn=active
                       ;=flag to C64 to wait 
l27410: rcall l26430   ;reads byte from SD/MMC-card-SPI (changes r16, (r17,) r24, r25)
        
        dec r28        ;
        brne l27410    ;reads rest of sector

        dec r29
        brne l27410

        rcall l26300   ;finish SPI-SD-card-access

       #if partname == 6    
        #message 644-NLQ-HD/SD
        jmp l11960     ;5d--  read byte after Atn=active-edge
                       ;!!!! difference !!!!
       #else  
        jmp l12360     ;  main waiting looop       
       #endif
;================================================================================================
                       ;aso SD/MMC-order (command)
                       ;asr SD/MMC-read
                       ;asw SD/MMC-write
                       ;asc SD/MMC-clear sectors

                       ;        $0200   a aa a a a a a a a a a a aa a a                additional
                       ;r16     $0201   c hh h h h i i e e r r f +- 2 2
                       ;r17     $0202   a ii r w c r w r w r w r    r w
                       ;r12=r28 $0203     01 lba-0 reg              sla LBA0 (sector?)      
                       ;r13=r29 $0204        lba-1  vl                  LBA1 (!hexdez  not ASCII)  
                       ;r14     $0205        lba-2  vh                  LBA2  lowbyte first   
                       ;r15     $0206        lba-3                      LBA3  highbyte-last
                       ;        $0207         0/1                       master/slave?????
                       ;        $0208        amount                   

                       ;at the as.-commands the swapbuffer is made to SA15
                       ; (it's cleared?)

l27420: ldi r25,$e0    ;e0--
        call l13130    

        cpi r17,$4f    ;'o'
        brne l27450

        ldi r25,$e1    ;e1--
        call l13130    

        rcall l26280   ;initializes SPI-SD-card-access

        ldi r28,low(inbube+$03) ;                                     =aso SD/MMC-order (command)
        ldi r29,high(inbube+$03) ;Y shows to char behind aso = first char of command

l27430: ld r16,y+
       
        mov r25,r16    ;---- commandbytes 
        call l13130    

        rcall l26440   ;sends r16 to SPI-bus  sends command 6bytes

        cpi r28,low(inbube+$09) ;  
        brne l27430

        ldi r25,$e2    ;e2--
        call l13130    

        ldi r26,low(erbube) ;error-buffer-begin   
        ldi r27,high(erbube) ;message is 16bytes => errorbuffer is long enough
        sts erbuve,r26 ;sets error-buffer vector to first byte    
 
        rcall l26380   ;reads response 
     
        mov r25,r16    ;---- response 
        call l13130    
        
        st x+,r16      ;stores responsebyte to external errorbuffer

        ldi r25,$e3    ;e3--
        call l13130    

l27440: rcall l26430   ;reads byte 
        mov r25,r16    
        call l13130    
        st x+,r16      ;stores responsebyte to external errorbuffer
        cpi r26,low(erbuen) ; 1response + 16bytes + 2crc + ff??
        brne l27440    ;or:   1response + 1*#$ff +1*#$fe(starttoken) + 16bytes + 2crc + ff??

        ldi r25,$e4    ;e4--
        call l13130    

        sts erbufi,r26 ;error-buffer filelength (remaining) (for EOI-calculating)
        sts erbufi+1,r06 ;#$00  
        rjmp l26300    ;finish SPI-SD-card-access----------

l27450: cpi r16,$52    ;'r'
        brne l27460

                       ;=asr SD/MMC-read

l27460: cpi r16,$57    ;'w'
        brne l27470

                       ;=asr SD/MMC-write

l27470: cpi r16,$43    ;'c'
        brne l27480

                       ;=asr SD/MMC-clear


l27480: jmp l23540    ;syntax error
                       ;                                               end additional as.-command
;================================================================================================
txcmd0: .db $40, $00, $00, $00, $00, $95 ;text CMD0 = reset command of sd-card
txcmd1: .db $41, $00, $10, $00, $00, $01 ;text CMD1 send operation conditions
                                         ;byte1-4 = databytes
                                         ;bit30 of databytes = HCS = high capacity support
                                         ;                     (<=2GB = no high capacity)
                                         ;                     (>=4GB = high capacity) 
                                         ;         0=no high capacity   1=high capacity
                                         ;bit20 of databyte = 3.2-3.3V
txcmd8: .db $48, $00, $00, $01, $aa, $01 ;text CMD8 = send interface condition
                                         ;byte1-4 = databytes
                                         ;31-12: reserved %0...0
                                         ;11-8:  VHS voltage supplied %0001 = 2.7-3,6V
                                         ; 7-0:  check-pattern (%10101010 SPL40)       
txcm13: .db $4d, $00, $00, $00, $00, $01 ;text CMD13 send status 
txcm16: .db $50, $00, $00, $02, $00, $01 ;text CMD16 set blocklen
txcm17:                                  ;text CMD17 read single block
txcm24:                                  ;text CMD24 write single block
txcm55: .db $77, $00, $00, $00, $00, $01 ;text CMD55 = next command is an application specific
                                         ; command (ACMDxx instead of CMDxx)
txcm58: .db $7a, $00, $00, $00, $00, $01 ;text CMD58 = send OCR

txac41: .db $69, $00, $10, $00, $00, $01 ;text ACMD41 send operation conditions
                                         ;byte1-4 = databytes
                                         ;bit30 of databytes = HCS = high capacity support
                                         ;                     (<=2GB = no high capacity)
                                         ;                     (>=4GB = high capacity) 
                                         ;         0=no high capacity   1=high capacity
                                         ;bit20 of databyte = 3.2-3.3V







      #endif           ;of l26280 (SD-MMC-SPI)
;================================================================================================
                                         ;DIR_CrtTimeTenth  0d  Millisecond stamp at file 
                                         ;                      creation time. This field
                                         ;                      actually contains a count of
                                         ;                      tenths of a second. The
                                         ;                      granularity of the seconds part
                                         ;                      of DIR_CrtTime is 2 seconds so
                                         ;                      this field is a count of tenths
                                         ;                      of a second and its valid value
                                         ;                      range is 0-199 inclusive. (1byte)
                                         ;DIR_CrtTime       0e  Time file was created.   (2bytes)
                                         ;DIR_CrtDate      $10  Date file was created.   (2bytes)

                                         ;Date and Time Formats
                                         ;Many FAT file systems do not support Date/Time other
                                         ; than DIR_WrtTime and DIR_WrtDate. For this reason,
                                         ; DIR_CrtTimeMil, DIR_CrtTime, DIR_CrtDate, and 
                                         ; DIR_LstAccDate are actually optional fields. 
                                         ; DIR_WrtTime and DIR_WrtDate must be supported, 
                                         ; however. If the other date and time fields are not
                                         ; supported, they should be set to 0 on file create and
                                         ; ignored on other file operations.
                                         
                                         ;Date Format. A FAT directory entry date stamp is a
                                         ; 16-bit field that is basically a date relative to the
                                         ; MS-DOS epoch of 01/01/1980. Here is the format (bit 0
                                         ; is the LSB of the 16-bit word, bit 15 is the MSB of
                                         ; the 16-bit word):
                                         ;Bits 0-4: Day of month, valid value range 1-31
                                         ;           inclusive.
                                         ;Bits 5-8: Month of year, 1 = January, valid value
                                         ;           range 1-12 inclusive.
                                         ;Bits 9-15: Count of years from 1980, valid value range
                                         ;            0-127 inclusive (1980-2107).
                                         
                                         ;Time Format. A FAT directory entry time stamp is a
                                         ; 16-bit field that has a granularity of 2 seconds. Here
                                         ; is the format (bit 0 is the LSB of the 16-bit word,
                                         ; bit 15 is the MSB of the 16-bit word).
                                         ;Bits 0-4: 2-second count, valid value range 0-29
                                         ;           inclusive (0 - 58 seconds).
                                         ;Bits 5-10: Minutes, valid value range 0-59 inclusive.
                                         ;Bits 11-15: Hours, valid value range 0-23 inclusive.

                                         ;The valid time range is from Midnight 
                                         ;  00:00:00 to 23:59:58.

;        00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f
; 0040:   a  b  c  d  e  f  ~  1  p  r  g FA 00 CT CT-CT               FileAttribute  CreateTime
; 0050:  CD-CD AD-AD C2-C3 WT-WT WD-WD C0-C1 L0-L1-L2-L3  CreateDate  AccessDate startCluster0-3
;                                                         WriteTime  WriteDate  fileLength
 
; time                  time    date         date
; 76543210 76543210 76543210    76543210 76543210 
; hhhhhmmm mmmsssss shhhhhhh    yyyyyyym mmmddddd
; hour  mints  scnds  hndrdth    year   mth  day
; 
       #if (partname ==6) | (partname == 7)    
l27490: andi r20,$1f

l27500: andi r20,$3f 

l27510: mov r16,r20    ;BCD->hexdec
        andi r16,$0f   ;masks low nibble 
        swap r20       ;highnibble -> lownibble               
        andi r20,$0f
     
l27520: breq l27530

        subi r16,$100-$0a ;adds $0a 10
        dec r20
        rjmp l27520
     
l27530: ret
;------------------------------------------------------------------------------------------------
                       ;from l19450
l27540:                ;X shows to next direntry (not actual one)
        mov r28,r26    ;Y can store STD with displacement  X can't
        mov r29,r27 
        ld r20,-y      ;undo overflow to next direntry (important to decrement highbyte)
                       ;Y shows to last byte of actual direntry      
        subi r28,$12   ;061f->060d

       #if partname == 6    
        #message 644-NLQ-HD/SD

        ldi r25,$8c    ;8c----
        call l13090

        cli            ;disable IRQs        
    
        lds r20,tcnt2  ;TCNT2 Timer/Counter2        
                       ;(8 Bit)  seconds  and 1/100
        
        lds r16,tifr2  ;Timer/Counter2 Interrupt Flag Register
        tst r16
        breq l27550    ;b.i.there was an overflow from $bf to $00 which could not be executed
                       ; because the IRQ was disabled
        
        ldi r20,$bf
        
l27550: mov r16,r20    ;bit7-5: seconds
                       ;bit4-0: 1/32 seconds (0-31)
        andi r16,$1f   ;masks 1/32   0-31
        ;sts $09f0,r16
        inc r16        ;             1-32
        mov r17,r16
        lsl r16        ;*2           2-64
        add r16,r17    ;+1 = *3      3-96                          r16
                       ;                                           bit6-0=1/10&1/100
    
                       ;                0-31 32-63 64-95 96-127 128-159 160-191
        andi r20,$e0   ;masks seconds   0    32    64    96      128     160
        swap r20       ;                0    2      4     6       8       a     
        lsr r20        ;                0    1      2     3       4       5
        ;sts $09f1,r20
        bst r20,0      ;copies bit 0 from seconds to T-flag
        brtc l27560    ;b.i.even seconds 0,2...58

                       ;=odd seconds 1,3,59
        subi r16,$100-$64 ;adds $64 100 CTultralow: 0-199 (bit7 isn't directly bit of second)

l27560: st y+,r16      ;                                           CTultralow

        lds r17,airtse ;AVR-internal-RTC-second (in 6s steps)-----
        add r17,r20    ; seconds 0-5                               r17
        andi r17,$fe   ;msaks off bit0
        ;sts $09f2,r16 ;                                           bit5-1=seconds 
                       ;bit5-1=seconds (0-58 in 2s-steps)
        lsl r17        ;bit6-2=seconds
        lsl r17        ;bit7-3=seconds

        lds r16,airtmi ;AVR-internal-RTC-minutes   -----
        ;sts $09f3,r16
                       ;                                           r16             r17   
                       ;                                           bit5-0=minutes  bit7-3=seconds                     
        lsr r16        ;  
        ror r17        ;bit4-0=minutes  bit7=minutes bit6-2=seconds
        lsr r16        ;  
        ror r17        ;bit3-0=minutes  bit7-6=minutes bit5-1=seconds
        lsr r16        ;  
        ror r17        ;bit2-0=minutes  bit7-5=minutes bit4-0=seconds
        std y+$08,r17  ;                                           WTlow 
        st y+,r17      ;                                           CTlow 
    
        lds r17,airtho ;AVR-internal-RTC-hours   ----
        ;sts $09f4,r17
                       ;                                           r16             r17
                       ;bit4-0=hour                                bit2-0=minutes  bit4-0=hour     
        lsl r17        ;bit5-1=hour 
        lsl r17        ;bit6-2=hour 
        lsl r17        ;bit7-3=hour 
        or r17,r16
        std y+$08,r17  ;                                           WThigh
        st y+,r17      ;                                           CThigh  
                       ;-----------------------end time----begin date----------------------------
        lds r16,airtda ;AVR-internal-RTC-day ----
        ;sts $09f5,r16
                       ;                                           r16
                       ;                                           bit4-0=day 
        lds r17,airtmo ;AVR-internal-RTC-month
        ;sts $09f6,r17
        swap r17       ;                                           r17
                       ;                                           bit7-4=month
        lsl r17        ;                                           c & r17
                       ;                                           c & bit7-4=month
        or r17,r16     ;                                           r17
                       ;                                           bit7-5=month bit4-0=day
        std y+$02,r17  ;                                           ADlow
        std y+$08,r17  ;                                           WDlow
        st y+,r17      ;                                           CDlow      
        
        ldi r16,$00
        rol r16        ;                                           r16
                       ;                                           bit0=month
        lds r19,airtyl ;AVR-internal-RTC-year-low   -----
        ;sts $09f7,r19  ;      
        lds r20,airtyh ;AVR-internal-RTC-year-high   -----
        ;sts $09f8,r20
        subi r19,$bc   ;subtracts 1980        0000  1979  1980  2107  2108 2235  2236  65535
                       ;                      0000  07bb  07bc  083b  083c 08bb  08bc  ffff
                       ;                      f844  ffff  0000  007f  0080 00ff  0100  f843
        ;sts $09fa,r19
        brmi l27570    ;b.i.2108-2235

        ;sts $09fb,r07  ;#$ff 
        sbci r20,$07   ;subtracts 1980
        ;sts $09fc,r20
        tst r20        ;the subi- and sbci-command has a strange behavior at the equal-flag
        breq l27580    ;b.i.year1980-2107

        ;sts $09fd,r07  ;#$ff

l27570: ;sts $09fe,r07  ;#$ff
        ldi r19,$7f

l27580: ;sts $09ff,r19
        lsl r19        ;bit7-3=year
        or r16,r19
        std y+$02,r16  ;                                           ADhigh
        std y+$08,r16  ;                                           WDhigh
        st y+,r16      ;                                           CDhigh      

        reti           ; sei & ret
       #endif 

       #if partname == 7    
        #message 644-NLQ-HD/full
/*
        ldi r25,$8b    ;8b----
        call l13090
      
        rcall l23630   ;I2C-start-condition  !!changes r20!!

        ldi r20,$a0
        rcall l23660   ;send slave address of pcf8583RTC write

        ldi r20,$00
        rcall l23660   ;send wordaddress#$00=control-register

        ldi r20,$40
        rcall l23660   ;send set hold last count flag in control-register
                       ;wordaddress is incremented #$00->#$01
        rcall l23650   ;I2C-stop-condition 
*/

        ldi r25,$8c    ;8c----
        call l13090
        
        rcall l23630   ;I2C-start-condition  !!changes r20!!

        ldi r20,$a0
        rcall l23660   ;send slave address of pcf8583RTC write

        ldi r20,$00
        rcall l23660   ;send wordaddress#$00=status

        rcall l23650   ;I2C-stop-condition  (necessary??)
        
        ldi r25,$8d    ;8d----
        call l13090
    
        rcall l23630   ;I2C-start-condition  !!changes r20!!

        ldi r20,$a1
        rcall l23660   ;send slave address of pcf8583RTC read
        
        rcall l23700   ;read r00 status----
        ;sts $09f0,r20
        andi r20,$fc
        brne l27600    ;b.i.any bit set wrongly

        rcall l23700   ;read r01  1/10  1/100 ----
        ;sts $09f1,r20
        rcall l27510   ;BCD->hexdec                                r16
                       ;                                           bit6-0=1/10&1/100
        rcall l23700   ;read r02 seconds ----   
        ;sts $09f2,r20
        bst r20,0      ;copies bit 0 from seconds to T-flag
        brtc l27590    ;b.i.even seconds 0,2...58

                       ;=odd seconds 1,3,59
        subi r16,$100-$64 ;adds $64 100 

l27590: st y+,r16      ;                                           CTultralow
        rcall l27510   ;BCD->hexdec                                r16
                       ;                                           bit5-1=seconds 
        mov r17,r16    ;bit5-1=seconds (0-58 in 2s-steps)
        lsl r17        ;bit6-2=seconds
        lsl r17        ;bit7-3=seconds

        rcall l23700   ;read r03 minutes   -----
        ;sts $09f3,r20
        rcall l27510   ;BCD->hexdec                                r16             r17   
                       ;                                           bit5-0=minutes  bit7-3=seconds                     
        lsr r16        ;  
        ror r17        ;bit4-0=minutes  bit7=minutes bit6-2=seconds
        lsr r16        ;  
        ror r17        ;bit3-0=minutes  bit7-6=minutes bit5-1=seconds
        lsr r16        ;  
        ror r17        ;bit2-0=minutes  bit7-5=minutes bit4-0=seconds
        std y+$08,r17  ;                                           WTlow 
        st y+,r17      ;                                           CTlow 
        mov r17,r16

        rcall l23700   ;read r04 hours     -> r20----
        ;sts $09f4,r20
        tst r20
        brpl l27610    ;b.i.AM/PM-flag is cleared

l27600: rcall l23710   ;read + send that this is the last I2C-byte
        rcall l23650   ;I2C-stop-condition
        ldi r17,$fa    ;(fa-- 250--)   
        jmp syserr     ;system error PCF8583-RTS set wrongly 
        .db 0

l27610: rcall l27510   ;BCD->hexdec                                r16             r17
                       ;bit4-0=hour                                bit4-0=hour     bit2-0=minutes
        lsl r16        ;bit5-1=hour 
        lsl r16        ;bit6-2=hour 
        lsl r16        ;bit7-3=hour 
        or r16,r17
        std y+$08,r16  ;                                           WThigh
        st y+,r16      ;                                           CThigh  
                       ;-----------------------end time----begin date----------------------------
        rcall l23700   ;read r05 year/date -> r20
        ;sts $09f5,r20
        mov r19,r20    ;backups year (0-3)
     
        rcall l27500   ;BCD(and#$3f)->hexdec                       r16
                       ;                                           bit4-0=day 
        mov r17,r16    ;bit4-0=day
        rcall l23700   ;read r06 weekday/month
        ;sts $09f6,r20
       
        rcall l27490   ;BCD(and#$1f)->hexdec                       r16       r17        r19
                       ;                                           bt3-0=mo  bt4-0=day  bt7-6=yea
        andi r19,$c0   ;bit 7-6=year
        lsr r19        ;bit 6-5=year
        lsr r19        ;bit 5-4=year
        or r16,r19     ;bit 5-4=year bit 3-0=month
        ldi r18,$00
        lsr r16        ;    year  month
        ror r18        ;r16:bt4-3 bit2-0 r18:bit7
        lsr r16
        ror r18        ;r16:bt3-2 bit1-0 r18:bit7-6
        lsr r16
        ror r18        ;r16:bt2-1 bit0   r18:bit7-5 =month
        or r17,r18     ;                                           r17
                       ;                                           bit7-5=month bit4-0=day
        std y+$02,r17  ;                                           ADlow
        std y+$08,r17  ;                                           WDlow
        st y+,r17      ;                                           CDlow      

        rcall l23700   ;read r07 (overread)                        r16
                       ;                                           bit2-1=year bit0=month
        ;sts $09f7,r20  ;                    
        rcall l23700   ;read r08 year low from RAM wordaddress#$08 (alarm must be disabled)
        ;sts $09f8,r20
        mov r19,r20    ;year low (hexdec  not BCD) bit1-0=%00 

        rcall l23710   ;read r09 year high from RAM wordaddress#$09 (alarm must be disabled)
                       ; + send that this is the last I2C-byte
        ;sts $09f9,r20  
        subi r19,$bc   ;subtracts 1980        0000  1979  1980  2107  2108 2235  2236  65535
                       ;                      0000  07bb  07bc  083b  083c 08bb  08bc  ffff
                       ;                      f844  ffff  0000  007f  0080 00ff  0100  f843
        ;sts $09fa,r19
        brmi l27620    ;b.i.2108-2235

        ;sts $09fb,r07  ;#$ff 
        sbci r20,$07   ;subtracts 1980
        ;sts $09fc,r20
        tst r20        ;the subi- and sbci-command has a strange behavior at the equal-flag
        breq l27630    ;b.i.year1980-2107

        ;sts $09fd,r07  ;#$ff

l27620: ;sts $09fe,r07  ;#$ff
        ldi r19,$7f

l27630: ;sts $09ff,r19
        lsl r19        ;bit7-3=year
        or r16,r19
        std y+$02,r16  ;                                           ADhigh
        std y+$08,r16  ;                                           WDhigh
        st y+,r16      ;                                           CDhigh      

        rcall l23650   ;I2C-stop-condition
        

        ldi r25,$8e    ;8e----
        call l13090

/*      
        rcall l23630   ;I2C-start-condition  !!changes r20!!

        ldi r20,$a0
        rcall l23660   ;send slave address of pcf8583RTC write

        ldi r20,$00
        rcall l23660   ;send wordaddress#$00=control-register

        ldi r20,$00
        rcall l23660   ;send clear hold last count flag in control-register

        rcall l23650   ;I2C-stop-condition 
        
        ldi r25,$8f    ;8f----
        call l13090
*/      
        ret
       #endif 

       #endif
;================================================================================================
       #if partname >= 2    
        #message 644-non-IEC-ATA
nanlsw: .db "NLQ-SWAPSYS",$00 ;name NLQ-SWAP.SYS
nansds: .db "NLQ-SWAP.SYS"    ;name NLQ-SWAP-DOT-SYS
       #endif
;------------------------------------------------------------------------------------------------
fidili: .db 1,4, 1,1, 0,0, $12, $22, "(NAMELESS)      ", $22, " NLQHD", 0 ;first directory line
                                    ;"0123456789abcdef"   last 5 characters must be spaces
txblfr: .db "BLOCKS FREE. ",0 ;text blocks free  
;------------------------------------------------------------------------------------------------
;            00000000000000001
;            0123456789abcdef0
tacoch: .db "VI/MBUP&CRSNGLTWA" ,0    ;table command chars                                   fe89
;................................................................................................
tacolo: .db low(l13970),low(l18230)   ;00 validate   01 initialize    table command lowbyte  fe95
        .db low(l13970),low(l18140)   ;02 / cd-1581  03 memory
        .db low(l13970),low(l23510)   ;04 block      05 user
        .db low(l13970),low(l13970)   ;06 position   07 &
        .db low(l17770),low(l18000)   ;08 copy       09 rename
        .db low(l17590),low(l13970)   ;0a scratch    0b new

        .db low(l13970),low(l13970)   ;0c get        0d lock/unlock
        .db low(l22200),low(l13970)   ;0e time       0f write-protect

        .db low(l22800),low(l13970)   ;10 additional/advanced
;................................................................................................
tacohi: .db high(l13970),high(l18230) ;00 validate   01 initialize   table command highbyte  fea1
        .db high(l13970),high(l18140) ;02 / cd-1581  03 memory
        .db high(l13970),high(l23510) ;04 block      05 user
        .db high(l13970),high(l13970) ;06 position   07 &
        .db high(l17770),high(l18000) ;08 copy       09 rename
        .db high(l17590),high(l13970) ;0a scratch    0b new
        .db high(l13970),high(l13970) ;0c get        0d lock/unlock
        .db high(l22200),high(l13970) ;0e time       0f write-protect
        .db high(l22800),high(l13970) ;10 additional/advanced
;................................................................................................
tacoma: .db 0b01010001,0b11011101 ;08 copy       09 rename          table command mask  fea5/fead
        .db 0b00011100,0b10011110 ;0a scratch    0b new
        .db 0b00000000,0b00000000 ;0c get        0d lock/unlock
        .db 0b00000000,0b00011100 ;0e time       0f write-protect
        .db 0b00000000,0b01011110 ;10 additional/advanced  11 cd   
        .db 0b00011100,0          ;12 load dir (l20790 da55) 
                       ;--bit7: 0=no joker in front of =
                       ;        1= joker in front of = 
                       ;--bit6: 0=no , in front of =
                       ;        1= , in front of = 
                       ;--bit5: always 1??
                       ;--bit4: always 0??
                       ;--bit3: 0=no joker behind =
                       ;        1= joker behind = 
                       ;--bit2: 0=no , behind =
                       ;        1= , behind = 
                       ;--bit1: 0=no = in inputstring 
                       ;        1= = in inputstring
                       ;--bit0: 0= = in inputstring
                       ;        1= no = in inputstring
;................................................................................................
; command-characters
;       1541/CMD-HD/NLQ-HD                                 JiffyDos-C64

;                                                        read error-channel
;(#)  direct access of buffer                            actual devicenumber
; $                                                      directory
; &   utility-loader
; /     make 1581-partition in 1581-partition ("....,c") (CMD-FD S36)  
; /     change 1581-partition in 1581-partition (CMD-FD S38) 
; a       additional/advanced
; b   block                                              bump at 1541 off
; c   copy
; c   concat
; cd    change directory
; cp    change partition (ASCII)
; cP    change partition (hexdec)
; d   (duplicate)                                        list basic-prg from disk          
; e     extended (HD-DOS+) 
; f                                                      funktion-keys off
; g     get partition-information                        gap = sector-interleave at 1541
; h
; i   initialize
; j  
; k
; l     lock                                             lock 
; m   memory
; md    make directory 
; n   new
; o                                                      old (basic-prg renew)
; p   position                                           printer-output on/off
; q                                                      quit = JD-funktions off
; r   rename
; rd    remove directory
; r-h   rename header
; r-p   rename partition 
; s   scratch
; s-,   swap
; s-    SCSI-commands
; t     time  real-time-clock                            list text-file from disk
; u   user
; v   validate
; w     write-protect
; x                                                      destination drive at copy
; y
; z
;------------------------------------------------------------------------------------------------
optamo: .db "RWAM"              ;open table mode: Read Write Append Modify                   feb2
optats: .db "DSPUL B N478  F "  ;open table type short:                                      feb6
;                 C #           ;Del, Seq, Prg, Usr, reL, (Cbm-1581-directory), Branch, Native-,
;            0123456789abcdef   ;1541-, 1571-, 1581-partition, Foreign  
                                ;problem: D is for Deleted => D cannot be used for directory
                                ;=> must use different character for dir (B how CMD makes)
                                ;CMD uses B for dir (branch) and probably 4, 7, 8 for diskimages
                                ;CMD uses probably N for native 16MB-images
                                ;=> don't know whether N or 1 should be used for 16MB-D16-images
                                ;I think that 'N' is better ('1' would be D16)
                                ;unused types in this table must be filled with a letter
                                ; which is used before in the table                              
;                               ;$0d is dot- and dotdot-entry of directory
;                               ;$0f is used at dir-routines for volume-id of root-directory
;            0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  =filetype  
;            D  S  P  U  L     B     N  4     8        F     =character for directory-selection    
optatl: .db "DELSEQPRGUSRRELCBMDIRSYSNAT41 71 81 C81PRNFOR",0 ;open table type long
optatf: .db "DELSEQPRGUSRREL.........D16D64D71D81"            ;open table type FAT-names
;                                    DNP                              
                                ;$07 = sys is perhaps direct access
                                ;$0c = C81 is probably 1581-CP/M-partition                                
                                ;CMD-HD+ uses perhaps e for extendet native???
                                ;     CBM IBM
                                ;     dir dir    
                                ;   r                     Read                  
                                ;   w                     Write
                                ;   a                     Append
                                ;   m                     Modify 
                                ;00 d del del   Deleted
                                ;01 s seq seq   Sequential
                                ;02 p prg prg   Program
                                ;03 u usr usr   User
                                ;04 l rel rel   reLative
                                ;05   dir       1581-subdir
                                ;06 b dir dir   branch subdir
                                ;07             perhaps direct access #
                                ;08 n nat d16   cmd-Native (d16m or dnp)
                                ;09 4 41  d64   1541-emulation
                                ;0a 7 71  d71   1571-emulation
                                ;0b 8 81  d81   1581-emulation
                                ;0c c c81 c81   CP/M-1581-emulation
                                ;0d   prn       printer?
                                ;0e f for xyz   foreign-partition / -file

                                ;0f             volume-ID,dot,dotdot (0f-> $1d, $1e and $1f???)

                                ;   e           extended-native?     (?0f?)

                                ;   1 1m  d1m   fd-4000 DD-emulation ($10?)
                                ;   2 2m  d2m   fd-4000 HD-emulation ($11?)
                                ;   3 3m9 d4m   fd-4000 ED-emulation ($12?)  ('4' is already d64)
                                ;  (i) (IBM)    IBM-display o.AVR-FLASHER on 3.5"-IBM-format-disk
;CMD-nativ-partitions have perhaps already the IBM-PC-filetype .DNP:
;http://www.forum64.de/wbb3/index.php?page=Thread&postID=307897#post307897

;------------------------------------------------------------------------------------------------
       #if ((partname >= 3) & (partname <= 7))
         #message 644-NLQ-HD/all
txdesw: .db "M-W", $77, $00, $02 ;text device-swap
       #endif

       #if partname == 3
         #message 644-NLQ-HD/SD
tx41ud: .db "M-E",$06,$02,$00               ;$0200       text 1541U-Debug
        .db $78,$a2,$00,$8e,$00,$18         ;$0206 sei
                                            ;      ldx #00
                                            ;      stx 1800 DtaOut=inactive
        .db $a0,$02                         ;      ldy #02
        .db $a9,$04                         ;      lda #04
        .db $2c,$00,$18,$f0,$fb,$8c,$00,$18 ;$0210 bit 1800 
                                            ;      beq 0210 waits until SD2IEC makes Clk=active
                                            ;      sty 1800 DtaOut=active
        .db $2c,$00,$18,$d0,$fb,$8e,$00,$18 ;$0218 bit 1800 
                                            ;      bne 0218 waits until SD2IEC makes Clk=inactive
                                            ;      stx 1800 DtaOut=inactive                               
        .db $2c,$00,$18,$10,$eb,$6c,$fc,$ff ;      bit 1800
                                            ;      bpl 0210 b.i.AtnIn=inactive
                                            ;      jmp (fffc) reset 1541 / 1541U
       #endif
;================================================================================================
/*
tabtst:                         ;table buffer transfer starttable
        .db low(tabt02<<1),high(tabt02<<1) ;2 FAT compare
        .db low(tabt03<<1),high(tabt03<<1) ;3 FAT read/write
        .db low(tabt04<<1),high(tabt04<<1) ;4 HD-buffer
        .db low(tabt05<<1),high(tabt05<<1) ;5 hd- & CBM-buffer 
        .db low(tabt06<<1),high(tabt06<<1) ;6 swap CBM-buffer
        .db low(tabt07<<1),high(tabt07<<1) ;7 swap device emulation buffer
                              ;more logical would be:
                              ; 6= swap CBM buffer (instead of 7)
                              ; 7= swap device-emulation-buffer (instead of 6)
                              ; but CBM-buffer is so far the only command which needs two entries
                              ; => tabtst can be saved
                              ; if there would be more than 1 command with 2 or 3 entries
                              ;   then the table tabtst would still be necessary
*/
                                                    ;reads 2bytes per 1 counter
                              ;tabt02-tabt07
                              ;2 words
                              ;first word: counter for amount of bytes
                              ; highbyte:
                              ;   b7: 0=no HD-status-check after this job 
                              ;            (= 1 HD-sector (512bytes) not yet written)
                              ;       1=HD-status-check after this job
                              ;            (= 1 HD-sector (512bytes) completely written)
                              ;   b6: 0=skip & compare (don't write)   1= write into buffer
                              ;   b5: 0=reread counter and vector from flash-table at jobend
                              ;           used at clear multiple sectors 
                              ;            (writeing 1-256 times the same #$00-buffer)
                              ;       1= leave vector unchanged (incremented to end of old job)
                              ;          and use counter for 1 sector = 512 bytes
                              ;           used at load/save device-swap-area 
                              ;       at end (not at begin) of this job      
                              ;decission whether end of HD-access or whether continue with
                              ; next HD-access is with idscre amount of to-read/write sectors
                              ;   b4-2:unused
                              ; bit1-0 of highbyte & bit7-0of lowbyte: counter
                              ;            ! 01ff = 255bytes
                              ;            ! 0100 = 256bytes
                              ;            ! 0201 = 257bytes
                              ;second word: address of AVR-buffer/memory

tabt02:                       ;table buffertransfer 02 FAT (compare/write)
        .db $00,$82 , low(fabube),high(fabube) 
                              ;$8200 = counter = copy 512bytes ($0200 bytes)
                              ;$8200 = %1....... = end after this loop
                              ;        %.0...... = skip and compare (don't write to AVR-RAM)
                              ;                                    (but write to HD)
                              ;$0400 = begin of buffer   FAT-buffer-begin ($0400) 

tabt03:                       ;table buffertransfer 03 FAT (read/write)
        .db $00,$c2 , low(fabube),high(fabube) 
                              ;$c200 = counter = copy 512bytes ($0200 bytes)
                              ;$c200 = %1....... = end after this loop
                              ;        %.1...... = write into buffer (not skip)
                              ;$0400 = begin of buffer   FAT-buffer-begin ($0400) 

tabt04:                       ;tab-buf-trans 04 HD-buffer only
        .db $00,$c2 , low(hdbube),high(hdbube)
                              ;$c200 = counter = copy 512bytes ($0200 bytes)
                              ;$c200 = %1....... = end after this loop
                              ;        %.1...... = write into buffer (not skip)
                              ;$0600 = begin of buffer
                              ;hd-buffer begin

tabt05:                       ;tab-buf-trans 05 HD- and CBM-buffer
        .db $00,$c2 , low(hdbube),high(hdbube)
                              ;$c200 = counter = copy 512bytes ($0200 bytes)
                              ;$c200 = %1....... = end after this loop
                              ;        %.1...... = write into buffer (not skip)
                              ;$0600 = begin of buffer
                              ;hd-buffer begin
       #if partname >= 2    
        #message 644-non-IEC-ATA
tabt06:                       ;table buffertransfer 06 swap device-emulation-buffer     
        .db $00,$e2 , low(deembb),high(deembb)
                              ;$e200 = counter = copy 512bytes ($0200 bytes)
                              ;$e200 = %1....... = continue after this loop
                              ;        %.1...... = write into buffer (not skip)
                              ;        %..1..... = drive ready check
                              ;$0800 = begin of buffer  (0800-0dff/0fff)
                              ;device-emulation-buffer-begin    

tabt07:                       ;table buffertransfer 07 swap CBM-buffer 
        .db $e0,$01 , $00,high(swbube)
                              ;skips from $0a00-=adf ($e0 = 224 bytes)
        .db $20,$c2 , low(swbube),high(swbube);swap buffer begin
                              ;copies to $0ae0-0bff and ends ($0120 = 32+256 bytes)
                              ;swap buffer begin 
                              ;swap-values must be directly in front of swapbuffer
       #endif
                              ;more logical would be:
                              ; 6= swap CBM buffer (instead of 7)
                              ; 7= swap device-emulation-buffer (instead of 6)
                              ; but CBM-buffer is so far the only command which needs two entries
                              ; => tabtst can be saved
                              ; if there would be more than 1 command with 2 or 3 entries
                              ;   then the table tabtst would still be necessary


                              ;!! change order because swapbuffer and device emulation buffer
                              ;   isn't necessary at IEC-ATA!!
                              ;!! change that 02 is compare (and write) FAT
                              ;   and         03 is read (and write) FAT
                              ;   use 03 for writing the FAT2 back to disk
                              ;   and don't change the values of the actual sectotr in FAT-buffer
                              ;   => the FAT-sector isn't reloaded again!!   
;------------------------------------------------------------------------------------------------
txsbss: .db $00,$00,$55,$aa   ;SignatureBytes SystemSector (boot- and FSInfo-sector)
txsbfi: .db $52,$52,$61,$41   ;SignatureBytes of FsInfo sector
;------------------------------------------------------------------------------------------------
; LFN = long-filenames of FAT (Windows95)
; (1) = Microsoft Extensible Firmware Initiative FAT32 File System Specification
;             http://www.microsoft.com/whdc/system/platform/firmware/fatgen.mspx
;             fatgen103.doc

; leading = at begin of filename
; embedded = in middle of filename
; trailing = at end of filename

;change of characters in filenames
;                     CBM                          long-filenames                 short-filenames
;$00-$1f        displayed as                         forbidden           --          forbidden
;                reverse-$40-$5f                                     
; $00           don't use?               $20                             --
; $01-$0c                               $c1-cc?                          -- 
; $0d           don't use?                                               --
; $0e-$13                               $ce-d3
; $14           don't use
; $15-$1f                               $d5-df?                          -- 
;20-$3f                                                                  
; $20                                    <-        as 1.char forbidden   <-
; $21     !                              <-                              <-
; $22     "     forbidden                               forbidden                     forbidden
; $23     #     as 1.char forbidden
; $24     $     as 1.char forbidden?
; $25     %
; $26     &
; $27     '
; $28     (
; $29     )
; $2a     *     forbidden
; $2b     +
; $2c     ,                                             
; $2d     -
; $2e     .                                        as 1.char forbidden  
; $2f     /
; $30-39 0-9                             <-
; $3a     :
; $3b     ;                              <-
; $3c     <
; $3d     =     forbidden
; $3e     >
; $3f     ?     forbidden
;$40-$5f
; $40     @                              <-      
; $41-5a a-z    small characters        $61-7a          capital characters
; $5b     [
; $5c    £ \
; $5d     ]
; $5e     ^
; $5f   <- _  
;$60-$7f        not usual
;               ($c0-df is used)
; $60    × `                              
; $61-7a A-Z    capital characters       <-               small characters
; $7b    × {
; $7c    × |
; $7d    × }  
; $7e    × ~
; $7f    × del
;$80-9f         displayed as            $e0-ff?                forbidden --             
;                reverse-$c0-df  
; $8d           don't use                                      forbidden --
;$a0-bf         grafical characters      <-                              <-
; $a0           don't use
;$c0-df
; $c0    ×                               <-                              <- 
; $c1-da A-Z    capital characters      $61-7a                          $01-1a? 
;$db-df  ×                                                                        
;$e0-ff                                                                 $80-9f        
; $e0-fe        not usual               $a0-be                         ($80-9e)         
;                ($a0-be is used)                                                
; $ff           not usual               $7e??                            ($9f)         
;                 ($de is used)                                                  
;  



; ×   grafical character of C64  (create at PC: 'alt' + number-keys of number-key-block)
; <-  no change
; --  impossible, not allowed 
;characters making strange things if they are in a CBM-dir:
; -$00 new basic-line               (if used it would be changed to $c0 => LFN-$c0 is free)
; -$0d carriage return              (if used it would be changed to $cd => LFN-$cd is free)
; -$14 delete character left of $14 (if used it would be changed to $dd => LFN-$d4 is free)
; -$8d carriage return              (if used it would be changed to $ed => LFN-$ed is free)
; -$a0 (=shift space) makes "       (if used it would be changed to $a0 => LFN-$a0 is free)
; => these 5 characters can be used for different things

;characters which aren't allowed at CBM and LFN
; -$22  "         (but file can be created)
; -$2a  * (joker) (-> 33 syntax error)
; -$3a  :         (-> 33 syntax error)
; -$3f  ? (joker) (-> 33 syntax error)
;
; -$23  #  as first character of filename only
; -$24  $  as first character of filename only

;characters which are allowed at LFN but not allowed at CBM
; -$2c  , (=> use for leading .)
; -$3d  = (=> use for leading space)


;characters which are allowed at CBM but not allowed at LFN
; -$00-$04
;            ($05 is allowed??? (only as first character???))
; -$06-$1f
; -$20 space at beginning of filename (=> use $3d = instead)
; -$2e  .    at beginning of filename? (=> use $2c , instead)
;            at end = no problem, because there is always the fileextension at the end
; -$2f  /    change CBM-$2f to LFN-$c0
; -$3c  <    change CBM-$3c to LFN-$cd
; -$3e  >    change CBM-$3e to LFN-$d4
; -$5c  \    change CBM-$5c to LFN-$ed
; -$7c  |    change CBM-$7c to LFN-$a0
; -$80-$9f

; -$7f del  in (1) is that $7f isn't allowed  

; - still test $05  $e5 (page 23)

;characters which aren't allowed at MS-DOS-shortnames                    (change at LFN)
; ---$00-$04
;            ($05 is allowed??? (only as first character???))
; ---$06-$1f
; --+$20 space  only at first position     behind allowed??                   embedded allowed 
; ---$22  "
; ---$2a  *
; -++$2b  +                                                                 + allowed
; -++$2c  ,                                                                 , allowed
; --+$2e  .                                                                 . embedded allowed
; ---$2f  /
; ---$3a  :
; -++$3b  ;                                                                 ; allowed
; ---$3c  <
; -++$3d  =                                                                 = allowed
; ---$3e  >
; ---$3f  ?
; -++$5b  [                                                                 [ allowed
; ---$5c  \
; -++$5d  ]                                                                 ] allowed
; ---$7c  |
; ---$61-$7a (lower case caracters  they are converted to upper case characters $41-$5a)
; -    -=forbidden at MSDOS shortnames ( + would be allowed)
;  -   -=forbidden at first position of LFN  +=allowed even at first position of LFN
;   -  -=forbidden at LFN  +=allowed at non-first position of LFN


; (at page 24 is nothing that $80-$ff would be not allowed?????)
; (at page 29 $80-$ff is allowed in shortnames
;   but problem is that the special characters must be converted tu upper case)
;   problem: every codepage changes different values at change of lower to upper case
;    => W95 accepts probably every ASCII value $80-$ff???)

;problem: W95 doesn' differ lower an upper special chars (e.g. ä and Ä) => problem
;   if an UNICODE-$c4 (Ä) is then the filename cannot be $e4 (ä) 
;        (c0-ff is for reverse characters)
; LFN-$41-$5a is same character as LFN-$61-$7a (upper and lower case) (same char not allowed in different names)
; LFN-$c0-$df is same char as LFN-$e0-$ff (exeption: d5/f5 and df/ff) (upper and lower case) ( -"- ) 


; at DOS-codepages (short filenames) $80-$9f is allowed?
; at UNICODE-page #$00: ASCII $00-$1f, $7f, $80-$90 isn't allowed?

; at C64 you can save every character as filename exept $2a* $2c, $3f?
 
;change of characters in filenames from 
;              CBM->IBM                                     IBM->CBM

;-----------------------------------------------------------------------------------------------
;C64 uses $00-$5f and $80-$df only
;C64 doesn't use $60-$7f and $e0-$ff
; it would be good to change the used C64-charcters to UNICODE-page 0

;$60-$7f is changed to $c0-df
;$e0-$fe is changed to $a0-$be
;$ff is changed to $de  

;for 63 charcaters there are two ASCII-values possible, e.g. ?chr$(97) and ?chr$(193) is a 'A'
;there are three ASCII-values for 'pi': ?chr$(126)  ?chr$(222)  ?chr$(255)

;------------------------------------------------------------------------------------------------
;
;     -CBM-    is changed to LFN (UNICODE)
;     -CBM-$00         -> LFN-$40 @ ($00 makes new basic-line in dir)
;                                  => LFN-$c0 is free (but same-LFN-char as $e0 (lower/upper)          LFN-$c0
;                                  => LFN-$e0 isn't free

;     -CBM-$0d         -> LFN-$6d m ($0d makes carriage return)
;                                  => LFN-$cd is free (but same-LFN-char as $ed (lower/upper)          LFN-$cd
;                                  => LFN-$ed isn't free

;     -CBM-$14         -> LFN-$74 t ($14 deletes character left of it)
;                                  => LFN-$74 would be free (but same-LFN-char as $f4 (lower/upper) 
;                                  => LFN-$f4 is used => LFN-$74 isn't free

;     -CBM-$1b-1f  -> LFN-$5b-5f  because I need free LFN-characters                                   LFN-$db
;                                  => LFN-$db-$df and LFN-$ff is free (6 characters won)               LFN-$dc
;                                       LFN-$fb-fe is free (but same-LFN-char as $db-de (lower/upper)  LFN-$dd
;                                        => LFN-$fb-fe isn't free                                      LFN-$de
;                                                                                                      LFN-$df
;                                                                                                      LFN-$ff
;      -CBM-$22  "     -> LFN-$27 '   " isn't allowed anyway but to be on the shure hand
;                                       or make a syntax error???


;table change PETSCII to LFN-ASCII
; only at first position of filename (because here forbidden at LFN, allowed at CBM):
;     -CBM-$20 (space) -> LFN-$3d ('=')    (3d and 2c isn't allowed at CBM)
;     -CBM-$2e ('.')   -> LFN-$2c (',')

;    _0   _1   _2   _3   _4   _5   _6   _7   _8   _9   _a   _b   _c   _d   _e   _f   
;             
;0_ 410  411                                                                   41f
;1_ 420                                                                        42f

;2_ 020  021! 060"`023# 024$ 025% 026& 027' 028( 029) ---* 02b+ ---, 02d- 02e. 0f7/ 
;3_ 0300 0311 0322 0333 0344 0355 0366 0377 0388 0399 ---: 03b; 07b<{---= 07d>}---?

;4_ 040@ 041a 042b 043c 044d 045e 046f 047g 048h 049i 04aj 04bk 04cl 04dm 04en 04fo
;5_ 050p 051q 052r 053s 054t 055u 056v 057w 058x 059y 05az 05b[ 0ff£\05d] 05e^ 05f<-_

;6_ 250×    A    B    C    D    E    F    G    H    I    J    K    L    M    N 25fO
;7_ 260P    Q    R    S    T    U    V    W    X    Y    Z    ×    ×    ×    × 26f× 

;8_ 270×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    × 27f× 
;9_ 280×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    × 28f× 

;a_ 0a0×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    × 0af× 
;b_ 0b0×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    × 0bf× 

;c_ 07e×~0c1A    B    C    D    E    F    G    H    I    J    K    L    M    N 0cfO
;d_ 0d0P    Q    R    S    T    U    V    W    X    Y 0daZ 0db× 0dc× 0dd× 0de× 0df×                                  

;e_ 2b0×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    × 2bf× 
;f_ 2c0×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    × 2cf× 
;------------------------------------------------------------------------------------------------
;table change LFN-ASCII to PETSCII 
;     _0   _1   _2   _3   _4   _5   _6   _7   _8   _9   _a   _b   _c   _d   _e   _f   
;             
;00_  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×                                                                     
;01_  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×                                                                           

;02_  20   21!  --"  23#  24$  25%  26&  27'  28(  29)  --*  2b+  2e., 2d-  2e.  --/ 
;03_  300  311  322  333  344  355  366  377  388  399  --:  3b;  --<  20 = -->  --?

;04_  40@  41a  42b  43c  44d  45e  46f  47g  48h  49i  4aj  4bk  4cl  4dm  4en  4fo
;05_  50p  51q  52r  53s  54t  55u  56v  57w  58x  59y  5az  5b[  --£\ 5d]  5e^  5f<-_

;06_  22"` 41Aa   Bb   Cc   Dd   Ee   Ff   Gg   Hh   Ii   Jj   Kk   Ll   Mm   Nn 4fOo
;07_  50Pp   Qq   Rr   Ss   Tt   Uu   Vv   Ww   Xx   Yy 5aZz 3c<{  --| 3e>} c0×~ --× del 

;08_  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --× 
;09_  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --×  --× 

;0a_  a0×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×  af× 
;0b_  b0×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×    ×  bf× 

;0c_  --   c1A    B    C    D    E    F    G    H    I    J    K    L    M    N  cfO
;0d_  d0P    Q    R    S    T    U    V    W    X    Y  daZ  db×  dc×  dd×  de×  df×                                  

;0e_  --×  c1A    B    C    D    E    F    G    H    I    J    K    L    M    N  cfO 
;0f_  d0P    Q    R    S    T    U    V  2f/×   X    Y    ×    ×    ×    ×  de×  5c\× 

;25_  60                                                                         6f
;26_  70                                                                         7f

;27_  80                                                                         8f
;28_  90                                                                         9f

;2b_  e0                                                                         ef
;2c_  f0                                                                         ff

;41_  00   01                                                                    0f
;42_  10                                                                         1f


; #$00 is flag for end of file => mustn't be in filename
; or make $2a* or $3f? as endflag and perhaps also >shift-space> ?????


;- LFN-$c0 is still free??
; --- = isn't allowed at CBM when a file is saved => syntax error?
;  -- = this is a illegal LFN-character => if this is found then the shortname is displayed only
;  .. = I don't know so far
;AT LFN can be used:
; $20-60 (some exceptions)
; $7b-7e (some exceptions)
; $a0-df
; $f7
; $ff
; ($00-1f isn't allowed)
; ($61-7a is lower case of $41-5a => would make file-exist error at LFN)
; ($7f-9f isn't allowed)
; ($e0-ff is lower case of $c0-df (with exception $f7,$ff) => would make file-exist error at LFN)
; l19650 a character which cannot be in a inputbuffer-filename is $8d (shift-carriage-return)


;------------------------------------------------------------------------------------------------
;table character import CBM
;            "   *  .,   /    :   <   =   >   ?    \   "`   <{   |  >}   ~  del       /   \
tacicb: .db $00,$00,$2e,$00, $00,$00,$20,$00,$00, $00, $22, $3c,$00,$3e,$c0,$00, $00, $2f,$5c,0       
tacilf: .db $22,$2a,$2c,$2f, $3a,$3c,$3d,$3e,$3f, $5c, $60, $7b,$7c,$7d,$7e,$7f, $c0, $f7,$ff,0
                        ;table character import longfilename  (load)
;------------------------------------------------------------------------------------------------
;table character export
;            _                   _                                           short first char
;                `   _   _   _       ÷   _   _   {   _   }   _   _   ÿ   _   short 2.-8.char              
;            =                   ,                                           long first char
;                `   *   +   ,   .   ÷   :   ;   {   =   }   ?   [   ÿ   ]   long 2.-16.char                      
;                "   *   +   ,   .   /   :   ;   <   =   >   ?   [   £\  ]   CBM                               
;                                                                            table char export 

;            01                  01                                             (/first char)
tacesf: .db $00,$60,$01,$01,$01,$00,$f6,$01,$01,$7b,$01,$7d,$01,$01,$98,$01 ;shortfilenames save
;                                                                               (\next chars)

;            3d                  2c                                             (/first char) 
tacelf: .db $20,$60,$2a,$2b,$2c,$2e,$f7,$3a,$3b,$7b,$3d,$7d,$3f,$5b,$ff,$5d ; longfilename  save
;                                                                               (\next chars) 

tacecb: .db $20,$22,$2a,$2b,$2c,$2e,$2f,$3a,$3b,$3c,$3d,$3e,$3f,$5b,$5c,$5d ; CBM
;at tacesf: #$00 = skip byte
;           #$01 = print underscore _ $5f


;  first and last|   all chars
;      char only |    |
;            =   | ,  |  `           ÷       {       }       ÿ     ~
;           spc  | .  |  "   *   ,   /   :   <   =   >   ?   £\   '-' 
taclnl: .db $3d , $2c , $60,$00,$00,$f7,$00,$7b,$00,$7d,$00,$ff , $7e ,0;table CFN->LFN/LFN-part
taclnc: .db $20 , $2e , $22,$2a,$2c,$2f,$3a,$3c,$3d,$3e,$3f,$5c , $c0 ,0;table CFN->LFN/CFN-part

; #$00=illegal char -> 31 syntax error 
; dot (= period) isn't allowed as firts and last char only; is allowed in middle of filename
; but dot is always replaced with comma, because then it's shure that there is no 
;  unwanted fileextension, e.g. at DIR

;         first | all chars
;          char | 
;          only | 
;       SFN: Õ  |          _   _   ÷   _   _   _   ÿ   _  
;       LFN: Õ  |      .   +   ,   ÷   ;   =   [   ÿ   ]
;       CFN: U  |      .   +   .   /   ;  spc  [   £\  ]
talsns: .db $05 , $00,$00,$01,$01,$f6,$01,$01,$01,$98,$01 ,0 ;table LFN->SFN / SFN-part
talsnl: .db $d5 , $20,$2e,$2b,$2c,$f7,$3b,$3d,$5b,$ff,$5d ,0 ;table LFN->SFN / LFN-part
;first char: CFN-$d5 CFN-'U'
;            LFN-$d5 LFN-'Õ'
;            SFN-$e5 SFN-'Õ'
;                             SFN-$e5 as first char would mean empty direntry => is changed
;first char: SFN-$05 SFN-'Õ'       
;at tacesf: #$00 = skip byte 
;           #$01 = print underscore _ $5f            
;spc = space
;------------------------------------------------------------------------------------------------

          ;table shortname CBM-$a0-df -> DOS-ASCII
;           $a0,$a1,$a2,$a3,$a4,$a5,$a6,$a7,$a8,$a9,$aa,$ab,$ac,$ad,$ae,$af
tashna: .db $ff,$ad,$bd,$9c,$cf,$be,$dd,$f5,$f9,$b8,$a6,$ae,$aa,$f0,$a9,$ee ;$00a0-00af 
;                ¡   ¢   £   ¤   ¥   ¦   §   ¨   ©   ª   «   ¬   ­   ®   ¯

;           $b0,$b1,$b2,$b3,$b4,$b5,$b6,$b7,$b8,$b9,$ba,$bb,$bc,$bd,$be,$bf
        .db $f8,$f1,$fd,$fc,$ef,$e6,$f4,$fa,$f7,$fb,$a7,$af,$ac,$ab,$f3,$a8 ;$00b0-00bf        
;            °   ±   ²   ³   ´   µ   ¶   ·   ¸   ¹   º   »   ¼   ½   ¾   ¿

;           $c0,$c1,$c2,$c3,$c4,$c5,$c6,$c7,$c8,$c9,$ca,$cb,$cc,$cd,$ce,$cf
        .db $7e,$b5,$b6,$c7,$8e,$8f,$92,$80,$d4,$90,$d2,$d3,$de,$d6,$d7,$d8 ;$00c0-00cf                                                                
;           À ~  Á   Â   Ã   Ä   Å   Æ   Ç   È   É   Ê   Ë   Ì   Í   Î   Ï                                                                          

;           $d0,$d1,$d2,$d3,$d4,$d5,$d6,$d7,$d8,$d9,$da,$db,$dc,$dd,$de,$df
        .db $d1,$a5,$e3,$e0,$e2,$e5,$99,$9e,$9d,$eb,$e9,$ea,$9a,$ed,$e8,$e1 ;$00d0-00df                                                                
;            Ð   Ñ   Ò   Ó   Ô   Õ   Ö   ×   Ø   Ù   Ú   Û   Ü   Ý   Þ   ß                                                                          
       
           ;CBM-$c0 (-) must be changed to ASCII-$7e (~) because:
           ; foreign-filenames are displayed short only and the tail has a ~
           ; the ~ is displayed at CBM ugly => I replaced the ASCCI-$7e (~) 
           ;  with a CBM-$c0 (-) what's more beautiful
           ; => in the opposite direction the CBM-$c0 (-) must be changed to ASCII-$7e (~)
           ; =>  CBM-$c0 (-) should be UNICODE-$c0 (À) = ASCCI-$b7 (À)
           ; but CBM-$c0 (-) is really UNICODE-$7e (~) = ASCII-$7e (~)   
  
           ;ASCII-$e5 Õ  (=UNICODE-$d5 Õ  = CBM-$d5 U) 
           ;    mustn't be first character of DOS-filename; must be saved as $05
           ;    (because $e5 is flag for empty direntry)
;------------------------------------------------------------------------------------------------
; CFN    CFN      LFN    LFN-1.char  LFN-last-char    SFN
;$00-1f        0410-042f                              5f _

; $20   space     20        3d =        3d =        skipped     as 1. and last LFN-char forbidden
; $21     !          !                                   !
; $22     "       60 `                                60 `      (forbidden, but works anyway)
; $23     #          #                                   #      as 1.CFN-char forbidden
; $24     $          $                                   $      as 1.CFN-char forbidden?
; $25     %          %                                   %
; $26     &          &                                   &
; $27     '          '                                   '
; $28     (          (                                   (
; $29     )          )                                   )
; $2a     *       5f _                                5f _      forbidden
; $2b     +          +                                5f _   
; $2c     ,          ,                                5f _      forbidden                                   
; $2d     -          -                                   -
; $2e     .       2c ,      2c ,        2c ,        skipped     as 1. and last LFN-char forbidden  
;                                                               but chnaged always
; $2f     /       f7 ÷                                f7 ÷
; $30-39 0-9     30-39 0-9                          20-39 0-9                        
; $3a     :          :                                5f _      forbidden
; $3b     ;          ;                                5f _
; $3c     <       7b {                                7b {    
; $3d     =          =                                5f _      forbidden
; $3e     >       7d }                                7d }
; $3f     ?       5f _                                5f _      forbidden

;$40-$5f
; $40     @          @                                   @      
; $41-5a a-z     41-5a A-Z                          41-5a A-Z  
; $5b     [          [                                5f _ 
; $5c    £ \      ff ÿ                                98 ÿ   
; $5d     ]          ]                                5f _  
; $5e     ^          ^                                   ^
; $5f    <-          _                                   _   

;$60-$7f       0250-026f                              5f _      not used usually (c0-df is used)

;$80-9f        0270-028f                              5f _      displayed as reverse-$c0-df  

;$a0-bf          a0-bf                              a0-bf       grafical characters

; $c0     -       7e ~                                7e ~      looks better 
;$c1-da A-Z      c1-da                              c1-da  
;$db-df  ×       db-df                              db-df                                                                

;$e0-ff        02b0-02cf                              5f _      not used usually

; (LFN-$c0 is probably so far unused  is still free?)
;------------------------------------------------------------------------------------------------
; not allowed characters in filename
; CFN-          W95-LFN-             MSDOS-SFN-                      CFN-  is chan- LFN-char
; forbidden     forbidden            forbidden                       char  ged to
;               $00-1f               $00-1f                 

; $22 "         $22 "                $22 "                           $22 "          $60 `
; $2a *         $2a *                $2a *                           $2a *          syntaxerror
; $3a :         $3a :                $3a :                           $3a :          syntaxerror
; $3f ?         $3f ?                $3f ?                           $3f ?          syntaxerror
;                                                                
;               $3c <                $3c <                           $3c <          7b { 
;               $3e >                $3e >                           $3e >          7d }
;               $5c \                $5c \                           $5c £ \        ff ÿ  
;               $7c |                $7c |                           $7c          026c  

;               allowed in middle
;               forbidden at begin
;               forbidden at end    
;               (allowed at 
;                end when a 
;                fileextension
;                is behind)          always        \
;               $20 space            $20 space      \                $20 space      $3d =       
;                                                    \
;               allowed at begin                      \
;               allowed in middle                       \
;               forbidden at end                         = skipped
;               (allowed at                             /   in SFN
;                end when a                            / 
;                fileextension                        /
;                is behind)          always          /
;               $2e dot period       $2e dot period /                $2e .          $2c ,    

; $2c ,                              $2c ,                           $2c ,          syntaxerror
; $3d =                              $3d =                           $3d =          syntaxerror
;                                    $2b +   \    replaced
;                                    $3b ;    \ = with underscore
;                                    $5b [    /   in SFN 
;                                    $5d ]   /
;
;                                    only at begin
;                                    not in middle
;                                    not at end
;                                    $e5 Õ (changed to $05) 

;LFN-$2e = dot = period:
; the document says that it is allowed as first char, but I couldn't generate a filename with
;  a dot as first char under WXP
;------------------------------------------------------------------------------------------------
; FAT32-direntry
;        00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f

; 0000:  42 dl-dh el-eh fl-fh .l-.h Pl-Ph 0f 00 CS Rl-Rh  char13-15 ($d-$f) .PR     CheckSum 
; 0010:  Gl-Gh 00-00 ff-ff ff-ff ff-ff 00 00 ff-ff ff-ff               G endflag

; 0020:  01 0l-0h 1l-1h 2l-2h 3l-3h 4l-4h 0f 00 CS 5l-5h  char 0-12 ($0-$c)   
; 0030:  6l-6h 7l-7h 8l-8h 9l-9h al-ah 00 00 bl-bh cl-ch

; 0040:   a  b  c  d  e  f  ~  1  p  r  g FA 00 CT CT-CT               FileAttribute  CreateTime
; 0050:  CD-CD AD-AD C2-C3 WT-WT WD-WD C0-C1 L0-L1-L2-L3  CreateDate  AccessDate startCluster0-3
;                                                               WriteTime  WriteDate  fileLength
;fileattribute FA
; 7 unused should be %0
; 6 unused should be %0
; 5 archiv
; 4 directtory
; 3 volume ID
; 2 system
; 1 hidden
; 0 read only
;  flag for long-part-direntry : %00001111 $0f
;   (archiv-bit is cleared even if in MSDOS-direntry set)
;------------------------------------------------------------------------------------------------
       #if (partname == 6) | (partname == 7)    
        #message 644-NLQ-HD/
txweda: .db "SUN.MON.TUESWED.THURFRI.SAT." ;text weekdays
 
       #endif 
;------------------------------------------------------------------------------------------------ 
       #if partname == 3
        #message 644-NLQ-HD/SD2IEC
        .org $77fc

        .db "IEC1"     ;signature for Shadowolf2 (SD2IEC) hardware
        .db 0,0        ;versionnumber
        .db 0,0        ;CRC-checksum (must be made by crc-gen.exe)  
       #endif
;================================================================================================
;open directory:
;C64 sends filename; then:
; l25290 mainwaitingloop: Analyses command
; l17150 analyse command
; l17160 open -> l19560
; l19560 open
; l19570 if directory then l20790
; l20790 directory: writes 1 complet block (256 bytes) full with dirlines (same at 1541)
;================================================================================================
; SYSTEM-errors
;           1  flash-error (checksum-error over flash)
;           2  RAM-error         
;$03  03       eeprom error
;           4  no devicenumber in emulation table

;$05  05       NLQHD-SD: OCD on, JTAG on, watchdog on or brown-out on

;$08  08       no HD connected
;$09  09       HD doesn't support LBA-mode (IEC-ATA-V2-hardware only)
;$0a  10       no FAT32 or illegal FAT32
;$0b  11       rootdirectory doesn't start at cluster 00000002
;$0c  12       NLQ-SWAP.SYS not found (in rootdir)
;$0d  13       illegal NLQ-SAWP.SYS
;$0e  14       fragmented NLQ-SWAP.SYS
;$0f  15       error at FileSystemInfo sector
;$10  16       no datas at computing free clusters (not used;
;                                              free clusters are read from FSInfo-sector)

;$14  20      at printing errormessage???

;$17  23      try to append a file having the length 0000000 or startcluster 000000000

;$1a  26      read from rel-file  
;$1b  27      write to rel-file  

;$1e  30      at namegeneration: illegal shortname

;$26  38      try to access cluster 00000000-00000001
;$27  39      try to access cluster which is too big 
;$28  40      opfd..-values don't contain value of end of dir 
;$29  41      old dircluster was no endcluster
;$2a  42      bad cluster
;$2b  43      actual sector is over end of partition

;$2d  45      wanted direntry not free
;$2e  46      wanted direntry not free (l19290)
;$2f  47      wanted direntry not free

;$33  51      actual sector is over end of partition

;$40  64      at JD-load: datarequest isn't set

;$42  66      actual cluster is free
;$43  67      actual cluster isn't allocated

;$50  80      no read-/write-bit set at ashbtr/hdbtrwr HD-buffertransfer (r/w) of actual SA
;$51  81      illegal command to HD
;$52  82 
;$53  83      wrong bits set in ashbtw ;HD-buffertransfer-read/write of actual SA
;$54  84      so far not supported copy buffer
;$55  85      wrong value in table of buffer-values at reading/writing

;$60  96      listen to rel file
;$61  97      listen to direct access 
;$62  98      listen to direct access 
;$63  99      listen to rel file

;$67 103      try to swap illegal SA (l14190)
;$68 104      startsector of swapfile not set

;$80 128      illegal value of sector-in-this-cluster

;$88 136      copy-command

;$98 152      at cluster->sector: access to cluster 00000000 or 00000001
;$99 153      at cluster->sector: overflow at multiplication * 4
;$9a 154      at cluster->sector: overflow ad addition of actual-sector-in-this-cluster
;$9b 155      at cluster->sector: overflow at addition of startsector of partition

;$a0 160      error at I2C-bus

;$c8 200      at ehc command: drive busy

;$d2 210      SD-cards: high capacity SD-card (so far not supported)
;$d3 211      system error (error at MMC-CMD1) 
;$d4 212      system error (error at SD-ACMD41) 
;$d5 213      system error at set blocklength

;$dc 220      illegal command to SM-card
;$dd 221      illegal address at reading smc
;$de 222      R1-error at reading sector from SMC 
;$df 223      start token not received at reading from SMC (only #$ffs received)
;$e0 224      errort token (not-#$fe) received at reading from SMC

;$e1 225      illegal address at writing smc
;$e2 226      R1-error at writing SMC
;$e3 227      error at data response token
;$e4 228      error at response after having written a sector to SD

;$fa 240      PCF8583-RTC set wrongly

;$fe 254      CD-access (not supported)
;$ff 255      unsupported command
;================================================================================================
;debyhi = debug-byte-high               
;there are so many debug bytes that it's difficult to find in the debug buffer what is what.
;So this can be found easier by a highbyte.
;use perhaps values for the highbyte from $41-$5a (a-z) so that it's easier to find

;$41 a

;$52 r  rename
;$53 s  scratch

;$57 w  save (write)

;$5a z



;================================================================================================
;                        SUBROUTINES-table
; l10740 LED blink 
; l10750 LED on
; l10760 LED off

; l10860 read byte after ATN-edge  
; l11130 Atn-mode is finished

; l11430 IECIN read one byte from C64 to AVR 
; l11700 IECOUT send one byte from AVR to C64
; l12090 JiffyDOS-LOAD

; l12730 device-number-swap
;
; l13080 debugbyte & IEC-ports to buffer

; l13360 Job when Talk received     action after Talk   (e909)
; l13510 Job when Listen received   action after Listen (ea2e)

; l13770 EEPROM read

; l13880 00,ok into errorbuffer
; l13880 error-message

; l14060 ATA

; l26570 SD-/MMC-SDI

; l14190 save old CBM-buffer to swapfile and load new CBM-buffer from swapfile
; l14330 save old device-buffer to swapfile and load new device-buffer from swapfile

; l14380 read FAT-entry of actual cluster  
; l14440 read follow-cluster of actual cluster
; l14530 compute actual sector of cluster in r12-r15       r12-r15=cluster
; l14570 identify-drive-command
; l14590 write last-read/actual HD-buffer back to HD using acsehb actual sector HD-buffer
; l14600 write back actual FAT-buffer
; l14760 read follow-512-HD-sector of actual cluster using ashbcl
; l14770 read follow-256-CBM-sector of actual cluster 
; l14790 read actual sector of actual cluster (again)
; l14810 reads startsector of actual SA HD-buffer cluster 
; l14820 read startsector of cluster                       r12-r15=cluster
; l14930 read/write 1 sector (with LBA->CHS computing)     r12-r15=sector <---------------
; l15140 read/write 1 sector (without LBA->CHS computing)
; l15410 end of read/write 1 sector (l14930/l15140)

; l15630 read one direntry of actual directory into directorybuffer dibube (- l16440)
; l20790 create directory open of directory                                                  da55

; l16640 if necessary then initialize drive & switch on LED                                  c3ca
; l16770 search first to inputname fitting dirnameentry                                      c49d
; l16750 search next to inputname fitting dirnameentry and load dirblock from disk           c48b
; l16790 search next to inputname fitting dirnameentry without loading dirblock fr.disk      c4b5

; l16990 search first deleted / not-deleted dirnameentry                                     c5ac
; l17060 search next deleted / not-deleted dirnameentry and load dirblock from disk          c604
; l17070 search next deleted / not-deleted dirnameentry without loading dirblock fr.disk     c617
; l17090 if necessary then initialize drive                                                  c63d

; l17150 analyse & execute command from C64 / open
; l17590 command 0a: scratch 
; l17770 command   : c copy cd
; l18000 command   : r rename                                                                ca88
; l18140 command   ; m memory                                                                caf8
; l18240 command   : i initialize                                                                          d042
; l18910 test whether the SD has been changed and if so then free all buffers
; l18950 free all buffers (without closing them)
; l19180 create dir-entry (part1 search or make 3 free direntries)                           d6e4
; l19240 create dir-entry (part2)                                                            d73d
; l19560 open                                                                                d7b4
; l19650 place at open where files in dir are searched (rcall l16770)
; l19760 save&replace                                                                        d8f5
; l19860 append                                                                         d976/d99a
; l20680 save                                                                                d9e3

; l21580 close      
; l21950 free general actual cluster in FATs                                                 ef5f
; l22000 alocate general actual cluster in FATs                                              ef90
; l22050 search next free cluster                                                            f11e
   
; l22800 command  $10: a additional  ... -> l27420
; l23510 command     : u user  ui uj
; l23630 I2C-routines
; l23920 Reset
; l25290 mainwaitingloop
; l25500 switches 

;------------------------------------------------------------------------------------------------
;direditor  under Windows:
;http://www.anerty.net/software/file/DriveSort.php 
; drivesort -> playlist ->  arrow-down left to 'playlist' -> extensions -> delete mp3,wma... 
; add seq, prg, usr, rel. -> ok -> click on wanted filename -> change pos of this filename
; click on playlist until 'Nb.' is disdplayed (not 'Short Name')
; !! destroys shortnames; but makes from a file with a shortanme ony a file with a short- and
;    longname   or  cannot move shortname???
; rightclick on filename -> proprietes -> can even change date, hidden, system...
;disadvantage: makes files with non-CBM.filextension to end of dir
; =>nlq-swap.sys is at the end of the dir (=> slower reset-routine)
; -scandisk of Windows ME deletes all long filename
; -defrag of Windoes ME doesn't work; ends with an error and 'start scandisk'
;
;www.oliver-frietsch.de:                          reorganize: bad; sorts mp3s only
;http://www.fenux.net/story/fatsorteroneohfour:    fatsorter: bad; sorts alphabeticaly only
;http://software.magnus.de/tools/QQartikelZ23479/download/foldersort.html
;                                                 foldersort: bad; sorts not manually   
;------------------------------------------------------------------------------------------------
;Problems / todo: 
;- At a software reset (UI): The LED stays off at m644
;- test when a FAT16-hd is connected
;- AVR hangs when no HD connected
;- mul command uses r00,r01 => change debug-registers and use mul-command
;- ei+ /ei- command should be reset proof
;- still compare shortnames at save
;- the maximal length of a directory is 65536 entries (2MB) => make perhaps counter??? 
;- look how long a dir can be at a cmd-hd
;- set bit7 of actual sector in HD-buffer at error 
;- andi r..,#$ff/and r..,r07 replace with tst r..
;- at close: write to HD free clusters and first free cluster if flag for changed is set 
;-what happens when the last or last-two direntries are unused? Where is the new direntry made?
;-dir flag in asfla0 must be cleared
;-at save: if a file exist -> file not oipen error instead of file exists erroir????
;-Windows uses allway first free cluster as follow-cluster even if the distance to the actual one 
;    is far
;-Windows ME doesn't defrag root-dir
;-store actual values of amount of free cluster and first free cluster to second sector of
;    partition
;-if there is a write to disk then set perhaps flag that Windows makes Scandisk
;laprfl last program filelength (for load"*") must be set at save
;at JD-load the HD-LED stays on 
;is 'cd<-' legal or illegal (only 'cd:<-' legal)
;load correct swapbuffer at executing commands
;how many free blocks are displayed at CMD-HD at a native partition with 16MBs free
;is a dir starting with '<-' legal (e.g. <-abcdef) or are alle dirs starting with a '<-' illegal
;load swapbuffer for commandchannel $0f=15 at commands, because dirfilename ($09e5-09ff) and 
;  values for sector overwrite CBM-buffer of ols SA
;check if the stackpointer is smaller than $80 (e.g.at read sector) and if yes then erreor?
;what happens if there is no HD connected?
;check: open two files and read from bozth ones
;at block-free: check whether cluster 00000000 or 00000001 or too big cluster 
;  and make error if yes
;if SA=15 ($05) = errorchannel. Don't always swap CBM-buffer and load buffer for SA=15 to AVR-RAM
; because else the ERR RAM-read command couldn't read values of the CBM-buffer of the different
; SA
;problem: there is no bit whether the command-errorbuffer ($0f) is opened or not
; => at swap-buffers with wanted new buffer $0f there is always the datas loaded from the
; swapfile, where usually nonsense is 
;I2C-Belegung so machen, dass nichts stört, wenn Adapter an PC angeschlossen ist 
;test when FAT end exatly at a $0100 length  or x*$0100+1
;when the AVR is connected with power-supply but HD isn't then the AVR pulls with more than 
; 20mA the input-pins of the HD to +5V. Perhaps make all AVR-pins to IDE-HD-lines to inactive and
; pullups on and see then whether all wires stay at 0V. If yes then there is a HD without
; power supply connected
; But there would still be the same problem when a user switches the power-suppply of the HD off
;  while it is used
; make a timeout after 30 seconds when there is no HD connected 
;  or use writing and reading the drive-&haed/LBA3-register for detcting a HD
; at LOAD and debug-printing: The RAM is mirrored => writing to RAM $9000 overwrites RAM at $0100
; change a_dioR to open collector with 4.7kOhm pullupresistor

;test current(s) from HD(s) to AVR, which AVR mus make to pull dioR to 0V. This is connected to
;  I2C-clock. This current must be maximal 3mA. If it is more then a 74LS244 driver and pullup
;  resistor must be used => timing to HD must perhaps be slowed???
;replave 10kOhm at SPI-lines to SD-card (SPI-Dta-Out->SD-DtaIn and SPI-Clk) with 1.5kOhm??
; could be faster
; (don't replace 10kOhm at SPI-line from SD-Card (SPI-Dta-In<-SD-DtaOut)!!)
;still replace 3.3V voltage-regulator and 100Ohm LED-resistors with 3.5V and 120Ohm
;limit amount of files in a dir (?to256 or 65536??) (CMD-HD has 500000)
;the system hangs when you cancel a JD-load
;NLQ-HD_full: 74LS244 pulls dataout of SDcard to +5V !! check how high the voltag is when
; no card si inserted!!! perhaps make a diode to +3.3V?????????????
;SD2IEC. SrqIn isn't connected => make pullupresistor on to prevent swinging
;test whether there is a Formula too complex error at formating a 10 or 40GB partition on a 40GB HD
;Windows-restriction: length of filename including drivenumber and path: 259 chars
; length of a dirname=16 -> 17 including \   => allow perhaps 15 subdirs only?????
;write a new FAT-sector with the first FAT-entry occupied to HD to avoid cross-linked files
; when NLQ-HD is resetted without writeing the FAT to HD
;WXP: 'format /?' FAT32: amount of clusters: 65526-4177918  ($fff6-3FBFFE) 
;still load correct swapbuffer-SA ($11, $12) internal for SA=15, e.g.  
; not yet made: buffer at scartch atl17610
; cd/test/test ( / instead of :) (WTE Hobby&Elektronik 2008)
;close all channels at automatic initialize?????
;at open (shortly before open): check whether the disk is changed and finish all SAs (l18950)
;at rename (and save?): when the last (three) direntries are deletd ones ($e5), then the next
;file is made at the end, not at the $e5 entry 
;values of last loaded program to area of swapbuffer
;test what happens when you copy a dir from one hd to a different one  '* "test"      bdir'
;Save":" makes destroyed dir
;bits 1&0 of asfla0 are not cleared = often %00000011 = flag for long dir
;what happens when a file with length 00000000 and startcluster 00000000 is loaded / opened














